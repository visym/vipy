<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.6" />
<meta name="google-site-verification" content="aB8LkQegj94_TJPdrcJm2ldIRWyXY82Jp24Gtkdgyn0" />
<title>vipy.activity API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vipy.activity</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/activity.py#L1-L400" class="git-link">Browse git</a>
</summary>
<pre><code class="python">import numpy as np
from vipy.geometry import BoundingBox
from vipy.util import isstring, tolist, shortuuid
import uuid
import copy
from vipy.object import Track

try:
    import ujson as json  # faster
except ImportError:
    import json


class Activity(object):
    &#34;&#34;&#34;vipy.object.Activity class
    
    An activity is a grouping of one or more tracks involved in an activity within a given startframe and endframe.
    The activity occurs at a given (startframe, endframe), where these frame indexes are extracted at the provided framerate.
    All objects are passed by reference with a globally unique track ID, for the tracks involved with the activity.  This 
    is done since tracks can exist after an activity completes, and that tracks should update the spatial transformation of boxes.
        
    Valid constructors

    ```python 
    t = vipy.object.Track(category=&#39;Person&#39;)
    a = vipy.object.Activity(startframe=0, endframe=10, category=&#39;Walking&#39;, tracks=t.id())
    a = vipy.object.Activity(startframe=0, endframe=10, category=&#39;Walking&#39;, tracks=t)    
    ```

    Note.. shortlabel is kepy for backwards compatibility and will be deprecated
    
    &#34;&#34;&#34;
    __slots__ = [&#39;_id&#39;, &#39;_startframe&#39;, &#39;_endframe&#39;, &#39;_framerate&#39;, &#39;_label&#39;, &#39;_trackid&#39;, &#39;_actorid&#39;, &#39;attributes&#39;]
    def __init__(self, startframe, endframe, framerate=30, label=None, category=None, tracks=None, attributes=None, actorid=None, confidence=None, id=None, shortlabel=None):
        assert not (label is not None and category is not None), &#34;Activity() Constructor requires either label or category kwargs, not both&#34;
        assert startframe &lt;= endframe, &#34;Start frame must be less than or equal to end frame&#34;
        assert framerate is not None, &#34;initial framerate is required for framerate conversion&#34;
        if tracks:
            tracks = [v for (k,v) in tracks.items()] if isinstance(tracks, dict) else tracks  # backwards compatible, track dictionary input
            assert (all([isstring(t) for t in tracks]) or all([isinstance(t, Track) for t in tracks])), &#34;Invalid track input&#34;
            if all([isinstance(t, Track) for t in tracks]):
                assert any([any([t.during(f) for f in range(startframe, endframe)]) for t in tracks]), &#34;At least one track must be be present in at least one frame when this activity occurs&#34;
                tracks = [t.id() for t in tracks]  
        trackid = set(tracks) if tracks is not None else (set([actorid]) if actorid is not None else set([]))  # only store IDs, not tracks
        
        if tracks is not None and actorid is not None and actorid not in trackid:
            trackid.add(actorid)

        self._id = shortuuid() if id is None else id  # use provided
        self._startframe = int(startframe)
        self._endframe = int(endframe)
        self._framerate = float(framerate)
        self._label = category if category is not None else label        
        self._trackid = trackid
        self._actorid = actorid

        self.attributes = attributes.copy() if attributes is not None else {}  # shallow copy
        if confidence is not None:
            self.attributes[&#39;confidence&#39;] = float(confidence)

    def hasattribute(self, k):
        return k in self.attributes

    def confidence(self, c=None):
        if c is not None:
            self.attributes[&#39;confidence&#39;] = float(c)
            return self
        else:
            return self.attributes[&#39;confidence&#39;] if &#39;confidence&#39; in self.attributes else None
    
    @classmethod
    def from_json(obj, s):
        d = json.loads(s) if not isinstance(s, dict) else s
        d = {k.lstrip(&#39;_&#39;):v for (k,v) in d.items()}  # prettyjson (remove &#34;_&#34; prefix to attributes)                                        
        return obj(startframe=int(d[&#39;startframe&#39;]),
                   endframe=int(d[&#39;endframe&#39;]),
                   framerate=d[&#39;framerate&#39;] if &#39;framerate&#39; in d else None,
                   category=d[&#39;label&#39;] if &#39;label&#39; in d else None,
                   tracks=d[&#39;trackid&#39;] if &#39;trackid&#39; in d else None,
                   attributes=d[&#39;attributes&#39;] if &#39;attributes&#39; in d else None,
                   actorid=d[&#39;actorid&#39;] if &#39;actorid&#39; in d else None,
                   id=d[&#39;id&#39;] if &#39;id&#39; in d else None)
                
    def __len__(self):
        &#34;&#34;&#34;Return activity length in frames, or zero if degenerate&#34;&#34;&#34;
        return max(0, self.endframe() - self.startframe())

    def duration(self, s=None, centered=False):
        &#34;&#34;&#34;The length of the activity in seconds.

        Args:
            s: [float] The number of seconds for this activity, starting at the startframe
            centered: [bool] If true, then set the duration centered on the middle frame

        Returns:
            The duration in seconds of this activity object (if s=None)
            This activity object with the requested duration (if s!=None)
        &#34;&#34;&#34;
        assert self.framerate() is not None, &#34;Framerate must be set in constructor&#34;
        if s is None:
            return len(self) / float(self.framerate())
        else:
            return (self.endframe(self.startframe() + int(round(s*self.framerate()))) if not centered else 
                    self.truncate(startframe=self.middleframe()-int(np.ceil(s*self.framerate())//2), endframe=self.middleframe()+int(np.ceil(s*self.framerate())//2)))
        
    def __repr__(self):
        return str(&#39;&lt;vipy.activity.Activity: category=&#34;%s&#34;, frames=(%d,%d), tracks=%s%s&gt;&#39; % (self.category(), self.startframe(), self.endframe(), len(self.trackids()), &#39;&#39; if self.confidence() is None else &#39;, confidence=%1.2f&#39; % self.confidence()))

    def dict(self):
        &#34;&#34;&#34;Return a python dictionary containing the relevant serialized attributes suitable for JSON encoding&#34;&#34;&#34;
        return self.json(s=None, encode=False)

    def __json__(self):
        &#34;&#34;&#34;Serialization method for json package&#34;&#34;&#34;
        return self.json(encode=True)
    
    def json(self, encode=True):
        d = {k.lstrip(&#39;_&#39;):getattr(self, k) for k in Activity.__slots__ if getattr(self, k) is not None}  # prettyjson (remove &#34;_&#34; prefix to attributes)          
        d = {k:v if k != &#39;trackid&#39; else tuple(v) for (k,v) in d.items()}  # sets are non-serializable
        return json.dumps(d) if encode else d
    
    def actorid(self, actorid=None):
        if actorid is None:
            return self._actorid
        else:
            self._actorid = actorid
            if actorid not in self._trackid:
                self._trackid.add(actorid) if isinstance(self._trackid, set) else self._trackid.append(actorid)                    
            return self

    def startframe(self, f=None):
        if f is None:
            return self._startframe
        else:
            self._startframe = f
            return self
    
    def endframe(self, f=None):
        if f is None:
            return self._endframe
        else:
            self._endframe = int(f)
            return self

    def middleframe(self):
        &#34;&#34;&#34;Return the middle frame number of the activity&#34;&#34;&#34;
        return int(np.round((self._endframe - self._startframe) / 2.0)) + self._startframe

    def _set_framerate(self, fps):
        &#34;&#34;&#34;Override framerate conversion and just set the framerate attribute.  This should really be set only in constructor.  Use with caution!&#34;&#34;&#34;
        self._framerate = float(fps)
        return self

    def framerate(self, fps=None, speed=None):
        &#34;&#34;&#34;Resample (startframe, endframe) from known original framerate set by constructor to be new framerate fps&#34;&#34;&#34;        
        if fps is None and speed is None:
            return self._framerate
        else:
            assert fps is not None or speed is not None, &#34;Invalid input&#34;
            assert not (fps is not None and speed is not None), &#34;Invalid input&#34;
            assert speed is None or speed &gt; 0, &#34;Invalid speed, must specify speed multiplier s=1, s=2 for 2x faster, s=0.5 for half slower&#34;                    
            assert fps is None or fps &gt; 0, &#34;Invalid framerate&#34;
            assert self._framerate is not None, &#34;Framerate conversion requires that the framerate is known for current activities.  This must be provided to the vipy.object.Activity() constructor.&#34;

            fps = float(fps) if fps is not None else (1.0/speed)*self._framerate            
            (self._startframe, self._endframe) = [int(np.round(f*(fps/float(self._framerate)))) for f in (self._startframe, self._endframe)]
            self._framerate = float(fps)
            return self
    
    def category(self, label=None):
        &#34;&#34;&#34;Change the label to the new label &#34;&#34;&#34;
        if label is not None:
            self._label = label
            return self
        else:
            return self._label

    def categoryif(self, ifcategory, tocategory=None):
        &#34;&#34;&#34;If the current category is equal to ifcategory, then change it to newcategory.

        Args:
            
            ifcategory [dict, str]: May be a dictionary {ifcategory:tocategory}, or just an ifcategory
            tocategory [str]:  the target category 

        Returns:
        
            this object with the category changed.

        .. note:: This is useful for converting synonyms such as self.categoryif(&#39;person_sits&#39;, &#39;person_sitting&#39;)
        &#34;&#34;&#34;
        assert (isinstance(ifcategory, dict) and tocategory is None) or tocategory is not None

        if isinstance(ifcategory, dict):
            for (k,v) in ifcategory.items():
                self.categoryif(k, v)
        elif self.category() == ifcategory:
            self.category(tocategory)
        return self

    def label(self, label=None):
        &#34;&#34;&#34;Alias for category&#34;&#34;&#34;
        return self.category(label)

    def add(self, track):
        &#34;&#34;&#34;Add the track id for the track to this activity, so that if the track is changed externally it is reflected here&#34;&#34;&#34;
        assert isinstance(track, Track), &#34;Invalid input - must be vipy.object.Track&#34;
        assert self.during_interval(track.startframe(), track.endframe()), &#34;The track must be present during the activity&#34;
        if track.id() not in self._trackid:
            self._trackid = list(self._trackid)
            self._trackid.append(track.id())
        return self

    def addid(self, trackid):
        &#34;&#34;&#34;Add the track id for the track to this activity, so that if the track is changed externally it is reflected here&#34;&#34;&#34;
        if trackid not in self._trackid:
            self._trackid = list(self._trackid)
            self._trackid.append(trackid)
        return self
    
    def tracks(self):
        &#34;&#34;&#34;alias for trackids&#34;&#34;&#34;
        return self.trackids()

    def cleartracks(self):
        &#34;&#34;&#34;Remove all track IDs from this activity&#34;&#34;&#34;
        self._trackid = []
        return self

    def trackids(self):
        &#34;&#34;&#34;Return a set of track IDs associated with this activity&#34;&#34;&#34;
        return set(self._trackid)

    def hasoverlap(self, other, threshold=0):
        &#34;&#34;&#34;Return true if the temporal_iou is greater than the provided threshold between self and other Track or other Activity&#34;&#34;&#34;
        assert isinstance(other, Activity) or isinstance(other, Track), &#34;Invalid input&#34;
        assert threshold &gt;= 0 and threshold &lt;= 1, &#34;Invalid temporal IOU threshold&#34;
        return (((min(self._endframe, other.endframe()) - max(self._startframe, other.startframe())) &gt; 0) if threshold == 0 else
                self.temporal_iou(other) &gt; threshold)
        
    def isneighbor(self, other, framegate=10):
        return self.temporal_iou(other.clone().temporalpad(framegate)) &gt; 0 

    def hastrack(self, track):
        &#34;&#34;&#34;Is the track part of the activity?&#34;&#34;&#34;
        assert isstring(track) or isinstance(track, Track), &#34;Invalid input - Must be a vipy.object.Track().id() or vipy.object.Track()&#34;
        trackid = track.id() if isinstance(track, Track) else track
        return trackid in self._trackid

    def hastrackoverlap(self, track):
        &#34;&#34;&#34;is the activity occurring during the interval when the track is occurring and is this track assigned to the activity?&#34;&#34;&#34;
        assert isinstance(track, Track)
        return self.hastrack(track) and self.temporal_iou(track) &gt; 0

    def append(self, newtrack):
        &#34;&#34;&#34;Append newtrack to this activity and set as actorid()&#34;&#34;&#34;
        assert isinstance(newtrack, Track), &#34;Invalid input - must be vipy.object.Track&#34;
        self._trackid.add(newtrack.id()) if isinstance(self._trackid, set) else self._trackid.append(newtrack.id())
        self.actorid(newtrack.id())
        return self

    def trackfilter(self, f):
        &#34;&#34;&#34;Remove all tracks such that the lambda function f(trackid) resolves to False&#34;&#34;&#34;
        assert callable(f)
        self._trackid = [tid for tid in self._trackid if f(tid)]
        if self.actorid() not in self._trackid:
            self._actorid = None
        return self

    def replace(self, oldtrack, newtrack):
        &#34;&#34;&#34;Replace oldtrack with newtrack if present in self._tracks.  Pass in a trackdict to share reference to track, so that track owner can modify the track and this object observes the change&#34;&#34;&#34;
        assert isinstance(oldtrack, Track) and isinstance(newtrack, Track), &#34;Invalid input - must be vipy.object.Track&#34;
        if self.hastrack(oldtrack):
            self._trackid.discard(oldtrack.id())
            self._trackid.add(newtrack.id())
            if self.actorid() == oldtrack.id():
                self.actorid(newtrack.id())
        return self    

    def replaceid(self, oldtrackid, newtrackid):
        &#34;&#34;&#34;Replace oldtrack with newtrack if present in self._tracks.  Pass in a trackdict to share reference to track, so that track owner can modify the track and this object observes the change&#34;&#34;&#34;
        if self.hastrack(oldtrackid):
            ti = set(self._trackid)
            ti.discard(oldtrackid)
            ti.add(newtrackid)
            if self.actorid() == oldtrackid:
                self.actorid(newtrackid)
            self._trackid = list(ti)
        return self    
    
    def during(self, frame):
        &#34;&#34;&#34;Is frame during the time interval (startframe, endframe) inclusive?&#34;&#34;&#34;
        return int(frame) &gt;= self._startframe and int(frame) &lt;= self._endframe

    def during_interval(self, startframe, endframe, inclusive=False):
        &#34;&#34;&#34;Is the activity occurring for any frames within the interval [startframe, endframe) (non-inclusive of endframe)?&#34;&#34;&#34;
        ef = endframe+(0 if not inclusive else 1)
        return (startframe &gt;= self._startframe and startframe &lt;= self._endframe) or (ef &gt;= self._startframe and ef &lt;= self._endframe) or (startframe &lt;= self._startframe and ef &gt;= self._endframe)

    
    def union(self, other, confweight=0.5, maxconf=False):
        &#34;&#34;&#34;Compute the union of the new activity other to this activity by updating the start and end times and computing the mean confidence.
        
           -Note: other must have the same category and track IDs as self
           -confweight [0,1]:  the convex combinatiopn weight applied to the new activity 
        &#34;&#34;&#34;
        assert isinstance(other, Activity), &#34;Invalid input&#34;
        assert self._actorid == other._actorid, &#34;Actor ID must be the same&#34;
        assert self._label == other._label, &#34;Assigned activity is a different category&#34;
        assert self._framerate == other._framerate, &#34;Invalid input&#34;
        assert confweight &gt;= 0 and confweight &lt;= 1, &#34;Confidence weight must be [0,1]&#34;

        self.startframe(min(other._startframe, self._startframe))
        self.endframe(max(other._endframe, self._endframe))
        if other.confidence() is not None and self.confidence() is not None:
            self.confidence(float((1.0-confweight)*self.confidence() + confweight*other.confidence()) if not maxconf else float(max(self.confidence(), other.confidence())))  # running mean confidence or max
        return self
        
    def temporal_iou(self, other):
        &#34;&#34;&#34;Return the temporal intersection over union of two activities or this activity and a track&#34;&#34;&#34;
        assert isinstance(other, Activity) or isinstance(other, Track), &#34;Invalid input - must be vipy.activity.Activity or vipy.object.Track&#34;
        assert self._framerate == other._framerate, &#34;invalid input - framerate must match&#34;
        (sf, ef) = (other._startframe, other._endframe) if isinstance(other, Activity) else (other.startframe(), other.endframe())  # attribute access is faster than methods
        
        t_start = min(self._startframe, sf)
        t_end = max(self._endframe, ef)
        t_union = float(t_end - t_start)
        
        t_start = max(self._startframe, sf)
        t_end = min(self._endframe, ef)
        t_intersection = float(t_end - t_start)
        
        return (t_intersection / t_union) if t_intersection &gt; 0 else 0
    
    def offset(self, dt):
        dt = dt if isinstance(dt, int) else int(np.round(dt*self.framerate()))
        self._startframe = int(self._startframe + dt)
        self._endframe = int(self._endframe + dt)
        return self

    def truncate(self, start=None, end=None):
        &#34;&#34;&#34;Truncate the activity so that it is between start and end&#34;&#34;&#34;
        startframe = int(np.round(start*self.framerate())) if isinstance(start, float) else start
        endframe = int(np.round(end*self.framerate())) if isinstance(end, float) else end        
        
        self._startframe = self._startframe if startframe is None else max(self._startframe, startframe)
        self._endframe = self._endframe if endframe is None else min(self._endframe, endframe)
        self._endframe = self._endframe if self._endframe &gt; self._startframe else self._startframe  # degenerate truncation
        return self
            
    def id(self, newid=None):
        if newid is None:
            return self._id
        else:
            self._id = newid
            return self

    def clone(self, rekey=False):
        #a = copy.deepcopy(self)
        a = Activity.from_json(self.json(encode=False))
        if rekey:
            a.id(newid=shortuuid())
        return a
    
    def temporalpad(self, df):
        &#34;&#34;&#34;Add a temporal pad of df=(before frames, after frames) or df=pad frames to the start and end of the activity.  The padded start frame may be negative.&#34;&#34;&#34;
        df = (df, df) if not isinstance(df, tuple) else df
        self._startframe -= int(df[0])
        self._endframe += int(df[1])
        return self  

    def padto(self, t):
        &#34;&#34;&#34;Add a symmetric temporal pad so that the activity is at least t seconds long&#34;&#34;&#34;
        return self.temporalpad(int(np.ceil(self.framerate()*((t - self.duration())/2.0)))) if t &gt; self.duration() else self

    def disjoint(self, other, strict=False):
        &#34;&#34;&#34;Enforce disjoint activities with other by shifting the endframe or startframe of self to not overlap if they share the same tracks.
           Other may be an Activity() or list of Activity()
           if strict=True, then throw an exception if other or self is fully contained with the other, resulting in degenerate activity after disjoint
        &#34;&#34;&#34;
        for o in tolist(other):
            assert isinstance(o, Activity), &#34;Invalid input - must be vipy.activity.Activity() or list of activities&#34;       
            if strict:
                assert not (o.during(self.startframe()) and o.during(self.endframe())), &#34;Self cannot fully overlap other&#34;
                assert not (self.during(o.startframe()) and self.during(o.endframe())), &#34;Other cannot fully overlap self&#34;
            if o.trackids() == self.trackids() and o.during(self.endframe()):
                self.endframe(o.startframe()-1)
            if o.trackids() == self.trackids() and o.during(self.startframe()):
                self.startframe(o.endframe()+1)
        return self  # may be zero length now

    def temporal_distance(self, other):
        &#34;&#34;&#34;Return the temporal distance in frames between self and other which is the minimum frame difference between the end of one to the start of the other, or zero if they overlap&#34;&#34;&#34;
        assert isinstance(other, Activity), &#34;Invalid input - must be vipy.activity.Activity()&#34;
        return (max(self.startframe(), other.startframe()) - min(self.endframe(), other.endframe())) if self.temporal_iou(other) == 0 else 0

    def within(self, startframe, endframe):
        &#34;&#34;&#34;Is the activity within the frame rate (startframe, endframe)?&#34;&#34;&#34;
        return self.startframe() &gt;= startframe and self.endframe() &lt;= endframe
    </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="vipy.activity.Activity"><code class="flex name class">
<span>class <span class="ident">Activity</span></span>
<span>(</span><span>startframe, endframe, framerate=30, label=None, category=None, tracks=None, attributes=None, actorid=None, confidence=None, id=None, shortlabel=None)</span>
</code></dt>
<dd>
<div class="desc"><p>vipy.object.Activity class</p>
<p>An activity is a grouping of one or more tracks involved in an activity within a given startframe and endframe.
The activity occurs at a given (startframe, endframe), where these frame indexes are extracted at the provided framerate.
All objects are passed by reference with a globally unique track ID, for the tracks involved with the activity.
This
is done since tracks can exist after an activity completes, and that tracks should update the spatial transformation of boxes.</p>
<p>Valid constructors</p>
<pre><code class="language-python">t = vipy.object.Track(category='Person')
a = vipy.object.Activity(startframe=0, endframe=10, category='Walking', tracks=t.id())
a = vipy.object.Activity(startframe=0, endframe=10, category='Walking', tracks=t)    
</code></pre>
<p>Note.. shortlabel is kepy for backwards compatibility and will be deprecated</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/activity.py#L14-L399" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Activity(object):
    &#34;&#34;&#34;vipy.object.Activity class
    
    An activity is a grouping of one or more tracks involved in an activity within a given startframe and endframe.
    The activity occurs at a given (startframe, endframe), where these frame indexes are extracted at the provided framerate.
    All objects are passed by reference with a globally unique track ID, for the tracks involved with the activity.  This 
    is done since tracks can exist after an activity completes, and that tracks should update the spatial transformation of boxes.
        
    Valid constructors

    ```python 
    t = vipy.object.Track(category=&#39;Person&#39;)
    a = vipy.object.Activity(startframe=0, endframe=10, category=&#39;Walking&#39;, tracks=t.id())
    a = vipy.object.Activity(startframe=0, endframe=10, category=&#39;Walking&#39;, tracks=t)    
    ```

    Note.. shortlabel is kepy for backwards compatibility and will be deprecated
    
    &#34;&#34;&#34;
    __slots__ = [&#39;_id&#39;, &#39;_startframe&#39;, &#39;_endframe&#39;, &#39;_framerate&#39;, &#39;_label&#39;, &#39;_trackid&#39;, &#39;_actorid&#39;, &#39;attributes&#39;]
    def __init__(self, startframe, endframe, framerate=30, label=None, category=None, tracks=None, attributes=None, actorid=None, confidence=None, id=None, shortlabel=None):
        assert not (label is not None and category is not None), &#34;Activity() Constructor requires either label or category kwargs, not both&#34;
        assert startframe &lt;= endframe, &#34;Start frame must be less than or equal to end frame&#34;
        assert framerate is not None, &#34;initial framerate is required for framerate conversion&#34;
        if tracks:
            tracks = [v for (k,v) in tracks.items()] if isinstance(tracks, dict) else tracks  # backwards compatible, track dictionary input
            assert (all([isstring(t) for t in tracks]) or all([isinstance(t, Track) for t in tracks])), &#34;Invalid track input&#34;
            if all([isinstance(t, Track) for t in tracks]):
                assert any([any([t.during(f) for f in range(startframe, endframe)]) for t in tracks]), &#34;At least one track must be be present in at least one frame when this activity occurs&#34;
                tracks = [t.id() for t in tracks]  
        trackid = set(tracks) if tracks is not None else (set([actorid]) if actorid is not None else set([]))  # only store IDs, not tracks
        
        if tracks is not None and actorid is not None and actorid not in trackid:
            trackid.add(actorid)

        self._id = shortuuid() if id is None else id  # use provided
        self._startframe = int(startframe)
        self._endframe = int(endframe)
        self._framerate = float(framerate)
        self._label = category if category is not None else label        
        self._trackid = trackid
        self._actorid = actorid

        self.attributes = attributes.copy() if attributes is not None else {}  # shallow copy
        if confidence is not None:
            self.attributes[&#39;confidence&#39;] = float(confidence)

    def hasattribute(self, k):
        return k in self.attributes

    def confidence(self, c=None):
        if c is not None:
            self.attributes[&#39;confidence&#39;] = float(c)
            return self
        else:
            return self.attributes[&#39;confidence&#39;] if &#39;confidence&#39; in self.attributes else None
    
    @classmethod
    def from_json(obj, s):
        d = json.loads(s) if not isinstance(s, dict) else s
        d = {k.lstrip(&#39;_&#39;):v for (k,v) in d.items()}  # prettyjson (remove &#34;_&#34; prefix to attributes)                                        
        return obj(startframe=int(d[&#39;startframe&#39;]),
                   endframe=int(d[&#39;endframe&#39;]),
                   framerate=d[&#39;framerate&#39;] if &#39;framerate&#39; in d else None,
                   category=d[&#39;label&#39;] if &#39;label&#39; in d else None,
                   tracks=d[&#39;trackid&#39;] if &#39;trackid&#39; in d else None,
                   attributes=d[&#39;attributes&#39;] if &#39;attributes&#39; in d else None,
                   actorid=d[&#39;actorid&#39;] if &#39;actorid&#39; in d else None,
                   id=d[&#39;id&#39;] if &#39;id&#39; in d else None)
                
    def __len__(self):
        &#34;&#34;&#34;Return activity length in frames, or zero if degenerate&#34;&#34;&#34;
        return max(0, self.endframe() - self.startframe())

    def duration(self, s=None, centered=False):
        &#34;&#34;&#34;The length of the activity in seconds.

        Args:
            s: [float] The number of seconds for this activity, starting at the startframe
            centered: [bool] If true, then set the duration centered on the middle frame

        Returns:
            The duration in seconds of this activity object (if s=None)
            This activity object with the requested duration (if s!=None)
        &#34;&#34;&#34;
        assert self.framerate() is not None, &#34;Framerate must be set in constructor&#34;
        if s is None:
            return len(self) / float(self.framerate())
        else:
            return (self.endframe(self.startframe() + int(round(s*self.framerate()))) if not centered else 
                    self.truncate(startframe=self.middleframe()-int(np.ceil(s*self.framerate())//2), endframe=self.middleframe()+int(np.ceil(s*self.framerate())//2)))
        
    def __repr__(self):
        return str(&#39;&lt;vipy.activity.Activity: category=&#34;%s&#34;, frames=(%d,%d), tracks=%s%s&gt;&#39; % (self.category(), self.startframe(), self.endframe(), len(self.trackids()), &#39;&#39; if self.confidence() is None else &#39;, confidence=%1.2f&#39; % self.confidence()))

    def dict(self):
        &#34;&#34;&#34;Return a python dictionary containing the relevant serialized attributes suitable for JSON encoding&#34;&#34;&#34;
        return self.json(s=None, encode=False)

    def __json__(self):
        &#34;&#34;&#34;Serialization method for json package&#34;&#34;&#34;
        return self.json(encode=True)
    
    def json(self, encode=True):
        d = {k.lstrip(&#39;_&#39;):getattr(self, k) for k in Activity.__slots__ if getattr(self, k) is not None}  # prettyjson (remove &#34;_&#34; prefix to attributes)          
        d = {k:v if k != &#39;trackid&#39; else tuple(v) for (k,v) in d.items()}  # sets are non-serializable
        return json.dumps(d) if encode else d
    
    def actorid(self, actorid=None):
        if actorid is None:
            return self._actorid
        else:
            self._actorid = actorid
            if actorid not in self._trackid:
                self._trackid.add(actorid) if isinstance(self._trackid, set) else self._trackid.append(actorid)                    
            return self

    def startframe(self, f=None):
        if f is None:
            return self._startframe
        else:
            self._startframe = f
            return self
    
    def endframe(self, f=None):
        if f is None:
            return self._endframe
        else:
            self._endframe = int(f)
            return self

    def middleframe(self):
        &#34;&#34;&#34;Return the middle frame number of the activity&#34;&#34;&#34;
        return int(np.round((self._endframe - self._startframe) / 2.0)) + self._startframe

    def _set_framerate(self, fps):
        &#34;&#34;&#34;Override framerate conversion and just set the framerate attribute.  This should really be set only in constructor.  Use with caution!&#34;&#34;&#34;
        self._framerate = float(fps)
        return self

    def framerate(self, fps=None, speed=None):
        &#34;&#34;&#34;Resample (startframe, endframe) from known original framerate set by constructor to be new framerate fps&#34;&#34;&#34;        
        if fps is None and speed is None:
            return self._framerate
        else:
            assert fps is not None or speed is not None, &#34;Invalid input&#34;
            assert not (fps is not None and speed is not None), &#34;Invalid input&#34;
            assert speed is None or speed &gt; 0, &#34;Invalid speed, must specify speed multiplier s=1, s=2 for 2x faster, s=0.5 for half slower&#34;                    
            assert fps is None or fps &gt; 0, &#34;Invalid framerate&#34;
            assert self._framerate is not None, &#34;Framerate conversion requires that the framerate is known for current activities.  This must be provided to the vipy.object.Activity() constructor.&#34;

            fps = float(fps) if fps is not None else (1.0/speed)*self._framerate            
            (self._startframe, self._endframe) = [int(np.round(f*(fps/float(self._framerate)))) for f in (self._startframe, self._endframe)]
            self._framerate = float(fps)
            return self
    
    def category(self, label=None):
        &#34;&#34;&#34;Change the label to the new label &#34;&#34;&#34;
        if label is not None:
            self._label = label
            return self
        else:
            return self._label

    def categoryif(self, ifcategory, tocategory=None):
        &#34;&#34;&#34;If the current category is equal to ifcategory, then change it to newcategory.

        Args:
            
            ifcategory [dict, str]: May be a dictionary {ifcategory:tocategory}, or just an ifcategory
            tocategory [str]:  the target category 

        Returns:
        
            this object with the category changed.

        .. note:: This is useful for converting synonyms such as self.categoryif(&#39;person_sits&#39;, &#39;person_sitting&#39;)
        &#34;&#34;&#34;
        assert (isinstance(ifcategory, dict) and tocategory is None) or tocategory is not None

        if isinstance(ifcategory, dict):
            for (k,v) in ifcategory.items():
                self.categoryif(k, v)
        elif self.category() == ifcategory:
            self.category(tocategory)
        return self

    def label(self, label=None):
        &#34;&#34;&#34;Alias for category&#34;&#34;&#34;
        return self.category(label)

    def add(self, track):
        &#34;&#34;&#34;Add the track id for the track to this activity, so that if the track is changed externally it is reflected here&#34;&#34;&#34;
        assert isinstance(track, Track), &#34;Invalid input - must be vipy.object.Track&#34;
        assert self.during_interval(track.startframe(), track.endframe()), &#34;The track must be present during the activity&#34;
        if track.id() not in self._trackid:
            self._trackid = list(self._trackid)
            self._trackid.append(track.id())
        return self

    def addid(self, trackid):
        &#34;&#34;&#34;Add the track id for the track to this activity, so that if the track is changed externally it is reflected here&#34;&#34;&#34;
        if trackid not in self._trackid:
            self._trackid = list(self._trackid)
            self._trackid.append(trackid)
        return self
    
    def tracks(self):
        &#34;&#34;&#34;alias for trackids&#34;&#34;&#34;
        return self.trackids()

    def cleartracks(self):
        &#34;&#34;&#34;Remove all track IDs from this activity&#34;&#34;&#34;
        self._trackid = []
        return self

    def trackids(self):
        &#34;&#34;&#34;Return a set of track IDs associated with this activity&#34;&#34;&#34;
        return set(self._trackid)

    def hasoverlap(self, other, threshold=0):
        &#34;&#34;&#34;Return true if the temporal_iou is greater than the provided threshold between self and other Track or other Activity&#34;&#34;&#34;
        assert isinstance(other, Activity) or isinstance(other, Track), &#34;Invalid input&#34;
        assert threshold &gt;= 0 and threshold &lt;= 1, &#34;Invalid temporal IOU threshold&#34;
        return (((min(self._endframe, other.endframe()) - max(self._startframe, other.startframe())) &gt; 0) if threshold == 0 else
                self.temporal_iou(other) &gt; threshold)
        
    def isneighbor(self, other, framegate=10):
        return self.temporal_iou(other.clone().temporalpad(framegate)) &gt; 0 

    def hastrack(self, track):
        &#34;&#34;&#34;Is the track part of the activity?&#34;&#34;&#34;
        assert isstring(track) or isinstance(track, Track), &#34;Invalid input - Must be a vipy.object.Track().id() or vipy.object.Track()&#34;
        trackid = track.id() if isinstance(track, Track) else track
        return trackid in self._trackid

    def hastrackoverlap(self, track):
        &#34;&#34;&#34;is the activity occurring during the interval when the track is occurring and is this track assigned to the activity?&#34;&#34;&#34;
        assert isinstance(track, Track)
        return self.hastrack(track) and self.temporal_iou(track) &gt; 0

    def append(self, newtrack):
        &#34;&#34;&#34;Append newtrack to this activity and set as actorid()&#34;&#34;&#34;
        assert isinstance(newtrack, Track), &#34;Invalid input - must be vipy.object.Track&#34;
        self._trackid.add(newtrack.id()) if isinstance(self._trackid, set) else self._trackid.append(newtrack.id())
        self.actorid(newtrack.id())
        return self

    def trackfilter(self, f):
        &#34;&#34;&#34;Remove all tracks such that the lambda function f(trackid) resolves to False&#34;&#34;&#34;
        assert callable(f)
        self._trackid = [tid for tid in self._trackid if f(tid)]
        if self.actorid() not in self._trackid:
            self._actorid = None
        return self

    def replace(self, oldtrack, newtrack):
        &#34;&#34;&#34;Replace oldtrack with newtrack if present in self._tracks.  Pass in a trackdict to share reference to track, so that track owner can modify the track and this object observes the change&#34;&#34;&#34;
        assert isinstance(oldtrack, Track) and isinstance(newtrack, Track), &#34;Invalid input - must be vipy.object.Track&#34;
        if self.hastrack(oldtrack):
            self._trackid.discard(oldtrack.id())
            self._trackid.add(newtrack.id())
            if self.actorid() == oldtrack.id():
                self.actorid(newtrack.id())
        return self    

    def replaceid(self, oldtrackid, newtrackid):
        &#34;&#34;&#34;Replace oldtrack with newtrack if present in self._tracks.  Pass in a trackdict to share reference to track, so that track owner can modify the track and this object observes the change&#34;&#34;&#34;
        if self.hastrack(oldtrackid):
            ti = set(self._trackid)
            ti.discard(oldtrackid)
            ti.add(newtrackid)
            if self.actorid() == oldtrackid:
                self.actorid(newtrackid)
            self._trackid = list(ti)
        return self    
    
    def during(self, frame):
        &#34;&#34;&#34;Is frame during the time interval (startframe, endframe) inclusive?&#34;&#34;&#34;
        return int(frame) &gt;= self._startframe and int(frame) &lt;= self._endframe

    def during_interval(self, startframe, endframe, inclusive=False):
        &#34;&#34;&#34;Is the activity occurring for any frames within the interval [startframe, endframe) (non-inclusive of endframe)?&#34;&#34;&#34;
        ef = endframe+(0 if not inclusive else 1)
        return (startframe &gt;= self._startframe and startframe &lt;= self._endframe) or (ef &gt;= self._startframe and ef &lt;= self._endframe) or (startframe &lt;= self._startframe and ef &gt;= self._endframe)

    
    def union(self, other, confweight=0.5, maxconf=False):
        &#34;&#34;&#34;Compute the union of the new activity other to this activity by updating the start and end times and computing the mean confidence.
        
           -Note: other must have the same category and track IDs as self
           -confweight [0,1]:  the convex combinatiopn weight applied to the new activity 
        &#34;&#34;&#34;
        assert isinstance(other, Activity), &#34;Invalid input&#34;
        assert self._actorid == other._actorid, &#34;Actor ID must be the same&#34;
        assert self._label == other._label, &#34;Assigned activity is a different category&#34;
        assert self._framerate == other._framerate, &#34;Invalid input&#34;
        assert confweight &gt;= 0 and confweight &lt;= 1, &#34;Confidence weight must be [0,1]&#34;

        self.startframe(min(other._startframe, self._startframe))
        self.endframe(max(other._endframe, self._endframe))
        if other.confidence() is not None and self.confidence() is not None:
            self.confidence(float((1.0-confweight)*self.confidence() + confweight*other.confidence()) if not maxconf else float(max(self.confidence(), other.confidence())))  # running mean confidence or max
        return self
        
    def temporal_iou(self, other):
        &#34;&#34;&#34;Return the temporal intersection over union of two activities or this activity and a track&#34;&#34;&#34;
        assert isinstance(other, Activity) or isinstance(other, Track), &#34;Invalid input - must be vipy.activity.Activity or vipy.object.Track&#34;
        assert self._framerate == other._framerate, &#34;invalid input - framerate must match&#34;
        (sf, ef) = (other._startframe, other._endframe) if isinstance(other, Activity) else (other.startframe(), other.endframe())  # attribute access is faster than methods
        
        t_start = min(self._startframe, sf)
        t_end = max(self._endframe, ef)
        t_union = float(t_end - t_start)
        
        t_start = max(self._startframe, sf)
        t_end = min(self._endframe, ef)
        t_intersection = float(t_end - t_start)
        
        return (t_intersection / t_union) if t_intersection &gt; 0 else 0
    
    def offset(self, dt):
        dt = dt if isinstance(dt, int) else int(np.round(dt*self.framerate()))
        self._startframe = int(self._startframe + dt)
        self._endframe = int(self._endframe + dt)
        return self

    def truncate(self, start=None, end=None):
        &#34;&#34;&#34;Truncate the activity so that it is between start and end&#34;&#34;&#34;
        startframe = int(np.round(start*self.framerate())) if isinstance(start, float) else start
        endframe = int(np.round(end*self.framerate())) if isinstance(end, float) else end        
        
        self._startframe = self._startframe if startframe is None else max(self._startframe, startframe)
        self._endframe = self._endframe if endframe is None else min(self._endframe, endframe)
        self._endframe = self._endframe if self._endframe &gt; self._startframe else self._startframe  # degenerate truncation
        return self
            
    def id(self, newid=None):
        if newid is None:
            return self._id
        else:
            self._id = newid
            return self

    def clone(self, rekey=False):
        #a = copy.deepcopy(self)
        a = Activity.from_json(self.json(encode=False))
        if rekey:
            a.id(newid=shortuuid())
        return a
    
    def temporalpad(self, df):
        &#34;&#34;&#34;Add a temporal pad of df=(before frames, after frames) or df=pad frames to the start and end of the activity.  The padded start frame may be negative.&#34;&#34;&#34;
        df = (df, df) if not isinstance(df, tuple) else df
        self._startframe -= int(df[0])
        self._endframe += int(df[1])
        return self  

    def padto(self, t):
        &#34;&#34;&#34;Add a symmetric temporal pad so that the activity is at least t seconds long&#34;&#34;&#34;
        return self.temporalpad(int(np.ceil(self.framerate()*((t - self.duration())/2.0)))) if t &gt; self.duration() else self

    def disjoint(self, other, strict=False):
        &#34;&#34;&#34;Enforce disjoint activities with other by shifting the endframe or startframe of self to not overlap if they share the same tracks.
           Other may be an Activity() or list of Activity()
           if strict=True, then throw an exception if other or self is fully contained with the other, resulting in degenerate activity after disjoint
        &#34;&#34;&#34;
        for o in tolist(other):
            assert isinstance(o, Activity), &#34;Invalid input - must be vipy.activity.Activity() or list of activities&#34;       
            if strict:
                assert not (o.during(self.startframe()) and o.during(self.endframe())), &#34;Self cannot fully overlap other&#34;
                assert not (self.during(o.startframe()) and self.during(o.endframe())), &#34;Other cannot fully overlap self&#34;
            if o.trackids() == self.trackids() and o.during(self.endframe()):
                self.endframe(o.startframe()-1)
            if o.trackids() == self.trackids() and o.during(self.startframe()):
                self.startframe(o.endframe()+1)
        return self  # may be zero length now

    def temporal_distance(self, other):
        &#34;&#34;&#34;Return the temporal distance in frames between self and other which is the minimum frame difference between the end of one to the start of the other, or zero if they overlap&#34;&#34;&#34;
        assert isinstance(other, Activity), &#34;Invalid input - must be vipy.activity.Activity()&#34;
        return (max(self.startframe(), other.startframe()) - min(self.endframe(), other.endframe())) if self.temporal_iou(other) == 0 else 0

    def within(self, startframe, endframe):
        &#34;&#34;&#34;Is the activity within the frame rate (startframe, endframe)?&#34;&#34;&#34;
        return self.startframe() &gt;= startframe and self.endframe() &lt;= endframe</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="vipy.activity.Activity.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>s)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="vipy.activity.Activity.attributes"><code class="name">var <span class="ident">attributes</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/activity.py#L14-L399" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Activity(object):
    &#34;&#34;&#34;vipy.object.Activity class
    
    An activity is a grouping of one or more tracks involved in an activity within a given startframe and endframe.
    The activity occurs at a given (startframe, endframe), where these frame indexes are extracted at the provided framerate.
    All objects are passed by reference with a globally unique track ID, for the tracks involved with the activity.  This 
    is done since tracks can exist after an activity completes, and that tracks should update the spatial transformation of boxes.
        
    Valid constructors

    ```python 
    t = vipy.object.Track(category=&#39;Person&#39;)
    a = vipy.object.Activity(startframe=0, endframe=10, category=&#39;Walking&#39;, tracks=t.id())
    a = vipy.object.Activity(startframe=0, endframe=10, category=&#39;Walking&#39;, tracks=t)    
    ```

    Note.. shortlabel is kepy for backwards compatibility and will be deprecated
    
    &#34;&#34;&#34;
    __slots__ = [&#39;_id&#39;, &#39;_startframe&#39;, &#39;_endframe&#39;, &#39;_framerate&#39;, &#39;_label&#39;, &#39;_trackid&#39;, &#39;_actorid&#39;, &#39;attributes&#39;]
    def __init__(self, startframe, endframe, framerate=30, label=None, category=None, tracks=None, attributes=None, actorid=None, confidence=None, id=None, shortlabel=None):
        assert not (label is not None and category is not None), &#34;Activity() Constructor requires either label or category kwargs, not both&#34;
        assert startframe &lt;= endframe, &#34;Start frame must be less than or equal to end frame&#34;
        assert framerate is not None, &#34;initial framerate is required for framerate conversion&#34;
        if tracks:
            tracks = [v for (k,v) in tracks.items()] if isinstance(tracks, dict) else tracks  # backwards compatible, track dictionary input
            assert (all([isstring(t) for t in tracks]) or all([isinstance(t, Track) for t in tracks])), &#34;Invalid track input&#34;
            if all([isinstance(t, Track) for t in tracks]):
                assert any([any([t.during(f) for f in range(startframe, endframe)]) for t in tracks]), &#34;At least one track must be be present in at least one frame when this activity occurs&#34;
                tracks = [t.id() for t in tracks]  
        trackid = set(tracks) if tracks is not None else (set([actorid]) if actorid is not None else set([]))  # only store IDs, not tracks
        
        if tracks is not None and actorid is not None and actorid not in trackid:
            trackid.add(actorid)

        self._id = shortuuid() if id is None else id  # use provided
        self._startframe = int(startframe)
        self._endframe = int(endframe)
        self._framerate = float(framerate)
        self._label = category if category is not None else label        
        self._trackid = trackid
        self._actorid = actorid

        self.attributes = attributes.copy() if attributes is not None else {}  # shallow copy
        if confidence is not None:
            self.attributes[&#39;confidence&#39;] = float(confidence)

    def hasattribute(self, k):
        return k in self.attributes

    def confidence(self, c=None):
        if c is not None:
            self.attributes[&#39;confidence&#39;] = float(c)
            return self
        else:
            return self.attributes[&#39;confidence&#39;] if &#39;confidence&#39; in self.attributes else None
    
    @classmethod
    def from_json(obj, s):
        d = json.loads(s) if not isinstance(s, dict) else s
        d = {k.lstrip(&#39;_&#39;):v for (k,v) in d.items()}  # prettyjson (remove &#34;_&#34; prefix to attributes)                                        
        return obj(startframe=int(d[&#39;startframe&#39;]),
                   endframe=int(d[&#39;endframe&#39;]),
                   framerate=d[&#39;framerate&#39;] if &#39;framerate&#39; in d else None,
                   category=d[&#39;label&#39;] if &#39;label&#39; in d else None,
                   tracks=d[&#39;trackid&#39;] if &#39;trackid&#39; in d else None,
                   attributes=d[&#39;attributes&#39;] if &#39;attributes&#39; in d else None,
                   actorid=d[&#39;actorid&#39;] if &#39;actorid&#39; in d else None,
                   id=d[&#39;id&#39;] if &#39;id&#39; in d else None)
                
    def __len__(self):
        &#34;&#34;&#34;Return activity length in frames, or zero if degenerate&#34;&#34;&#34;
        return max(0, self.endframe() - self.startframe())

    def duration(self, s=None, centered=False):
        &#34;&#34;&#34;The length of the activity in seconds.

        Args:
            s: [float] The number of seconds for this activity, starting at the startframe
            centered: [bool] If true, then set the duration centered on the middle frame

        Returns:
            The duration in seconds of this activity object (if s=None)
            This activity object with the requested duration (if s!=None)
        &#34;&#34;&#34;
        assert self.framerate() is not None, &#34;Framerate must be set in constructor&#34;
        if s is None:
            return len(self) / float(self.framerate())
        else:
            return (self.endframe(self.startframe() + int(round(s*self.framerate()))) if not centered else 
                    self.truncate(startframe=self.middleframe()-int(np.ceil(s*self.framerate())//2), endframe=self.middleframe()+int(np.ceil(s*self.framerate())//2)))
        
    def __repr__(self):
        return str(&#39;&lt;vipy.activity.Activity: category=&#34;%s&#34;, frames=(%d,%d), tracks=%s%s&gt;&#39; % (self.category(), self.startframe(), self.endframe(), len(self.trackids()), &#39;&#39; if self.confidence() is None else &#39;, confidence=%1.2f&#39; % self.confidence()))

    def dict(self):
        &#34;&#34;&#34;Return a python dictionary containing the relevant serialized attributes suitable for JSON encoding&#34;&#34;&#34;
        return self.json(s=None, encode=False)

    def __json__(self):
        &#34;&#34;&#34;Serialization method for json package&#34;&#34;&#34;
        return self.json(encode=True)
    
    def json(self, encode=True):
        d = {k.lstrip(&#39;_&#39;):getattr(self, k) for k in Activity.__slots__ if getattr(self, k) is not None}  # prettyjson (remove &#34;_&#34; prefix to attributes)          
        d = {k:v if k != &#39;trackid&#39; else tuple(v) for (k,v) in d.items()}  # sets are non-serializable
        return json.dumps(d) if encode else d
    
    def actorid(self, actorid=None):
        if actorid is None:
            return self._actorid
        else:
            self._actorid = actorid
            if actorid not in self._trackid:
                self._trackid.add(actorid) if isinstance(self._trackid, set) else self._trackid.append(actorid)                    
            return self

    def startframe(self, f=None):
        if f is None:
            return self._startframe
        else:
            self._startframe = f
            return self
    
    def endframe(self, f=None):
        if f is None:
            return self._endframe
        else:
            self._endframe = int(f)
            return self

    def middleframe(self):
        &#34;&#34;&#34;Return the middle frame number of the activity&#34;&#34;&#34;
        return int(np.round((self._endframe - self._startframe) / 2.0)) + self._startframe

    def _set_framerate(self, fps):
        &#34;&#34;&#34;Override framerate conversion and just set the framerate attribute.  This should really be set only in constructor.  Use with caution!&#34;&#34;&#34;
        self._framerate = float(fps)
        return self

    def framerate(self, fps=None, speed=None):
        &#34;&#34;&#34;Resample (startframe, endframe) from known original framerate set by constructor to be new framerate fps&#34;&#34;&#34;        
        if fps is None and speed is None:
            return self._framerate
        else:
            assert fps is not None or speed is not None, &#34;Invalid input&#34;
            assert not (fps is not None and speed is not None), &#34;Invalid input&#34;
            assert speed is None or speed &gt; 0, &#34;Invalid speed, must specify speed multiplier s=1, s=2 for 2x faster, s=0.5 for half slower&#34;                    
            assert fps is None or fps &gt; 0, &#34;Invalid framerate&#34;
            assert self._framerate is not None, &#34;Framerate conversion requires that the framerate is known for current activities.  This must be provided to the vipy.object.Activity() constructor.&#34;

            fps = float(fps) if fps is not None else (1.0/speed)*self._framerate            
            (self._startframe, self._endframe) = [int(np.round(f*(fps/float(self._framerate)))) for f in (self._startframe, self._endframe)]
            self._framerate = float(fps)
            return self
    
    def category(self, label=None):
        &#34;&#34;&#34;Change the label to the new label &#34;&#34;&#34;
        if label is not None:
            self._label = label
            return self
        else:
            return self._label

    def categoryif(self, ifcategory, tocategory=None):
        &#34;&#34;&#34;If the current category is equal to ifcategory, then change it to newcategory.

        Args:
            
            ifcategory [dict, str]: May be a dictionary {ifcategory:tocategory}, or just an ifcategory
            tocategory [str]:  the target category 

        Returns:
        
            this object with the category changed.

        .. note:: This is useful for converting synonyms such as self.categoryif(&#39;person_sits&#39;, &#39;person_sitting&#39;)
        &#34;&#34;&#34;
        assert (isinstance(ifcategory, dict) and tocategory is None) or tocategory is not None

        if isinstance(ifcategory, dict):
            for (k,v) in ifcategory.items():
                self.categoryif(k, v)
        elif self.category() == ifcategory:
            self.category(tocategory)
        return self

    def label(self, label=None):
        &#34;&#34;&#34;Alias for category&#34;&#34;&#34;
        return self.category(label)

    def add(self, track):
        &#34;&#34;&#34;Add the track id for the track to this activity, so that if the track is changed externally it is reflected here&#34;&#34;&#34;
        assert isinstance(track, Track), &#34;Invalid input - must be vipy.object.Track&#34;
        assert self.during_interval(track.startframe(), track.endframe()), &#34;The track must be present during the activity&#34;
        if track.id() not in self._trackid:
            self._trackid = list(self._trackid)
            self._trackid.append(track.id())
        return self

    def addid(self, trackid):
        &#34;&#34;&#34;Add the track id for the track to this activity, so that if the track is changed externally it is reflected here&#34;&#34;&#34;
        if trackid not in self._trackid:
            self._trackid = list(self._trackid)
            self._trackid.append(trackid)
        return self
    
    def tracks(self):
        &#34;&#34;&#34;alias for trackids&#34;&#34;&#34;
        return self.trackids()

    def cleartracks(self):
        &#34;&#34;&#34;Remove all track IDs from this activity&#34;&#34;&#34;
        self._trackid = []
        return self

    def trackids(self):
        &#34;&#34;&#34;Return a set of track IDs associated with this activity&#34;&#34;&#34;
        return set(self._trackid)

    def hasoverlap(self, other, threshold=0):
        &#34;&#34;&#34;Return true if the temporal_iou is greater than the provided threshold between self and other Track or other Activity&#34;&#34;&#34;
        assert isinstance(other, Activity) or isinstance(other, Track), &#34;Invalid input&#34;
        assert threshold &gt;= 0 and threshold &lt;= 1, &#34;Invalid temporal IOU threshold&#34;
        return (((min(self._endframe, other.endframe()) - max(self._startframe, other.startframe())) &gt; 0) if threshold == 0 else
                self.temporal_iou(other) &gt; threshold)
        
    def isneighbor(self, other, framegate=10):
        return self.temporal_iou(other.clone().temporalpad(framegate)) &gt; 0 

    def hastrack(self, track):
        &#34;&#34;&#34;Is the track part of the activity?&#34;&#34;&#34;
        assert isstring(track) or isinstance(track, Track), &#34;Invalid input - Must be a vipy.object.Track().id() or vipy.object.Track()&#34;
        trackid = track.id() if isinstance(track, Track) else track
        return trackid in self._trackid

    def hastrackoverlap(self, track):
        &#34;&#34;&#34;is the activity occurring during the interval when the track is occurring and is this track assigned to the activity?&#34;&#34;&#34;
        assert isinstance(track, Track)
        return self.hastrack(track) and self.temporal_iou(track) &gt; 0

    def append(self, newtrack):
        &#34;&#34;&#34;Append newtrack to this activity and set as actorid()&#34;&#34;&#34;
        assert isinstance(newtrack, Track), &#34;Invalid input - must be vipy.object.Track&#34;
        self._trackid.add(newtrack.id()) if isinstance(self._trackid, set) else self._trackid.append(newtrack.id())
        self.actorid(newtrack.id())
        return self

    def trackfilter(self, f):
        &#34;&#34;&#34;Remove all tracks such that the lambda function f(trackid) resolves to False&#34;&#34;&#34;
        assert callable(f)
        self._trackid = [tid for tid in self._trackid if f(tid)]
        if self.actorid() not in self._trackid:
            self._actorid = None
        return self

    def replace(self, oldtrack, newtrack):
        &#34;&#34;&#34;Replace oldtrack with newtrack if present in self._tracks.  Pass in a trackdict to share reference to track, so that track owner can modify the track and this object observes the change&#34;&#34;&#34;
        assert isinstance(oldtrack, Track) and isinstance(newtrack, Track), &#34;Invalid input - must be vipy.object.Track&#34;
        if self.hastrack(oldtrack):
            self._trackid.discard(oldtrack.id())
            self._trackid.add(newtrack.id())
            if self.actorid() == oldtrack.id():
                self.actorid(newtrack.id())
        return self    

    def replaceid(self, oldtrackid, newtrackid):
        &#34;&#34;&#34;Replace oldtrack with newtrack if present in self._tracks.  Pass in a trackdict to share reference to track, so that track owner can modify the track and this object observes the change&#34;&#34;&#34;
        if self.hastrack(oldtrackid):
            ti = set(self._trackid)
            ti.discard(oldtrackid)
            ti.add(newtrackid)
            if self.actorid() == oldtrackid:
                self.actorid(newtrackid)
            self._trackid = list(ti)
        return self    
    
    def during(self, frame):
        &#34;&#34;&#34;Is frame during the time interval (startframe, endframe) inclusive?&#34;&#34;&#34;
        return int(frame) &gt;= self._startframe and int(frame) &lt;= self._endframe

    def during_interval(self, startframe, endframe, inclusive=False):
        &#34;&#34;&#34;Is the activity occurring for any frames within the interval [startframe, endframe) (non-inclusive of endframe)?&#34;&#34;&#34;
        ef = endframe+(0 if not inclusive else 1)
        return (startframe &gt;= self._startframe and startframe &lt;= self._endframe) or (ef &gt;= self._startframe and ef &lt;= self._endframe) or (startframe &lt;= self._startframe and ef &gt;= self._endframe)

    
    def union(self, other, confweight=0.5, maxconf=False):
        &#34;&#34;&#34;Compute the union of the new activity other to this activity by updating the start and end times and computing the mean confidence.
        
           -Note: other must have the same category and track IDs as self
           -confweight [0,1]:  the convex combinatiopn weight applied to the new activity 
        &#34;&#34;&#34;
        assert isinstance(other, Activity), &#34;Invalid input&#34;
        assert self._actorid == other._actorid, &#34;Actor ID must be the same&#34;
        assert self._label == other._label, &#34;Assigned activity is a different category&#34;
        assert self._framerate == other._framerate, &#34;Invalid input&#34;
        assert confweight &gt;= 0 and confweight &lt;= 1, &#34;Confidence weight must be [0,1]&#34;

        self.startframe(min(other._startframe, self._startframe))
        self.endframe(max(other._endframe, self._endframe))
        if other.confidence() is not None and self.confidence() is not None:
            self.confidence(float((1.0-confweight)*self.confidence() + confweight*other.confidence()) if not maxconf else float(max(self.confidence(), other.confidence())))  # running mean confidence or max
        return self
        
    def temporal_iou(self, other):
        &#34;&#34;&#34;Return the temporal intersection over union of two activities or this activity and a track&#34;&#34;&#34;
        assert isinstance(other, Activity) or isinstance(other, Track), &#34;Invalid input - must be vipy.activity.Activity or vipy.object.Track&#34;
        assert self._framerate == other._framerate, &#34;invalid input - framerate must match&#34;
        (sf, ef) = (other._startframe, other._endframe) if isinstance(other, Activity) else (other.startframe(), other.endframe())  # attribute access is faster than methods
        
        t_start = min(self._startframe, sf)
        t_end = max(self._endframe, ef)
        t_union = float(t_end - t_start)
        
        t_start = max(self._startframe, sf)
        t_end = min(self._endframe, ef)
        t_intersection = float(t_end - t_start)
        
        return (t_intersection / t_union) if t_intersection &gt; 0 else 0
    
    def offset(self, dt):
        dt = dt if isinstance(dt, int) else int(np.round(dt*self.framerate()))
        self._startframe = int(self._startframe + dt)
        self._endframe = int(self._endframe + dt)
        return self

    def truncate(self, start=None, end=None):
        &#34;&#34;&#34;Truncate the activity so that it is between start and end&#34;&#34;&#34;
        startframe = int(np.round(start*self.framerate())) if isinstance(start, float) else start
        endframe = int(np.round(end*self.framerate())) if isinstance(end, float) else end        
        
        self._startframe = self._startframe if startframe is None else max(self._startframe, startframe)
        self._endframe = self._endframe if endframe is None else min(self._endframe, endframe)
        self._endframe = self._endframe if self._endframe &gt; self._startframe else self._startframe  # degenerate truncation
        return self
            
    def id(self, newid=None):
        if newid is None:
            return self._id
        else:
            self._id = newid
            return self

    def clone(self, rekey=False):
        #a = copy.deepcopy(self)
        a = Activity.from_json(self.json(encode=False))
        if rekey:
            a.id(newid=shortuuid())
        return a
    
    def temporalpad(self, df):
        &#34;&#34;&#34;Add a temporal pad of df=(before frames, after frames) or df=pad frames to the start and end of the activity.  The padded start frame may be negative.&#34;&#34;&#34;
        df = (df, df) if not isinstance(df, tuple) else df
        self._startframe -= int(df[0])
        self._endframe += int(df[1])
        return self  

    def padto(self, t):
        &#34;&#34;&#34;Add a symmetric temporal pad so that the activity is at least t seconds long&#34;&#34;&#34;
        return self.temporalpad(int(np.ceil(self.framerate()*((t - self.duration())/2.0)))) if t &gt; self.duration() else self

    def disjoint(self, other, strict=False):
        &#34;&#34;&#34;Enforce disjoint activities with other by shifting the endframe or startframe of self to not overlap if they share the same tracks.
           Other may be an Activity() or list of Activity()
           if strict=True, then throw an exception if other or self is fully contained with the other, resulting in degenerate activity after disjoint
        &#34;&#34;&#34;
        for o in tolist(other):
            assert isinstance(o, Activity), &#34;Invalid input - must be vipy.activity.Activity() or list of activities&#34;       
            if strict:
                assert not (o.during(self.startframe()) and o.during(self.endframe())), &#34;Self cannot fully overlap other&#34;
                assert not (self.during(o.startframe()) and self.during(o.endframe())), &#34;Other cannot fully overlap self&#34;
            if o.trackids() == self.trackids() and o.during(self.endframe()):
                self.endframe(o.startframe()-1)
            if o.trackids() == self.trackids() and o.during(self.startframe()):
                self.startframe(o.endframe()+1)
        return self  # may be zero length now

    def temporal_distance(self, other):
        &#34;&#34;&#34;Return the temporal distance in frames between self and other which is the minimum frame difference between the end of one to the start of the other, or zero if they overlap&#34;&#34;&#34;
        assert isinstance(other, Activity), &#34;Invalid input - must be vipy.activity.Activity()&#34;
        return (max(self.startframe(), other.startframe()) - min(self.endframe(), other.endframe())) if self.temporal_iou(other) == 0 else 0

    def within(self, startframe, endframe):
        &#34;&#34;&#34;Is the activity within the frame rate (startframe, endframe)?&#34;&#34;&#34;
        return self.startframe() &gt;= startframe and self.endframe() &lt;= endframe</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="vipy.activity.Activity.actorid"><code class="name flex">
<span>def <span class="ident">actorid</span></span>(<span>self, actorid=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/activity.py#L122-L129" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def actorid(self, actorid=None):
    if actorid is None:
        return self._actorid
    else:
        self._actorid = actorid
        if actorid not in self._trackid:
            self._trackid.add(actorid) if isinstance(self._trackid, set) else self._trackid.append(actorid)                    
        return self</code></pre>
</details>
</dd>
<dt id="vipy.activity.Activity.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, track)</span>
</code></dt>
<dd>
<div class="desc"><p>Add the track id for the track to this activity, so that if the track is changed externally it is reflected here</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/activity.py#L205-L212" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def add(self, track):
    &#34;&#34;&#34;Add the track id for the track to this activity, so that if the track is changed externally it is reflected here&#34;&#34;&#34;
    assert isinstance(track, Track), &#34;Invalid input - must be vipy.object.Track&#34;
    assert self.during_interval(track.startframe(), track.endframe()), &#34;The track must be present during the activity&#34;
    if track.id() not in self._trackid:
        self._trackid = list(self._trackid)
        self._trackid.append(track.id())
    return self</code></pre>
</details>
</dd>
<dt id="vipy.activity.Activity.addid"><code class="name flex">
<span>def <span class="ident">addid</span></span>(<span>self, trackid)</span>
</code></dt>
<dd>
<div class="desc"><p>Add the track id for the track to this activity, so that if the track is changed externally it is reflected here</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/activity.py#L214-L219" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def addid(self, trackid):
    &#34;&#34;&#34;Add the track id for the track to this activity, so that if the track is changed externally it is reflected here&#34;&#34;&#34;
    if trackid not in self._trackid:
        self._trackid = list(self._trackid)
        self._trackid.append(trackid)
    return self</code></pre>
</details>
</dd>
<dt id="vipy.activity.Activity.append"><code class="name flex">
<span>def <span class="ident">append</span></span>(<span>self, newtrack)</span>
</code></dt>
<dd>
<div class="desc"><p>Append newtrack to this activity and set as actorid()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/activity.py#L255-L260" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def append(self, newtrack):
    &#34;&#34;&#34;Append newtrack to this activity and set as actorid()&#34;&#34;&#34;
    assert isinstance(newtrack, Track), &#34;Invalid input - must be vipy.object.Track&#34;
    self._trackid.add(newtrack.id()) if isinstance(self._trackid, set) else self._trackid.append(newtrack.id())
    self.actorid(newtrack.id())
    return self</code></pre>
</details>
</dd>
<dt id="vipy.activity.Activity.category"><code class="name flex">
<span>def <span class="ident">category</span></span>(<span>self, label=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Change the label to the new label</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/activity.py#L170-L176" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def category(self, label=None):
    &#34;&#34;&#34;Change the label to the new label &#34;&#34;&#34;
    if label is not None:
        self._label = label
        return self
    else:
        return self._label</code></pre>
</details>
</dd>
<dt id="vipy.activity.Activity.categoryif"><code class="name flex">
<span>def <span class="ident">categoryif</span></span>(<span>self, ifcategory, tocategory=None)</span>
</code></dt>
<dd>
<div class="desc"><p>If the current category is equal to ifcategory, then change it to newcategory.</p>
<h2 id="args">Args</h2>
<p>ifcategory [dict, str]: May be a dictionary {ifcategory:tocategory}, or just an ifcategory
tocategory [str]:
the target category </p>
<h2 id="returns">Returns</h2>
<p>this object with the category changed.</p>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;This is useful for converting synonyms such as self.categoryif('person_sits', 'person_sitting')</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/activity.py#L178-L199" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def categoryif(self, ifcategory, tocategory=None):
    &#34;&#34;&#34;If the current category is equal to ifcategory, then change it to newcategory.

    Args:
        
        ifcategory [dict, str]: May be a dictionary {ifcategory:tocategory}, or just an ifcategory
        tocategory [str]:  the target category 

    Returns:
    
        this object with the category changed.

    .. note:: This is useful for converting synonyms such as self.categoryif(&#39;person_sits&#39;, &#39;person_sitting&#39;)
    &#34;&#34;&#34;
    assert (isinstance(ifcategory, dict) and tocategory is None) or tocategory is not None

    if isinstance(ifcategory, dict):
        for (k,v) in ifcategory.items():
            self.categoryif(k, v)
    elif self.category() == ifcategory:
        self.category(tocategory)
    return self</code></pre>
</details>
</dd>
<dt id="vipy.activity.Activity.cleartracks"><code class="name flex">
<span>def <span class="ident">cleartracks</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove all track IDs from this activity</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/activity.py#L225-L228" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def cleartracks(self):
    &#34;&#34;&#34;Remove all track IDs from this activity&#34;&#34;&#34;
    self._trackid = []
    return self</code></pre>
</details>
</dd>
<dt id="vipy.activity.Activity.clone"><code class="name flex">
<span>def <span class="ident">clone</span></span>(<span>self, rekey=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/activity.py#L358-L363" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def clone(self, rekey=False):
    #a = copy.deepcopy(self)
    a = Activity.from_json(self.json(encode=False))
    if rekey:
        a.id(newid=shortuuid())
    return a</code></pre>
</details>
</dd>
<dt id="vipy.activity.Activity.confidence"><code class="name flex">
<span>def <span class="ident">confidence</span></span>(<span>self, c=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/activity.py#L64-L69" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def confidence(self, c=None):
    if c is not None:
        self.attributes[&#39;confidence&#39;] = float(c)
        return self
    else:
        return self.attributes[&#39;confidence&#39;] if &#39;confidence&#39; in self.attributes else None</code></pre>
</details>
</dd>
<dt id="vipy.activity.Activity.dict"><code class="name flex">
<span>def <span class="ident">dict</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a python dictionary containing the relevant serialized attributes suitable for JSON encoding</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/activity.py#L109-L111" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dict(self):
    &#34;&#34;&#34;Return a python dictionary containing the relevant serialized attributes suitable for JSON encoding&#34;&#34;&#34;
    return self.json(s=None, encode=False)</code></pre>
</details>
</dd>
<dt id="vipy.activity.Activity.disjoint"><code class="name flex">
<span>def <span class="ident">disjoint</span></span>(<span>self, other, strict=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Enforce disjoint activities with other by shifting the endframe or startframe of self to not overlap if they share the same tracks.
Other may be an Activity() or list of Activity()
if strict=True, then throw an exception if other or self is fully contained with the other, resulting in degenerate activity after disjoint</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/activity.py#L376-L390" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def disjoint(self, other, strict=False):
    &#34;&#34;&#34;Enforce disjoint activities with other by shifting the endframe or startframe of self to not overlap if they share the same tracks.
       Other may be an Activity() or list of Activity()
       if strict=True, then throw an exception if other or self is fully contained with the other, resulting in degenerate activity after disjoint
    &#34;&#34;&#34;
    for o in tolist(other):
        assert isinstance(o, Activity), &#34;Invalid input - must be vipy.activity.Activity() or list of activities&#34;       
        if strict:
            assert not (o.during(self.startframe()) and o.during(self.endframe())), &#34;Self cannot fully overlap other&#34;
            assert not (self.during(o.startframe()) and self.during(o.endframe())), &#34;Other cannot fully overlap self&#34;
        if o.trackids() == self.trackids() and o.during(self.endframe()):
            self.endframe(o.startframe()-1)
        if o.trackids() == self.trackids() and o.during(self.startframe()):
            self.startframe(o.endframe()+1)
    return self  # may be zero length now</code></pre>
</details>
</dd>
<dt id="vipy.activity.Activity.duration"><code class="name flex">
<span>def <span class="ident">duration</span></span>(<span>self, s=None, centered=False)</span>
</code></dt>
<dd>
<div class="desc"><p>The length of the activity in seconds.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>s</code></strong></dt>
<dd>[float] The number of seconds for this activity, starting at the startframe</dd>
<dt><strong><code>centered</code></strong></dt>
<dd>[bool] If true, then set the duration centered on the middle frame</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The duration in seconds of this activity object (if s=None)
This activity object with the requested duration (if s!=None)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/activity.py#L88-L104" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def duration(self, s=None, centered=False):
    &#34;&#34;&#34;The length of the activity in seconds.

    Args:
        s: [float] The number of seconds for this activity, starting at the startframe
        centered: [bool] If true, then set the duration centered on the middle frame

    Returns:
        The duration in seconds of this activity object (if s=None)
        This activity object with the requested duration (if s!=None)
    &#34;&#34;&#34;
    assert self.framerate() is not None, &#34;Framerate must be set in constructor&#34;
    if s is None:
        return len(self) / float(self.framerate())
    else:
        return (self.endframe(self.startframe() + int(round(s*self.framerate()))) if not centered else 
                self.truncate(startframe=self.middleframe()-int(np.ceil(s*self.framerate())//2), endframe=self.middleframe()+int(np.ceil(s*self.framerate())//2)))</code></pre>
</details>
</dd>
<dt id="vipy.activity.Activity.during"><code class="name flex">
<span>def <span class="ident">during</span></span>(<span>self, frame)</span>
</code></dt>
<dd>
<div class="desc"><p>Is frame during the time interval (startframe, endframe) inclusive?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/activity.py#L291-L293" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def during(self, frame):
    &#34;&#34;&#34;Is frame during the time interval (startframe, endframe) inclusive?&#34;&#34;&#34;
    return int(frame) &gt;= self._startframe and int(frame) &lt;= self._endframe</code></pre>
</details>
</dd>
<dt id="vipy.activity.Activity.during_interval"><code class="name flex">
<span>def <span class="ident">during_interval</span></span>(<span>self, startframe, endframe, inclusive=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Is the activity occurring for any frames within the interval [startframe, endframe) (non-inclusive of endframe)?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/activity.py#L295-L298" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def during_interval(self, startframe, endframe, inclusive=False):
    &#34;&#34;&#34;Is the activity occurring for any frames within the interval [startframe, endframe) (non-inclusive of endframe)?&#34;&#34;&#34;
    ef = endframe+(0 if not inclusive else 1)
    return (startframe &gt;= self._startframe and startframe &lt;= self._endframe) or (ef &gt;= self._startframe and ef &lt;= self._endframe) or (startframe &lt;= self._startframe and ef &gt;= self._endframe)</code></pre>
</details>
</dd>
<dt id="vipy.activity.Activity.endframe"><code class="name flex">
<span>def <span class="ident">endframe</span></span>(<span>self, f=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/activity.py#L138-L143" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def endframe(self, f=None):
    if f is None:
        return self._endframe
    else:
        self._endframe = int(f)
        return self</code></pre>
</details>
</dd>
<dt id="vipy.activity.Activity.framerate"><code class="name flex">
<span>def <span class="ident">framerate</span></span>(<span>self, fps=None, speed=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Resample (startframe, endframe) from known original framerate set by constructor to be new framerate fps</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/activity.py#L154-L168" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def framerate(self, fps=None, speed=None):
    &#34;&#34;&#34;Resample (startframe, endframe) from known original framerate set by constructor to be new framerate fps&#34;&#34;&#34;        
    if fps is None and speed is None:
        return self._framerate
    else:
        assert fps is not None or speed is not None, &#34;Invalid input&#34;
        assert not (fps is not None and speed is not None), &#34;Invalid input&#34;
        assert speed is None or speed &gt; 0, &#34;Invalid speed, must specify speed multiplier s=1, s=2 for 2x faster, s=0.5 for half slower&#34;                    
        assert fps is None or fps &gt; 0, &#34;Invalid framerate&#34;
        assert self._framerate is not None, &#34;Framerate conversion requires that the framerate is known for current activities.  This must be provided to the vipy.object.Activity() constructor.&#34;

        fps = float(fps) if fps is not None else (1.0/speed)*self._framerate            
        (self._startframe, self._endframe) = [int(np.round(f*(fps/float(self._framerate)))) for f in (self._startframe, self._endframe)]
        self._framerate = float(fps)
        return self</code></pre>
</details>
</dd>
<dt id="vipy.activity.Activity.hasattribute"><code class="name flex">
<span>def <span class="ident">hasattribute</span></span>(<span>self, k)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/activity.py#L61-L62" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def hasattribute(self, k):
    return k in self.attributes</code></pre>
</details>
</dd>
<dt id="vipy.activity.Activity.hasoverlap"><code class="name flex">
<span>def <span class="ident">hasoverlap</span></span>(<span>self, other, threshold=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Return true if the temporal_iou is greater than the provided threshold between self and other Track or other Activity</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/activity.py#L234-L239" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def hasoverlap(self, other, threshold=0):
    &#34;&#34;&#34;Return true if the temporal_iou is greater than the provided threshold between self and other Track or other Activity&#34;&#34;&#34;
    assert isinstance(other, Activity) or isinstance(other, Track), &#34;Invalid input&#34;
    assert threshold &gt;= 0 and threshold &lt;= 1, &#34;Invalid temporal IOU threshold&#34;
    return (((min(self._endframe, other.endframe()) - max(self._startframe, other.startframe())) &gt; 0) if threshold == 0 else
            self.temporal_iou(other) &gt; threshold)</code></pre>
</details>
</dd>
<dt id="vipy.activity.Activity.hastrack"><code class="name flex">
<span>def <span class="ident">hastrack</span></span>(<span>self, track)</span>
</code></dt>
<dd>
<div class="desc"><p>Is the track part of the activity?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/activity.py#L244-L248" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def hastrack(self, track):
    &#34;&#34;&#34;Is the track part of the activity?&#34;&#34;&#34;
    assert isstring(track) or isinstance(track, Track), &#34;Invalid input - Must be a vipy.object.Track().id() or vipy.object.Track()&#34;
    trackid = track.id() if isinstance(track, Track) else track
    return trackid in self._trackid</code></pre>
</details>
</dd>
<dt id="vipy.activity.Activity.hastrackoverlap"><code class="name flex">
<span>def <span class="ident">hastrackoverlap</span></span>(<span>self, track)</span>
</code></dt>
<dd>
<div class="desc"><p>is the activity occurring during the interval when the track is occurring and is this track assigned to the activity?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/activity.py#L250-L253" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def hastrackoverlap(self, track):
    &#34;&#34;&#34;is the activity occurring during the interval when the track is occurring and is this track assigned to the activity?&#34;&#34;&#34;
    assert isinstance(track, Track)
    return self.hastrack(track) and self.temporal_iou(track) &gt; 0</code></pre>
</details>
</dd>
<dt id="vipy.activity.Activity.id"><code class="name flex">
<span>def <span class="ident">id</span></span>(<span>self, newid=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/activity.py#L351-L356" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def id(self, newid=None):
    if newid is None:
        return self._id
    else:
        self._id = newid
        return self</code></pre>
</details>
</dd>
<dt id="vipy.activity.Activity.isneighbor"><code class="name flex">
<span>def <span class="ident">isneighbor</span></span>(<span>self, other, framegate=10)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/activity.py#L241-L242" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isneighbor(self, other, framegate=10):
    return self.temporal_iou(other.clone().temporalpad(framegate)) &gt; 0 </code></pre>
</details>
</dd>
<dt id="vipy.activity.Activity.json"><code class="name flex">
<span>def <span class="ident">json</span></span>(<span>self, encode=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/activity.py#L117-L120" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def json(self, encode=True):
    d = {k.lstrip(&#39;_&#39;):getattr(self, k) for k in Activity.__slots__ if getattr(self, k) is not None}  # prettyjson (remove &#34;_&#34; prefix to attributes)          
    d = {k:v if k != &#39;trackid&#39; else tuple(v) for (k,v) in d.items()}  # sets are non-serializable
    return json.dumps(d) if encode else d</code></pre>
</details>
</dd>
<dt id="vipy.activity.Activity.label"><code class="name flex">
<span>def <span class="ident">label</span></span>(<span>self, label=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for category</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/activity.py#L201-L203" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def label(self, label=None):
    &#34;&#34;&#34;Alias for category&#34;&#34;&#34;
    return self.category(label)</code></pre>
</details>
</dd>
<dt id="vipy.activity.Activity.middleframe"><code class="name flex">
<span>def <span class="ident">middleframe</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the middle frame number of the activity</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/activity.py#L145-L147" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def middleframe(self):
    &#34;&#34;&#34;Return the middle frame number of the activity&#34;&#34;&#34;
    return int(np.round((self._endframe - self._startframe) / 2.0)) + self._startframe</code></pre>
</details>
</dd>
<dt id="vipy.activity.Activity.offset"><code class="name flex">
<span>def <span class="ident">offset</span></span>(<span>self, dt)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/activity.py#L335-L339" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def offset(self, dt):
    dt = dt if isinstance(dt, int) else int(np.round(dt*self.framerate()))
    self._startframe = int(self._startframe + dt)
    self._endframe = int(self._endframe + dt)
    return self</code></pre>
</details>
</dd>
<dt id="vipy.activity.Activity.padto"><code class="name flex">
<span>def <span class="ident">padto</span></span>(<span>self, t)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a symmetric temporal pad so that the activity is at least t seconds long</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/activity.py#L372-L374" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def padto(self, t):
    &#34;&#34;&#34;Add a symmetric temporal pad so that the activity is at least t seconds long&#34;&#34;&#34;
    return self.temporalpad(int(np.ceil(self.framerate()*((t - self.duration())/2.0)))) if t &gt; self.duration() else self</code></pre>
</details>
</dd>
<dt id="vipy.activity.Activity.replace"><code class="name flex">
<span>def <span class="ident">replace</span></span>(<span>self, oldtrack, newtrack)</span>
</code></dt>
<dd>
<div class="desc"><p>Replace oldtrack with newtrack if present in self._tracks.
Pass in a trackdict to share reference to track, so that track owner can modify the track and this object observes the change</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/activity.py#L270-L278" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def replace(self, oldtrack, newtrack):
    &#34;&#34;&#34;Replace oldtrack with newtrack if present in self._tracks.  Pass in a trackdict to share reference to track, so that track owner can modify the track and this object observes the change&#34;&#34;&#34;
    assert isinstance(oldtrack, Track) and isinstance(newtrack, Track), &#34;Invalid input - must be vipy.object.Track&#34;
    if self.hastrack(oldtrack):
        self._trackid.discard(oldtrack.id())
        self._trackid.add(newtrack.id())
        if self.actorid() == oldtrack.id():
            self.actorid(newtrack.id())
    return self    </code></pre>
</details>
</dd>
<dt id="vipy.activity.Activity.replaceid"><code class="name flex">
<span>def <span class="ident">replaceid</span></span>(<span>self, oldtrackid, newtrackid)</span>
</code></dt>
<dd>
<div class="desc"><p>Replace oldtrack with newtrack if present in self._tracks.
Pass in a trackdict to share reference to track, so that track owner can modify the track and this object observes the change</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/activity.py#L280-L289" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def replaceid(self, oldtrackid, newtrackid):
    &#34;&#34;&#34;Replace oldtrack with newtrack if present in self._tracks.  Pass in a trackdict to share reference to track, so that track owner can modify the track and this object observes the change&#34;&#34;&#34;
    if self.hastrack(oldtrackid):
        ti = set(self._trackid)
        ti.discard(oldtrackid)
        ti.add(newtrackid)
        if self.actorid() == oldtrackid:
            self.actorid(newtrackid)
        self._trackid = list(ti)
    return self    </code></pre>
</details>
</dd>
<dt id="vipy.activity.Activity.startframe"><code class="name flex">
<span>def <span class="ident">startframe</span></span>(<span>self, f=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/activity.py#L131-L136" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def startframe(self, f=None):
    if f is None:
        return self._startframe
    else:
        self._startframe = f
        return self</code></pre>
</details>
</dd>
<dt id="vipy.activity.Activity.temporal_distance"><code class="name flex">
<span>def <span class="ident">temporal_distance</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the temporal distance in frames between self and other which is the minimum frame difference between the end of one to the start of the other, or zero if they overlap</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/activity.py#L392-L395" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def temporal_distance(self, other):
    &#34;&#34;&#34;Return the temporal distance in frames between self and other which is the minimum frame difference between the end of one to the start of the other, or zero if they overlap&#34;&#34;&#34;
    assert isinstance(other, Activity), &#34;Invalid input - must be vipy.activity.Activity()&#34;
    return (max(self.startframe(), other.startframe()) - min(self.endframe(), other.endframe())) if self.temporal_iou(other) == 0 else 0</code></pre>
</details>
</dd>
<dt id="vipy.activity.Activity.temporal_iou"><code class="name flex">
<span>def <span class="ident">temporal_iou</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the temporal intersection over union of two activities or this activity and a track</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/activity.py#L319-L333" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def temporal_iou(self, other):
    &#34;&#34;&#34;Return the temporal intersection over union of two activities or this activity and a track&#34;&#34;&#34;
    assert isinstance(other, Activity) or isinstance(other, Track), &#34;Invalid input - must be vipy.activity.Activity or vipy.object.Track&#34;
    assert self._framerate == other._framerate, &#34;invalid input - framerate must match&#34;
    (sf, ef) = (other._startframe, other._endframe) if isinstance(other, Activity) else (other.startframe(), other.endframe())  # attribute access is faster than methods
    
    t_start = min(self._startframe, sf)
    t_end = max(self._endframe, ef)
    t_union = float(t_end - t_start)
    
    t_start = max(self._startframe, sf)
    t_end = min(self._endframe, ef)
    t_intersection = float(t_end - t_start)
    
    return (t_intersection / t_union) if t_intersection &gt; 0 else 0</code></pre>
</details>
</dd>
<dt id="vipy.activity.Activity.temporalpad"><code class="name flex">
<span>def <span class="ident">temporalpad</span></span>(<span>self, df)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a temporal pad of df=(before frames, after frames) or df=pad frames to the start and end of the activity.
The padded start frame may be negative.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/activity.py#L365-L370" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def temporalpad(self, df):
    &#34;&#34;&#34;Add a temporal pad of df=(before frames, after frames) or df=pad frames to the start and end of the activity.  The padded start frame may be negative.&#34;&#34;&#34;
    df = (df, df) if not isinstance(df, tuple) else df
    self._startframe -= int(df[0])
    self._endframe += int(df[1])
    return self  </code></pre>
</details>
</dd>
<dt id="vipy.activity.Activity.trackfilter"><code class="name flex">
<span>def <span class="ident">trackfilter</span></span>(<span>self, f)</span>
</code></dt>
<dd>
<div class="desc"><p>Remove all tracks such that the lambda function f(trackid) resolves to False</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/activity.py#L262-L268" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def trackfilter(self, f):
    &#34;&#34;&#34;Remove all tracks such that the lambda function f(trackid) resolves to False&#34;&#34;&#34;
    assert callable(f)
    self._trackid = [tid for tid in self._trackid if f(tid)]
    if self.actorid() not in self._trackid:
        self._actorid = None
    return self</code></pre>
</details>
</dd>
<dt id="vipy.activity.Activity.trackids"><code class="name flex">
<span>def <span class="ident">trackids</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a set of track IDs associated with this activity</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/activity.py#L230-L232" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def trackids(self):
    &#34;&#34;&#34;Return a set of track IDs associated with this activity&#34;&#34;&#34;
    return set(self._trackid)</code></pre>
</details>
</dd>
<dt id="vipy.activity.Activity.tracks"><code class="name flex">
<span>def <span class="ident">tracks</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>alias for trackids</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/activity.py#L221-L223" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def tracks(self):
    &#34;&#34;&#34;alias for trackids&#34;&#34;&#34;
    return self.trackids()</code></pre>
</details>
</dd>
<dt id="vipy.activity.Activity.truncate"><code class="name flex">
<span>def <span class="ident">truncate</span></span>(<span>self, start=None, end=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Truncate the activity so that it is between start and end</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/activity.py#L341-L349" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def truncate(self, start=None, end=None):
    &#34;&#34;&#34;Truncate the activity so that it is between start and end&#34;&#34;&#34;
    startframe = int(np.round(start*self.framerate())) if isinstance(start, float) else start
    endframe = int(np.round(end*self.framerate())) if isinstance(end, float) else end        
    
    self._startframe = self._startframe if startframe is None else max(self._startframe, startframe)
    self._endframe = self._endframe if endframe is None else min(self._endframe, endframe)
    self._endframe = self._endframe if self._endframe &gt; self._startframe else self._startframe  # degenerate truncation
    return self</code></pre>
</details>
</dd>
<dt id="vipy.activity.Activity.union"><code class="name flex">
<span>def <span class="ident">union</span></span>(<span>self, other, confweight=0.5, maxconf=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the union of the new activity other to this activity by updating the start and end times and computing the mean confidence.</p>
<p>-Note: other must have the same category and track IDs as self
-confweight [0,1]:
the convex combinatiopn weight applied to the new activity</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/activity.py#L301-L317" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def union(self, other, confweight=0.5, maxconf=False):
    &#34;&#34;&#34;Compute the union of the new activity other to this activity by updating the start and end times and computing the mean confidence.
    
       -Note: other must have the same category and track IDs as self
       -confweight [0,1]:  the convex combinatiopn weight applied to the new activity 
    &#34;&#34;&#34;
    assert isinstance(other, Activity), &#34;Invalid input&#34;
    assert self._actorid == other._actorid, &#34;Actor ID must be the same&#34;
    assert self._label == other._label, &#34;Assigned activity is a different category&#34;
    assert self._framerate == other._framerate, &#34;Invalid input&#34;
    assert confweight &gt;= 0 and confweight &lt;= 1, &#34;Confidence weight must be [0,1]&#34;

    self.startframe(min(other._startframe, self._startframe))
    self.endframe(max(other._endframe, self._endframe))
    if other.confidence() is not None and self.confidence() is not None:
        self.confidence(float((1.0-confweight)*self.confidence() + confweight*other.confidence()) if not maxconf else float(max(self.confidence(), other.confidence())))  # running mean confidence or max
    return self</code></pre>
</details>
</dd>
<dt id="vipy.activity.Activity.within"><code class="name flex">
<span>def <span class="ident">within</span></span>(<span>self, startframe, endframe)</span>
</code></dt>
<dd>
<div class="desc"><p>Is the activity within the frame rate (startframe, endframe)?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/activity.py#L397-L399" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def within(self, startframe, endframe):
    &#34;&#34;&#34;Is the activity within the frame rate (startframe, endframe)?&#34;&#34;&#34;
    return self.startframe() &gt;= startframe and self.endframe() &lt;= endframe</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="VIPY" href="https://github.com/visym/vipy/">
<img src="https://www.visym.com/labs/images/visym_logo_black_notext.png" alt="" width="60">
</a>
<h1 style="font-size:200%;"><b>VIPY:</b> Visual Dataset Transformation</h1>
</header>
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = './doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="vipy" href="index.html">vipy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="vipy.activity.Activity" href="#vipy.activity.Activity">Activity</a></code></h4>
<ul class="two-column">
<li><code><a title="vipy.activity.Activity.actorid" href="#vipy.activity.Activity.actorid">actorid</a></code></li>
<li><code><a title="vipy.activity.Activity.add" href="#vipy.activity.Activity.add">add</a></code></li>
<li><code><a title="vipy.activity.Activity.addid" href="#vipy.activity.Activity.addid">addid</a></code></li>
<li><code><a title="vipy.activity.Activity.append" href="#vipy.activity.Activity.append">append</a></code></li>
<li><code><a title="vipy.activity.Activity.attributes" href="#vipy.activity.Activity.attributes">attributes</a></code></li>
<li><code><a title="vipy.activity.Activity.category" href="#vipy.activity.Activity.category">category</a></code></li>
<li><code><a title="vipy.activity.Activity.categoryif" href="#vipy.activity.Activity.categoryif">categoryif</a></code></li>
<li><code><a title="vipy.activity.Activity.cleartracks" href="#vipy.activity.Activity.cleartracks">cleartracks</a></code></li>
<li><code><a title="vipy.activity.Activity.clone" href="#vipy.activity.Activity.clone">clone</a></code></li>
<li><code><a title="vipy.activity.Activity.confidence" href="#vipy.activity.Activity.confidence">confidence</a></code></li>
<li><code><a title="vipy.activity.Activity.dict" href="#vipy.activity.Activity.dict">dict</a></code></li>
<li><code><a title="vipy.activity.Activity.disjoint" href="#vipy.activity.Activity.disjoint">disjoint</a></code></li>
<li><code><a title="vipy.activity.Activity.duration" href="#vipy.activity.Activity.duration">duration</a></code></li>
<li><code><a title="vipy.activity.Activity.during" href="#vipy.activity.Activity.during">during</a></code></li>
<li><code><a title="vipy.activity.Activity.during_interval" href="#vipy.activity.Activity.during_interval">during_interval</a></code></li>
<li><code><a title="vipy.activity.Activity.endframe" href="#vipy.activity.Activity.endframe">endframe</a></code></li>
<li><code><a title="vipy.activity.Activity.framerate" href="#vipy.activity.Activity.framerate">framerate</a></code></li>
<li><code><a title="vipy.activity.Activity.from_json" href="#vipy.activity.Activity.from_json">from_json</a></code></li>
<li><code><a title="vipy.activity.Activity.hasattribute" href="#vipy.activity.Activity.hasattribute">hasattribute</a></code></li>
<li><code><a title="vipy.activity.Activity.hasoverlap" href="#vipy.activity.Activity.hasoverlap">hasoverlap</a></code></li>
<li><code><a title="vipy.activity.Activity.hastrack" href="#vipy.activity.Activity.hastrack">hastrack</a></code></li>
<li><code><a title="vipy.activity.Activity.hastrackoverlap" href="#vipy.activity.Activity.hastrackoverlap">hastrackoverlap</a></code></li>
<li><code><a title="vipy.activity.Activity.id" href="#vipy.activity.Activity.id">id</a></code></li>
<li><code><a title="vipy.activity.Activity.isneighbor" href="#vipy.activity.Activity.isneighbor">isneighbor</a></code></li>
<li><code><a title="vipy.activity.Activity.json" href="#vipy.activity.Activity.json">json</a></code></li>
<li><code><a title="vipy.activity.Activity.label" href="#vipy.activity.Activity.label">label</a></code></li>
<li><code><a title="vipy.activity.Activity.middleframe" href="#vipy.activity.Activity.middleframe">middleframe</a></code></li>
<li><code><a title="vipy.activity.Activity.offset" href="#vipy.activity.Activity.offset">offset</a></code></li>
<li><code><a title="vipy.activity.Activity.padto" href="#vipy.activity.Activity.padto">padto</a></code></li>
<li><code><a title="vipy.activity.Activity.replace" href="#vipy.activity.Activity.replace">replace</a></code></li>
<li><code><a title="vipy.activity.Activity.replaceid" href="#vipy.activity.Activity.replaceid">replaceid</a></code></li>
<li><code><a title="vipy.activity.Activity.startframe" href="#vipy.activity.Activity.startframe">startframe</a></code></li>
<li><code><a title="vipy.activity.Activity.temporal_distance" href="#vipy.activity.Activity.temporal_distance">temporal_distance</a></code></li>
<li><code><a title="vipy.activity.Activity.temporal_iou" href="#vipy.activity.Activity.temporal_iou">temporal_iou</a></code></li>
<li><code><a title="vipy.activity.Activity.temporalpad" href="#vipy.activity.Activity.temporalpad">temporalpad</a></code></li>
<li><code><a title="vipy.activity.Activity.trackfilter" href="#vipy.activity.Activity.trackfilter">trackfilter</a></code></li>
<li><code><a title="vipy.activity.Activity.trackids" href="#vipy.activity.Activity.trackids">trackids</a></code></li>
<li><code><a title="vipy.activity.Activity.tracks" href="#vipy.activity.Activity.tracks">tracks</a></code></li>
<li><code><a title="vipy.activity.Activity.truncate" href="#vipy.activity.Activity.truncate">truncate</a></code></li>
<li><code><a title="vipy.activity.Activity.union" href="#vipy.activity.Activity.union">union</a></code></li>
<li><code><a title="vipy.activity.Activity.within" href="#vipy.activity.Activity.within">within</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
