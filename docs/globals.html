<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.6" />
<meta name="google-site-verification" content="aB8LkQegj94_TJPdrcJm2ldIRWyXY82Jp24Gtkdgyn0" />
<title>vipy.globals API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vipy.globals</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/globals.py#L1-L284" class="git-link">Browse git</a>
</summary>
<pre><code class="python">import os
import webbrowser
import tempfile
import builtins
import logging 
import concurrent.futures 


# Global mutable dictionary
GLOBAL = {&#39;DASK_CLIENT&#39;: None,   # Global Dask() client for distributed processing
          &#39;CONCURRENT_FUTURES&#39;:None,  # global futures client 
          &#39;CACHE&#39;:os.environ[&#39;VIPY_CACHE&#39;] if &#39;VIPY_CACHE&#39; in os.environ else None,   # Cache directory for vipy.video and vipy.image donwloads
          &#39;LOGGER&#39;:logging.getLogger(&#39;vipy&#39;),     # The global logger
          &#39;DEBUG&#39;:False, # globally enable debugging flags
          &#39;GUI&#39;:{&#39;escape&#39;:False},
          &#39;AWS&#39;:{&#39;AWS_ACCESS_KEY_ID&#39;:os.environ[&#39;VIPY_AWS_ACCESS_KEY_ID&#39;] if &#39;VIPY_AWS_ACCESS_KEY_ID&#39; in os.environ else None,
                 &#39;AWS_SECRET_ACCESS_KEY&#39;:os.environ[&#39;VIPY_AWS_SECRET_ACCESS_KEY&#39;] if &#39;VIPY_AWS_SECRET_ACCESS_KEY&#39; in os.environ else None,
                 &#39;AWS_SESSION_TOKEN&#39;:os.environ[&#39;VIPY_AWS_SESSION_TOKEN&#39;] if &#39;VIPY_AWS_SESSION_TOKEN&#39; in os.environ else None},
          &#39;LATEX&#39;:os.environ[&#39;VIPY_LATEX&#39;] if &#39;VIPY_LATEX&#39; in os.environ else None}

log = GLOBAL[&#39;LOGGER&#39;]

def logger():
    return GLOBALS[&#39;LOGGER&#39;]


class Dask(object):
    &#34;&#34;&#34;Dask distributed client&#34;&#34;&#34;
    
    def __init__(self, num_workers=None, threaded=True, dashboard=False, verbose=False, address=None):
        from vipy.util import try_import
        try_import(&#39;dask&#39;, &#39;dask distributed&#39;); import dask, dask.distributed;
    
        assert address is not None or num_workers is not None, &#34;Invalid input&#34;

        self._num_workers = num_workers
        self._has_dashboard = dashboard
        
        # Dask configuration: https://docs.dask.org/en/latest/configuration.html
        # - when using vipy.dataset.Dataset minibatch iterator, large minibatches can result in a warning about large graphs
        # - The end user can set these environemnt variables, and will only be overwritten with defaults here if not provided
        if &#39;DASK_LOGGING__DISTRIBUTED&#39; not in os.environ:
            os.environ[&#39;DASK_LOGGING__DISTRIBUTED&#39;] = &#39;warning&#39; if not verbose else &#39;info&#39;
        if &#39;DASK_DISTRIBUTED__COMM__TIMEOUTS__CONNECT&#39; not in os.environ:
            os.environ[&#39;DASK_DISTRIBUTED__COMM__TIMEOUTS__CONNECT&#39;] = &#34;30s&#34;
        if &#39;DASK_DISTRIBUTED__COMM__TIMEOUTS__TCP&#39; not in os.environ:
            os.environ[&#39;DASK_DISTRIBUTED__COMM__TIMEOUTS__TCP&#39;] = &#34;30s&#34;
        if &#39;DASK_DISTRIBUTED__DEPLOY__LOST_WORKER_TIMEOUT&#39; not in os.environ:
            os.environ[&#39;DASK_DISTRIBUTED__DEPLOY__LOST_WORKER_TIMEOUT&#39;] = &#34;30s&#34;
        if &#39;DASK_DISTRIBUTED__COMM__RETRY__COUNT&#39; not in os.environ:
            os.environ[&#39;DASK_DISTRIBUTED__COMM__RETRY__COUNT&#39;] = &#34;10&#34;        
        if &#39;DASK_ADMIN_LARGE_GRAPH_WARNING_THREHSOLD&#39; not in os.environ:
            os.environ[&#39;DASK_ADMIN_LARGE_GRAPH_WARNING_THREHSOLD&#39;] = &#34;50MB&#34;        

        dask.config.refresh()
        
        dask.config.set({&#39;DISTRIBUTED.COMM.RETRY.COUNT&#39;.lower():int(os.environ[&#39;DASK_DISTRIBUTED__COMM__RETRY__COUNT&#39;])})
        dask.config.set({&#39;DISTRIBUTED.COMM.TIMEOUTS.CONNECT&#39;.lower():os.environ[&#39;DASK_DISTRIBUTED__COMM__TIMEOUTS__CONNECT&#39;]})
        dask.config.set({&#39;DISTRIBUTED.COMM.TIMEOUTS.TCP&#39;.lower():os.environ[&#39;DASK_DISTRIBUTED__COMM__TIMEOUTS__TCP&#39;]})
        dask.config.set({&#39;DISTRIBUTED.DEPLOY.LOST_WORKER_TIMEOUT&#39;.lower():os.environ[&#39;DASK_DISTRIBUTED__DEPLOY__LOST_WORKER_TIMEOUT&#39;]})        
        dask.config.set({&#34;distributed.admin.large-graph-warning-threshold&#34;: os.environ[&#39;DASK_ADMIN_LARGE_GRAPH_WARNING_THREHSOLD&#39;]})
        
        
        # Worker env
        env = {&#39;VIPY_BACKEND&#39;:&#39;Agg&#39;,  # headless in workers
               &#39;PYTHONOPATH&#39;:os.environ[&#39;PYTHONPATH&#39;] if &#39;PYTHONPATH&#39; in os.environ else &#39;&#39;,
               &#39;PATH&#39;:os.environ[&#39;PATH&#39;] if &#39;PATH&#39; in os.environ else &#39;&#39;}

        if &#39;VIPY_CACHE&#39; in os.environ:
            env.update({&#39;VIPY_CACHE&#39;:os.environ[&#39;VIPY_CACHE&#39;]})
        if &#39;VIPY_AWS_ACCESS_KEY_ID&#39; in os.environ:
            env.update({&#39;VIPY_AWS_ACCESS_KEY_ID&#39;:os.environ[&#39;VIPY_AWS_ACCESS_KEY_ID&#39;]})            
        if &#39;VIPY_AWS_SECRET_ACCESS_KEY&#39; in os.environ:
            env.update({&#39;VIPY_AWS_SECRET_ACCESS_KEY&#39;:os.environ[&#39;VIPY_AWS_SECRET_ACCESS_KEY&#39;]})        
                    
        for (k,v) in os.environ.items():
            if k.startswith(&#39;DASK_&#39;):
                env[k] = v
    
        if address is not None:
            # Distributed scheduler
            self._client = dask.distributed.Client(name=&#39;vipy&#39;, address=address)

            # Update key environment variables on remote workers using out of band function (yuck)
            # Make sure that any environment variables are accessible on all machines!  (e.g. VIPY_CACHE)
            # If not, then you need to unset these variables from os.environ prior to calling Dask()
            def _f_setenv_remote(localenv):
                import os; os.environ.update(localenv)

            localenv = {k:v for (k,v) in os.environ.items() if k.startswith(&#39;VIPY_&#39;)}
            localenv.update( {&#39;VIPY_BACKEND&#39;:&#39;Agg&#39;} )
            self._client.run(lambda env=localenv: _f_setenv_remote(env))

        else:
            kwargs = {&#39;name&#39;:&#39;vipy&#39;,
                      &#39;address&#39;:address,  # to connect to distributed scheduler HOSTNAME:PORT
                      &#39;scheduler_port&#39;:0,   # random
                      &#39;dashboard_address&#39;:None if not dashboard else &#39;:0&#39;,  # random port
                      &#39;processes&#39;:not threaded,
                      &#39;threads_per_worker&#39;:1,
                      &#39;n_workers&#39;:num_workers,
                      &#39;local_directory&#39;:tempfile.mkdtemp()}
            kwargs.update({&#39;env&#39;:env, &#39;direct_to_workers&#39;:True} if not threaded else {})
            
            # Local scheduler
            self._client = dask.distributed.Client(**kwargs)
            

    def __repr__(self):
        if self._num_workers is not None:
            # Local 
            return str(&#39;&lt;vipy.globals.Dask: %s%s&gt;&#39; % (&#39;workers=%d&#39; % self.num_workers(), &#39;, dashboard=%s&#39; % str(self._client.dashboard_link) if self._has_dashboard else &#39;&#39;))
        elif self._client is not None:
            # Distributed
            return str(&#39;&lt;vipy.globals.Dask: %s&gt;&#39; % (str(self._client)))
        else:
            return str(&#39;&lt;vipy.globals.Dask: shutdown&#39;)

    def num_workers(self):
        return self._num_workers

    def shutdown(self):
        self._client.close()
        self._num_workers = None
        GLOBAL[&#39;DASK_CLIENT&#39;] = None        
        return self

    def client(self):
        return self._client



def cache(cachedir=None):
    &#34;&#34;&#34;The cache is the location that URLs are downloaded to on your system.  This can be set here, or with the environment variable VIPY_CACHE

    &gt;&gt;&gt; vipy.globals.cache(&#39;/path/to/.vipy&#39;)
    &gt;&gt;&gt; cachedir = vipy.globals.cache()

    Args:
        cachedir:  the location to store cached files when downloaded.  Can also be set using the VIPY_CACHE environment variable.  if none, return the current cachedir
    
    Returns:
        The current cachedir if cachedir=None else None
    
    &#34;&#34;&#34;
    if cachedir is not None:
        from vipy.util import remkdir        
        os.environ[&#39;VIPY_CACHE&#39;] = remkdir(cachedir)
        GLOBAL[&#39;CACHE&#39;] = cachedir
    return os.environ[&#39;VIPY_CACHE&#39;] if &#39;VIPY_CACHE&#39; in os.environ else None
    

def _user_hit_escape(b=None):
    &#34;&#34;&#34;Did the user hit the escape key?  Useful for matplotlib GUI to stop displaying video&#34;&#34;&#34;
    if b is None:
        if GLOBAL[&#39;GUI&#39;][&#39;escape&#39;]:
            GLOBAL[&#39;GUI&#39;][&#39;escape&#39;] = False  # toggle it
            return True
        else:
            return False
    else:
        # Set in vipy.gui.using_matplotlib.escape_to_exit()
        assert isinstance(b, bool)
        GLOBAL[&#39;GUI&#39;][&#39;escape&#39;] = b  

        
def cf(num_workers=None, threaded=True):
    if num_workers is not None:
        if GLOBAL[&#39;CONCURRENT_FUTURES&#39;]:
            GLOBAL[&#39;CONCURRENT_FUTURES&#39;].shutdown()
        GLOBAL[&#39;CONCURRENT_FUTURES&#39;] = (concurrent.futures.ThreadPoolExecutor(max_workers=num_workers, thread_name_prefix=&#39;vipy&#39;) if threaded else
                                        concurrent.futures.ProcessPoolExecutor(max_workers=num_workers))
    return GLOBAL[&#39;CONCURRENT_FUTURES&#39;]
                                                 
    
def dask(num_workers=None, dashboard=False, address=None, pct=None, threaded=True):
    &#34;&#34;&#34;Return the current Dask client, can be accessed globally for parallel processing.
    
    Args:
        pct: float in [0,1] the percentage of the current machine to use
        address:  the dask scheduler of the form &#39;HOSTNAME:PORT&#39;
        num_workers:  the number of prpcesses to use on the current machine
        dashboard: [bool] whether to inialize the dask client with a web dashboard
        threaded: [bool] if true, create threaded workers intead of processes

    Returns:
        The `vipy.batch.Dask` object pointing to the Dask Distrbuted object
    &#34;&#34;&#34;
    if pct is not None:
        assert pct &gt; 0 and pct &lt;= 1
        num_workers = int(pct*os.cpu_count())
    if address is not None or num_workers is not None:
        if GLOBAL[&#39;DASK_CLIENT&#39;]:
            GLOBAL[&#39;DASK_CLIENT&#39;].shutdown()
        GLOBAL[&#39;DASK_CLIENT&#39;] = Dask(num_workers, threaded=threaded, dashboard=dashboard, verbose=False, address=address)        
    return GLOBAL[&#39;DASK_CLIENT&#39;]


def parallel(workers=None, pct=None, threaded=True):
    &#34;&#34;&#34;Enable parallel processing with n&gt;=1 processes or a percentage of system core (pct in [0,1])  .

    This can be be used as a context manager
    
    &gt;&gt;&gt; with vipy.globals.parallel(n=4):
    &gt;&gt;&gt;     vipy.batch.Batch(...)

    or using the global variables:

    &gt;&gt;&gt; vipy.globals.parallel(n=4):
    &gt;&gt;&gt; vipy.batch.Batch(...)
    &gt;&gt;&gt; vipy.globals.noparallel()
    
    To check the current parallelism level:
    
    &gt;&gt;&gt; num_workers = vipy.globals.parallel().num_workers()

    To run with a dask scheduler:
    
    &gt;&gt;&gt; with vipy.globals.parallel(scheduler=&#39;10.0.1.1:8585&#39;)
    &gt;&gt;&gt;    vipy.batch.Batch(...)

    Args:
        workers: [int] number of parallel workers
        pct: [float] the percentage [0,1] of system cores to dedicate to parallel processing
        threaded [bool]: if false, use processes (not recommended, since vipy parallel processing usually releases the GIL)
    &#34;&#34;&#34;

    class Parallel():
        def __init__(self, workers):
            self._workers = workers
            self._threaded = threaded
            self.start()
            
        def __enter__(self):
            pass
            
        def __exit__(self, *args):            
            self.shutdown() 
            
        def __repr__(self):
            return &#39;&lt;vipy.globals.parallel: workers=%d, cf=%s&gt;&#39; % (self.num_workers(), GLOBAL[&#39;CONCURRENT_FUTURES&#39;] if GLOBAL[&#39;CONCURRENT_FUTURES&#39;] else &#39;stopped&#39;)

        def start(self):
            if not GLOBAL[&#39;CONCURRENT_FUTURES&#39;] and self._workers&gt;0:                
                cf(num_workers=self._workers, threaded=self._threaded)
            GLOBAL[&#39;LOGGER&#39;].info(&#39;Parallel executor initialized %s&#39; % self)
            return self
        
        def shutdown(self):
            if GLOBAL[&#39;CONCURRENT_FUTURES&#39;]:
                GLOBAL[&#39;LOGGER&#39;].info(&#39;Parallel executor shutdown %s&#39; % self)                            
                GLOBAL[&#39;CONCURRENT_FUTURES&#39;].shutdown(wait=True)
            GLOBAL[&#39;CONCURRENT_FUTURES&#39;] = None
        
        def num_workers(self):
            return self._workers

    return Parallel(workers if not pct else int(pct*os.cpu_count()))

def multithreading(n=None, pct=None):
    &#34;&#34;&#34;Context manager for concurrent futures multithreaded executor, use with `vipy.dataset.Dataset`&#34;&#34;&#34;
    return parallel(workers=n, pct=pct, threaded=True)

def multiprocessing(n=None, pct=None):
    &#34;&#34;&#34;Context manager for concurrent futures multiprocessing executor, use with `vipy.dataset.Dataset`&#34;&#34;&#34;    
    return parallel(workers=n, pct=pct, threaded=False)

def noparallel():
    &#34;&#34;&#34;Disable all parallel processing&#34;&#34;&#34;
    if GLOBAL[&#39;DASK_CLIENT&#39;] is not None:
        GLOBAL[&#39;DASK_CLIENT&#39;].shutdown()
        del GLOBAL[&#39;DASK_CLIENT&#39;]
        GLOBAL[&#39;LOGGER&#39;].info(&#39;Parallel executor shutdown&#39;)
    if GLOBAL[&#39;CONCURRENT_FUTURES&#39;]:
        GLOBAL[&#39;CONCURRENT_FUTURES&#39;].shutdown()
        
    GLOBAL[&#39;CONCURRENT_FUTURES&#39;] = None
    GLOBAL[&#39;DASK_CLIENT&#39;] = None 
    
    
def shutdown():
    &#34;&#34;&#34;Alias for `vipy.globals.noparallel`&#34;&#34;&#34;    
    return noparallel()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="vipy.globals.cache"><code class="name flex">
<span>def <span class="ident">cache</span></span>(<span>cachedir=None)</span>
</code></dt>
<dd>
<div class="desc"><p>The cache is the location that URLs are downloaded to on your system.
This can be set here, or with the environment variable VIPY_CACHE</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; vipy.globals.cache('/path/to/.vipy')
&gt;&gt;&gt; cachedir = vipy.globals.cache()
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cachedir</code></strong></dt>
<dd>the location to store cached files when downloaded.
Can also be set using the VIPY_CACHE environment variable.
if none, return the current cachedir</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The current cachedir if cachedir=None else None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/globals.py#L133-L150" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def cache(cachedir=None):
    &#34;&#34;&#34;The cache is the location that URLs are downloaded to on your system.  This can be set here, or with the environment variable VIPY_CACHE

    &gt;&gt;&gt; vipy.globals.cache(&#39;/path/to/.vipy&#39;)
    &gt;&gt;&gt; cachedir = vipy.globals.cache()

    Args:
        cachedir:  the location to store cached files when downloaded.  Can also be set using the VIPY_CACHE environment variable.  if none, return the current cachedir
    
    Returns:
        The current cachedir if cachedir=None else None
    
    &#34;&#34;&#34;
    if cachedir is not None:
        from vipy.util import remkdir        
        os.environ[&#39;VIPY_CACHE&#39;] = remkdir(cachedir)
        GLOBAL[&#39;CACHE&#39;] = cachedir
    return os.environ[&#39;VIPY_CACHE&#39;] if &#39;VIPY_CACHE&#39; in os.environ else None</code></pre>
</details>
</dd>
<dt id="vipy.globals.cf"><code class="name flex">
<span>def <span class="ident">cf</span></span>(<span>num_workers=None, threaded=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/globals.py#L167-L173" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def cf(num_workers=None, threaded=True):
    if num_workers is not None:
        if GLOBAL[&#39;CONCURRENT_FUTURES&#39;]:
            GLOBAL[&#39;CONCURRENT_FUTURES&#39;].shutdown()
        GLOBAL[&#39;CONCURRENT_FUTURES&#39;] = (concurrent.futures.ThreadPoolExecutor(max_workers=num_workers, thread_name_prefix=&#39;vipy&#39;) if threaded else
                                        concurrent.futures.ProcessPoolExecutor(max_workers=num_workers))
    return GLOBAL[&#39;CONCURRENT_FUTURES&#39;]</code></pre>
</details>
</dd>
<dt id="vipy.globals.dask"><code class="name flex">
<span>def <span class="ident">dask</span></span>(<span>num_workers=None, dashboard=False, address=None, pct=None, threaded=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the current Dask client, can be accessed globally for parallel processing.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>pct</code></strong></dt>
<dd>float in [0,1] the percentage of the current machine to use</dd>
<dt><strong><code>address</code></strong></dt>
<dd>the dask scheduler of the form 'HOSTNAME:PORT'</dd>
<dt><strong><code>num_workers</code></strong></dt>
<dd>the number of prpcesses to use on the current machine</dd>
<dt><strong><code>dashboard</code></strong></dt>
<dd>[bool] whether to inialize the dask client with a web dashboard</dd>
<dt><strong><code>threaded</code></strong></dt>
<dd>[bool] if true, create threaded workers intead of processes</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The <code>vipy.batch.Dask</code> object pointing to the Dask Distrbuted object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/globals.py#L176-L196" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dask(num_workers=None, dashboard=False, address=None, pct=None, threaded=True):
    &#34;&#34;&#34;Return the current Dask client, can be accessed globally for parallel processing.
    
    Args:
        pct: float in [0,1] the percentage of the current machine to use
        address:  the dask scheduler of the form &#39;HOSTNAME:PORT&#39;
        num_workers:  the number of prpcesses to use on the current machine
        dashboard: [bool] whether to inialize the dask client with a web dashboard
        threaded: [bool] if true, create threaded workers intead of processes

    Returns:
        The `vipy.batch.Dask` object pointing to the Dask Distrbuted object
    &#34;&#34;&#34;
    if pct is not None:
        assert pct &gt; 0 and pct &lt;= 1
        num_workers = int(pct*os.cpu_count())
    if address is not None or num_workers is not None:
        if GLOBAL[&#39;DASK_CLIENT&#39;]:
            GLOBAL[&#39;DASK_CLIENT&#39;].shutdown()
        GLOBAL[&#39;DASK_CLIENT&#39;] = Dask(num_workers, threaded=threaded, dashboard=dashboard, verbose=False, address=address)        
    return GLOBAL[&#39;DASK_CLIENT&#39;]</code></pre>
</details>
</dd>
<dt id="vipy.globals.logger"><code class="name flex">
<span>def <span class="ident">logger</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/globals.py#L23-L24" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def logger():
    return GLOBALS[&#39;LOGGER&#39;]</code></pre>
</details>
</dd>
<dt id="vipy.globals.multiprocessing"><code class="name flex">
<span>def <span class="ident">multiprocessing</span></span>(<span>n=None, pct=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Context manager for concurrent futures multiprocessing executor, use with <code><a title="vipy.dataset.Dataset" href="dataset.html#vipy.dataset.Dataset">Dataset</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/globals.py#L264-L266" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def multiprocessing(n=None, pct=None):
    &#34;&#34;&#34;Context manager for concurrent futures multiprocessing executor, use with `vipy.dataset.Dataset`&#34;&#34;&#34;    
    return parallel(workers=n, pct=pct, threaded=False)</code></pre>
</details>
</dd>
<dt id="vipy.globals.multithreading"><code class="name flex">
<span>def <span class="ident">multithreading</span></span>(<span>n=None, pct=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Context manager for concurrent futures multithreaded executor, use with <code><a title="vipy.dataset.Dataset" href="dataset.html#vipy.dataset.Dataset">Dataset</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/globals.py#L260-L262" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def multithreading(n=None, pct=None):
    &#34;&#34;&#34;Context manager for concurrent futures multithreaded executor, use with `vipy.dataset.Dataset`&#34;&#34;&#34;
    return parallel(workers=n, pct=pct, threaded=True)</code></pre>
</details>
</dd>
<dt id="vipy.globals.noparallel"><code class="name flex">
<span>def <span class="ident">noparallel</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Disable all parallel processing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/globals.py#L268-L278" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def noparallel():
    &#34;&#34;&#34;Disable all parallel processing&#34;&#34;&#34;
    if GLOBAL[&#39;DASK_CLIENT&#39;] is not None:
        GLOBAL[&#39;DASK_CLIENT&#39;].shutdown()
        del GLOBAL[&#39;DASK_CLIENT&#39;]
        GLOBAL[&#39;LOGGER&#39;].info(&#39;Parallel executor shutdown&#39;)
    if GLOBAL[&#39;CONCURRENT_FUTURES&#39;]:
        GLOBAL[&#39;CONCURRENT_FUTURES&#39;].shutdown()
        
    GLOBAL[&#39;CONCURRENT_FUTURES&#39;] = None
    GLOBAL[&#39;DASK_CLIENT&#39;] = None </code></pre>
</details>
</dd>
<dt id="vipy.globals.parallel"><code class="name flex">
<span>def <span class="ident">parallel</span></span>(<span>workers=None, pct=None, threaded=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Enable parallel processing with n&gt;=1 processes or a percentage of system core (pct in [0,1])
.</p>
<p>This can be be used as a context manager</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; with vipy.globals.parallel(n=4):
&gt;&gt;&gt;     vipy.batch.Batch(...)
</code></pre>
<p>or using the global variables:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; vipy.globals.parallel(n=4):
&gt;&gt;&gt; vipy.batch.Batch(...)
&gt;&gt;&gt; vipy.globals.noparallel()
</code></pre>
<p>To check the current parallelism level:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; num_workers = vipy.globals.parallel().num_workers()
</code></pre>
<p>To run with a dask scheduler:</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; with vipy.globals.parallel(scheduler='10.0.1.1:8585')
&gt;&gt;&gt;    vipy.batch.Batch(...)
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>workers</code></strong></dt>
<dd>[int] number of parallel workers</dd>
<dt><strong><code>pct</code></strong></dt>
<dd>[float] the percentage [0,1] of system cores to dedicate to parallel processing</dd>
</dl>
<p>threaded [bool]: if false, use processes (not recommended, since vipy parallel processing usually releases the GIL)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/globals.py#L199-L258" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def parallel(workers=None, pct=None, threaded=True):
    &#34;&#34;&#34;Enable parallel processing with n&gt;=1 processes or a percentage of system core (pct in [0,1])  .

    This can be be used as a context manager
    
    &gt;&gt;&gt; with vipy.globals.parallel(n=4):
    &gt;&gt;&gt;     vipy.batch.Batch(...)

    or using the global variables:

    &gt;&gt;&gt; vipy.globals.parallel(n=4):
    &gt;&gt;&gt; vipy.batch.Batch(...)
    &gt;&gt;&gt; vipy.globals.noparallel()
    
    To check the current parallelism level:
    
    &gt;&gt;&gt; num_workers = vipy.globals.parallel().num_workers()

    To run with a dask scheduler:
    
    &gt;&gt;&gt; with vipy.globals.parallel(scheduler=&#39;10.0.1.1:8585&#39;)
    &gt;&gt;&gt;    vipy.batch.Batch(...)

    Args:
        workers: [int] number of parallel workers
        pct: [float] the percentage [0,1] of system cores to dedicate to parallel processing
        threaded [bool]: if false, use processes (not recommended, since vipy parallel processing usually releases the GIL)
    &#34;&#34;&#34;

    class Parallel():
        def __init__(self, workers):
            self._workers = workers
            self._threaded = threaded
            self.start()
            
        def __enter__(self):
            pass
            
        def __exit__(self, *args):            
            self.shutdown() 
            
        def __repr__(self):
            return &#39;&lt;vipy.globals.parallel: workers=%d, cf=%s&gt;&#39; % (self.num_workers(), GLOBAL[&#39;CONCURRENT_FUTURES&#39;] if GLOBAL[&#39;CONCURRENT_FUTURES&#39;] else &#39;stopped&#39;)

        def start(self):
            if not GLOBAL[&#39;CONCURRENT_FUTURES&#39;] and self._workers&gt;0:                
                cf(num_workers=self._workers, threaded=self._threaded)
            GLOBAL[&#39;LOGGER&#39;].info(&#39;Parallel executor initialized %s&#39; % self)
            return self
        
        def shutdown(self):
            if GLOBAL[&#39;CONCURRENT_FUTURES&#39;]:
                GLOBAL[&#39;LOGGER&#39;].info(&#39;Parallel executor shutdown %s&#39; % self)                            
                GLOBAL[&#39;CONCURRENT_FUTURES&#39;].shutdown(wait=True)
            GLOBAL[&#39;CONCURRENT_FUTURES&#39;] = None
        
        def num_workers(self):
            return self._workers

    return Parallel(workers if not pct else int(pct*os.cpu_count()))</code></pre>
</details>
</dd>
<dt id="vipy.globals.shutdown"><code class="name flex">
<span>def <span class="ident">shutdown</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for <code><a title="vipy.globals.noparallel" href="#vipy.globals.noparallel">noparallel()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/globals.py#L281-L283" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def shutdown():
    &#34;&#34;&#34;Alias for `vipy.globals.noparallel`&#34;&#34;&#34;    
    return noparallel()</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="vipy.globals.Dask"><code class="flex name class">
<span>class <span class="ident">Dask</span></span>
<span>(</span><span>num_workers=None, threaded=True, dashboard=False, verbose=False, address=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Dask distributed client</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/globals.py#L27-L129" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Dask(object):
    &#34;&#34;&#34;Dask distributed client&#34;&#34;&#34;
    
    def __init__(self, num_workers=None, threaded=True, dashboard=False, verbose=False, address=None):
        from vipy.util import try_import
        try_import(&#39;dask&#39;, &#39;dask distributed&#39;); import dask, dask.distributed;
    
        assert address is not None or num_workers is not None, &#34;Invalid input&#34;

        self._num_workers = num_workers
        self._has_dashboard = dashboard
        
        # Dask configuration: https://docs.dask.org/en/latest/configuration.html
        # - when using vipy.dataset.Dataset minibatch iterator, large minibatches can result in a warning about large graphs
        # - The end user can set these environemnt variables, and will only be overwritten with defaults here if not provided
        if &#39;DASK_LOGGING__DISTRIBUTED&#39; not in os.environ:
            os.environ[&#39;DASK_LOGGING__DISTRIBUTED&#39;] = &#39;warning&#39; if not verbose else &#39;info&#39;
        if &#39;DASK_DISTRIBUTED__COMM__TIMEOUTS__CONNECT&#39; not in os.environ:
            os.environ[&#39;DASK_DISTRIBUTED__COMM__TIMEOUTS__CONNECT&#39;] = &#34;30s&#34;
        if &#39;DASK_DISTRIBUTED__COMM__TIMEOUTS__TCP&#39; not in os.environ:
            os.environ[&#39;DASK_DISTRIBUTED__COMM__TIMEOUTS__TCP&#39;] = &#34;30s&#34;
        if &#39;DASK_DISTRIBUTED__DEPLOY__LOST_WORKER_TIMEOUT&#39; not in os.environ:
            os.environ[&#39;DASK_DISTRIBUTED__DEPLOY__LOST_WORKER_TIMEOUT&#39;] = &#34;30s&#34;
        if &#39;DASK_DISTRIBUTED__COMM__RETRY__COUNT&#39; not in os.environ:
            os.environ[&#39;DASK_DISTRIBUTED__COMM__RETRY__COUNT&#39;] = &#34;10&#34;        
        if &#39;DASK_ADMIN_LARGE_GRAPH_WARNING_THREHSOLD&#39; not in os.environ:
            os.environ[&#39;DASK_ADMIN_LARGE_GRAPH_WARNING_THREHSOLD&#39;] = &#34;50MB&#34;        

        dask.config.refresh()
        
        dask.config.set({&#39;DISTRIBUTED.COMM.RETRY.COUNT&#39;.lower():int(os.environ[&#39;DASK_DISTRIBUTED__COMM__RETRY__COUNT&#39;])})
        dask.config.set({&#39;DISTRIBUTED.COMM.TIMEOUTS.CONNECT&#39;.lower():os.environ[&#39;DASK_DISTRIBUTED__COMM__TIMEOUTS__CONNECT&#39;]})
        dask.config.set({&#39;DISTRIBUTED.COMM.TIMEOUTS.TCP&#39;.lower():os.environ[&#39;DASK_DISTRIBUTED__COMM__TIMEOUTS__TCP&#39;]})
        dask.config.set({&#39;DISTRIBUTED.DEPLOY.LOST_WORKER_TIMEOUT&#39;.lower():os.environ[&#39;DASK_DISTRIBUTED__DEPLOY__LOST_WORKER_TIMEOUT&#39;]})        
        dask.config.set({&#34;distributed.admin.large-graph-warning-threshold&#34;: os.environ[&#39;DASK_ADMIN_LARGE_GRAPH_WARNING_THREHSOLD&#39;]})
        
        
        # Worker env
        env = {&#39;VIPY_BACKEND&#39;:&#39;Agg&#39;,  # headless in workers
               &#39;PYTHONOPATH&#39;:os.environ[&#39;PYTHONPATH&#39;] if &#39;PYTHONPATH&#39; in os.environ else &#39;&#39;,
               &#39;PATH&#39;:os.environ[&#39;PATH&#39;] if &#39;PATH&#39; in os.environ else &#39;&#39;}

        if &#39;VIPY_CACHE&#39; in os.environ:
            env.update({&#39;VIPY_CACHE&#39;:os.environ[&#39;VIPY_CACHE&#39;]})
        if &#39;VIPY_AWS_ACCESS_KEY_ID&#39; in os.environ:
            env.update({&#39;VIPY_AWS_ACCESS_KEY_ID&#39;:os.environ[&#39;VIPY_AWS_ACCESS_KEY_ID&#39;]})            
        if &#39;VIPY_AWS_SECRET_ACCESS_KEY&#39; in os.environ:
            env.update({&#39;VIPY_AWS_SECRET_ACCESS_KEY&#39;:os.environ[&#39;VIPY_AWS_SECRET_ACCESS_KEY&#39;]})        
                    
        for (k,v) in os.environ.items():
            if k.startswith(&#39;DASK_&#39;):
                env[k] = v
    
        if address is not None:
            # Distributed scheduler
            self._client = dask.distributed.Client(name=&#39;vipy&#39;, address=address)

            # Update key environment variables on remote workers using out of band function (yuck)
            # Make sure that any environment variables are accessible on all machines!  (e.g. VIPY_CACHE)
            # If not, then you need to unset these variables from os.environ prior to calling Dask()
            def _f_setenv_remote(localenv):
                import os; os.environ.update(localenv)

            localenv = {k:v for (k,v) in os.environ.items() if k.startswith(&#39;VIPY_&#39;)}
            localenv.update( {&#39;VIPY_BACKEND&#39;:&#39;Agg&#39;} )
            self._client.run(lambda env=localenv: _f_setenv_remote(env))

        else:
            kwargs = {&#39;name&#39;:&#39;vipy&#39;,
                      &#39;address&#39;:address,  # to connect to distributed scheduler HOSTNAME:PORT
                      &#39;scheduler_port&#39;:0,   # random
                      &#39;dashboard_address&#39;:None if not dashboard else &#39;:0&#39;,  # random port
                      &#39;processes&#39;:not threaded,
                      &#39;threads_per_worker&#39;:1,
                      &#39;n_workers&#39;:num_workers,
                      &#39;local_directory&#39;:tempfile.mkdtemp()}
            kwargs.update({&#39;env&#39;:env, &#39;direct_to_workers&#39;:True} if not threaded else {})
            
            # Local scheduler
            self._client = dask.distributed.Client(**kwargs)
            

    def __repr__(self):
        if self._num_workers is not None:
            # Local 
            return str(&#39;&lt;vipy.globals.Dask: %s%s&gt;&#39; % (&#39;workers=%d&#39; % self.num_workers(), &#39;, dashboard=%s&#39; % str(self._client.dashboard_link) if self._has_dashboard else &#39;&#39;))
        elif self._client is not None:
            # Distributed
            return str(&#39;&lt;vipy.globals.Dask: %s&gt;&#39; % (str(self._client)))
        else:
            return str(&#39;&lt;vipy.globals.Dask: shutdown&#39;)

    def num_workers(self):
        return self._num_workers

    def shutdown(self):
        self._client.close()
        self._num_workers = None
        GLOBAL[&#39;DASK_CLIENT&#39;] = None        
        return self

    def client(self):
        return self._client</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="vipy.globals.Dask.client"><code class="name flex">
<span>def <span class="ident">client</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/globals.py#L128-L129" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def client(self):
    return self._client</code></pre>
</details>
</dd>
<dt id="vipy.globals.Dask.num_workers"><code class="name flex">
<span>def <span class="ident">num_workers</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/globals.py#L119-L120" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def num_workers(self):
    return self._num_workers</code></pre>
</details>
</dd>
<dt id="vipy.globals.Dask.shutdown"><code class="name flex">
<span>def <span class="ident">shutdown</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/globals.py#L122-L126" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def shutdown(self):
    self._client.close()
    self._num_workers = None
    GLOBAL[&#39;DASK_CLIENT&#39;] = None        
    return self</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="VIPY" href="https://github.com/visym/vipy/">
<img src="https://www.visym.com/labs/images/visym_logo_black_notext.png" alt="" width="60">
</a>
<h1 style="font-size:200%;"><b>VIPY:</b> Visual Dataset Transformation</h1>
</header>
<form>
<input id="lunr-search" name="q" placeholder="ðŸ”Ž Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = './doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="vipy" href="index.html">vipy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="vipy.globals.cache" href="#vipy.globals.cache">cache</a></code></li>
<li><code><a title="vipy.globals.cf" href="#vipy.globals.cf">cf</a></code></li>
<li><code><a title="vipy.globals.dask" href="#vipy.globals.dask">dask</a></code></li>
<li><code><a title="vipy.globals.logger" href="#vipy.globals.logger">logger</a></code></li>
<li><code><a title="vipy.globals.multiprocessing" href="#vipy.globals.multiprocessing">multiprocessing</a></code></li>
<li><code><a title="vipy.globals.multithreading" href="#vipy.globals.multithreading">multithreading</a></code></li>
<li><code><a title="vipy.globals.noparallel" href="#vipy.globals.noparallel">noparallel</a></code></li>
<li><code><a title="vipy.globals.parallel" href="#vipy.globals.parallel">parallel</a></code></li>
<li><code><a title="vipy.globals.shutdown" href="#vipy.globals.shutdown">shutdown</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="vipy.globals.Dask" href="#vipy.globals.Dask">Dask</a></code></h4>
<ul class="">
<li><code><a title="vipy.globals.Dask.client" href="#vipy.globals.Dask.client">client</a></code></li>
<li><code><a title="vipy.globals.Dask.num_workers" href="#vipy.globals.Dask.num_workers">num_workers</a></code></li>
<li><code><a title="vipy.globals.Dask.shutdown" href="#vipy.globals.Dask.shutdown">shutdown</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
