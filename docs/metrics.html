<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.6" />
<meta name="google-site-verification" content="aB8LkQegj94_TJPdrcJm2ldIRWyXY82Jp24Gtkdgyn0" />
<title>vipy.metrics API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vipy.metrics</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/metrics.py#L1-L513" class="git-link">Browse git</a>
</summary>
<pre><code class="python">import numpy as np
import matplotlib.pyplot as plt
from vipy.util import seq, groupby, try_import, temppng
from vipy.math import interp1d
from vipy.globals import log
from vipy.image import Image, owl
from vipy.math import gaussian


def cumulative_match_characteristic(similarityMatrix, gtMatrix):
    &#34;&#34;&#34;CMC curve for probe x gallery similarity matrix (larger is more similar) and ground truth match matrix (one +1 per row, rest zeros)&#34;&#34;&#34;
    n_categories = gtMatrix.shape[1]
    n_probe = gtMatrix.shape[0]
    rank = range(1,n_categories + 1)

    for i in range(0,n_probe):
        k = np.argsort(-similarityMatrix[i,:])  # index of sorted rows in descending order
        similarityMatrix[i,:] = similarityMatrix[i,k]  # reorder columns in similarityOrder
        gtMatrix[i,:] = gtMatrix[i,k]  # reorder ground truth in same order

    # Given ground truth matrix, if a row has exactly one &#34;1&#34; then there is a mate.  If a row has all zeros, then the mate does not exist in the gallery
    # if a row has nan, then there is a mate in the gallery, but this was not found in the top-k
    n_pos = np.sum(np.array(np.logical_or((np.sum(gtMatrix, axis=1) == 1.0), np.isnan(np.sum(gtMatrix, axis=1)))).astype(np.float32))
    gtMatrix = np.nan_to_num(gtMatrix)  # convert nans to zeros
    recall = [np.sum(np.max(gtMatrix[:,0:r], axis=1)) / n_pos for r in rank]
    return (rank, recall)


def cmc_curve(rank=None, tdr=None, similarityMatrix=None, truthMatrix=None, label=None, title=None, outfile=None, logscale=True, logy=False, figure=None, style=None, fontsize=None, xlabel=&#39;Rank&#39;, ylabel=&#39;Correct Retrieval Rate&#39;, legendSwap=False, errorbars=None, miny=0.0, color=None):
    &#34;&#34;&#34;Plot cumulative match characteristic (CMC) curve &#34;&#34;&#34;

    if rank is None and tdr is None:
        (rank, tdr) = cumulative_match_characteristic(similarityMatrix, truthMatrix)

    if figure is not None:
        plt.figure(figure)
    else:
        plt.figure()
        plt.clf()

    if style is None:
        p = plt.plot(rank, tdr, label=label, color=color)
    else:
        p = plt.plot(rank, tdr, style, label=label, color=color)

    if errorbars is not None:
        (x,y,yerr) = zip(*errorbars)  # [(x,y,yerr), (x,y,yerr), ...]
        plt.gca().errorbar(x, y, yerr=yerr, fmt=&#39;none&#39;, ecolor=plt.getp(p[0], &#39;color&#39;))  # HACK: force error bars to have same color as plot

    plt.xlabel(xlabel)
    plt.ylabel(ylabel)

    plt.ylim([miny, 1.0])
    plt.xlim([0.95 if not logscale else 0.95, len(rank)])
    if logscale:
        plt.gca().set_xscale(&#39;log&#39;)
    if logy:
        plt.gca().set_yscale(&#39;log&#39;)

    if title is not None:
        plt.title(&#39;%s&#39; % (title))
    legendLoc = &#34;lower left&#34; if legendSwap else &#34;lower right&#34;
    if fontsize is None:
        plt.legend(loc=legendLoc)
    else:
        plt.legend(loc=legendLoc, prop={&#39;size&#39;:fontsize})
    plt.grid(True)

    # Font size
    ax = plt.gca()
    for item in ([ax.title, ax.xaxis.label, ax.yaxis.label] + ax.get_xticklabels() + ax.get_yticklabels()):
        item.set_fontsize(fontsize)
    # plt.tight_layout()
    plt.gcf().set_tight_layout(True)

    if outfile is not None:
        log.info(&#39;[vipy.metric.plot_cmc]: saving &#34;%s&#34;&#39; % outfile)
        plt.savefig(outfile)

    else:
        plt.show()


def tdr_at_rank(rank=None, tdr=None, y_true=None, y_pred=None, numGallery=None, at=10):
    &#34;&#34;&#34;Janus metric for correct retrieval (true detection rate) within a specific rank&#34;&#34;&#34;

    if rank is None and tdr is None:
        if y_true is not None and y_pred is not None:
            y_true = np.array(y_true)
            y_pred = np.array(y_pred)
            if numGallery is not None:
                truthMatrix = y_true.reshape((len(y_true) / numGallery, numGallery))
                similarityMatrix = y_pred.reshape((len(y_pred) / numGallery, numGallery))
            elif np.min(y_true.shape) &gt; 1:
                truthMatrix = y_true
                similarityMatrix = y_pred
            else:
                raise ValueError(&#39;(y,yhat) must be reshaped into (numProbe x numGallery) of numGallery provided as input&#39;)
            (rank, tdr) = cumulative_match_characteristic(similarityMatrix, truthMatrix)
        else:
            raise ValueError(&#39;either (rank,tdr) or (y,yhat) required&#39;)

    if at &gt; np.max(rank):
        raise ValueError(&#39;Selected operating point rank=%d must be less than maximum rank=%d&#39; % (at, np.max(rank)))

    f = interp1d(rank, tdr)
    return f(at)

def tpr_at_fpr(y_true, y_pred, at=0.01):
    &#34;&#34;&#34;Janus metric for true positive rate at a specific false positive rate&#34;&#34;&#34;
    (fpr, tpr) = roc(y_true, y_pred)
    f = interp1d(fpr, tpr)  # FIXME: kind=&#39;cubic&#39; is singular?
    return f(at)


def fpr_at_tpr(y_true, y_pred, at=0.85):
    &#34;&#34;&#34;Janus metric for false positive rate at a specific true positive rate&#34;&#34;&#34;
    (fpr, tpr) = roc(y_true, y_pred)
    f = interp1d(tpr, fpr)  # FIXME: kind=&#39;cubic&#39; is singular?
    return f(at)


def receiver_operating_curve(y_true=None, y_pred=None, fpr=None, tpr=None, label=None, title=None, outfile=None, figure=None, logx=False, style=None, fontsize=None, xlabel=&#39;False Positive Rate&#39;, ylabel=&#39;True Positive Rate&#39;, legendSwap=False, errorbars=None):
    &#34;&#34;&#34;Plot ROC: http://scikit-learn.org/stable/auto_examples/plot_roc.html&#34;&#34;&#34;
    if (fpr is None) and (tpr is None):
        (fpr, tpr) = roc(y_true, y_pred)

    if figure is not None:
        plt.figure(figure)
    else:
        plt.figure()

    if style is None:
        # Use plot defaults to increment plot style when holding
        p = plt.plot(fpr, tpr, label=label)
    else:
        p = plt.plot(fpr, tpr, style, label=label)

    if errorbars is not None:
        (x,y,yerr) = zip(*errorbars)  # [(x,y,yerr), (x,y,yerr), ...]
        plt.gca().errorbar(x, y, yerr=yerr, fmt=&#39;none&#39;, ecolor=plt.getp(p[0], &#39;color&#39;))  # HACK: force error bars to have same color as plot

    if logx is False:
        plt.plot([0, 1], [0, 1], &#39;k--&#39;, label=&#34;_nolegend_&#34;)
    if logx is True:
        plt.xscale(&#39;log&#39;)
    plt.xlim([0.0, 1.0])
    plt.ylim([0.0, 1.0])
    plt.xlabel(xlabel)
    plt.ylabel(ylabel)
    legendLoc = &#34;upper left&#34; if legendSwap else &#34;lower right&#34;
    if fontsize is None:
        plt.legend(loc=legendLoc)
    else:
        plt.legend(loc=legendLoc, prop={&#39;size&#39;:fontsize})
    plt.grid(True)
    plt.gca().set_aspect(&#39;equal&#39;)
    plt.autoscale(tight=True)

    if title is not None:
        plt.title(title)

    # Font size
    ax = plt.gca()
    for item in ([ax.title, ax.xaxis.label, ax.yaxis.label] + ax.get_xticklabels() + ax.get_yticklabels()):
        item.set_fontsize(fontsize)
    plt.gcf().set_tight_layout(True)
    plt.xlim([0.0, 1.0])
    plt.ylim([0.0, 1.0])

    if outfile is not None:
        log.info(&#39;[vipy.metric.plot_roc]: saving &#34;%s&#34;&#39; % outfile)
        plt.savefig(outfile)
    else:
        plt.show()



def confusion_matrix_plot(cm, outfile=None, figure=None, fontsize=5, xlabel=None, ylabel=None, classes=None, colorbar=False, figsize=None):
    &#34;&#34;&#34;Generate a confusion matrix plot for a confusion matrix cm&#34;&#34;&#34;

    outfile = outfile if outfile is not None else temppng()
    figure = 1 if figure is None else figure
    
    if figsize:
        plt.figure(figure, figsize=figsize)
    else:
        plt.figure(figure)
    plt.clf()
    plt.matshow(cm, fignum=figure)

    if colorbar:
        plt.colorbar()
    if classes is not None:
        tick_marks = np.arange(len(classes))
        plt.yticks(tick_marks, classes)
        plt.xticks(tick_marks, classes, rotation=&#39;vertical&#39;)

    xl = plt.xlabel(xlabel) if xlabel is not None else None
    yl = plt.ylabel(ylabel) if ylabel is not None else None

    # Font size
    ax = plt.gca()
    for item in ([ax.title, ax.xaxis.label, ax.yaxis.label] + ax.get_xticklabels() + ax.get_yticklabels()):
        item.set_fontsize(fontsize)

    plt.savefig(outfile, bbox_extra_artists=(yl,) if yl is not None else None, bbox_inches=&#39;tight&#39;, dpi=600)

    return outfile
    

def precision_recall_curve(precision, recall, title=None, label=&#39;Precision-Recall&#39;, outfile=None, figure=None, fontsize=8, loc=&#39;upper right&#39;):
    &#34;&#34;&#34;Plot precision recall curve using matplotlib, with optional figure save.  Call this multiple times with same figure number to plot multiple curves.&#34;&#34;&#34;

    if figure is not None:
        plt.figure(figure)
    else:
        plt.figure()
        plt.clf()

    plt.plot(recall, precision, label=label)
    plt.xlabel(&#39;Recall&#39;)
    plt.ylabel(&#39;Precision&#39;)
    plt.ylim([0.0, 1.05])
    plt.xlim([0.0, 1.0])
    if title is not None:
        plt.title(&#39;%s&#39; % (title))
    plt.legend(loc=loc, fontsize=fontsize)
    plt.grid(True)

    if outfile is not None:
        log.info(&#39;[vipy.metric.plot_pr]: saving &#34;%s&#34;&#39; % outfile)
        plt.savefig(outfile)
    else:
        plt.show()


def average_precision_chart(ap, categories, title=None, outfile=None):
    &#34;&#34;&#34;Plot Average-Precision bar chart using matplotlib, with optional figure save&#34;&#34;&#34;
    plt.bar(range(1,len(ap) + 1), height=ap, width=0.8, bottom=None)
    plt.gca().set_xticks(seq(1,len(ap)))
    plt.gca().set_xticklabels(categories, rotation=45)
    plt.ylim([0.0, 1.1])
    plt.ylabel(&#39;Average Precision&#39;)
    plt.autoscale(tight=True)
    if title is not None:
        plt.title(&#39;%s&#39; % (title))
    if outfile is not None:
        log.info(&#39;[vipy.metric.plot_ap]: saving &#34;%s&#34;&#39; % outfile)
        plt.savefig(outfile)
    else:
        plt.show()


def histogram(freq, categories, barcolors=None, title=None, outfile=None, figure=None, ylabel=&#39;Frequency&#39;, xrot=&#39;vertical&#39;, xlabel=None, fontsize=10, xshow=True):
    &#34;&#34;&#34;Plot histogram bar chart using matplotlib with vertical axis labels on x-axis,, with optional figure save.
       
       Inputs:
          -freq:  the output of (freq, categories) = np.histogram(..., bins=n)
          -categories [list]:  a list of category names that must be length n, or the output of (f,c) = np.histogram(...) and categories=c[:-1]
          -xrot [&#39;vertical&#39;|None]:  rotate the xticks
          -barcolors [list]:  list of named colors equal to the length of categories
    &#34;&#34;&#34;
    if figure is not None:
        plt.figure(figure)
    else:
        plt.figure(1)
        plt.clf()

    x = range(1, len(categories)+1)
    plt.bar(x, height=freq, width=0.8, bottom=None, color=barcolors)
    if xshow:
        plt.xticks(x, list(categories), rotation=xrot, fontsize=fontsize)
    plt.autoscale(tight=True)
    if ylabel is not None:
        plt.ylabel(ylabel)
    if xlabel is not None:
        plt.xlabel(xlabel)
    plt.subplots_adjust(bottom=0.75)  # tweak
    if title is not None:
        plt.title(&#39;%s&#39; % (title))
    plt.tight_layout()            
    if outfile is not None:
        plt.savefig(outfile)
        plt.clf()
        return outfile
    else:
        plt.show()

    return outfile


def pie(sizes, labels, explode=None, outfile=None, shadow=False, legend=True, fontsize=10, rotatelabels=False):
    &#34;&#34;&#34;Generate a matplotlib style pie chart with wedges with specified size and labels, with an optional outfile&#34;&#34;&#34;
    plt.figure(1)
    plt.clf()
    
    # pie = plt.pie(sizes, explode=explode, labels=labels, autopct=&#39;%1.1f%%&#39;, shadow=shadow, startangle=0)
    if legend:
        pie = plt.pie(sizes, explode=explode, shadow=shadow, startangle=0,  textprops={&#39;fontsize&#39;: fontsize}, rotatelabels=rotatelabels)
        plt.legend(labels)
    else:
        pie = plt.pie(sizes, explode=explode, shadow=shadow, startangle=0, labels=labels,  textprops={&#39;fontsize&#39;: fontsize}, rotatelabels=rotatelabels)

    plt.axis(&#39;equal&#39;)  # Equal aspect ratio ensures that pie is drawn as a circle.

    plt.tight_layout()        
    if outfile is not None:
        plt.savefig(outfile)
        plt.clf()        
        return outfile
    else:
        plt.show()

        
def scatterplot(X, labels, outfile=None):
    &#34;&#34;&#34;Generate a scatterplot of 2D points in an Nx2 matrix (X) with provided category labels in list of length N (labels).  Each label will be assigned a unique color.  Scatterplot saved to outfile (if provided).&#34;&#34;&#34; 
    assert isinstance(X, np.ndarray) and X.ndim == 2 and X.shape[1] == 2
    assert len(X) == len(labels)
    import vipy.show
    
    plt.clf()
    #plt.figure()
    plt.grid(True)
    colors = vipy.show.colorlist()
    d_label_to_color = {c:colors[k % len(colors)] for (k,c) in enumerate(set(labels))}
    plt.axis(&#39;equal&#39;)  
    for y in sorted(set(labels)):
        x = np.array([xi for (xi,yi) in zip(X, labels) if yi == y])
        plt.scatter(x[:,0], x[:,1], c=d_label_to_color[y], label=y)
    plt.axis([np.min(X), np.max(X), np.min(X), np.max(X)])                
    plt.legend()
    plt.gca().set_axisbelow(True)  # grid behind

    plt.tight_layout()
    if outfile is not None:
        plt.savefig(outfile)
        plt.clf()        
        return outfile
    else:
        plt.ion()
        plt.show()
        plt.pause(0.001)

        
def ascii_bar_chart(soft_labels, bar_width=40, min_conf=0, max_conf=1):
    &#34;&#34;&#34;Given a list of soft_labels = [(label, confidence), ...], return an ascii horizontal bar chart for each label sorted by confidence.

    Confidences are specied for the provide range (min_conf, max_conf)
    The bar_width controls how wide the overall bars are in characters
    
    &gt;&gt;&gt; print(vipy.metrics.ascii_bar_chart([(&#39;A&#39;,1), (&#39;B&#39;,0.5), (&#39;C&#39;,0.1)]))
    [████████████████████████████████████████]  A (1.000)
    [████████████████████....................]  B (0.500)
    [████....................................]  C (0.100)

    &#34;&#34;&#34;
    cmin = min_conf if min_conf is not None else min(c for (l,c) in soft_labels)
    cmax = max_conf if max_conf is not None else max(c for (l,c) in soft_labels)
    num_blocks = lambda c: int(round(((c-cmin)/(cmax-cmin)) * bar_width))      
    num_dots   = lambda c: int(round((1 - ((c - cmin)/(cmax-cmin))) * bar_width))
    return &#39;\n&#39;.join([&#34;[%s]  %s (%1.3f)&#34; % (&#39;█&#39; * num_blocks(c) + &#39;.&#39; * num_dots(c), lbl,c) for (lbl,c) in sorted(soft_labels, key=lambda x: x[1], reverse=True)])        


class SSIM():
    &#34;&#34;&#34;Structural similarity (SSIM) index &#34;&#34;&#34;
    &#34;&#34;&#34;Z. Wang, A. Bovik, H. Sheikh, E. Simoncelli, &#34;Image quality assessment: from error visibility to structural similarity&#34;. IEEE Transactions on Image Processing. 13 (4): 600–612&#34;&#34;&#34;

    def __init__(self, do_alignment=True, min_matches_for_alignment=10, num_matches_for_alignment=500, K1=0.01, K2=0.03):        
        self.do_alignment = do_alignment
        self.min_matches_for_alignment = min_matches_for_alignment
        self.num_matches_for_alignment = num_matches_for_alignment
        self.K1 = K1
        self.K2 = K2

    def __repr__(self):
        return str(&#39;&lt;vipy.ssim: do_alignment=%s, min_matches_for_alignment=%d, num_matches_for_alignment=%d, K1=%f, K2=%f&gt;&#39; % (str(self.do_alignment), self.min_matches_for_alignment, self.num_matches_for_alignment, self.K1, self.K2))

    def match(self, img1, img2):
        &#34;&#34;&#34;Return a set of matching points in img1 (MxN uint8 numpy) and img2 (MxN uint8 numpy) in the form suitable for homography estimation&#34;&#34;&#34;
        try_import(&#39;cv2&#39;, &#39;opencv-python&#39;); import cv2 
        
        # Initiate ORB detector
        orb = cv2.ORB_create()

        # find the keypoints and descriptors with ORB
        kp1, des1 = orb.detectAndCompute(img1,None)
        kp2, des2 = orb.detectAndCompute(img2,None)

        # Match descriptors.
        bf = cv2.BFMatcher(cv2.NORM_HAMMING, crossCheck=True)
        matches = bf.match(des1,des2)

        # Sort them in the order of their distance.
        matches = sorted(matches, key=lambda x:x.distance)[:self.num_matches_for_alignment]

        img1_pts = np.float32([kp1[m.queryIdx].pt for m in matches]).reshape(-1,1,2)
        img2_pts = np.float32([kp2[m.trainIdx].pt for m in matches]).reshape(-1,1,2)

        return (img1_pts, img2_pts)

    def warp(self, src_pts, dst_pts, im_src):
        &#34;&#34;&#34;Warp an image im_src with points src_pts to align with dst_pts&#34;&#34;&#34;

        try_import(&#39;cv2&#39;, &#39;opencv-python&#39;); import cv2
        
        if src_pts.shape[0] &lt; self.min_matches_for_alignment:
            raise ValueError(&#39;Invalid number of inliers&#39;)
        h, mask = cv2.findHomography(src_pts, dst_pts, cv2.RANSAC, 5.0)
        return cv2.warpPerspective(im_src, h, (im_src.shape[1], im_src.shape[0]))

    def align(self, img1, img2):
        &#34;&#34;&#34;Return an image which is the warped version of img1 (MxN uint8 numpy) that aligns with img2 (MxN uint8 numpy)&#34;&#34;&#34;
        (p1, p2) = self.match(img1, img2)
        return self.warp(p1, p2, img1)

    def rgb2gray(self, I):
        &#34;&#34;&#34;Convert RGB image to grayscale; accesory function&#34;&#34;&#34;
        R = I[:,:,0]
        G = I[:,:,1]
        B = I[:,:,2]
        return 0.299 * R + 0.587 * G + 0.114 * B

    def similarity(self, I1, I2, returnMap=True):
        &#34;&#34;&#34;Compute the Structural Similarity Index (SSIM) score of two images
        Inputs:
        1) I1, image array
        2) I2, image array
        3) K1, float (optional, default=0.01)
        - constant
        4) K2, float (optional, default=0.03)
        - constant
        Outputs:
        1) out; float
        - SSIM score
        2) ssim_map; 2-D image array
        - SSIM map&#34;&#34;&#34;

        I1 = self.rgb2gray(I1) if I1.ndim == 3 else I1
        I2 = self.rgb2gray(I2) if I2.ndim == 3 else I2

        C1 = np.power(self.K1 * 255,2)
        C2 = np.power(self.K2 * 255,2)

        w = gaussian(11,1.5)
        f = np.zeros((11,11))
        for k in range(len(w)):
            for k2 in range(len(w)):
                f[k,k2] = np.multiply(w[k],w[k2])
        f = np.true_divide(f,np.sum(f))

        try_import(&#39;scipy.signal&#39;, &#39;scipy&#39;); from scipy.signal import convolve2d        
        ux = convolve2d(I1,f,mode=&#39;same&#39;)
        uy = convolve2d(I2,f,mode=&#39;same&#39;)

        # Compute SSIM constants
        ux_sq = np.power(ux,2)
        uy_sq = np.power(uy,2)
        ux_uy = np.multiply(ux,uy)

        sig_x = convolve2d(np.power(I1,2),f,mode=&#39;same&#39;) - ux_sq
        sig_y = convolve2d(np.power(I2,2),f,mode=&#39;same&#39;) - uy_sq
        sig_xy = convolve2d(np.multiply(I1,I2),f,mode=&#39;same&#39;) - ux_uy

        # Core SSIM Equation
        ssim_map = np.divide(np.multiply(2 * ux_uy + C1, 2 * sig_xy + C2),
                             np.multiply(ux_sq + uy_sq + C1, sig_x + sig_y + C2))

        out = np.mean(ssim_map)

        return (out, ssim_map) if returnMap else out

    
    def ssim(self, im_reference, im_degraded, returnAligned=False):
        &#34;&#34;&#34;Return structural similarity score when aligning im_degraded to im_reference

        &gt;&gt;&gt; (ssim, im_aligned) = vipy.ssim.SSIM(do_alignment=True).ssim(vipy.image.squareowl(), vipy.image.squareowl().rotate(0.01), returnAligned=True)
        &gt;&gt;&gt; print(ssim)
        &gt;&gt;&gt; im_aligned.show(figure=1)
        &gt;&gt;&gt; vipy.image.squareowl().rotate(0.01).show(figure=2)
        
        &#34;&#34;&#34;
        assert isinstance(im_reference, np.ndarray) or isinstance(im_reference, Image)
        assert isinstance(im_degraded, np.ndarray) or isinstance(im_degraded, Image)
        
        img_degraded = im_degraded.lum().numpy() if isinstance(im_degraded, Image) else im_degraded
        img_reference = im_reference.lum().numpy() if isinstance(im_reference, Image) else im_reference
        
        img_degraded_aligned = self.align(img_degraded, img_reference) if self.do_alignment else im_degraded
        ssim = self.similarity(img_degraded_aligned, img_reference, returnMap=False)
        return (ssim, Image(array=img_degraded_aligned, colorspace=&#39;lum&#39;)) if returnAligned else ssim

    @staticmethod
    def demo(im=None):
        &#34;&#34;&#34;Synthetically rotate an image by 4 degrees, and compute structural similarity with and without alignment, return images
        
        &gt;&gt;&gt; (image, degraded_image, aligned_image) = vipy.ssim.demo(vipy.image.Image(filename=&#39;/path/to/image.jpg&#39;)))
        
        &#34;&#34;&#34;
        assert im is None or isinstance(im, Image)
        im = owl().centersquare() if im is None else im
        
        # Synthetic degradation: 1-channel uint8
        (im, im_degraded) = (im.lum(), im.clone().rotate(4*(np.pi/180.0)).lum())
    
        # SSIM
        (ssim_aligned, im_aligned) = SSIM(do_alignment=True).ssim(im.numpy(), im_degraded.numpy(), returnAligned=True)
        (ssim_unaligned) = SSIM(do_alignment=False).ssim(im.numpy(), im_degraded.numpy())    
        log.info(&#39;Structural similarity score (aligned): %f&#39; % ssim_aligned)
        log.info(&#39;Structural similarity score (unaligned): %f&#39; % ssim_unaligned)
        return (im.show(figure=1),
                im_degraded.show(figure=2),
                im_aligned.show(figure=3))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="vipy.metrics.ascii_bar_chart"><code class="name flex">
<span>def <span class="ident">ascii_bar_chart</span></span>(<span>soft_labels, bar_width=40, min_conf=0, max_conf=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Given a list of soft_labels = [(label, confidence), &hellip;], return an ascii horizontal bar chart for each label sorted by confidence.</p>
<p>Confidences are specied for the provide range (min_conf, max_conf)
The bar_width controls how wide the overall bars are in characters</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; print(vipy.metrics.ascii_bar_chart([('A',1), ('B',0.5), ('C',0.1)]))
[████████████████████████████████████████]  A (1.000)
[████████████████████....................]  B (0.500)
[████....................................]  C (0.100)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/metrics.py#L346-L362" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def ascii_bar_chart(soft_labels, bar_width=40, min_conf=0, max_conf=1):
    &#34;&#34;&#34;Given a list of soft_labels = [(label, confidence), ...], return an ascii horizontal bar chart for each label sorted by confidence.

    Confidences are specied for the provide range (min_conf, max_conf)
    The bar_width controls how wide the overall bars are in characters
    
    &gt;&gt;&gt; print(vipy.metrics.ascii_bar_chart([(&#39;A&#39;,1), (&#39;B&#39;,0.5), (&#39;C&#39;,0.1)]))
    [████████████████████████████████████████]  A (1.000)
    [████████████████████....................]  B (0.500)
    [████....................................]  C (0.100)

    &#34;&#34;&#34;
    cmin = min_conf if min_conf is not None else min(c for (l,c) in soft_labels)
    cmax = max_conf if max_conf is not None else max(c for (l,c) in soft_labels)
    num_blocks = lambda c: int(round(((c-cmin)/(cmax-cmin)) * bar_width))      
    num_dots   = lambda c: int(round((1 - ((c - cmin)/(cmax-cmin))) * bar_width))
    return &#39;\n&#39;.join([&#34;[%s]  %s (%1.3f)&#34; % (&#39;█&#39; * num_blocks(c) + &#39;.&#39; * num_dots(c), lbl,c) for (lbl,c) in sorted(soft_labels, key=lambda x: x[1], reverse=True)])        </code></pre>
</details>
</dd>
<dt id="vipy.metrics.average_precision_chart"><code class="name flex">
<span>def <span class="ident">average_precision_chart</span></span>(<span>ap, categories, title=None, outfile=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot Average-Precision bar chart using matplotlib, with optional figure save</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/metrics.py#L238-L252" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def average_precision_chart(ap, categories, title=None, outfile=None):
    &#34;&#34;&#34;Plot Average-Precision bar chart using matplotlib, with optional figure save&#34;&#34;&#34;
    plt.bar(range(1,len(ap) + 1), height=ap, width=0.8, bottom=None)
    plt.gca().set_xticks(seq(1,len(ap)))
    plt.gca().set_xticklabels(categories, rotation=45)
    plt.ylim([0.0, 1.1])
    plt.ylabel(&#39;Average Precision&#39;)
    plt.autoscale(tight=True)
    if title is not None:
        plt.title(&#39;%s&#39; % (title))
    if outfile is not None:
        log.info(&#39;[vipy.metric.plot_ap]: saving &#34;%s&#34;&#39; % outfile)
        plt.savefig(outfile)
    else:
        plt.show()</code></pre>
</details>
</dd>
<dt id="vipy.metrics.cmc_curve"><code class="name flex">
<span>def <span class="ident">cmc_curve</span></span>(<span>rank=None, tdr=None, similarityMatrix=None, truthMatrix=None, label=None, title=None, outfile=None, logscale=True, logy=False, figure=None, style=None, fontsize=None, xlabel='Rank', ylabel='Correct Retrieval Rate', legendSwap=False, errorbars=None, miny=0.0, color=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot cumulative match characteristic (CMC) curve</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/metrics.py#L29-L81" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def cmc_curve(rank=None, tdr=None, similarityMatrix=None, truthMatrix=None, label=None, title=None, outfile=None, logscale=True, logy=False, figure=None, style=None, fontsize=None, xlabel=&#39;Rank&#39;, ylabel=&#39;Correct Retrieval Rate&#39;, legendSwap=False, errorbars=None, miny=0.0, color=None):
    &#34;&#34;&#34;Plot cumulative match characteristic (CMC) curve &#34;&#34;&#34;

    if rank is None and tdr is None:
        (rank, tdr) = cumulative_match_characteristic(similarityMatrix, truthMatrix)

    if figure is not None:
        plt.figure(figure)
    else:
        plt.figure()
        plt.clf()

    if style is None:
        p = plt.plot(rank, tdr, label=label, color=color)
    else:
        p = plt.plot(rank, tdr, style, label=label, color=color)

    if errorbars is not None:
        (x,y,yerr) = zip(*errorbars)  # [(x,y,yerr), (x,y,yerr), ...]
        plt.gca().errorbar(x, y, yerr=yerr, fmt=&#39;none&#39;, ecolor=plt.getp(p[0], &#39;color&#39;))  # HACK: force error bars to have same color as plot

    plt.xlabel(xlabel)
    plt.ylabel(ylabel)

    plt.ylim([miny, 1.0])
    plt.xlim([0.95 if not logscale else 0.95, len(rank)])
    if logscale:
        plt.gca().set_xscale(&#39;log&#39;)
    if logy:
        plt.gca().set_yscale(&#39;log&#39;)

    if title is not None:
        plt.title(&#39;%s&#39; % (title))
    legendLoc = &#34;lower left&#34; if legendSwap else &#34;lower right&#34;
    if fontsize is None:
        plt.legend(loc=legendLoc)
    else:
        plt.legend(loc=legendLoc, prop={&#39;size&#39;:fontsize})
    plt.grid(True)

    # Font size
    ax = plt.gca()
    for item in ([ax.title, ax.xaxis.label, ax.yaxis.label] + ax.get_xticklabels() + ax.get_yticklabels()):
        item.set_fontsize(fontsize)
    # plt.tight_layout()
    plt.gcf().set_tight_layout(True)

    if outfile is not None:
        log.info(&#39;[vipy.metric.plot_cmc]: saving &#34;%s&#34;&#39; % outfile)
        plt.savefig(outfile)

    else:
        plt.show()</code></pre>
</details>
</dd>
<dt id="vipy.metrics.confusion_matrix_plot"><code class="name flex">
<span>def <span class="ident">confusion_matrix_plot</span></span>(<span>cm, outfile=None, figure=None, fontsize=5, xlabel=None, ylabel=None, classes=None, colorbar=False, figsize=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a confusion matrix plot for a confusion matrix cm</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/metrics.py#L179-L209" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def confusion_matrix_plot(cm, outfile=None, figure=None, fontsize=5, xlabel=None, ylabel=None, classes=None, colorbar=False, figsize=None):
    &#34;&#34;&#34;Generate a confusion matrix plot for a confusion matrix cm&#34;&#34;&#34;

    outfile = outfile if outfile is not None else temppng()
    figure = 1 if figure is None else figure
    
    if figsize:
        plt.figure(figure, figsize=figsize)
    else:
        plt.figure(figure)
    plt.clf()
    plt.matshow(cm, fignum=figure)

    if colorbar:
        plt.colorbar()
    if classes is not None:
        tick_marks = np.arange(len(classes))
        plt.yticks(tick_marks, classes)
        plt.xticks(tick_marks, classes, rotation=&#39;vertical&#39;)

    xl = plt.xlabel(xlabel) if xlabel is not None else None
    yl = plt.ylabel(ylabel) if ylabel is not None else None

    # Font size
    ax = plt.gca()
    for item in ([ax.title, ax.xaxis.label, ax.yaxis.label] + ax.get_xticklabels() + ax.get_yticklabels()):
        item.set_fontsize(fontsize)

    plt.savefig(outfile, bbox_extra_artists=(yl,) if yl is not None else None, bbox_inches=&#39;tight&#39;, dpi=600)

    return outfile</code></pre>
</details>
</dd>
<dt id="vipy.metrics.cumulative_match_characteristic"><code class="name flex">
<span>def <span class="ident">cumulative_match_characteristic</span></span>(<span>similarityMatrix, gtMatrix)</span>
</code></dt>
<dd>
<div class="desc"><p>CMC curve for probe x gallery similarity matrix (larger is more similar) and ground truth match matrix (one +1 per row, rest zeros)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/metrics.py#L10-L26" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def cumulative_match_characteristic(similarityMatrix, gtMatrix):
    &#34;&#34;&#34;CMC curve for probe x gallery similarity matrix (larger is more similar) and ground truth match matrix (one +1 per row, rest zeros)&#34;&#34;&#34;
    n_categories = gtMatrix.shape[1]
    n_probe = gtMatrix.shape[0]
    rank = range(1,n_categories + 1)

    for i in range(0,n_probe):
        k = np.argsort(-similarityMatrix[i,:])  # index of sorted rows in descending order
        similarityMatrix[i,:] = similarityMatrix[i,k]  # reorder columns in similarityOrder
        gtMatrix[i,:] = gtMatrix[i,k]  # reorder ground truth in same order

    # Given ground truth matrix, if a row has exactly one &#34;1&#34; then there is a mate.  If a row has all zeros, then the mate does not exist in the gallery
    # if a row has nan, then there is a mate in the gallery, but this was not found in the top-k
    n_pos = np.sum(np.array(np.logical_or((np.sum(gtMatrix, axis=1) == 1.0), np.isnan(np.sum(gtMatrix, axis=1)))).astype(np.float32))
    gtMatrix = np.nan_to_num(gtMatrix)  # convert nans to zeros
    recall = [np.sum(np.max(gtMatrix[:,0:r], axis=1)) / n_pos for r in rank]
    return (rank, recall)</code></pre>
</details>
</dd>
<dt id="vipy.metrics.fpr_at_tpr"><code class="name flex">
<span>def <span class="ident">fpr_at_tpr</span></span>(<span>y_true, y_pred, at=0.85)</span>
</code></dt>
<dd>
<div class="desc"><p>Janus metric for false positive rate at a specific true positive rate</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/metrics.py#L116-L120" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def fpr_at_tpr(y_true, y_pred, at=0.85):
    &#34;&#34;&#34;Janus metric for false positive rate at a specific true positive rate&#34;&#34;&#34;
    (fpr, tpr) = roc(y_true, y_pred)
    f = interp1d(tpr, fpr)  # FIXME: kind=&#39;cubic&#39; is singular?
    return f(at)</code></pre>
</details>
</dd>
<dt id="vipy.metrics.histogram"><code class="name flex">
<span>def <span class="ident">histogram</span></span>(<span>freq, categories, barcolors=None, title=None, outfile=None, figure=None, ylabel='Frequency', xrot='vertical', xlabel=None, fontsize=10, xshow=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot histogram bar chart using matplotlib with vertical axis labels on x-axis,, with optional figure save.</p>
<h2 id="inputs">Inputs</h2>
<p>-freq:
the output of (freq, categories) = np.histogram(&hellip;, bins=n)
-categories [list]:
a list of category names that must be length n, or the output of (f,c) = np.histogram(&hellip;) and categories=c[:-1]
-xrot ['vertical'|None]:
rotate the xticks
-barcolors [list]:
list of named colors equal to the length of categories</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/metrics.py#L255-L290" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def histogram(freq, categories, barcolors=None, title=None, outfile=None, figure=None, ylabel=&#39;Frequency&#39;, xrot=&#39;vertical&#39;, xlabel=None, fontsize=10, xshow=True):
    &#34;&#34;&#34;Plot histogram bar chart using matplotlib with vertical axis labels on x-axis,, with optional figure save.
       
       Inputs:
          -freq:  the output of (freq, categories) = np.histogram(..., bins=n)
          -categories [list]:  a list of category names that must be length n, or the output of (f,c) = np.histogram(...) and categories=c[:-1]
          -xrot [&#39;vertical&#39;|None]:  rotate the xticks
          -barcolors [list]:  list of named colors equal to the length of categories
    &#34;&#34;&#34;
    if figure is not None:
        plt.figure(figure)
    else:
        plt.figure(1)
        plt.clf()

    x = range(1, len(categories)+1)
    plt.bar(x, height=freq, width=0.8, bottom=None, color=barcolors)
    if xshow:
        plt.xticks(x, list(categories), rotation=xrot, fontsize=fontsize)
    plt.autoscale(tight=True)
    if ylabel is not None:
        plt.ylabel(ylabel)
    if xlabel is not None:
        plt.xlabel(xlabel)
    plt.subplots_adjust(bottom=0.75)  # tweak
    if title is not None:
        plt.title(&#39;%s&#39; % (title))
    plt.tight_layout()            
    if outfile is not None:
        plt.savefig(outfile)
        plt.clf()
        return outfile
    else:
        plt.show()

    return outfile</code></pre>
</details>
</dd>
<dt id="vipy.metrics.pie"><code class="name flex">
<span>def <span class="ident">pie</span></span>(<span>sizes, labels, explode=None, outfile=None, shadow=False, legend=True, fontsize=10, rotatelabels=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a matplotlib style pie chart with wedges with specified size and labels, with an optional outfile</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/metrics.py#L293-L313" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def pie(sizes, labels, explode=None, outfile=None, shadow=False, legend=True, fontsize=10, rotatelabels=False):
    &#34;&#34;&#34;Generate a matplotlib style pie chart with wedges with specified size and labels, with an optional outfile&#34;&#34;&#34;
    plt.figure(1)
    plt.clf()
    
    # pie = plt.pie(sizes, explode=explode, labels=labels, autopct=&#39;%1.1f%%&#39;, shadow=shadow, startangle=0)
    if legend:
        pie = plt.pie(sizes, explode=explode, shadow=shadow, startangle=0,  textprops={&#39;fontsize&#39;: fontsize}, rotatelabels=rotatelabels)
        plt.legend(labels)
    else:
        pie = plt.pie(sizes, explode=explode, shadow=shadow, startangle=0, labels=labels,  textprops={&#39;fontsize&#39;: fontsize}, rotatelabels=rotatelabels)

    plt.axis(&#39;equal&#39;)  # Equal aspect ratio ensures that pie is drawn as a circle.

    plt.tight_layout()        
    if outfile is not None:
        plt.savefig(outfile)
        plt.clf()        
        return outfile
    else:
        plt.show()</code></pre>
</details>
</dd>
<dt id="vipy.metrics.precision_recall_curve"><code class="name flex">
<span>def <span class="ident">precision_recall_curve</span></span>(<span>precision, recall, title=None, label='Precision-Recall', outfile=None, figure=None, fontsize=8, loc='upper right')</span>
</code></dt>
<dd>
<div class="desc"><p>Plot precision recall curve using matplotlib, with optional figure save.
Call this multiple times with same figure number to plot multiple curves.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/metrics.py#L212-L235" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def precision_recall_curve(precision, recall, title=None, label=&#39;Precision-Recall&#39;, outfile=None, figure=None, fontsize=8, loc=&#39;upper right&#39;):
    &#34;&#34;&#34;Plot precision recall curve using matplotlib, with optional figure save.  Call this multiple times with same figure number to plot multiple curves.&#34;&#34;&#34;

    if figure is not None:
        plt.figure(figure)
    else:
        plt.figure()
        plt.clf()

    plt.plot(recall, precision, label=label)
    plt.xlabel(&#39;Recall&#39;)
    plt.ylabel(&#39;Precision&#39;)
    plt.ylim([0.0, 1.05])
    plt.xlim([0.0, 1.0])
    if title is not None:
        plt.title(&#39;%s&#39; % (title))
    plt.legend(loc=loc, fontsize=fontsize)
    plt.grid(True)

    if outfile is not None:
        log.info(&#39;[vipy.metric.plot_pr]: saving &#34;%s&#34;&#39; % outfile)
        plt.savefig(outfile)
    else:
        plt.show()</code></pre>
</details>
</dd>
<dt id="vipy.metrics.receiver_operating_curve"><code class="name flex">
<span>def <span class="ident">receiver_operating_curve</span></span>(<span>y_true=None, y_pred=None, fpr=None, tpr=None, label=None, title=None, outfile=None, figure=None, logx=False, style=None, fontsize=None, xlabel='False Positive Rate', ylabel='True Positive Rate', legendSwap=False, errorbars=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Plot ROC: <a href="http://scikit-learn.org/stable/auto_examples/plot_roc.html">http://scikit-learn.org/stable/auto_examples/plot_roc.html</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/metrics.py#L123-L175" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def receiver_operating_curve(y_true=None, y_pred=None, fpr=None, tpr=None, label=None, title=None, outfile=None, figure=None, logx=False, style=None, fontsize=None, xlabel=&#39;False Positive Rate&#39;, ylabel=&#39;True Positive Rate&#39;, legendSwap=False, errorbars=None):
    &#34;&#34;&#34;Plot ROC: http://scikit-learn.org/stable/auto_examples/plot_roc.html&#34;&#34;&#34;
    if (fpr is None) and (tpr is None):
        (fpr, tpr) = roc(y_true, y_pred)

    if figure is not None:
        plt.figure(figure)
    else:
        plt.figure()

    if style is None:
        # Use plot defaults to increment plot style when holding
        p = plt.plot(fpr, tpr, label=label)
    else:
        p = plt.plot(fpr, tpr, style, label=label)

    if errorbars is not None:
        (x,y,yerr) = zip(*errorbars)  # [(x,y,yerr), (x,y,yerr), ...]
        plt.gca().errorbar(x, y, yerr=yerr, fmt=&#39;none&#39;, ecolor=plt.getp(p[0], &#39;color&#39;))  # HACK: force error bars to have same color as plot

    if logx is False:
        plt.plot([0, 1], [0, 1], &#39;k--&#39;, label=&#34;_nolegend_&#34;)
    if logx is True:
        plt.xscale(&#39;log&#39;)
    plt.xlim([0.0, 1.0])
    plt.ylim([0.0, 1.0])
    plt.xlabel(xlabel)
    plt.ylabel(ylabel)
    legendLoc = &#34;upper left&#34; if legendSwap else &#34;lower right&#34;
    if fontsize is None:
        plt.legend(loc=legendLoc)
    else:
        plt.legend(loc=legendLoc, prop={&#39;size&#39;:fontsize})
    plt.grid(True)
    plt.gca().set_aspect(&#39;equal&#39;)
    plt.autoscale(tight=True)

    if title is not None:
        plt.title(title)

    # Font size
    ax = plt.gca()
    for item in ([ax.title, ax.xaxis.label, ax.yaxis.label] + ax.get_xticklabels() + ax.get_yticklabels()):
        item.set_fontsize(fontsize)
    plt.gcf().set_tight_layout(True)
    plt.xlim([0.0, 1.0])
    plt.ylim([0.0, 1.0])

    if outfile is not None:
        log.info(&#39;[vipy.metric.plot_roc]: saving &#34;%s&#34;&#39; % outfile)
        plt.savefig(outfile)
    else:
        plt.show()</code></pre>
</details>
</dd>
<dt id="vipy.metrics.scatterplot"><code class="name flex">
<span>def <span class="ident">scatterplot</span></span>(<span>X, labels, outfile=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a scatterplot of 2D points in an Nx2 matrix (X) with provided category labels in list of length N (labels).
Each label will be assigned a unique color.
Scatterplot saved to outfile (if provided).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/metrics.py#L316-L343" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def scatterplot(X, labels, outfile=None):
    &#34;&#34;&#34;Generate a scatterplot of 2D points in an Nx2 matrix (X) with provided category labels in list of length N (labels).  Each label will be assigned a unique color.  Scatterplot saved to outfile (if provided).&#34;&#34;&#34; 
    assert isinstance(X, np.ndarray) and X.ndim == 2 and X.shape[1] == 2
    assert len(X) == len(labels)
    import vipy.show
    
    plt.clf()
    #plt.figure()
    plt.grid(True)
    colors = vipy.show.colorlist()
    d_label_to_color = {c:colors[k % len(colors)] for (k,c) in enumerate(set(labels))}
    plt.axis(&#39;equal&#39;)  
    for y in sorted(set(labels)):
        x = np.array([xi for (xi,yi) in zip(X, labels) if yi == y])
        plt.scatter(x[:,0], x[:,1], c=d_label_to_color[y], label=y)
    plt.axis([np.min(X), np.max(X), np.min(X), np.max(X)])                
    plt.legend()
    plt.gca().set_axisbelow(True)  # grid behind

    plt.tight_layout()
    if outfile is not None:
        plt.savefig(outfile)
        plt.clf()        
        return outfile
    else:
        plt.ion()
        plt.show()
        plt.pause(0.001)</code></pre>
</details>
</dd>
<dt id="vipy.metrics.tdr_at_rank"><code class="name flex">
<span>def <span class="ident">tdr_at_rank</span></span>(<span>rank=None, tdr=None, y_true=None, y_pred=None, numGallery=None, at=10)</span>
</code></dt>
<dd>
<div class="desc"><p>Janus metric for correct retrieval (true detection rate) within a specific rank</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/metrics.py#L84-L107" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def tdr_at_rank(rank=None, tdr=None, y_true=None, y_pred=None, numGallery=None, at=10):
    &#34;&#34;&#34;Janus metric for correct retrieval (true detection rate) within a specific rank&#34;&#34;&#34;

    if rank is None and tdr is None:
        if y_true is not None and y_pred is not None:
            y_true = np.array(y_true)
            y_pred = np.array(y_pred)
            if numGallery is not None:
                truthMatrix = y_true.reshape((len(y_true) / numGallery, numGallery))
                similarityMatrix = y_pred.reshape((len(y_pred) / numGallery, numGallery))
            elif np.min(y_true.shape) &gt; 1:
                truthMatrix = y_true
                similarityMatrix = y_pred
            else:
                raise ValueError(&#39;(y,yhat) must be reshaped into (numProbe x numGallery) of numGallery provided as input&#39;)
            (rank, tdr) = cumulative_match_characteristic(similarityMatrix, truthMatrix)
        else:
            raise ValueError(&#39;either (rank,tdr) or (y,yhat) required&#39;)

    if at &gt; np.max(rank):
        raise ValueError(&#39;Selected operating point rank=%d must be less than maximum rank=%d&#39; % (at, np.max(rank)))

    f = interp1d(rank, tdr)
    return f(at)</code></pre>
</details>
</dd>
<dt id="vipy.metrics.tpr_at_fpr"><code class="name flex">
<span>def <span class="ident">tpr_at_fpr</span></span>(<span>y_true, y_pred, at=0.01)</span>
</code></dt>
<dd>
<div class="desc"><p>Janus metric for true positive rate at a specific false positive rate</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/metrics.py#L109-L113" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def tpr_at_fpr(y_true, y_pred, at=0.01):
    &#34;&#34;&#34;Janus metric for true positive rate at a specific false positive rate&#34;&#34;&#34;
    (fpr, tpr) = roc(y_true, y_pred)
    f = interp1d(fpr, tpr)  # FIXME: kind=&#39;cubic&#39; is singular?
    return f(at)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="vipy.metrics.SSIM"><code class="flex name class">
<span>class <span class="ident">SSIM</span></span>
<span>(</span><span>do_alignment=True, min_matches_for_alignment=10, num_matches_for_alignment=500, K1=0.01, K2=0.03)</span>
</code></dt>
<dd>
<div class="desc"><p>Structural similarity (SSIM) index</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/metrics.py#L365-L513" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SSIM():
    &#34;&#34;&#34;Structural similarity (SSIM) index &#34;&#34;&#34;
    &#34;&#34;&#34;Z. Wang, A. Bovik, H. Sheikh, E. Simoncelli, &#34;Image quality assessment: from error visibility to structural similarity&#34;. IEEE Transactions on Image Processing. 13 (4): 600–612&#34;&#34;&#34;

    def __init__(self, do_alignment=True, min_matches_for_alignment=10, num_matches_for_alignment=500, K1=0.01, K2=0.03):        
        self.do_alignment = do_alignment
        self.min_matches_for_alignment = min_matches_for_alignment
        self.num_matches_for_alignment = num_matches_for_alignment
        self.K1 = K1
        self.K2 = K2

    def __repr__(self):
        return str(&#39;&lt;vipy.ssim: do_alignment=%s, min_matches_for_alignment=%d, num_matches_for_alignment=%d, K1=%f, K2=%f&gt;&#39; % (str(self.do_alignment), self.min_matches_for_alignment, self.num_matches_for_alignment, self.K1, self.K2))

    def match(self, img1, img2):
        &#34;&#34;&#34;Return a set of matching points in img1 (MxN uint8 numpy) and img2 (MxN uint8 numpy) in the form suitable for homography estimation&#34;&#34;&#34;
        try_import(&#39;cv2&#39;, &#39;opencv-python&#39;); import cv2 
        
        # Initiate ORB detector
        orb = cv2.ORB_create()

        # find the keypoints and descriptors with ORB
        kp1, des1 = orb.detectAndCompute(img1,None)
        kp2, des2 = orb.detectAndCompute(img2,None)

        # Match descriptors.
        bf = cv2.BFMatcher(cv2.NORM_HAMMING, crossCheck=True)
        matches = bf.match(des1,des2)

        # Sort them in the order of their distance.
        matches = sorted(matches, key=lambda x:x.distance)[:self.num_matches_for_alignment]

        img1_pts = np.float32([kp1[m.queryIdx].pt for m in matches]).reshape(-1,1,2)
        img2_pts = np.float32([kp2[m.trainIdx].pt for m in matches]).reshape(-1,1,2)

        return (img1_pts, img2_pts)

    def warp(self, src_pts, dst_pts, im_src):
        &#34;&#34;&#34;Warp an image im_src with points src_pts to align with dst_pts&#34;&#34;&#34;

        try_import(&#39;cv2&#39;, &#39;opencv-python&#39;); import cv2
        
        if src_pts.shape[0] &lt; self.min_matches_for_alignment:
            raise ValueError(&#39;Invalid number of inliers&#39;)
        h, mask = cv2.findHomography(src_pts, dst_pts, cv2.RANSAC, 5.0)
        return cv2.warpPerspective(im_src, h, (im_src.shape[1], im_src.shape[0]))

    def align(self, img1, img2):
        &#34;&#34;&#34;Return an image which is the warped version of img1 (MxN uint8 numpy) that aligns with img2 (MxN uint8 numpy)&#34;&#34;&#34;
        (p1, p2) = self.match(img1, img2)
        return self.warp(p1, p2, img1)

    def rgb2gray(self, I):
        &#34;&#34;&#34;Convert RGB image to grayscale; accesory function&#34;&#34;&#34;
        R = I[:,:,0]
        G = I[:,:,1]
        B = I[:,:,2]
        return 0.299 * R + 0.587 * G + 0.114 * B

    def similarity(self, I1, I2, returnMap=True):
        &#34;&#34;&#34;Compute the Structural Similarity Index (SSIM) score of two images
        Inputs:
        1) I1, image array
        2) I2, image array
        3) K1, float (optional, default=0.01)
        - constant
        4) K2, float (optional, default=0.03)
        - constant
        Outputs:
        1) out; float
        - SSIM score
        2) ssim_map; 2-D image array
        - SSIM map&#34;&#34;&#34;

        I1 = self.rgb2gray(I1) if I1.ndim == 3 else I1
        I2 = self.rgb2gray(I2) if I2.ndim == 3 else I2

        C1 = np.power(self.K1 * 255,2)
        C2 = np.power(self.K2 * 255,2)

        w = gaussian(11,1.5)
        f = np.zeros((11,11))
        for k in range(len(w)):
            for k2 in range(len(w)):
                f[k,k2] = np.multiply(w[k],w[k2])
        f = np.true_divide(f,np.sum(f))

        try_import(&#39;scipy.signal&#39;, &#39;scipy&#39;); from scipy.signal import convolve2d        
        ux = convolve2d(I1,f,mode=&#39;same&#39;)
        uy = convolve2d(I2,f,mode=&#39;same&#39;)

        # Compute SSIM constants
        ux_sq = np.power(ux,2)
        uy_sq = np.power(uy,2)
        ux_uy = np.multiply(ux,uy)

        sig_x = convolve2d(np.power(I1,2),f,mode=&#39;same&#39;) - ux_sq
        sig_y = convolve2d(np.power(I2,2),f,mode=&#39;same&#39;) - uy_sq
        sig_xy = convolve2d(np.multiply(I1,I2),f,mode=&#39;same&#39;) - ux_uy

        # Core SSIM Equation
        ssim_map = np.divide(np.multiply(2 * ux_uy + C1, 2 * sig_xy + C2),
                             np.multiply(ux_sq + uy_sq + C1, sig_x + sig_y + C2))

        out = np.mean(ssim_map)

        return (out, ssim_map) if returnMap else out

    
    def ssim(self, im_reference, im_degraded, returnAligned=False):
        &#34;&#34;&#34;Return structural similarity score when aligning im_degraded to im_reference

        &gt;&gt;&gt; (ssim, im_aligned) = vipy.ssim.SSIM(do_alignment=True).ssim(vipy.image.squareowl(), vipy.image.squareowl().rotate(0.01), returnAligned=True)
        &gt;&gt;&gt; print(ssim)
        &gt;&gt;&gt; im_aligned.show(figure=1)
        &gt;&gt;&gt; vipy.image.squareowl().rotate(0.01).show(figure=2)
        
        &#34;&#34;&#34;
        assert isinstance(im_reference, np.ndarray) or isinstance(im_reference, Image)
        assert isinstance(im_degraded, np.ndarray) or isinstance(im_degraded, Image)
        
        img_degraded = im_degraded.lum().numpy() if isinstance(im_degraded, Image) else im_degraded
        img_reference = im_reference.lum().numpy() if isinstance(im_reference, Image) else im_reference
        
        img_degraded_aligned = self.align(img_degraded, img_reference) if self.do_alignment else im_degraded
        ssim = self.similarity(img_degraded_aligned, img_reference, returnMap=False)
        return (ssim, Image(array=img_degraded_aligned, colorspace=&#39;lum&#39;)) if returnAligned else ssim

    @staticmethod
    def demo(im=None):
        &#34;&#34;&#34;Synthetically rotate an image by 4 degrees, and compute structural similarity with and without alignment, return images
        
        &gt;&gt;&gt; (image, degraded_image, aligned_image) = vipy.ssim.demo(vipy.image.Image(filename=&#39;/path/to/image.jpg&#39;)))
        
        &#34;&#34;&#34;
        assert im is None or isinstance(im, Image)
        im = owl().centersquare() if im is None else im
        
        # Synthetic degradation: 1-channel uint8
        (im, im_degraded) = (im.lum(), im.clone().rotate(4*(np.pi/180.0)).lum())
    
        # SSIM
        (ssim_aligned, im_aligned) = SSIM(do_alignment=True).ssim(im.numpy(), im_degraded.numpy(), returnAligned=True)
        (ssim_unaligned) = SSIM(do_alignment=False).ssim(im.numpy(), im_degraded.numpy())    
        log.info(&#39;Structural similarity score (aligned): %f&#39; % ssim_aligned)
        log.info(&#39;Structural similarity score (unaligned): %f&#39; % ssim_unaligned)
        return (im.show(figure=1),
                im_degraded.show(figure=2),
                im_aligned.show(figure=3))</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="vipy.metrics.SSIM.demo"><code class="name flex">
<span>def <span class="ident">demo</span></span>(<span>im=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Synthetically rotate an image by 4 degrees, and compute structural similarity with and without alignment, return images</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; (image, degraded_image, aligned_image) = vipy.ssim.demo(vipy.image.Image(filename='/path/to/image.jpg')))
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/metrics.py#L493-L513" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def demo(im=None):
    &#34;&#34;&#34;Synthetically rotate an image by 4 degrees, and compute structural similarity with and without alignment, return images
    
    &gt;&gt;&gt; (image, degraded_image, aligned_image) = vipy.ssim.demo(vipy.image.Image(filename=&#39;/path/to/image.jpg&#39;)))
    
    &#34;&#34;&#34;
    assert im is None or isinstance(im, Image)
    im = owl().centersquare() if im is None else im
    
    # Synthetic degradation: 1-channel uint8
    (im, im_degraded) = (im.lum(), im.clone().rotate(4*(np.pi/180.0)).lum())

    # SSIM
    (ssim_aligned, im_aligned) = SSIM(do_alignment=True).ssim(im.numpy(), im_degraded.numpy(), returnAligned=True)
    (ssim_unaligned) = SSIM(do_alignment=False).ssim(im.numpy(), im_degraded.numpy())    
    log.info(&#39;Structural similarity score (aligned): %f&#39; % ssim_aligned)
    log.info(&#39;Structural similarity score (unaligned): %f&#39; % ssim_unaligned)
    return (im.show(figure=1),
            im_degraded.show(figure=2),
            im_aligned.show(figure=3))</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="vipy.metrics.SSIM.align"><code class="name flex">
<span>def <span class="ident">align</span></span>(<span>self, img1, img2)</span>
</code></dt>
<dd>
<div class="desc"><p>Return an image which is the warped version of img1 (MxN uint8 numpy) that aligns with img2 (MxN uint8 numpy)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/metrics.py#L412-L415" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def align(self, img1, img2):
    &#34;&#34;&#34;Return an image which is the warped version of img1 (MxN uint8 numpy) that aligns with img2 (MxN uint8 numpy)&#34;&#34;&#34;
    (p1, p2) = self.match(img1, img2)
    return self.warp(p1, p2, img1)</code></pre>
</details>
</dd>
<dt id="vipy.metrics.SSIM.match"><code class="name flex">
<span>def <span class="ident">match</span></span>(<span>self, img1, img2)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a set of matching points in img1 (MxN uint8 numpy) and img2 (MxN uint8 numpy) in the form suitable for homography estimation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/metrics.py#L379-L400" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def match(self, img1, img2):
    &#34;&#34;&#34;Return a set of matching points in img1 (MxN uint8 numpy) and img2 (MxN uint8 numpy) in the form suitable for homography estimation&#34;&#34;&#34;
    try_import(&#39;cv2&#39;, &#39;opencv-python&#39;); import cv2 
    
    # Initiate ORB detector
    orb = cv2.ORB_create()

    # find the keypoints and descriptors with ORB
    kp1, des1 = orb.detectAndCompute(img1,None)
    kp2, des2 = orb.detectAndCompute(img2,None)

    # Match descriptors.
    bf = cv2.BFMatcher(cv2.NORM_HAMMING, crossCheck=True)
    matches = bf.match(des1,des2)

    # Sort them in the order of their distance.
    matches = sorted(matches, key=lambda x:x.distance)[:self.num_matches_for_alignment]

    img1_pts = np.float32([kp1[m.queryIdx].pt for m in matches]).reshape(-1,1,2)
    img2_pts = np.float32([kp2[m.trainIdx].pt for m in matches]).reshape(-1,1,2)

    return (img1_pts, img2_pts)</code></pre>
</details>
</dd>
<dt id="vipy.metrics.SSIM.rgb2gray"><code class="name flex">
<span>def <span class="ident">rgb2gray</span></span>(<span>self, I)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert RGB image to grayscale; accesory function</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/metrics.py#L417-L422" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rgb2gray(self, I):
    &#34;&#34;&#34;Convert RGB image to grayscale; accesory function&#34;&#34;&#34;
    R = I[:,:,0]
    G = I[:,:,1]
    B = I[:,:,2]
    return 0.299 * R + 0.587 * G + 0.114 * B</code></pre>
</details>
</dd>
<dt id="vipy.metrics.SSIM.similarity"><code class="name flex">
<span>def <span class="ident">similarity</span></span>(<span>self, I1, I2, returnMap=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the Structural Similarity Index (SSIM) score of two images
Inputs:
1) I1, image array
2) I2, image array
3) K1, float (optional, default=0.01)
- constant
4) K2, float (optional, default=0.03)
- constant
Outputs:
1) out; float
- SSIM score
2) ssim_map; 2-D image array
- SSIM map</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/metrics.py#L424-L471" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def similarity(self, I1, I2, returnMap=True):
    &#34;&#34;&#34;Compute the Structural Similarity Index (SSIM) score of two images
    Inputs:
    1) I1, image array
    2) I2, image array
    3) K1, float (optional, default=0.01)
    - constant
    4) K2, float (optional, default=0.03)
    - constant
    Outputs:
    1) out; float
    - SSIM score
    2) ssim_map; 2-D image array
    - SSIM map&#34;&#34;&#34;

    I1 = self.rgb2gray(I1) if I1.ndim == 3 else I1
    I2 = self.rgb2gray(I2) if I2.ndim == 3 else I2

    C1 = np.power(self.K1 * 255,2)
    C2 = np.power(self.K2 * 255,2)

    w = gaussian(11,1.5)
    f = np.zeros((11,11))
    for k in range(len(w)):
        for k2 in range(len(w)):
            f[k,k2] = np.multiply(w[k],w[k2])
    f = np.true_divide(f,np.sum(f))

    try_import(&#39;scipy.signal&#39;, &#39;scipy&#39;); from scipy.signal import convolve2d        
    ux = convolve2d(I1,f,mode=&#39;same&#39;)
    uy = convolve2d(I2,f,mode=&#39;same&#39;)

    # Compute SSIM constants
    ux_sq = np.power(ux,2)
    uy_sq = np.power(uy,2)
    ux_uy = np.multiply(ux,uy)

    sig_x = convolve2d(np.power(I1,2),f,mode=&#39;same&#39;) - ux_sq
    sig_y = convolve2d(np.power(I2,2),f,mode=&#39;same&#39;) - uy_sq
    sig_xy = convolve2d(np.multiply(I1,I2),f,mode=&#39;same&#39;) - ux_uy

    # Core SSIM Equation
    ssim_map = np.divide(np.multiply(2 * ux_uy + C1, 2 * sig_xy + C2),
                         np.multiply(ux_sq + uy_sq + C1, sig_x + sig_y + C2))

    out = np.mean(ssim_map)

    return (out, ssim_map) if returnMap else out</code></pre>
</details>
</dd>
<dt id="vipy.metrics.SSIM.ssim"><code class="name flex">
<span>def <span class="ident">ssim</span></span>(<span>self, im_reference, im_degraded, returnAligned=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Return structural similarity score when aligning im_degraded to im_reference</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; (ssim, im_aligned) = vipy.ssim.SSIM(do_alignment=True).ssim(vipy.image.squareowl(), vipy.image.squareowl().rotate(0.01), returnAligned=True)
&gt;&gt;&gt; print(ssim)
&gt;&gt;&gt; im_aligned.show(figure=1)
&gt;&gt;&gt; vipy.image.squareowl().rotate(0.01).show(figure=2)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/metrics.py#L474-L491" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def ssim(self, im_reference, im_degraded, returnAligned=False):
    &#34;&#34;&#34;Return structural similarity score when aligning im_degraded to im_reference

    &gt;&gt;&gt; (ssim, im_aligned) = vipy.ssim.SSIM(do_alignment=True).ssim(vipy.image.squareowl(), vipy.image.squareowl().rotate(0.01), returnAligned=True)
    &gt;&gt;&gt; print(ssim)
    &gt;&gt;&gt; im_aligned.show(figure=1)
    &gt;&gt;&gt; vipy.image.squareowl().rotate(0.01).show(figure=2)
    
    &#34;&#34;&#34;
    assert isinstance(im_reference, np.ndarray) or isinstance(im_reference, Image)
    assert isinstance(im_degraded, np.ndarray) or isinstance(im_degraded, Image)
    
    img_degraded = im_degraded.lum().numpy() if isinstance(im_degraded, Image) else im_degraded
    img_reference = im_reference.lum().numpy() if isinstance(im_reference, Image) else im_reference
    
    img_degraded_aligned = self.align(img_degraded, img_reference) if self.do_alignment else im_degraded
    ssim = self.similarity(img_degraded_aligned, img_reference, returnMap=False)
    return (ssim, Image(array=img_degraded_aligned, colorspace=&#39;lum&#39;)) if returnAligned else ssim</code></pre>
</details>
</dd>
<dt id="vipy.metrics.SSIM.warp"><code class="name flex">
<span>def <span class="ident">warp</span></span>(<span>self, src_pts, dst_pts, im_src)</span>
</code></dt>
<dd>
<div class="desc"><p>Warp an image im_src with points src_pts to align with dst_pts</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/metrics.py#L402-L410" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def warp(self, src_pts, dst_pts, im_src):
    &#34;&#34;&#34;Warp an image im_src with points src_pts to align with dst_pts&#34;&#34;&#34;

    try_import(&#39;cv2&#39;, &#39;opencv-python&#39;); import cv2
    
    if src_pts.shape[0] &lt; self.min_matches_for_alignment:
        raise ValueError(&#39;Invalid number of inliers&#39;)
    h, mask = cv2.findHomography(src_pts, dst_pts, cv2.RANSAC, 5.0)
    return cv2.warpPerspective(im_src, h, (im_src.shape[1], im_src.shape[0]))</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="VIPY" href="https://github.com/visym/vipy/">
<img src="https://www.visym.com/labs/images/visym_logo_black_notext.png" alt="" width="60">
</a>
<h1 style="font-size:200%;"><b>VIPY:</b> Visual Dataset Transformation</h1>
</header>
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = './doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="vipy" href="index.html">vipy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="vipy.metrics.ascii_bar_chart" href="#vipy.metrics.ascii_bar_chart">ascii_bar_chart</a></code></li>
<li><code><a title="vipy.metrics.average_precision_chart" href="#vipy.metrics.average_precision_chart">average_precision_chart</a></code></li>
<li><code><a title="vipy.metrics.cmc_curve" href="#vipy.metrics.cmc_curve">cmc_curve</a></code></li>
<li><code><a title="vipy.metrics.confusion_matrix_plot" href="#vipy.metrics.confusion_matrix_plot">confusion_matrix_plot</a></code></li>
<li><code><a title="vipy.metrics.cumulative_match_characteristic" href="#vipy.metrics.cumulative_match_characteristic">cumulative_match_characteristic</a></code></li>
<li><code><a title="vipy.metrics.fpr_at_tpr" href="#vipy.metrics.fpr_at_tpr">fpr_at_tpr</a></code></li>
<li><code><a title="vipy.metrics.histogram" href="#vipy.metrics.histogram">histogram</a></code></li>
<li><code><a title="vipy.metrics.pie" href="#vipy.metrics.pie">pie</a></code></li>
<li><code><a title="vipy.metrics.precision_recall_curve" href="#vipy.metrics.precision_recall_curve">precision_recall_curve</a></code></li>
<li><code><a title="vipy.metrics.receiver_operating_curve" href="#vipy.metrics.receiver_operating_curve">receiver_operating_curve</a></code></li>
<li><code><a title="vipy.metrics.scatterplot" href="#vipy.metrics.scatterplot">scatterplot</a></code></li>
<li><code><a title="vipy.metrics.tdr_at_rank" href="#vipy.metrics.tdr_at_rank">tdr_at_rank</a></code></li>
<li><code><a title="vipy.metrics.tpr_at_fpr" href="#vipy.metrics.tpr_at_fpr">tpr_at_fpr</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="vipy.metrics.SSIM" href="#vipy.metrics.SSIM">SSIM</a></code></h4>
<ul class="two-column">
<li><code><a title="vipy.metrics.SSIM.align" href="#vipy.metrics.SSIM.align">align</a></code></li>
<li><code><a title="vipy.metrics.SSIM.demo" href="#vipy.metrics.SSIM.demo">demo</a></code></li>
<li><code><a title="vipy.metrics.SSIM.match" href="#vipy.metrics.SSIM.match">match</a></code></li>
<li><code><a title="vipy.metrics.SSIM.rgb2gray" href="#vipy.metrics.SSIM.rgb2gray">rgb2gray</a></code></li>
<li><code><a title="vipy.metrics.SSIM.similarity" href="#vipy.metrics.SSIM.similarity">similarity</a></code></li>
<li><code><a title="vipy.metrics.SSIM.ssim" href="#vipy.metrics.SSIM.ssim">ssim</a></code></li>
<li><code><a title="vipy.metrics.SSIM.warp" href="#vipy.metrics.SSIM.warp">warp</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
