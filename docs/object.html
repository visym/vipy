<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.6" />
<meta name="google-site-verification" content="aB8LkQegj94_TJPdrcJm2ldIRWyXY82Jp24Gtkdgyn0" />
<title>vipy.object API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vipy.object</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L1-L1283" class="git-link">Browse git</a>
</summary>
<pre><code class="python">import numpy as np
from vipy.geometry import BoundingBox, Point2d
from vipy.util import isstring, tolist, chunklistwithoverlap, try_import, Timer, truncate_string, shortuuid, to_iterable
import uuid
import copy
from itertools import islice
from vipy.globals import log
from itertools import zip_longest

try:
    import ujson as json  # faster
except ImportError:
    import json


class Object():
    __slots__ = ()

    def category(self):
        return self.attributes[&#39;tags&#39;][0] if &#39;tags&#39; in self.attributes else None

    def new_category(self, category, confidence=None):
        return self.del_attribute(&#39;confidences&#39;).del_attribute(&#39;tags&#39;).add_tag(category, confidence)
    
    def confidence(self):
        return self.get_attribute(&#39;confidences&#39;)[self.category()] if self.has_attribute(&#39;confidences&#39;) and self.category() in self.attributes[&#39;confidences&#39;] else None
    
    def tags(self, tags=None):
        if tags is not None:
            return self.set_attribute(&#39;tags&#39;, tolist(tags))
        return self.attributes[&#39;tags&#39;] if &#39;tags&#39; in self.attributes else []
    
    def confidences(self):
        return tuple(self.attributes[&#39;confidences&#39;][t] if t in self.aattributes[&#39;confidences&#39;] else None for t in self.tags())
    
    def add_tag(self, tag, confidence=None):
        self.append_attribute(&#39;tags&#39;, tag)
        if confidence is not None:
            if not self.has_attribute(&#39;confidences&#39;):
                self.set_attribute(&#39;confidences&#39;, {})
            self.attributes[&#39;confidences&#39;][tag] = confidence
        return self

    def add_tags(self, tags, confidences=[]):
        for (t,c) in zip_longest(tags, confidences):
            self.add_tag(t, c)
        return self
    
    def has_attribute(self, k):
        return k in self.attributes

    def get_attribute(self, k):
        return self.attributes[k] if k in self.attributes else None

    def set_attribute(self, k, v):
        self.attributes[k] = v
        return self
    
    def del_attribute(self, k):
        self.attributes.pop(k, None)
        return self

    def clear_attributes(self):
        self.attributes = {}
        return self
    
    def append_attribute(self, key, value):
        &#34;&#34;&#34;Append the value to attribute key, creating the key as an empty list if it does not exist&#34;&#34;&#34;
        if key not in self.attributes:
            self.attributes[key] = []
        self.attributes[key].append(value)
        return self

    def has_normalized_coordinates(self):
        return self.get_attribute(&#39;normalized_coordinates&#39;) == True

    
class Detection(BoundingBox, Object):
    &#34;&#34;&#34;vipy.object.Detection class
    
    This class represent a single object detection in the form a bounding box with a label and confidence.
    The constructor of this class follows a subset of the constructor patterns of vipy.geometry.BoundingBox

    ```python
    d = vipy.object.Detection(category=&#39;Person&#39;, xmin=0, ymin=0, width=50, height=100)
    d = vipy.object.Detection(label=&#39;Person&#39;, xmin=0, ymin=0, width=50, height=100)  # &#34;label&#34; is an alias for &#34;category&#34;
    d = vipy.object.Detection(label=&#39;Person&#39;, xywh=[0,0,50,100])
    d = vipy.object.Detection(..., id=True)  # generate a unique UUID for this detection retrievable with d.id()
    ```

    Args:
        - normalized_coordinates [bool]: if True, then all of the (x,y) track coordinates are normalized to [0,1] where (0,0) is the upper left and (1,1) is bottom right. Tracks are converted to pixel coordinates on load().  
          This is useful for legacy datasets where bounding boxes were stored in a scale invariant manner.  This flag avoids having to probe the image to determine the size in the constructor and delays conversion until pixels are loaded.

    &#34;&#34;&#34;
    __slots__ = [&#39;_xmin&#39;, &#39;_ymin&#39;, &#39;_xmax&#39;, &#39;_ymax&#39;, &#39;attributes&#39;, &#39;_id&#39;]    
    def __init__(self, category=None, xmin=None, ymin=None, width=None, height=None, xmax=None, ymax=None, confidence=None, xcentroid=None, ycentroid=None, ulbr=None, xywh=None, attributes=None, id=None, tags=None, normalized_coordinates=False):
        super().__init__(xmin=xmin, ymin=ymin, width=width, height=height, xmax=xmax, ymax=ymax, xcentroid=xcentroid, ycentroid=ycentroid, xywh=xywh, ulbr=ulbr)

        self._id = shortuuid() if id == True else (str(id) if id is not None else id)
        self.attributes = {} if attributes is None else attributes  # user must copy if needed

        if category is not None:
            self.add_tag(category, confidence)        
        if tags is not None:
            for t in to_iterable(tags):
                self.add_tag(t)

        if normalized_coordinates:
            self.attributes[&#39;normalized_coordinates&#39;] = True
            
    @classmethod
    def cast(cls, d):
        assert isinstance(d, BoundingBox)
        return d if isinstance(d, Detection) else cls(xywh=d.xywh())

    def downcast(self):
        return BoundingBox(xywh=self.xywh())

    def __json__(self):
        &#34;&#34;&#34;Serialization method for json package&#34;&#34;&#34;
        return self.json(encode=True)

    def json(self, encode=True):
        d = {k.lstrip(&#39;_&#39;):getattr(self, k) for k in Detection.__slots__ if getattr(self, k) is not None}  # prettyjson (remove &#34;_&#34; prefix to attributes)  
        return json.dumps(d) if encode else d
    
    @classmethod
    def from_json(cls, s):
        d = json.loads(s) if not isinstance(s, dict) else s
        if any(k.startswith(&#39;_&#39;) for k in d.keys()):
            # Legacy support &lt;= vipy 1.14.4
            return cls(xmin=d[&#39;_xmin&#39;], ymin=d[&#39;_ymin&#39;], xmax=d[&#39;_xmax&#39;], ymax=d[&#39;_ymax&#39;],
                       attributes=d[&#39;attributes&#39;] if &#39;attributes&#39; in d else None,
                       tags=d[&#39;tags&#39;] if &#39;tags&#39; in d else None,
                       category=d[&#39;_category&#39;] if &#39;_category&#39; in d else None,
                       id=d[&#39;_id&#39;] if &#39;_id&#39; in d else None)
        elif &#39;label&#39; in d.keys():
            # Legacy support &lt;= vipy 1.14.4
            return cls(xmin=d[&#39;xmin&#39;], ymin=d[&#39;ymin&#39;], xmax=d[&#39;xmax&#39;], ymax=d[&#39;ymax&#39;],
                       attributes=d[&#39;attributes&#39;] if &#39;attributes&#39; in d else None,
                       tags=None,  # in attributes
                       category=d[&#39;label&#39;] if &#39;label&#39; in d else None,
                       confidence=d[&#39;confidence&#39;] if &#39;confidence&#39; in d else None,
                       id=d[&#39;id&#39;] if &#39;id&#39; in d else None)
        else:            
            # vipy-1.16.1            
            return cls(xmin=d[&#39;xmin&#39;], ymin=d[&#39;ymin&#39;], xmax=d[&#39;xmax&#39;], ymax=d[&#39;ymax&#39;],
                       attributes=d[&#39;attributes&#39;] if &#39;attributes&#39; in d else None,
                       tags=None,  # in attributes
                       category=None,
                       confidence=None,
                       id=d[&#39;id&#39;] if &#39;id&#39; in d else None)
        
    def __repr__(self):
        strlist = []
        if self.category() is not None:
            strlist.append(&#39;category=%s&#39; % (str(self.category())[0:80] + (&#39; ... &#39; if len(str(self.category()))&gt;80 else &#39;&#39;)))                        
        if True:
            strlist.append(&#39;bbox=(xmin=%1.1f, ymin=%1.1f, width=%1.1f, height=%1.1f)&#39; %
                           (self.xmin(), self.ymin(),self.width(), self.height()))
        if self.category() is not None and self.confidence() is not None:
            strlist.append(&#39;conf=%1.3f&#39; % self.confidence())
        if self.isdegenerate():
            strlist.append(&#39;degenerate&#39;)
        return str(&#39;&lt;vipy.object.Detection: %s&gt;&#39; % (&#39;, &#39;.join(strlist)))

    def __eq__(self, other):
        &#34;&#34;&#34;Detection equality when bounding boxes (integer resolution) and categories are equivalent&#34;&#34;&#34;
        return isinstance(other, Detection) and self.clone().int().xywh() == other.clone().int().xywh() and self.category() == other.category()

    def __str__(self):
        return self.__repr__()

    def dict(self):
        &#34;&#34;&#34;Return a python dictionary containing the relevant serialized attributes suitable for JSON encoding&#34;&#34;&#34;
        return self.json(s=None, encode=False)
                
    def id(self):
        return self._id

    def clone(self, deep=False):
        &#34;&#34;&#34;Copy the object, if deep=True, then include a deep copy of the attribute dictionary, else a shallow copy.  Cloned object has the same id()&#34;&#34;&#34;
        d = Detection.from_json(self.json(encode=False))
        if deep:
            d.attributes = copy.deepcopy(self.attributes)
        else:
            d.attributes = self.attributes.copy()            
        return d


    
class Keypoint2d(Point2d, Object):
    &#34;&#34;&#34;vipy.object.Keypoint2d class&#34;&#34;&#34;

    __slots__ = [&#39;_x&#39;, &#39;_y&#39;, &#39;_r&#39;, &#39;attributes&#39;, &#39;_id&#39;]        
    def __init__(self, x, y, radius=1, attributes=None, confidence=None, id=None, category=None, tags=None, normalized_coordinates=False):
        super().__init__(x, y, r=radius)
        
        assert attributes is None or isinstance(attributes, dict)        
        self.attributes = attributes if attributes is not None else {}
        
        self._id = shortuuid() if id is True else (str(id) if id is not None else id)

        if category is not None:
            self.add_tag(category, confidence)        
        if tags is not None:
            for t in to_iterable(tags):
                self.add_tag(t)

        if normalized_coordinates:
            self.set_attribute(&#39;normalized_coordinates&#39;, True)  # updated on load after size is available

    @classmethod
    def cast(cls, obj):
        if isinstance(obj, Detection):
            return cls(obj.centroid_x(), obj.centroid_y(), min(obj.width()/2, obj.height()/2), attributes=obj.attributes)
        elif isinstance(obj, Keypoint2d):
            return self
        else:
            raise TypeError(&#39;unsupported type &#34;%s&#34;&#39; % (type(obj)))
                
    def clone(self, deep=False):
        &#34;&#34;&#34;Copy the object, if deep=True, then include a deep copy of the attribute dictionary, else a shallow copy.  Cloned object has the same id()&#34;&#34;&#34;
        #return copy.deepcopy(self)
        d = Keypoint2d.from_json(self.json(encode=False))
        if deep:
            d.attributes = copy.deepcopy(self.attributes)
        else:
            d.attributes = self.attributes.copy()            
        return d
    
    @property
    def guid(self):
        return self._id

    def id(self):
        return self._id

    def __repr__(self):
        fields  = [&#39;x=%s&#39; % self.x]
        fields += [&#39;y=%s&#39; % self.y]
        fields += [&#39;r=%s&#39; % self.r]        
        fields += [&#39;category=%s&#39; % truncate_string(str(self.category()), 40)] if self.category() is not None else []
        fields += [&#39;conf=%1.3f&#39; % self.confidence()] if self.category() is not None and self.confidence() is not None else []
        fields += [&#39;tags=%s&#39; % truncate_string(str(self.tags()), 40)] if len(self.tags())&gt;1 else []        
        return str(&#39;&lt;vipy.object.Keypoint2d: %s&gt;&#39; % (&#39;, &#39;.join(fields)))
    
    @classmethod
    def from_json(cls, s):
        d = json.loads(s) if not isinstance(s, dict) else s
        return cls(x=d[&#39;x&#39;], y=d[&#39;y&#39;], radius=d[&#39;r&#39;],
                   attributes=d[&#39;attributes&#39;] if &#39;attributes&#39; in d else None,
                   id=d[&#39;id&#39;] if &#39;id&#39; in d else True)
    
    def json(self, encode=True):
        d = {k.lstrip(&#39;_&#39;):getattr(self, k) for k in Keypoint2d.__slots__ if getattr(self, k) is not None}  # prettyjson (remove &#34;_&#34; prefix to attributes)  
        return json.dumps(d) if encode else d
                
    
                          
class Track():
    &#34;&#34;&#34;vipy.object.Track class
    
    A track represents one or more labeled bounding boxes of an object instance through time.  A track is defined as a finite set of labeled boxes observed 
    at keyframes, which are discrete observations of this instance.  Each keyframe has an associated vipy.geometry.BoundingBox() which defines the spatial bounding box
    of the instance in this keyframe.  The kwarg &#34;interpolation&#34; defines how the track is interpolated between keyframes, and the kwarg &#34;boundary&#34; defines how the 
    track is interpolated outside the (min,max) of the keyframes.  

    Valid constructors are:

    ```python
    t = vipy.object.Track(keyframes=[0,100], boxes=[vipy.geometry.BoundingBox(0,0,10,10), vipy.geometry.BoundingBox(0,0,20,20)], label=&#39;Person&#39;)
    t = vipy.object.Track(keyframes=[0,100], boxes=[vipy.geometry.BoundingBox(0,0,10,10), vipy.geometry.BoundingBox(0,0,20,20)], label=&#39;Person&#39;, interpolation=&#39;linear&#39;)
    t = vipy.object.Track(keyframes=[10,100], boxes=[vipy.geometry.BoundingBox(0,0,10,10), vipy.geometry.BoundingBox(0,0,20,20)], label=&#39;Person&#39;, boundary=&#39;strict&#39;)
    ```

    Tracks can be constructed incrementally:

    ```python
    t = vipy.object.Track(&#39;Person&#39;)
    t.add(0, vipy.geometry.BoundingBox(0,0,10,10))
    t.add(100, vipy.geometry.BoundingBox(0,0,20,20))
    ```

    Tracks can be resampled at a new framerate, as long as the framerate is known when the keyframes are extracted

    ```python
    t.framerate(newfps)
    ```

    &#34;&#34;&#34;
    __slots__ = [&#39;_id&#39;, &#39;_label&#39;, &#39;_framerate&#39;, &#39;_interpolation&#39;, &#39;_boundary&#39;, &#39;attributes&#39;, &#39;_keyframes&#39;, &#39;_keyboxes&#39;]    
    def __init__(self, keyframes, boxes, category=None, label=None, framerate=30, interpolation=&#39;linear&#39;, boundary=&#39;strict&#39;, attributes=None, id=None, filterbox=False):
        keyframes = tolist(keyframes)
        boxes = tolist(boxes)        
        assert isinstance(keyframes, tuple) or isinstance(keyframes, list), &#34;Keyframes are required and must be tuple or list&#34;
        assert isinstance(boxes, tuple) or isinstance(boxes, list), &#34;Keyframe boundingboxes are required and must be tuple or list&#34;
        assert all([isinstance(bb, BoundingBox) for bb in boxes]), &#34;Keyframe bounding boxes must be vipy.geometry.BoundingBox objects&#34;
        assert filterbox or all([bb.isvalid() for bb in boxes]), &#34;All keyframe bounding boxes must be valid&#34;        
        assert not (label is not None and category is not None), &#34;Constructor requires either label or category kwargs, not both&#34;                
        assert len(keyframes) == len(boxes), &#34;Boxes and keyframes must be the same length, there must be a one to one mapping of frames to boxes&#34;
        assert boundary in set([&#39;extend&#39;, &#39;strict&#39;]), &#34;Invalid interpolation boundary - Must be [&#39;extend&#39;, &#39;strict&#39;]&#34;
        assert interpolation in set([&#39;linear&#39;]), &#34;Invalid interpolation - Must be [&#39;linear&#39;]&#34;
        assert framerate is not None, &#34;initial framerate for keyframes is required for framerate conversion&#34;
        
        self._id = shortuuid() if id is None else str(id)
        self._label = category if category is not None else label
        self._framerate = float(framerate) 
        self._interpolation = interpolation
        self._boundary = boundary
        self.attributes = attributes if attributes is not None else {}  # user must copy if needed
        self._keyframes = [int(np.round(f)) for f in keyframes]  # coerce to int
        self._keyboxes = boxes
        
        # Sorted increasing frame order
        if len(keyframes) &gt; 0 and len(boxes) &gt; 0 and not all([keyframes[i-1] &lt;= keyframes[i] for i in range(1,len(keyframes))]):
            (keyframes, boxes) = zip(*sorted([(f,bb) for (f,bb) in zip(keyframes, boxes)], key=lambda x: x[0]))
            self._keyframes = list(keyframes)
            self._keyboxes = list(boxes)

        # Filter boxes:  remove invalid boxes and keyframes
        if filterbox and len(keyframes) &gt; 0 and len(boxes) &gt; 0:
            kfbb = [(f,bb) for (f,bb) in zip(keyframes, boxes) if bb.isvalid()]
            (keyframes, boxes) = zip(*kfbb) if len(kfbb)&gt;0 else ([],[])
            self._keyframes = list(keyframes)
            self._keyboxes = list(boxes)
            if len(self) == 0:
                log.warning(&#39;vipy.object.Track - filtering invalid boxes with filterbox=True resulted in zero length track for track ID %s&#39; % str(self.id()))            
            
    @classmethod
    def from_json(cls, s):
        d = json.loads(s) if not isinstance(s, dict) else s
        d = {k.lstrip(&#39;_&#39;):v for (k,v) in d.items()}  # prettyjson (remove &#34;_&#34; prefix to attributes), legacy support
        return cls(keyframes=tuple(int(f) for f in d[&#39;keyframes&#39;]),
                   boxes=tuple([Detection.from_json(bbs) for bbs in d[&#39;keyboxes&#39;]]),
                   category=d[&#39;label&#39;] if &#39;label&#39; in d else None,
                   framerate=d[&#39;framerate&#39;] if &#39;framerate&#39; in d and d[&#39;framerate&#39;] is not None else 30,  # legacy support (pip_175k)
                   interpolation=d[&#39;interpolation&#39;] if &#39;interpolation&#39; in d else &#39;linear&#39;,
                   boundary=d[&#39;boundary&#39;],
                   attributes=d[&#39;attributes&#39;],
                   id=d[&#39;id&#39;] if &#39;id&#39; in d else None)

    def __json__(self):
        &#34;&#34;&#34;Serialization method for json package&#34;&#34;&#34;
        return self.json(encode=True)
    
    def json(self, encode=True):
        d = {k:getattr(self, k) if k != &#39;_keyboxes&#39; else tuple([bb.json(encode=False) for bb in getattr(self, k)]) for k in Track.__slots__}        
        d = {k.lstrip(&#39;_&#39;):v for (k,v) in d.items() if v is not None}  # prettyjson (remove &#34;_&#34; prefix to attributes)                
        d[&#39;keyframes&#39;] = tuple([int(f) for f in self._keyframes])
        return json.dumps(d) if encode else d

    def __repr__(self):
        strlist = []
        if self.category() is not None:
            strlist.append(&#39;category=&#34;%s&#34;&#39; % self.category())
        if self.endframe() is not None and self.startframe() is not None:
            strlist.append(&#39;startframe=%d, endframe=%d&#39; % (self.startframe(), self.endframe()))
        strlist.append(&#39;keyframes=%d&#39; % len(self._keyframes))
        return str(&#39;&lt;vipy.object.Track: %s&gt;&#39; % (&#39;, &#39;.join(strlist)))

    def __getitem__(self, k):
        &#34;&#34;&#34;Interpolate the track at frame k&#34;&#34;&#34;
        return self.linear_interpolation(k)

    def __iter__(self):
        &#34;&#34;&#34;Iterate over the track interpolating each frame from min(keyframes) to max(keyframes)&#34;&#34;&#34;
        for k in range(self.startframe(), self.endframe()+1):
            yield self.linear_interpolation(k)

    def __len__(self):
        &#34;&#34;&#34;The length of a track is the total number of interpolated frames, or zero if degenerate&#34;&#34;&#34;
        return max(0, self.endframe() - self.startframe() + 1) if (len(self._keyframes)&gt;0 and len(self._keyboxes)&gt;0) else 0

    def isempty(self):
        return self.__len__() == 0

    def has_normalized_coordinates(self):
        return all(isinstance(bb, Detection) and bb.has_normalized_coordinates() for bb in self.keyboxes())
    
    def confidence(self, last=None, samples=None):
        &#34;&#34;&#34;The confidence of a track is the mean confidence of all (or just last=last frames, or samples=samples uniformly spaced) keyboxes (if confidences are available) else 0&#34;&#34;&#34;
        if samples is not None:
            dt = max(1, int(round(len(self._keyframes)/float(samples))))
            C = [self._keyboxes[i]._confidence for i in range(len(self._keyframes)-1, -1, -dt) if (hasattr(self._keyboxes[i], &#39;_confidence&#39;) and self._keyboxes[i]._confidence is not None)]
        elif last == 1:
            return self.endbox().confidence() if len(self)&gt;0 else 0
        else:
            ef = self.endframe() - last if last is not None else 0
            C = [d._confidence for (f,d) in zip(self.keyframes(), self.keyboxes()) if f &gt;= ef and (hasattr(d, &#39;_confidence&#39;) and d._confidence is not None)]
        return C[0] if len(C) == 1 else (float(np.mean(C)) if len(C) &gt; 0 else 0)
        
    def isdegenerate(self):
        &#34;&#34;&#34;Is the track degenerate?  
        
        A degenerate track has:
            - Unequal length keyboxes and keyframes
            - length zero track
            - Non increasing keyframes
            - Invalid keyboxes
        &#34;&#34;&#34;
        return not (len(self.keyboxes()) == len(self.keyframes()) and
                    (len(self) == 0 or all([bb.isvalid() for bb in self.keyboxes()])) and
                    sorted(self.keyframes()) == list(self.keyframes()))
    
    def dict(self):
        &#34;&#34;&#34;Return a python dictionary containing the relevant serialized attributes suitable for JSON encoding&#34;&#34;&#34;
        return self.json(encode=False)

    
    def add(self, keyframe, bbox, strict=True):
        &#34;&#34;&#34;Add a new keyframe and associated box to track, preserve sorted order of keyframes.  If keyframe is already in track, throw an exception.  In this case use update() instead

           -strict [bool]:  If box is degenerate, throw an exception if strict=True, otherwise just don&#39;t add it
        
        .. note::  The BoundingBox is added by reference.  If you want to this to be a copy, pass in bbox.clone()
        &#34;&#34;&#34;
        assert isinstance(bbox, BoundingBox), &#34;Invalid input - Box must be vipy.geometry.BoundingBox()&#34;
        assert strict is False or bbox.isvalid(), &#34;Invalid input - Box must be non-degenerate&#34;
        assert int(keyframe) not in self._keyframes, &#34;Invalid input - repeated keyframe&#34;
        if not bbox.isvalid():            
            return self  # just don&#39;t add it 
        self._keyframes.append(int(keyframe))
        self._keyboxes.append(bbox)  # not cloned()
        if len(self._keyframes) &gt; 1 and keyframe &lt; self._keyframes[-2]:
            # Preserve sorted order if inserting into the middle somewhere
            (self._keyframes, self._keyboxes) = zip(*sorted([(f,bb) for (f,bb) in zip(self._keyframes, self._keyboxes)], key=lambda x: x[0]))        
            self._keyframes = list(self._keyframes)
            self._keyboxes = list(self._keyboxes)
        return self

    def update(self, keyframe, bbox):
        if keyframe in self._keyframes:
            self.delete(keyframe)
        self.add(keyframe, bbox)
        return self
        
    def replace(self, keyframe, box):
        &#34;&#34;&#34;Replace the keyframe and associated box(es), preserve sorted order of keyframes&#34;&#34;&#34;
        return self.delete(keyframe).add(keyframe, box)

    def delete(self, keyframe):
        &#34;&#34;&#34;Replace a keyframe and associated box to track, preserve sorted order of keyframes&#34;&#34;&#34;
        while keyframe in self._keyframes:
            k = self._keyframes.index(keyframe)
            del self._keyboxes[k]
            del self._keyframes[k]
        return self
    
    def keyframes(self):
        &#34;&#34;&#34;Return keyframe frame indexes where there are track observations&#34;&#34;&#34;
        return self._keyframes

    def num_keyframes(self):
        return len(self._keyframes)

    def keyboxes(self, boxes=None, keyframes=None):
        &#34;&#34;&#34;Return keyboxes where there are track observations&#34;&#34;&#34;
        if boxes is None and keyframes is None:
            return self._keyboxes
        else:
            assert all([isinstance(bb, BoundingBox) for bb in boxes])
            self._keyboxes = boxes
            self._keyframes = keyframes if keyframes is not None else self._keyframes
            assert not self.isdegenerate()
            return self
        
    def meanshape(self):
        &#34;&#34;&#34;Return the mean (width,height) of the box during the track, or None if the track is degenerate&#34;&#34;&#34;
        s = np.mean([bb.shape() for bb in self.keyboxes()], axis=0) if len(self.keyboxes()) &gt; 0 else None
        return (float(s[0]), float(s[1])) if s is not None else None

    def meanbox(self):
        &#34;&#34;&#34;Return the mean bounding box during the track, or None if the track is degenerate&#34;&#34;&#34;
        return BoundingBox(ulbr=np.mean([bb.ulbr() for bb in self.keyboxes()], axis=0)) if len(self.keyboxes()) &gt; 0 else None 
    
    def shapevariance(self):
        &#34;&#34;&#34;Return the variance (width, height) of the box shape relative to `vipy.object.Track.meanbox` during the track or None if the track is degenerate.  

        This is useful for filtering spurious tracks where the aspect ratio changes rapidly and randomly

        Returns:
            (width_variance, height_variance) of the box shape during the track (or None)
        &#34;&#34;&#34;
        m = self.meanshape()
        return (float(np.mean([(bb.width() - m[0])**2 for bb in self.keyboxes()])), 
                float(np.mean([(bb.height() - m[1])**2 for bb in self.keyboxes()]))) if m is not None else None


    def framerate(self, fps=None, speed=None):
        &#34;&#34;&#34;Resample keyframes from known original framerate set by constructor to be new framerate fps.

        Args:
            fps: [float]  The new frame rate in frames per second
            speed: [float]  An optional speed factor which will multiply the current framerate by this factor (e.g. speed=2 --&gt; fps=self.framerate()*2)

        Returns:
            This track object with the keyframes resampled to the new framerate

        &#34;&#34;&#34;
        if fps is None and speed is None:
            return self._framerate
        
        assert self._framerate is not None, &#34;Framerate conversion requires that the framerate is known for current keyframes.  This must be provided to the vipy.object.Track() constructor.&#34;
        assert fps is not None or speed is not None, &#34;Invalid input&#34;
        assert not (fps is not None and speed is not None), &#34;Invalid input&#34;
        assert speed is None or speed &gt; 0, &#34;Invalid speed, must specify speed multiplier s=1, s=2 for 2x faster, s=0.5 for half slower&#34;
        
        fps = float(fps) if fps is not None else (1.0/speed)*self._framerate
        self._keyframes = [int(np.round(f*(fps/float(self._framerate)))) for f in self._keyframes]
        self._framerate = fps
        return self
        
    def startframe(self):
        &#34;&#34;&#34;Return the startframe of the track or None if there are no keyframes.  
        
        The frame index is relative to the framerate set in the constructor.

        &#34;&#34;&#34;        
        return int(self._keyframes[0]) if len(self._keyframes)&gt;0 else None  # assumes sorted order

    def endframe(self):
        &#34;&#34;&#34;Return the endframe of the track or None if there are no keyframes.

        The frame index is relative to the framerate set in the constructor.
        &#34;&#34;&#34;
        return int(self._keyframes[-1]) if len(self._keyframes)&gt;0 else None  # assumes sorted order

    def duration(self):
        &#34;&#34;&#34;The length of the track in seconds.

        Returns:
            The duration in seconds of this track object
        &#34;&#34;&#34;
        assert self.framerate() is not None, &#34;Framerate must be set in constructor&#34;
        return len(self) / float(self.framerate())
    
    def linear_interpolation(self, f):
        &#34;&#34;&#34;Linear bounding box interpolation at frame=f given observed boxes (x,y,w,h) at keyframes.  

        This returns a `vipy.object.Detection` which is the interpolation of the `vipy.object.Track` at frame k

        - If self._boundary=&#39;extend&#39;, then boxes are repeated if the interpolation is outside the keyframes
        - If self._boundary=&#39;strict&#39;, then interpolation returns None if the interpolation is outside the keyframes
        
        .. note::  
            - The returned BoundingBox object is not cloned when possible for speed purposes, be careful when modifying this object.  clone() the returned object if necessary
            - This means that we return a reference to the underlying keybox upgraded with track properties and cast as `vipy.object.Detection`.  If you modify this object, then the track keybox will be modfied.
        &#34;&#34;&#34;
        assert len(self._keyboxes) &gt; 0, &#34;Degenerate object for interpolation&#34;   # not self.isempty()
        if len(self._keyboxes) == 1:
            return Detection.cast(self._keyboxes[0].clone()).new_category(self.category()).set_attribute(&#39;__trackid&#39;, self.id()) if (self._boundary == &#39;extend&#39; or self.during(f)) else None
        if f in self._keyframes:            
            return Detection.cast(self._keyboxes[self._keyframes.index(f)].clone()).new_category(self.category()).set_attribute(&#39;__trackid&#39;, self.id())  # clone requuired to not pollute attributes

        kf = self._keyframes
        ft = min(max(f, kf[0]), kf[-1])  # truncated frame index
        for i in reversed(range(0, len(kf)-1)):
            if kf[i] &lt;= ft and kf[i+1] &gt;= ft:
                break  # floor keyframe index
        c = (ft - kf[i]) / max(1, float(kf[i+1] - kf[i]))  # interpolation coefficient
        (bi, bj) = (self._keyboxes[i], self._keyboxes[i+1])
        d = Detection(xmin=bi._xmin + c*(bj._xmin - bi._xmin),   # float(np.interp(k, self._keyframes, [bb._xmin for bb in self._keyboxes])),
                      ymin=bi._ymin + c*(bj._ymin - bi._ymin),   # float(np.interp(k, self._keyframes, [bb._ymin for bb in self._keyboxes])),
                      xmax=bi._xmax + c*(bj._xmax - bi._xmax),   # float(np.interp(k, self._keyframes, [bb._xmax for bb in self._keyboxes])),
                      ymax=bi._ymax + c*(bj._ymax - bi._ymax),   # float(np.interp(k, self._keyframes, [bb._ymax for bb in self._keyboxes])),
                      confidence=bi.confidence() if isinstance(bi, Detection) else None,
                      attributes=bi.attributes.copy() if isinstance(bi, Detection) else None,  # unshared attributes (to allow for __trackid)
                      category=self.category())

        d.attributes[&#39;__trackid&#39;] = self.id()  # for correspondence of detections to tracks
        return d if self._boundary == &#39;extend&#39; or self.during(f) else None

    def category(self, label=None):
        &#34;&#34;&#34;Set the track category to label.  Updates all keyboxes&#34;&#34;&#34;
        if label is not None:
            self._label = label
            self.boxmap(lambda bb: bb.category(self._label) if isinstance(bb, Detection) else bb)
            return self
        else:
            return self._label
    
    def categoryif(self, ifcategory, tocategory=None):
        &#34;&#34;&#34;If the current category is equal to ifcategory, then change it to newcategory.

        Args:
            
            ifcategory [dict, str]: May be a dictionary {ifcategory:tocategory}, or just an ifcategory
            tocategory [str]:  the target category 

        Returns:
        
            this object with the category changed.

        .. note:: This is useful for converting synonyms such as self.categoryif(&#39;motorbike&#39;, &#39;motorcycle&#39;)
        &#34;&#34;&#34;
        assert (isinstance(ifcategory, dict) and tocategory is None) or tocategory is not None

        if isinstance(ifcategory, dict):
            for (k,v) in ifcategory.items():
                self.categoryif(k, v)
        elif self.category() == ifcategory:
            self.category(tocategory)
        return self

    def label(self, label):
        &#34;&#34;&#34;Alias for category&#34;&#34;&#34;
        return self.category(label)
        
    def during(self, k_start, k_end=None):
        &#34;&#34;&#34;Does the track contain a keyframe during the time interval (startframe, endframe) inclusive?&#34;&#34;&#34;        
        k_end = k_start+1 if k_end is None else k_end
        (startframe, endframe) = (self.startframe(), self.endframe())
        return len(self)&gt;0 and ((k_start &gt;= startframe and k_start &lt;= endframe) or (k_end &gt;= startframe and k_end &lt;= endframe) or (k_start &lt;= startframe and k_end &gt;= endframe))
        
    def during_interval(self, k_start, k_end):
        &#34;&#34;&#34;Does the track contain a keyframe during the inclusive frame interval (startframe, endframe)?

        .. note:: The start and end frames are inclusive
        &#34;&#34;&#34;
        return self.during(k_start, k_end)

    def within(self, starframe, endframe):
        &#34;&#34;&#34;Is the track within the frame range (startframe, endframe)?&#34;&#34;&#34;
        return self.startframe() &gt;= startframe and self.endframe() &lt;= endframe
    
    def offset(self, dt=0, dx=0, dy=0):
        &#34;&#34;&#34;Apply a temporal shift of dt frames, and a spatial shift of (dx, dy) pixels.
        
        Args:
            dt: [int] frame offset
            dx: [float] horizontal spatial offset 
            dy: [float] vertical spatial offset 

        Returns:
            This box updated in place
        &#34;&#34;&#34;
        dt = int(np.round(dt*self.framerate())) if isinstance(dt, float) else dt
        self._keyboxes = [bb.offset(dx, dy) for bb in self._keyboxes]
        self._keyframes = [(f+dt) for f in self._keyframes]
        return self

    def uncrop(self, bb, s=1):
        &#34;&#34;&#34;Apply a transformation to the track that will undo a crop of a bounding box with an optional scale factor.

        A typical operation is as follows.  A video is cropped and zommed in order to run a detector on a region of interest.  However, we want to align the resulting tracks on the original video before the crop and zoom.  

        Args:
            bb: [`vipy.geometry.BoundingBox`].  A bounding box which was used to crop this track
            s: [float]  A scale factor applied after the bounding box crop

        Returns:
            This track after undoing the scale and crop 
        &#34;&#34;&#34;
        assert isinstance(bb, BoundingBox)
        return self.rescale(1/s).offset(dt=0, dx=bb.xmin(), dy=bb.ymin())

    def frameoffset(self, dx, dy):
        &#34;&#34;&#34;Offset boxes by (dx,dy) in each frame.
        
        This is used to apply a different offset for each frame.  To apply one offset to all frames, use `vipy.object.Track.offset`.
        Args:
            dx: [list]  This should be a list of frame offsets at each keyframe the same length as the number of keyboxes
            dy: [list]  This should be a list of frame offsets at each keyframe the same length as the number of keyboxes

        Returns:
            This track updated in place
        &#34;&#34;&#34;
        assert isinstance(dx, list) or isinstance(dx, tuple)
        assert isinstance(dy, list) or isinstance(dy, tuple)
        assert len(self.keyboxes()) == len(dx) and len(self.keyboxes()) == len(dy)
        self._keyboxes = [bb.offset(dx=x, dy=y) for (bb, (x, y)) in zip(self._keyboxes, zip(dx, dy))]
        return self

    def truncate(self, start=None, end=None):
        &#34;&#34;&#34;Truncate a track so that any keyframes less than startframe or greater than endframe (inclusive) are removed.  Interpolate keyboxes at (startframe, endframe) endpoints.

        Args:
            start: [int|float] The start of the truncation relative to the track framerate.  All keyframes less than or equal to startframe are included.  If the keyframe does not exist at startframe, one is interpolated and added.
            end: [int|float] The end of the truncation relative to the track framerate.  All keyframes greater than or equal to the endframe are included.  If the keyfrmae does not exist at endframe, one is interpolated and added.

        Returns:
            This track such that all keyboxes &lt;= startframe or &gt;= endframe are removed.

        .. note::  The startframe and endframe for truncation are inclusive.  
        &#34;&#34;&#34;
        startframe = int(np.round(start*self.framerate())) if isinstance(start, float) else start
        endframe = int(np.round(end*self.framerate())) if isinstance(end, float) else end        
        
        if startframe is not None and startframe not in self._keyframes and self[startframe] is not None:
            self.add(startframe, self[startframe].clone())  # interpolated boundary condition
        if endframe is not None and endframe not in self._keyframes and self[endframe] is not None:
            self.add(endframe, self[endframe].clone())  # intepolated boundary condition
        kfkb = [(kf,kb) for (kf,kb) in zip(self._keyframes, self._keyboxes) if ((startframe is None or kf &gt;= startframe) and (endframe is None or kf &lt;= endframe))]
        (self._keyframes, self._keyboxes) = zip(*kfkb) if len(kfkb) &gt; 0 else ([], [])
        return self
        
    def rescale(self, s):
        &#34;&#34;&#34;Rescale track boxes by scale factor s&#34;&#34;&#34;
        if s != 1.0:
            self._keyboxes = [bb.rescale(s) for bb in self._keyboxes]
        return self

    def scale(self, s):
        &#34;&#34;&#34;Alias for rescale&#34;&#34;&#34;
        return self.rescale(s)

    def scale_x(self, sx):
        &#34;&#34;&#34;Rescale track boxes by scale factor sx&#34;&#34;&#34;
        self._keyboxes = [bb.scale_x(sx) for bb in self._keyboxes]
        return self

    def scale_y(self, sy):
        &#34;&#34;&#34;Rescale track boxes by scale factor sx&#34;&#34;&#34;
        self._keyboxes = [bb.scale_y(sy) for bb in self._keyboxes]
        return self

    def dilate(self, s):
        &#34;&#34;&#34;Dilate track boxes by scale factor s&#34;&#34;&#34;
        self._keyboxes = [bb.dilate(s) for bb in self._keyboxes]
        return self

    def maxsquare(self):
        &#34;&#34;&#34;Set all of the track boxes to maxsquare&#34;&#34;&#34;
        self._keyboxes = [bb.maxsquare() for bb in self._keyboxes]
        return self
    
    def rot90cw(self, H, W):
        &#34;&#34;&#34;Rotate an image with (H,W)=shape 90 degrees clockwise and update all boxes to be consistent&#34;&#34;&#34;
        self._keyboxes = [bb.rot90cw(H, W) for bb in self._keyboxes]
        return self

    def rot90ccw(self, H, W):
        &#34;&#34;&#34;Rotate an image with (H,W)=shape 90 degrees clockwise and update all boxes to be consistent&#34;&#34;&#34;
        self._keyboxes = [bb.rot90ccw(H, W) for bb in self._keyboxes]
        return self

    def fliplr(self, H, W):
        &#34;&#34;&#34;Flip an image left and right (mirror about vertical axis)&#34;&#34;&#34;
        self._keyboxes = [bb.fliplr(width=W) for bb in self._keyboxes]
        return self

    def flipud(self, H, W):
        &#34;&#34;&#34;Flip an image left and right (mirror about vertical axis)&#34;&#34;&#34;
        self._keyboxes = [bb.flipud(height=H) for bb in self._keyboxes]
        return self

    def id(self, newid=None):
        if newid is None:
            return self._id
        else:
            self._id = newid
            return self

    def clone(self, startframe=None, endframe=None, rekey=False):
        #return copy.deepcopy(self)  
        t = Track.from_json(self.json(encode=False)) if (startframe is None and endframe is None) else self.clone_during(startframe, endframe)  # 2x faster than deepcopy
        t.attributes = t.attributes.copy()
        if rekey:
            t.id(newid=shortuuid())
        return t
    
    def clone_during(self, startframe, endframe):
        &#34;&#34;&#34;Clone a track during a specific interval (startframe, endframe) relative to the framerate of the track.

        - This is useful for copying a small segment of a long track without the expense of copying the whole track.  
        - All keyframes and keyboxes not in (startframe, endframe) are not copied.
        - Boundary keyframes are copied to enable proper interpolation.        
        &#34;&#34;&#34;
        # Update (startframe,endframe) to be the keyframes just before startframe and the keyframe just after endframe so that interpolation will work correctly
        (startframe, endframe) = (([kf for kf in self._keyframes if kf &lt;= startframe][-1]) if self.during(startframe, startframe) else startframe,
                                  ([kf for kf in self._keyframes if kf &gt;= endframe][0]) if self.during(endframe, endframe) else endframe)
        kfkb = [(kf,kb.clone()) for (kf,kb) in zip(self._keyframes, self._keyboxes) if ((startframe is None or kf &gt;= startframe) and (endframe is None or kf &lt;= endframe))]
        (kf, kb) = zip(*kfkb) if len(kfkb) &gt; 0 else ([], [])        
        return Track(keyframes=kf, boxes=kb, category=self.category(), framerate=self._framerate, interpolation=self._interpolation, boundary=self._boundary, attributes=self.attributes.copy(), id=self._id)
    
    def boundingbox(self, startframe=None, endframe=None):
        &#34;&#34;&#34;The bounding box of a track is the smallest spatial box that contains all of the BoundingBoxes of the track  within startframe and endframe, or None if there are no detections.
        
        Args:
            startframe: [int] the startframe of the track to compute the bounding box.
            endframe: [int] the endframe of the track to compute the bounding box.
        
        Returns:
            `vipy.geometry.BoundingBox` which is the smallest box that contains all boxes of the track from (startframe, endframe)
        &#34;&#34;&#34;
        t = self.clone() if (startframe is None and endframe is None) else self.clone().truncate(startframe, endframe)
        d = t._keyboxes[0].clone() if len(t._keyboxes) &gt;= 1 else None
        return d.union([bb for (k,bb) in zip(t._keyframes[1:], t._keyboxes[1:]) if t.during(k)]) if (d is not None and len(t._keyboxes) &gt;= 2) else d

    def smallestbox(self):
        &#34;&#34;&#34;The smallest box of a track is the smallest spatial box in area along the track&#34;&#34;&#34;
        k = np.argmin([bb.area() for bb in self._keyboxes]) if len(self._keyboxes) &gt; 0 else None
        return self._keyboxes[k] if k is not None else None

    def biggestbox(self):
        &#34;&#34;&#34;The biggest box of a track is the largest spatial box in area along the track&#34;&#34;&#34;
        k = np.argmax([bb.area() for bb in self._keyboxes]) if len(self._keyboxes) &gt; 0 else None
        return self._keyboxes[k] if k is not None else None
        
    def pathlength(self):
        &#34;&#34;&#34;The path length of a track is the cumulative Euclidean distance in pixels that the box travels&#34;&#34;&#34;
        return float(np.sum([bb_next.dist(bb_prev) for (bb_next, bb_prev) in zip(self._keyboxes[1:], self._keyboxes[0:-1])])) if len(self._keyboxes)&gt;1 else 0.0
        
    def startbox(self):
        &#34;&#34;&#34;The startbox is the first bounding box in the track&#34;&#34;&#34;
        return self._keyboxes[0] if len(self._keyboxes) &gt; 0 else None

    def endbox(self):
        &#34;&#34;&#34;The endbox is the last box in the track&#34;&#34;&#34;
        return self._keyboxes[-1] if len(self._keyboxes) &gt; 0 else None

    def loop_closure_distance(self):
        &#34;&#34;&#34;The loop closure track distance is the Euclidean distance in pixels between the start frame bounding box and end frame bounding box&#34;&#34;&#34;
        return self.startbox().dist(self.endbox()) if not self.isdegenerate() else None

    def boundary(self, b=None):
        if b is None:
            return self._boundary
        else:
            assert b in [&#39;strict&#39;, &#39;extend&#39;]
            self._boundary = b
            return self
        
    def clip(self, start, end):
        &#34;&#34;&#34;Clip a track to be within (start,end) with strict boundary handling.  

        Start and end may be frame numbers (int) or seconds (float).  Frames are relative to the current frame rate.

        Args:
            start [int|float]:  The start of the clip in frames|seconds
            end [int|float|None]:  The end of the clip in frames|seconds (if provided)
        &#34;&#34;&#34;
        startframe = int(np.round(start*self.framerate())) if isinstance(start, float) else start
        endframe = int(np.round(end*self.framerate())) if isinstance(end, float) else start        
        
        if self[startframe] is not None:
            self.add(startframe, self[startframe])
        if self[endframe] is not None:
            self.add(endframe, self[endframe])
        keyframes = [f for (f,bb) in zip(self._keyframes, self._keyboxes) if f&gt;=startframe and f&lt;=endframe]  # may be empty
        keyboxes = [bb for (f,bb) in zip(self._keyframes, self._keyboxes) if f&gt;=startframe and f&lt;=endframe]  # may be empty
        if len(keyframes) == 0 or len(keyboxes) == 0:
            raise ValueError(&#39;Track does not contain any keyboxes within the requested frames (%d,%d)&#39; % (startframe, endframe))
        self._keyframes = keyframes
        self._keyboxes = keyboxes
        self._boundary = &#39;strict&#39;
        return self

    def iou(self, other, dt=1):
        &#34;&#34;&#34;Compute the spatial IoU between two tracks as the mean IoU per frame in the range (self.startframe(), self.endframe())&#34;&#34;&#34;
        return self.rankiou(other, rank=len(self), dt=dt)

    def segment_maxiou(self, other, startframe, endframe):
        &#34;&#34;&#34;Return the maximum framewise bounding box IOU between self and other in the range (startframe, endframe)&#34;&#34;&#34;
        assert isinstance(other, Track), &#34;invalid input - Must be vipy.object.Track()&#34;
        assert startframe &lt; endframe
        return max([self[k].iou(other[k]) if (self[k] is not None) else 0 for k in range(startframe, endframe)])
    
    def maxiou(self, other, dt=1):
        &#34;&#34;&#34;Compute the maximum spatial IoU between two tracks per frame in the range (self.startframe(), self.endframe())&#34;&#34;&#34;        
        return self.rankiou(other, rank=1, dt=dt)

    def fragmentiou(self, other, dt=5):
        &#34;&#34;&#34;A fragment is a track that is fully contained within self&#34;&#34;&#34;
        assert isinstance(other, Track), &#34;invalid input - Must be vipy.object.Track()&#34;        
        startframe = max(self.startframe(), other.startframe())
        endframe = min(self.endframe(), other.endframe())
        return float(np.min([self[min(k,endframe)].iou(other[min(k,endframe)]) for k in range(startframe, endframe, dt)])) if (other.startframe() &gt;= self.startframe() and other.endframe() &lt;= self.endframe() and endframe &gt; startframe) else 0
        
    def endpointiou(self, other):
        &#34;&#34;&#34;Compute the mean spatial IoU between two tracks at the two overlapping endpoints.  useful for track continuation&#34;&#34;&#34;        
        assert isinstance(other, Track), &#34;invalid input - Must be vipy.object.Track()&#34;
        startframe = max(self.startframe(), other.startframe())
        endframe = min(self.endframe(), other.endframe())
        return float(np.mean([self[startframe].iou(other[startframe]), self[endframe].iou(other[endframe])]) if endframe &gt; startframe else 0.0)

    def segmentiou(self, other, dt=5):
        &#34;&#34;&#34;Compute the mean spatial IoU between two tracks at the overlapping segment, sampling by dt.  Useful for track continuation for densely overlapping tracks&#34;&#34;&#34;
        assert isinstance(other, Track), &#34;invalid input - Must be vipy.object.Track()&#34;
        startframe = max(self.startframe(), other.startframe())
        endframe = min(self.endframe(), other.endframe())   # inclusive
        return float(np.mean([self[min(k,endframe)].iou(other[min(k,endframe)]) for k in range(startframe, endframe, dt)]) if endframe &gt; startframe else 0.0)

    def segmentcover(self, other, dt=5):
        &#34;&#34;&#34;Compute the mean spatial cover between two tracks at the overlapping segment, sampling by dt.  Useful for track continuation for densely overlapping tracks&#34;&#34;&#34;
        assert isinstance(other, Track), &#34;invalid input - Must be vipy.object.Track()&#34;
        startframe = max(self.startframe(), other.startframe())
        endframe = min(self.endframe(), other.endframe())   # inclusive
        return float(np.mean([self[min(k,endframe)].maxcover(other[min(k,endframe)]) for k in range(startframe, endframe, dt)]) if endframe &gt; startframe else 0.0)
        
    def rankiou(self, other, rank, dt=1):
        &#34;&#34;&#34;Compute the mean spatial IoU between two tracks per frame in the range (self.startframe(), self.endframe()) using only the top-k (rank) frame overlaps
           Sample tracks at endpoints and n uniformly spaced frames or a stride of dt frames.  
        
           - rank [&gt;1]:  The top-k best IOU overlaps to average when computing the rank IOU
           - This is useful for track continuation where the box deforms in the overlapping segment at the end due to occlusion. 
           - This is useful for track correspondence where a ground truth box does not match an estimated box precisely (e.g. loose box, non-visually grounded box)
           - This is the robust version of segmentiou.
           - Use percentileiou to determine the rank based a fraction of the length of the overlap, which will be more efficient for long tracks
        &#34;&#34;&#34;
        assert rank &gt;= 1 and rank &lt;= len(self)
        assert isinstance(other, Track), &#34;Invalid input - must be vipy.object.Track()&#34;
        assert dt &gt;= 1
        frames = [self.startframe()] + list(range(self.startframe()+dt, self.endframe(), dt)) + [self.endframe()]
        return float(np.mean(sorted([self[k].iou(other[k]) if (self.during(k) and other.during(k)) else 0.0 for k in frames])[-rank:]))

    def percentileiou(self, other, percentile, samples=100):
        &#34;&#34;&#34;Percentile iou returns rankiou for rank=percentile*len(overlap(self, other))
        
           -other [Track]
           -percentile [0,1]:  The top-k best overlaps to average when computing rankiou
           -samples:  The number of uniformly spaced samples to take along the track for computing the rankiou
        &#34;&#34;&#34;
        assert percentile &gt; 0 and percentile &lt;= 1
        assert isinstance(other, Track), &#34;invalid input - Must be vipy.object.Track()&#34;
        assert self.framerate() == other.framerate()
        
        startframe = max(self.startframe(), other.startframe())
        endframe = min(self.endframe(), other.endframe())
        segmentlen = endframe - startframe
        dt = max(1, int(np.floor(segmentlen/samples)))
        return self.rankiou(other, max(1, int(segmentlen*percentile)), dt=dt) if segmentlen &gt; 0 else 0

    def segment_percentileiou(self, other, percentile, samples=100):
        &#34;&#34;&#34;percentiliou on the overlapping segment with other&#34;&#34;&#34;
        assert percentile &gt; 0 and percentile &lt;= 1
        assert isinstance(other, Track), &#34;invalid input - Must be vipy.object.Track()&#34;
        assert self.framerate() == other.framerate()
        
        startframe = max(self.startframe(), other.startframe())
        endframe = min(self.endframe(), other.endframe())
        segmentlen = endframe - startframe
        rank = int(segmentlen*percentile)
        dt = max(1, int(np.floor(segmentlen/samples)))
        iou = sorted([self[min(k,endframe)].iou(other[min(k,endframe)]) for k in range(startframe, endframe, dt)]) if endframe &gt; startframe else []
        return float(np.mean(iou[-rank:]) if endframe &gt; startframe else 0.0)


    def segment_percentilecover(self, other, percentile, samples=100):
        &#34;&#34;&#34;percentile cover on the overlapping segment with other&#34;&#34;&#34;
        assert percentile &gt; 0 and percentile &lt;= 1
        assert isinstance(other, Track), &#34;invalid input - Must be vipy.object.Track()&#34;
        assert self.framerate() == other.framerate()
        
        startframe = max(self.startframe(), other.startframe())
        endframe = min(self.endframe(), other.endframe())
        segmentlen = endframe - startframe
        rank = int(segmentlen*percentile)
        dt = max(1, int(np.floor(segmentlen/samples)))
        bblist = [(self[min(k,endframe)], other[min(k,endframe)]) for k in range(startframe, endframe, dt)] if endframe &gt; startframe else []
        cover = [max(bbself.cover(bbother), bbother.cover(bbself)) for (bbself, bbother) in bblist]
        return float(np.mean(cover[-rank:]) if endframe &gt; startframe else 0.0)

    def union(self, other, overlap=&#39;average&#39;):
        &#34;&#34;&#34;Compute the union of two tracks.  Overlapping boxes between self and other:
        
           Inputs
             - average [bool]:  average framewise interpolated boxes at overlapping keyframes
             - replace [bool]:  replace the box with other if other and self overlap at a keyframe
             - keep [bool]:  keep the box from self (discard other) at a keyframe
        &#34;&#34;&#34;
        assert isinstance(other, Track), &#34;Invalid input - must be vipy.object.Track()&#34;
        assert other.category() == self.category(), &#34;Category mismatch&#34;
        assert overlap in [&#39;average&#39;, &#39;replace&#39;, &#39;keep&#39;], &#34;Invalid input - &#39;overlap&#39; must be in [average, replace, keep]&#34;
        T = self.clone()
        keyframes = sorted(set(T._keyframes+other._keyframes))
        T._keyboxes = [((self[k].average(other[k]) if (overlap == &#39;average&#39;) else (self[k] if (overlap == &#39;keep&#39;) else other[k]))
                        if (self.during(k) and other.during(k)) else 
                        (self[k] if (self.during(k) and not other.during(k)) else (other[k])))
                       for k in keyframes] 
        T._keyframes = keyframes
        return T  


    def average(self, other):
        &#34;&#34;&#34;Compute the average of two tracks by the framewise interpolated boxes at the keyframes of this track&#34;&#34;&#34;
        assert isinstance(other, Track), &#34;Invalid input - must be vipy.object.Track()&#34;
        assert other.category() == self.category(), &#34;Category mismatch&#34;
        T = self.clone()
        T._keyboxes = [(self[k].average(other[k]) 
                        if (self.during(k) and other.during(k)) else (self[k] if (self.during(k) and not other.during(k)) else (other[k])))
                       for k in T._keyframes]  
        return T  

    def temporal_distance(self, other):
        &#34;&#34;&#34;The temporal distance between two tracks is the minimum number of frames separating them&#34;&#34;&#34;
        assert isinstance(other, Track), &#34;Invalid input - must be vipy.object.Track()&#34;
        return max(max(self.startframe() - other.endframe(), other.startframe() - self.endframe()), 0)

    def smooth(self, width):
        &#34;&#34;&#34;Track smoothing by averaging neighboring keyboxes&#34;&#34;&#34;
        assert isinstance(width, int) and width &gt; 0
        if len(self._keyboxes) &gt; width:
            self._keyboxes = [bb.clone().average(bbnbrs) for (bb, bbnbrs) in zip(self._keyboxes, chunklistwithoverlap(self._keyboxes, width, width-1))] 
        return self

    def smoothshape(self, width):
        &#34;&#34;&#34;Track smoothing by averaging width and height of neighboring keyboxes&#34;&#34;&#34;
        assert isinstance(width, int) and width &gt; 0
        if len(self._keyboxes) &gt; width:
            self._keyboxes = [bb.clone().averageshape(bbnbrs) for (bb, bbnbrs) in zip(self._keyboxes, chunklistwithoverlap(self._keyboxes, width, width-1))]
        return self

    def medianshape(self, width):
        &#34;&#34;&#34;Track smoothing by median width and height of neighboring keyboxes&#34;&#34;&#34;
        assert isinstance(width, int) and width &gt; 0
        if len(self._keyboxes) &gt; width:
            self._keyboxes = [bb.clone().medianshape(bbnbrs) for (bb, bbnbrs) in zip(self._keyboxes, chunklistwithoverlap(self._keyboxes, width, width-1))]
        return self

    def spline(self, smoothingfactor=None, strict=True, startframe=None, endframe=None):
        &#34;&#34;&#34;Track smoothing by cubic spline fit, will return resampled dt=1 track.  Smoothing factor will increase with smoothing &gt; 1 and decrease with 0 &lt; smoothing &lt; 1
        
           This function requires optional package scipy
        &#34;&#34;&#34;
        try_import(&#39;scipy&#39;, &#39;scipy&#39;);  import scipy.interpolate;
        assert smoothingfactor is None or smoothingfactor &gt; 0
        t = self.clone().resample(dt=1)
        (startframe, endframe) = (self.startframe() if startframe is None else startframe, self.endframe() if endframe is None else endframe)
        try:
            assert len(t._keyframes) &gt; 4, &#34;Invalid length for spline interpolation&#34;        
            s = smoothingfactor * len(self._keyframes) if smoothingfactor is not None else None
            (xmin, ymin, xmax, ymax) = zip(*[bb.to_ulbr() for bb in t._keyboxes])
            f_xmin = scipy.interpolate.UnivariateSpline(t._keyframes, xmin, check_finite=False, s=s)
            f_ymin = scipy.interpolate.UnivariateSpline(t._keyframes, ymin, check_finite=False, s=s)
            f_xmax = scipy.interpolate.UnivariateSpline(t._keyframes, xmax, check_finite=False, s=s)
            f_ymax = scipy.interpolate.UnivariateSpline(t._keyframes, ymax, check_finite=False, s=s)
            (self._keyframes, self._keyboxes) = zip(*[(k, BoundingBox(xmin=float(f_xmin(k)), ymin=float(f_ymin(k)), xmax=float(f_xmax(k)), ymax=float(f_ymax(k)))) for k in range(startframe, endframe)])
        except Exception as e:
            if not strict:
                log.warning(&#39;[vipy.object.track]: spline smoothing failed with error &#34;%s&#34; - Returning unsmoothed track&#39; % (str(e)))
                return self
            else:
                raise
        return self

    def linear_extrapolation(self, k, shape=False, dt=30):
        &#34;&#34;&#34;Track extrapolation by linear fit.
        
           * Requires at least 2 keyboxes.
           * Returned boxes may be degenerate.
           * shape=True then both the position and shape (width, height) of the box is extrapolated
        &#34;&#34;&#34;
        if self.during(k):
            return self[k]
        elif len(self._keyboxes) == 1:
            return self.nearest_keybox(k)
        else:
            n = self.endframe() if k &gt; self.endframe() else self.startframe()+1
            d = self.endbox().clone() if k &gt; self.endframe() else self.startbox().clone()
            (vx, vy) = self.shape_invariant_velocity(n, dt=dt) if not shape else self.velocity(n, dt=dt)
            (vw, vh) = (self.velocity_w(n, dt=dt), self.velocity_h(n, dt=dt)) if shape else (0,0)
            d = d.translate((k-n)*vx, (k-n)*vy)
            return d if not shape else d.top( ((k-n)*vh)/2.0).bottom( ((k-n)*vh)/2.0).left( ((k-n)*vw)/2.0).right( ((k-n)*vw)/2.0)
            
    def imclip(self, width, height):
        &#34;&#34;&#34;Clip the track to the image rectangle (width, height).  If a keybox is outside the image rectangle, remove it otherwise clip to the image rectangle. 
           This operation can change the length of the track and the size of the keyboxes.  The result may be an empty track if the track is completely outside
           the image rectangle, which results in an exception.
        &#34;&#34;&#34;
        clipped = [(f, bb.imclip(width=width, height=height)) for (f,bb) in zip(self._keyframes, self._keyboxes) if bb.hasoverlap(width=width, height=height)]
        if len(clipped) &gt; 0:
            (self._keyframes, self._keyboxes) = zip(*clipped)
            (self._keyframes, self._keyboxes) = (list(self._keyframes), list(self._keyboxes))
            return self
        else:
            raise ValueError(&#39;All key boxes for track outside image rectangle&#39;)

    def resample(self, dt):
        &#34;&#34;&#34;Resample the track using a stride of dt frames.  This reduces the density of keyframes by interpolating new keyframes as a uniform stride of dt.  This is useful for track compression&#34;&#34;&#34;
        assert dt &gt;= 1 and dt &lt; len(self)
        frames =  list(range(self.startframe(), self.endframe(), dt)) + [self.endframe()]
        (self._keyboxes, self._keyframes) = zip(*[(self[k], k) for k in frames])
        (self._keyboxes, self._keyframes) = (list(self._keyboxes), list(self._keyframes))
        return self

    def significant_digits(self, n):
        &#34;&#34;&#34;Round the coordinates of all boxes so that they have n significant digits for efficient serialization&#34;&#34;&#34;
        self._keyboxes = [bb.significant_digits(n) for bb in self._keyboxes]
        return self

    def bearing(self, f, dt=30, minspeed=1):
        &#34;&#34;&#34;The bearing of a track at frame f is the angle of the velocity vector relative to the (x,y) image coordinate frame, in radians [-pi, pi]&#34;&#34;&#34;
        v = self.shape_invariant_velocity(f, dt)
        return float(np.arctan2(v[1], v[0])) if self.speed(f, dt) &gt; minspeed else None  # atan2(y,x)

    def bearing_change(self, f1=None, f2=None, dt=30, minspeed=1, samples=None):
        &#34;&#34;&#34;The bearing change of a track from frame f1 (or start) and frame f2 (or end) is the relative angle of the velocity vectors in radians [-pi,pi].
        
        Args:
            f1: [int] the start frame for computing the bearing change.  If None, then use self.startframe()
            f2: [int] the end frame for computing the bearing change.  if None, then use self.endframe()
            dt: [int] The number of frames between computations of the velocity vector for bearing
            minspeed: [float] The minimum speed in frames per second used to threshold bearing computations if there is no motion
            samples: [int] The number of samples to average for computing the bearing change
        
        Returns:
            The floating point bearing change in radians in [-pi, pi] from (f1,f2) where bearing is computed at samples=n points, and each bearing is computed with a velocity stride of dt frames.

        &#34;&#34;&#34;
        dt = min(dt, len(self))
        (sf, ef) = (f1 if f1 is not None else self.startframe(), f2 if f2 is not None else self.endframe())
        df = 1 if samples is None else int(np.floor((ef-sf)/samples))
        B = [self.bearing(k, dt=dt, minspeed=minspeed) for k in range(sf, ef+df, df) if k&gt;=sf and k&lt;=ef]
        B = [b for b in B if b is not None]  # valid bearing estimates only
        dr = np.sum(np.diff(B)) if len(B) &gt; 0 else 0  # cumulative bearing angle change 
        return float(dr if np.abs(dr)&lt;=np.pi else ((2*np.pi - dr) if (dr &gt; np.pi) else (2*np.pi + dr)))

    def acceleration(self, f, dt=30):
        &#34;&#34;&#34;Return the (x,y) track acceleration magnitude at frame f computed using central finite differences of velocity.
        
        Returns:
            acceleration in (pixels / seconds^2) using velocity computed at (f-2*dt, f-dt), (f+dt, f+2*dt)
        &#34;&#34;&#34;
        (u, v) = (self.shape_invariant_velocity(f-dt, dt), self.shape_invariant_velocity(f+2*dt, dt))  # ((f-2*dt, (f-dt)), (f+dt, f+2*dt))
        (ax, ay) = ((v[0] - u[0])/float(2*dt), (v[1] - u[1])/float(2*dt))
        return float(np.sqrt(ax**2 + ay**2))  # acceleration magnitude in pixels    
        
    def velocity(self, f, dt=30):
        &#34;&#34;&#34;Return the (x,y) track velocity at frame f in units of pixels per frame computed by mean finite difference of the box centroid&#34;&#34;&#34;
        return (self.velocity_x(f, dt), self.velocity_y(f, dt))

    def speed(self, f, dt=30):
        (u,v) = self.shape_invariant_velocity(f, dt)
        return float(np.sqrt(u**2 + v**2))
    
    def boxmap(self, f):
        &#34;&#34;&#34;Apply the lambda function to each keybox&#34;&#34;&#34;
        assert callable(f)
        self._keyboxes = [f(bb) for bb in self._keyboxes]        
        return self

    def shape_invariant_velocity(self, f, dt=30):
        &#34;&#34;&#34;Return the (x,y) track velocity at frame f in units of pixels per frame computed by minimum mean finite differences of any box corner independent of changes in shape, over a finite time window of [f-dt, f]&#34;&#34;&#34;
        assert f &gt;= 0 and dt &gt; 0
        if len(self) &lt; 2 or not (self.during(f) and self.during(f-dt)) :
            return (0,0)
        
        kb = [((f-dt), self.linear_interpolation(f-dt))] + [(kf, bb) for (kf,bb) in zip(self._keyframes, self._keyboxes) if (kf &gt; f-dt) and (kf &lt; f)]
        (kfe, bbe) = (f, self.linear_interpolation(f))
        vx = float((1.0/len(kb))*sum([min([(bbe._xmin - bb._xmin), (bbe._xmax - bb._xmax)], key=abs)/float(kfe-kf) for (kf,bb) in kb]))
        vy = float((1.0/len(kb))*sum([min([(bbe._ymin - bb._ymin), (bbe._ymax - bb._ymax)], key=abs)/float(kfe-kf) for (kf,bb) in kb]))
        return (vx, vy)

    def velocity_x(self, f, dt=30):
        &#34;&#34;&#34;Return the left/right velocity at frame f in units of pixels per frame computed by mean finite difference over a fixed time window (dt, frames) of the box centroid&#34;&#34;&#34;
        assert f &gt;= 0 and dt &gt; 0
        return float(np.mean([(self[f].centroid_x() - self[f-k].centroid_x())/float(k) for k in range(1,dt) if self.during(f-k)])) if (self.during(f-1) and self.during(f)) else 0

    def velocity_y(self, f, dt=30):
        &#34;&#34;&#34;Return the up/down velocity at frame f in units of pixels per frame computed by mean finite difference over a fixed time window (dt, frames) of the box centroid&#34;&#34;&#34;
        assert f &gt;= 0 and dt &gt; 0
        return float(np.mean([(self[f].centroid_y() - self[f-k].centroid_y())/float(k) for k in range(1,dt) if self.during(f-k)])) if (self.during(f-1) and self.during(f)) else 0

    def velocity_w(self, f, dt=30):
        &#34;&#34;&#34;Return the width velocity at frame f in units of pixels per frame computed by finite difference&#34;&#34;&#34;
        assert f &gt;= 0 and dt &gt; 0 and self.during(f)
        return float(np.mean([(self[f].width() - self[f-k].width())/float(k) for k in range(1,dt) if self.during(f-k)])) if self.during(f-1) else 0

    def velocity_h(self, f, dt=30):
        &#34;&#34;&#34;Return the height velocity at frame f in units of pixels per frame computed by finite difference&#34;&#34;&#34;
        assert f &gt;= 0 and dt &gt; 0 and self.during(f)
        return float(np.mean([(self[f].height() - self[f-k].height())/float(k) for k in range(1,dt) if self.during(f-k)])) if self.during(f-1) else 0
    
    def nearest_keyframe(self, f):
        &#34;&#34;&#34;Nearest keyframe to frame f&#34;&#34;&#34;
        assert len(self._keyframes) &gt; 0
        return self._keyframes[int(np.abs(np.array(self._keyframes) - f).argmin())]

    def nearest_keybox(self, f):
        &#34;&#34;&#34;Nearest keybox to frame f&#34;&#34;&#34;
        assert len(self._keyframes) &gt; 0
        return self._keyboxes[int(np.abs(np.array(self._keyframes) - f).argmin())]  # by-reference
    
    def ismoving(self, startframe=None, endframe=None, mincover=0.9):
        &#34;&#34;&#34;Is the track moving in the frame range (startframe,endframe)?&#34;&#34;&#34;
        (bbs, bbe) = (self[max(self.startframe(), startframe)] if startframe is not None else self.startbox(), self[min(self.endframe(), endframe)] if endframe is not None else self.endbox())
        return (bbs.maxcover(bbe) &lt; mincover) if (bbs is not None and bbe is not None) else False

    
def non_maximum_suppression(detlist, conf, iou, bycategory=False, cover=None, gridsize=(6,9)):
    &#34;&#34;&#34;Compute greedy non-maximum suppression of a list of vipy.object.Detection() based on spatial IOU threshold (iou) and cover threhsold (cover) sorted by confidence (conf).

    Args:
        detlist: [list `vipy.object.Detection`]
        conf: [float] minimum confidence for non-maximum suppression
        iou: [float] minimum iou for non-maximum suporession
        bycategory: [bool] NMS only within the same category 
        cover: [float, None] A minimum cover for NMS (stricter than iou)
        gridsize: [tuple, (rows, cols)] An optional grid for fast intersection lookups 

    Returns:
        List of `vipy.object.Detection` non-maximum suppressed, sorted by increasing confidence 

    &#34;&#34;&#34;
    assert all([isinstance(d, Detection) for d in detlist])
    assert all([d.confidence() is not None for d in detlist])
    assert conf&gt;=0 and iou&gt;=0 and iou&lt;=1
    assert cover is None or (cover&gt;=0 and cover&lt;=1)
    assert isinstance(gridsize, tuple) and len(gridsize) == 2
        
    suppressed = set([])
    detlist = [d for d in detlist if d.confidence() &gt; conf and not d.isdegenerate()]  # valid
    detlist.sort(key=lambda d: d.confidence(), reverse=True)  # biggest to smallest, in-place
    grid = detlist[0].clone().union(detlist).grid(gridsize[0], gridsize[1]) if len(detlist) &gt; 0 else []
    bbidx = [set([k for (k,bbg) in enumerate(grid) if (((bbg._xmax if bbg._xmax &lt; bb._xmax else bb._xmax) - (bbg._xmin if bbg._xmin &gt; bb._xmin else bb._xmin)) &gt; 0 and
                                                       ((bbg._ymax if bbg._ymax &lt; bb._ymax else bb._ymax) - (bbg._ymin if bbg._ymin &gt; bb._ymin else bb._ymin)) &gt; 0)])
             for bb in detlist]  # spatial index, without the function call overhead of bbg.hasintersection(bb)
    #bbidx = [set([k for (k,bbg) in enumerate(grid) if bbg.hasintersection(bb)]) for bb in detlist]  # spatial index, equivalent to above but slower
    
    area = [bb.area() for bb in detlist]
    for (i, di) in enumerate(detlist):
        if i in suppressed:
            continue
        for (j, dj) in enumerate(islice(detlist, i+1, None), start=i+1):  # no-copy, equivalent to detlist[i+1:]
            if ((j not in suppressed) and
                (bycategory is False or di.category() == dj.category()) and
                (not bbidx[i].isdisjoint(bbidx[j])) and
                ((cover is not None and di.hasintersection(dj, maxcover=cover, area=area[i], otherarea=area[j])) or di.hasintersection(dj, iou=iou, area=area[i], otherarea=area[j]))):  
                suppressed.add(j)
    detlist_nms = [d for (j,d) in enumerate(detlist) if j not in suppressed]  # filter
    detlist_nms.sort(key=lambda x: x.confidence())  # smallest to biggest confidence for display layering, in-place
    return detlist_nms


def greedy_assignment(srclist, dstlist, miniou=0.0, bycategory=False):
    &#34;&#34;&#34;Compute a greedy one-to-one assignment of each vipy.object.Detection() in srclist to a unique element in dstlist with the largest IoU greater than miniou, else None
    
    Args:
        srclist: [list, `vipy.object.Detection`]
        dstlist: [list, `vipy.object.Detection`]
        miniou: [float, &gt;=0, &lt;=1] The minimum IoU for gated assignment
        bycategory: [bool]  If true, only assign di and dj if di.category() == dj.category()

    Returns:
        assignlist: [list, int]  same length as srclist, where j=assignlist[i] is the index of the assignment such that srclist[i] -&gt; dstlist[j]
    &#34;&#34;&#34;
    assert all([isinstance(d, Detection) for d in srclist])
    assert all([isinstance(d, Detection) for d in dstlist])    
    assert miniou &gt;= 0 and miniou &lt;= 1.0
    
    assigndict = {}
    for (k, ds) in sorted(enumerate(srclist), key=lambda x: x[1].area(), reverse=True):
        iou = [ds.iou(d) if (j not in assigndict.values() and (bycategory is False or ds.category() == d.category())) else 0.0 for (j,d) in enumerate(dstlist)]
        assigndict[k] = np.argmax(iou) if len(iou) &gt; 0 and max(iou) &gt; miniou else None
    return [assigndict[k] for k in range(0, len(srclist))]


def greedy_track_assignment(srclist, dstlist, miniou, bycategory=True, pct=0.5):
    &#34;&#34;&#34;Compute a greedy one-to-ine assignment of each `vipy.object.Track` in srclist to a unique element in dstlist with the largest assignment score.

    - Assignment score: `vipy.object.Track.segment_percentileiou` * `vipy.object.Track.confidence`, if maxiou() &gt; miniou else 0
    - Assigment order: longest to shortest src track

    Args:
        srclist: [list, `vipy.object.Track`]
        dstlist: [list, `vipy.object.Track`]
        miniou: [float, &gt;=0, &lt;=1] The minimum IoU for gated assignment
        bycategory: [bool]  If true, only assign di and dj if di.category() == dj.category()
        pct: [float &lt;=1] The percentile for percentileiou

    Returns:
        assignlist: [list, int]  same length as srclist, where j=assignlist[i] is the index of the assignment such that srclist[i] -&gt; dstlist[j]
    &#34;&#34;&#34;

    assert all([isinstance(d, Track) for d in srclist])
    assert all([isinstance(d, Track) for d in dstlist])    
    assert miniou &gt;= 0 and miniou &lt;= 1.0
    
    assigndict = {}
    for (k, ts) in sorted(enumerate(srclist), key=lambda x: len(x[1]), reverse=True):
        assignscore = [ts.segment_percentileiou(t, pct) * t.confidence() if (j not in assigndict.values() and (bycategory is False or ts.category() == t.category()) and (miniou == 0 or ts.maxiou(t) &gt; miniou)) else 0.0 for (j,t) in enumerate(dstlist)]
        assigndict[k] = np.argmax(assignscore) if len(assignscore) &gt; 0 and max(assignscore) &gt; 0 else None
    return [assigndict[k] for k in range(0, len(srclist))]
    
    
def RandomDetection(W=640, H=480):
    &#34;&#34;&#34;Return a random `vipy.object.Detection` in the range (0 &lt; xmin &lt; W, 0 &lt; ymin &lt; H, height &lt; 100, width &lt; 100).  Useful for unit testing.&#34;&#34;&#34;
    return Detection(xmin=np.random.rand()*W, ymin=np.random.rand()*H, width=np.random.rand()*100, height=np.random.rand()*100, category=str(np.random.rand()), confidence=np.random.rand())</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="vipy.object.RandomDetection"><code class="name flex">
<span>def <span class="ident">RandomDetection</span></span>(<span>W=640, H=480)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a random <code><a title="vipy.object.Detection" href="#vipy.object.Detection">Detection</a></code> in the range (0 &lt; xmin &lt; W, 0 &lt; ymin &lt; H, height &lt; 100, width &lt; 100).
Useful for unit testing.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L1279-L1281" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def RandomDetection(W=640, H=480):
    &#34;&#34;&#34;Return a random `vipy.object.Detection` in the range (0 &lt; xmin &lt; W, 0 &lt; ymin &lt; H, height &lt; 100, width &lt; 100).  Useful for unit testing.&#34;&#34;&#34;
    return Detection(xmin=np.random.rand()*W, ymin=np.random.rand()*H, width=np.random.rand()*100, height=np.random.rand()*100, category=str(np.random.rand()), confidence=np.random.rand())</code></pre>
</details>
</dd>
<dt id="vipy.object.greedy_assignment"><code class="name flex">
<span>def <span class="ident">greedy_assignment</span></span>(<span>srclist, dstlist, miniou=0.0, bycategory=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute a greedy one-to-one assignment of each vipy.object.Detection() in srclist to a unique element in dstlist with the largest IoU greater than miniou, else None</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>srclist</code></strong></dt>
<dd>[list, <code>vipy.object.Detection</code>]</dd>
<dt><strong><code>dstlist</code></strong></dt>
<dd>[list, <code>vipy.object.Detection</code>]</dd>
<dt><strong><code>miniou</code></strong></dt>
<dd>[float, &gt;=0, &lt;=1] The minimum IoU for gated assignment</dd>
<dt><strong><code>bycategory</code></strong></dt>
<dd>[bool]
If true, only assign di and dj if di.category() == dj.category()</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>assignlist</code></dt>
<dd>[list, int]
same length as srclist, where j=assignlist[i] is the index of the assignment such that srclist[i] -&gt; dstlist[j]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L1228-L1248" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def greedy_assignment(srclist, dstlist, miniou=0.0, bycategory=False):
    &#34;&#34;&#34;Compute a greedy one-to-one assignment of each vipy.object.Detection() in srclist to a unique element in dstlist with the largest IoU greater than miniou, else None
    
    Args:
        srclist: [list, `vipy.object.Detection`]
        dstlist: [list, `vipy.object.Detection`]
        miniou: [float, &gt;=0, &lt;=1] The minimum IoU for gated assignment
        bycategory: [bool]  If true, only assign di and dj if di.category() == dj.category()

    Returns:
        assignlist: [list, int]  same length as srclist, where j=assignlist[i] is the index of the assignment such that srclist[i] -&gt; dstlist[j]
    &#34;&#34;&#34;
    assert all([isinstance(d, Detection) for d in srclist])
    assert all([isinstance(d, Detection) for d in dstlist])    
    assert miniou &gt;= 0 and miniou &lt;= 1.0
    
    assigndict = {}
    for (k, ds) in sorted(enumerate(srclist), key=lambda x: x[1].area(), reverse=True):
        iou = [ds.iou(d) if (j not in assigndict.values() and (bycategory is False or ds.category() == d.category())) else 0.0 for (j,d) in enumerate(dstlist)]
        assigndict[k] = np.argmax(iou) if len(iou) &gt; 0 and max(iou) &gt; miniou else None
    return [assigndict[k] for k in range(0, len(srclist))]</code></pre>
</details>
</dd>
<dt id="vipy.object.greedy_track_assignment"><code class="name flex">
<span>def <span class="ident">greedy_track_assignment</span></span>(<span>srclist, dstlist, miniou, bycategory=True, pct=0.5)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute a greedy one-to-ine assignment of each <code><a title="vipy.object.Track" href="#vipy.object.Track">Track</a></code> in srclist to a unique element in dstlist with the largest assignment score.</p>
<ul>
<li>Assignment score: <code><a title="vipy.object.Track.segment_percentileiou" href="#vipy.object.Track.segment_percentileiou">Track.segment_percentileiou()</a></code> * <code><a title="vipy.object.Track.confidence" href="#vipy.object.Track.confidence">Track.confidence()</a></code>, if maxiou() &gt; miniou else 0</li>
<li>Assigment order: longest to shortest src track</li>
</ul>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>srclist</code></strong></dt>
<dd>[list, <code>vipy.object.Track</code>]</dd>
<dt><strong><code>dstlist</code></strong></dt>
<dd>[list, <code>vipy.object.Track</code>]</dd>
<dt><strong><code>miniou</code></strong></dt>
<dd>[float, &gt;=0, &lt;=1] The minimum IoU for gated assignment</dd>
<dt><strong><code>bycategory</code></strong></dt>
<dd>[bool]
If true, only assign di and dj if di.category() == dj.category()</dd>
<dt><strong><code>pct</code></strong></dt>
<dd>[float &lt;=1] The percentile for percentileiou</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>assignlist</code></dt>
<dd>[list, int]
same length as srclist, where j=assignlist[i] is the index of the assignment such that srclist[i] -&gt; dstlist[j]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L1251-L1276" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def greedy_track_assignment(srclist, dstlist, miniou, bycategory=True, pct=0.5):
    &#34;&#34;&#34;Compute a greedy one-to-ine assignment of each `vipy.object.Track` in srclist to a unique element in dstlist with the largest assignment score.

    - Assignment score: `vipy.object.Track.segment_percentileiou` * `vipy.object.Track.confidence`, if maxiou() &gt; miniou else 0
    - Assigment order: longest to shortest src track

    Args:
        srclist: [list, `vipy.object.Track`]
        dstlist: [list, `vipy.object.Track`]
        miniou: [float, &gt;=0, &lt;=1] The minimum IoU for gated assignment
        bycategory: [bool]  If true, only assign di and dj if di.category() == dj.category()
        pct: [float &lt;=1] The percentile for percentileiou

    Returns:
        assignlist: [list, int]  same length as srclist, where j=assignlist[i] is the index of the assignment such that srclist[i] -&gt; dstlist[j]
    &#34;&#34;&#34;

    assert all([isinstance(d, Track) for d in srclist])
    assert all([isinstance(d, Track) for d in dstlist])    
    assert miniou &gt;= 0 and miniou &lt;= 1.0
    
    assigndict = {}
    for (k, ts) in sorted(enumerate(srclist), key=lambda x: len(x[1]), reverse=True):
        assignscore = [ts.segment_percentileiou(t, pct) * t.confidence() if (j not in assigndict.values() and (bycategory is False or ts.category() == t.category()) and (miniou == 0 or ts.maxiou(t) &gt; miniou)) else 0.0 for (j,t) in enumerate(dstlist)]
        assigndict[k] = np.argmax(assignscore) if len(assignscore) &gt; 0 and max(assignscore) &gt; 0 else None
    return [assigndict[k] for k in range(0, len(srclist))]</code></pre>
</details>
</dd>
<dt id="vipy.object.non_maximum_suppression"><code class="name flex">
<span>def <span class="ident">non_maximum_suppression</span></span>(<span>detlist, conf, iou, bycategory=False, cover=None, gridsize=(6, 9))</span>
</code></dt>
<dd>
<div class="desc"><p>Compute greedy non-maximum suppression of a list of vipy.object.Detection() based on spatial IOU threshold (iou) and cover threhsold (cover) sorted by confidence (conf).</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>detlist</code></strong></dt>
<dd>[list <code>vipy.object.Detection</code>]</dd>
<dt><strong><code>conf</code></strong></dt>
<dd>[float] minimum confidence for non-maximum suppression</dd>
<dt><strong><code>iou</code></strong></dt>
<dd>[float] minimum iou for non-maximum suporession</dd>
<dt><strong><code>bycategory</code></strong></dt>
<dd>[bool] NMS only within the same category </dd>
<dt><strong><code>cover</code></strong></dt>
<dd>[float, None] A minimum cover for NMS (stricter than iou)</dd>
<dt><strong><code>gridsize</code></strong></dt>
<dd>[tuple, (rows, cols)] An optional grid for fast intersection lookups </dd>
</dl>
<h2 id="returns">Returns</h2>
<p>List of <code><a title="vipy.object.Detection" href="#vipy.object.Detection">Detection</a></code> non-maximum suppressed, sorted by increasing confidence</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L1183-L1225" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def non_maximum_suppression(detlist, conf, iou, bycategory=False, cover=None, gridsize=(6,9)):
    &#34;&#34;&#34;Compute greedy non-maximum suppression of a list of vipy.object.Detection() based on spatial IOU threshold (iou) and cover threhsold (cover) sorted by confidence (conf).

    Args:
        detlist: [list `vipy.object.Detection`]
        conf: [float] minimum confidence for non-maximum suppression
        iou: [float] minimum iou for non-maximum suporession
        bycategory: [bool] NMS only within the same category 
        cover: [float, None] A minimum cover for NMS (stricter than iou)
        gridsize: [tuple, (rows, cols)] An optional grid for fast intersection lookups 

    Returns:
        List of `vipy.object.Detection` non-maximum suppressed, sorted by increasing confidence 

    &#34;&#34;&#34;
    assert all([isinstance(d, Detection) for d in detlist])
    assert all([d.confidence() is not None for d in detlist])
    assert conf&gt;=0 and iou&gt;=0 and iou&lt;=1
    assert cover is None or (cover&gt;=0 and cover&lt;=1)
    assert isinstance(gridsize, tuple) and len(gridsize) == 2
        
    suppressed = set([])
    detlist = [d for d in detlist if d.confidence() &gt; conf and not d.isdegenerate()]  # valid
    detlist.sort(key=lambda d: d.confidence(), reverse=True)  # biggest to smallest, in-place
    grid = detlist[0].clone().union(detlist).grid(gridsize[0], gridsize[1]) if len(detlist) &gt; 0 else []
    bbidx = [set([k for (k,bbg) in enumerate(grid) if (((bbg._xmax if bbg._xmax &lt; bb._xmax else bb._xmax) - (bbg._xmin if bbg._xmin &gt; bb._xmin else bb._xmin)) &gt; 0 and
                                                       ((bbg._ymax if bbg._ymax &lt; bb._ymax else bb._ymax) - (bbg._ymin if bbg._ymin &gt; bb._ymin else bb._ymin)) &gt; 0)])
             for bb in detlist]  # spatial index, without the function call overhead of bbg.hasintersection(bb)
    #bbidx = [set([k for (k,bbg) in enumerate(grid) if bbg.hasintersection(bb)]) for bb in detlist]  # spatial index, equivalent to above but slower
    
    area = [bb.area() for bb in detlist]
    for (i, di) in enumerate(detlist):
        if i in suppressed:
            continue
        for (j, dj) in enumerate(islice(detlist, i+1, None), start=i+1):  # no-copy, equivalent to detlist[i+1:]
            if ((j not in suppressed) and
                (bycategory is False or di.category() == dj.category()) and
                (not bbidx[i].isdisjoint(bbidx[j])) and
                ((cover is not None and di.hasintersection(dj, maxcover=cover, area=area[i], otherarea=area[j])) or di.hasintersection(dj, iou=iou, area=area[i], otherarea=area[j]))):  
                suppressed.add(j)
    detlist_nms = [d for (j,d) in enumerate(detlist) if j not in suppressed]  # filter
    detlist_nms.sort(key=lambda x: x.confidence())  # smallest to biggest confidence for display layering, in-place
    return detlist_nms</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="vipy.object.Detection"><code class="flex name class">
<span>class <span class="ident">Detection</span></span>
<span>(</span><span>category=None, xmin=None, ymin=None, width=None, height=None, xmax=None, ymax=None, confidence=None, xcentroid=None, ycentroid=None, ulbr=None, xywh=None, attributes=None, id=None, tags=None, normalized_coordinates=False)</span>
</code></dt>
<dd>
<div class="desc"><p>vipy.object.Detection class</p>
<p>This class represent a single object detection in the form a bounding box with a label and confidence.
The constructor of this class follows a subset of the constructor patterns of vipy.geometry.BoundingBox</p>
<pre><code class="language-python">d = vipy.object.Detection(category='Person', xmin=0, ymin=0, width=50, height=100)
d = vipy.object.Detection(label='Person', xmin=0, ymin=0, width=50, height=100)  # &quot;label&quot; is an alias for &quot;category&quot;
d = vipy.object.Detection(label='Person', xywh=[0,0,50,100])
d = vipy.object.Detection(..., id=True)  # generate a unique UUID for this detection retrievable with d.id()
</code></pre>
<h2 id="args">Args</h2>
<ul>
<li>normalized_coordinates [bool]: if True, then all of the (x,y) track coordinates are normalized to [0,1] where (0,0) is the upper left and (1,1) is bottom right. Tracks are converted to pixel coordinates on load().<br>
This is useful for legacy datasets where bounding boxes were stored in a scale invariant manner.
This flag avoids having to probe the image to determine the size in the constructor and delays conversion until pixels are loaded.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L78-L189" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Detection(BoundingBox, Object):
    &#34;&#34;&#34;vipy.object.Detection class
    
    This class represent a single object detection in the form a bounding box with a label and confidence.
    The constructor of this class follows a subset of the constructor patterns of vipy.geometry.BoundingBox

    ```python
    d = vipy.object.Detection(category=&#39;Person&#39;, xmin=0, ymin=0, width=50, height=100)
    d = vipy.object.Detection(label=&#39;Person&#39;, xmin=0, ymin=0, width=50, height=100)  # &#34;label&#34; is an alias for &#34;category&#34;
    d = vipy.object.Detection(label=&#39;Person&#39;, xywh=[0,0,50,100])
    d = vipy.object.Detection(..., id=True)  # generate a unique UUID for this detection retrievable with d.id()
    ```

    Args:
        - normalized_coordinates [bool]: if True, then all of the (x,y) track coordinates are normalized to [0,1] where (0,0) is the upper left and (1,1) is bottom right. Tracks are converted to pixel coordinates on load().  
          This is useful for legacy datasets where bounding boxes were stored in a scale invariant manner.  This flag avoids having to probe the image to determine the size in the constructor and delays conversion until pixels are loaded.

    &#34;&#34;&#34;
    __slots__ = [&#39;_xmin&#39;, &#39;_ymin&#39;, &#39;_xmax&#39;, &#39;_ymax&#39;, &#39;attributes&#39;, &#39;_id&#39;]    
    def __init__(self, category=None, xmin=None, ymin=None, width=None, height=None, xmax=None, ymax=None, confidence=None, xcentroid=None, ycentroid=None, ulbr=None, xywh=None, attributes=None, id=None, tags=None, normalized_coordinates=False):
        super().__init__(xmin=xmin, ymin=ymin, width=width, height=height, xmax=xmax, ymax=ymax, xcentroid=xcentroid, ycentroid=ycentroid, xywh=xywh, ulbr=ulbr)

        self._id = shortuuid() if id == True else (str(id) if id is not None else id)
        self.attributes = {} if attributes is None else attributes  # user must copy if needed

        if category is not None:
            self.add_tag(category, confidence)        
        if tags is not None:
            for t in to_iterable(tags):
                self.add_tag(t)

        if normalized_coordinates:
            self.attributes[&#39;normalized_coordinates&#39;] = True
            
    @classmethod
    def cast(cls, d):
        assert isinstance(d, BoundingBox)
        return d if isinstance(d, Detection) else cls(xywh=d.xywh())

    def downcast(self):
        return BoundingBox(xywh=self.xywh())

    def __json__(self):
        &#34;&#34;&#34;Serialization method for json package&#34;&#34;&#34;
        return self.json(encode=True)

    def json(self, encode=True):
        d = {k.lstrip(&#39;_&#39;):getattr(self, k) for k in Detection.__slots__ if getattr(self, k) is not None}  # prettyjson (remove &#34;_&#34; prefix to attributes)  
        return json.dumps(d) if encode else d
    
    @classmethod
    def from_json(cls, s):
        d = json.loads(s) if not isinstance(s, dict) else s
        if any(k.startswith(&#39;_&#39;) for k in d.keys()):
            # Legacy support &lt;= vipy 1.14.4
            return cls(xmin=d[&#39;_xmin&#39;], ymin=d[&#39;_ymin&#39;], xmax=d[&#39;_xmax&#39;], ymax=d[&#39;_ymax&#39;],
                       attributes=d[&#39;attributes&#39;] if &#39;attributes&#39; in d else None,
                       tags=d[&#39;tags&#39;] if &#39;tags&#39; in d else None,
                       category=d[&#39;_category&#39;] if &#39;_category&#39; in d else None,
                       id=d[&#39;_id&#39;] if &#39;_id&#39; in d else None)
        elif &#39;label&#39; in d.keys():
            # Legacy support &lt;= vipy 1.14.4
            return cls(xmin=d[&#39;xmin&#39;], ymin=d[&#39;ymin&#39;], xmax=d[&#39;xmax&#39;], ymax=d[&#39;ymax&#39;],
                       attributes=d[&#39;attributes&#39;] if &#39;attributes&#39; in d else None,
                       tags=None,  # in attributes
                       category=d[&#39;label&#39;] if &#39;label&#39; in d else None,
                       confidence=d[&#39;confidence&#39;] if &#39;confidence&#39; in d else None,
                       id=d[&#39;id&#39;] if &#39;id&#39; in d else None)
        else:            
            # vipy-1.16.1            
            return cls(xmin=d[&#39;xmin&#39;], ymin=d[&#39;ymin&#39;], xmax=d[&#39;xmax&#39;], ymax=d[&#39;ymax&#39;],
                       attributes=d[&#39;attributes&#39;] if &#39;attributes&#39; in d else None,
                       tags=None,  # in attributes
                       category=None,
                       confidence=None,
                       id=d[&#39;id&#39;] if &#39;id&#39; in d else None)
        
    def __repr__(self):
        strlist = []
        if self.category() is not None:
            strlist.append(&#39;category=%s&#39; % (str(self.category())[0:80] + (&#39; ... &#39; if len(str(self.category()))&gt;80 else &#39;&#39;)))                        
        if True:
            strlist.append(&#39;bbox=(xmin=%1.1f, ymin=%1.1f, width=%1.1f, height=%1.1f)&#39; %
                           (self.xmin(), self.ymin(),self.width(), self.height()))
        if self.category() is not None and self.confidence() is not None:
            strlist.append(&#39;conf=%1.3f&#39; % self.confidence())
        if self.isdegenerate():
            strlist.append(&#39;degenerate&#39;)
        return str(&#39;&lt;vipy.object.Detection: %s&gt;&#39; % (&#39;, &#39;.join(strlist)))

    def __eq__(self, other):
        &#34;&#34;&#34;Detection equality when bounding boxes (integer resolution) and categories are equivalent&#34;&#34;&#34;
        return isinstance(other, Detection) and self.clone().int().xywh() == other.clone().int().xywh() and self.category() == other.category()

    def __str__(self):
        return self.__repr__()

    def dict(self):
        &#34;&#34;&#34;Return a python dictionary containing the relevant serialized attributes suitable for JSON encoding&#34;&#34;&#34;
        return self.json(s=None, encode=False)
                
    def id(self):
        return self._id

    def clone(self, deep=False):
        &#34;&#34;&#34;Copy the object, if deep=True, then include a deep copy of the attribute dictionary, else a shallow copy.  Cloned object has the same id()&#34;&#34;&#34;
        d = Detection.from_json(self.json(encode=False))
        if deep:
            d.attributes = copy.deepcopy(self.attributes)
        else:
            d.attributes = self.attributes.copy()            
        return d</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="vipy.geometry.BoundingBox" href="geometry.html#vipy.geometry.BoundingBox">BoundingBox</a></li>
<li><a title="vipy.object.Object" href="#vipy.object.Object">Object</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="vipy.object.Detection.cast"><code class="name flex">
<span>def <span class="ident">cast</span></span>(<span>d)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="vipy.object.Detection.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>s)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="vipy.object.Detection.attributes"><code class="name">var <span class="ident">attributes</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L78-L189" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Detection(BoundingBox, Object):
    &#34;&#34;&#34;vipy.object.Detection class
    
    This class represent a single object detection in the form a bounding box with a label and confidence.
    The constructor of this class follows a subset of the constructor patterns of vipy.geometry.BoundingBox

    ```python
    d = vipy.object.Detection(category=&#39;Person&#39;, xmin=0, ymin=0, width=50, height=100)
    d = vipy.object.Detection(label=&#39;Person&#39;, xmin=0, ymin=0, width=50, height=100)  # &#34;label&#34; is an alias for &#34;category&#34;
    d = vipy.object.Detection(label=&#39;Person&#39;, xywh=[0,0,50,100])
    d = vipy.object.Detection(..., id=True)  # generate a unique UUID for this detection retrievable with d.id()
    ```

    Args:
        - normalized_coordinates [bool]: if True, then all of the (x,y) track coordinates are normalized to [0,1] where (0,0) is the upper left and (1,1) is bottom right. Tracks are converted to pixel coordinates on load().  
          This is useful for legacy datasets where bounding boxes were stored in a scale invariant manner.  This flag avoids having to probe the image to determine the size in the constructor and delays conversion until pixels are loaded.

    &#34;&#34;&#34;
    __slots__ = [&#39;_xmin&#39;, &#39;_ymin&#39;, &#39;_xmax&#39;, &#39;_ymax&#39;, &#39;attributes&#39;, &#39;_id&#39;]    
    def __init__(self, category=None, xmin=None, ymin=None, width=None, height=None, xmax=None, ymax=None, confidence=None, xcentroid=None, ycentroid=None, ulbr=None, xywh=None, attributes=None, id=None, tags=None, normalized_coordinates=False):
        super().__init__(xmin=xmin, ymin=ymin, width=width, height=height, xmax=xmax, ymax=ymax, xcentroid=xcentroid, ycentroid=ycentroid, xywh=xywh, ulbr=ulbr)

        self._id = shortuuid() if id == True else (str(id) if id is not None else id)
        self.attributes = {} if attributes is None else attributes  # user must copy if needed

        if category is not None:
            self.add_tag(category, confidence)        
        if tags is not None:
            for t in to_iterable(tags):
                self.add_tag(t)

        if normalized_coordinates:
            self.attributes[&#39;normalized_coordinates&#39;] = True
            
    @classmethod
    def cast(cls, d):
        assert isinstance(d, BoundingBox)
        return d if isinstance(d, Detection) else cls(xywh=d.xywh())

    def downcast(self):
        return BoundingBox(xywh=self.xywh())

    def __json__(self):
        &#34;&#34;&#34;Serialization method for json package&#34;&#34;&#34;
        return self.json(encode=True)

    def json(self, encode=True):
        d = {k.lstrip(&#39;_&#39;):getattr(self, k) for k in Detection.__slots__ if getattr(self, k) is not None}  # prettyjson (remove &#34;_&#34; prefix to attributes)  
        return json.dumps(d) if encode else d
    
    @classmethod
    def from_json(cls, s):
        d = json.loads(s) if not isinstance(s, dict) else s
        if any(k.startswith(&#39;_&#39;) for k in d.keys()):
            # Legacy support &lt;= vipy 1.14.4
            return cls(xmin=d[&#39;_xmin&#39;], ymin=d[&#39;_ymin&#39;], xmax=d[&#39;_xmax&#39;], ymax=d[&#39;_ymax&#39;],
                       attributes=d[&#39;attributes&#39;] if &#39;attributes&#39; in d else None,
                       tags=d[&#39;tags&#39;] if &#39;tags&#39; in d else None,
                       category=d[&#39;_category&#39;] if &#39;_category&#39; in d else None,
                       id=d[&#39;_id&#39;] if &#39;_id&#39; in d else None)
        elif &#39;label&#39; in d.keys():
            # Legacy support &lt;= vipy 1.14.4
            return cls(xmin=d[&#39;xmin&#39;], ymin=d[&#39;ymin&#39;], xmax=d[&#39;xmax&#39;], ymax=d[&#39;ymax&#39;],
                       attributes=d[&#39;attributes&#39;] if &#39;attributes&#39; in d else None,
                       tags=None,  # in attributes
                       category=d[&#39;label&#39;] if &#39;label&#39; in d else None,
                       confidence=d[&#39;confidence&#39;] if &#39;confidence&#39; in d else None,
                       id=d[&#39;id&#39;] if &#39;id&#39; in d else None)
        else:            
            # vipy-1.16.1            
            return cls(xmin=d[&#39;xmin&#39;], ymin=d[&#39;ymin&#39;], xmax=d[&#39;xmax&#39;], ymax=d[&#39;ymax&#39;],
                       attributes=d[&#39;attributes&#39;] if &#39;attributes&#39; in d else None,
                       tags=None,  # in attributes
                       category=None,
                       confidence=None,
                       id=d[&#39;id&#39;] if &#39;id&#39; in d else None)
        
    def __repr__(self):
        strlist = []
        if self.category() is not None:
            strlist.append(&#39;category=%s&#39; % (str(self.category())[0:80] + (&#39; ... &#39; if len(str(self.category()))&gt;80 else &#39;&#39;)))                        
        if True:
            strlist.append(&#39;bbox=(xmin=%1.1f, ymin=%1.1f, width=%1.1f, height=%1.1f)&#39; %
                           (self.xmin(), self.ymin(),self.width(), self.height()))
        if self.category() is not None and self.confidence() is not None:
            strlist.append(&#39;conf=%1.3f&#39; % self.confidence())
        if self.isdegenerate():
            strlist.append(&#39;degenerate&#39;)
        return str(&#39;&lt;vipy.object.Detection: %s&gt;&#39; % (&#39;, &#39;.join(strlist)))

    def __eq__(self, other):
        &#34;&#34;&#34;Detection equality when bounding boxes (integer resolution) and categories are equivalent&#34;&#34;&#34;
        return isinstance(other, Detection) and self.clone().int().xywh() == other.clone().int().xywh() and self.category() == other.category()

    def __str__(self):
        return self.__repr__()

    def dict(self):
        &#34;&#34;&#34;Return a python dictionary containing the relevant serialized attributes suitable for JSON encoding&#34;&#34;&#34;
        return self.json(s=None, encode=False)
                
    def id(self):
        return self._id

    def clone(self, deep=False):
        &#34;&#34;&#34;Copy the object, if deep=True, then include a deep copy of the attribute dictionary, else a shallow copy.  Cloned object has the same id()&#34;&#34;&#34;
        d = Detection.from_json(self.json(encode=False))
        if deep:
            d.attributes = copy.deepcopy(self.attributes)
        else:
            d.attributes = self.attributes.copy()            
        return d</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="vipy.object.Detection.clone"><code class="name flex">
<span>def <span class="ident">clone</span></span>(<span>self, deep=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Copy the object, if deep=True, then include a deep copy of the attribute dictionary, else a shallow copy.
Cloned object has the same id()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L182-L189" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def clone(self, deep=False):
    &#34;&#34;&#34;Copy the object, if deep=True, then include a deep copy of the attribute dictionary, else a shallow copy.  Cloned object has the same id()&#34;&#34;&#34;
    d = Detection.from_json(self.json(encode=False))
    if deep:
        d.attributes = copy.deepcopy(self.attributes)
    else:
        d.attributes = self.attributes.copy()            
    return d</code></pre>
</details>
</dd>
<dt id="vipy.object.Detection.downcast"><code class="name flex">
<span>def <span class="ident">downcast</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L117-L118" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def downcast(self):
    return BoundingBox(xywh=self.xywh())</code></pre>
</details>
</dd>
<dt id="vipy.object.Detection.id"><code class="name flex">
<span>def <span class="ident">id</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L179-L180" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def id(self):
    return self._id</code></pre>
</details>
</dd>
<dt id="vipy.object.Detection.json"><code class="name flex">
<span>def <span class="ident">json</span></span>(<span>self, encode=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L124-L126" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def json(self, encode=True):
    d = {k.lstrip(&#39;_&#39;):getattr(self, k) for k in Detection.__slots__ if getattr(self, k) is not None}  # prettyjson (remove &#34;_&#34; prefix to attributes)  
    return json.dumps(d) if encode else d</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vipy.geometry.BoundingBox" href="geometry.html#vipy.geometry.BoundingBox">BoundingBox</a></b></code>:
<ul class="hlist">
<li><code><a title="vipy.geometry.BoundingBox.affine" href="geometry.html#vipy.geometry.BoundingBox.affine">affine</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.area" href="geometry.html#vipy.geometry.BoundingBox.area">area</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.area_of_intersection" href="geometry.html#vipy.geometry.BoundingBox.area_of_intersection">area_of_intersection</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.aspectratio" href="geometry.html#vipy.geometry.BoundingBox.aspectratio">aspectratio</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.average" href="geometry.html#vipy.geometry.BoundingBox.average">average</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.averageshape" href="geometry.html#vipy.geometry.BoundingBox.averageshape">averageshape</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.bl" href="geometry.html#vipy.geometry.BoundingBox.bl">bl</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.blx" href="geometry.html#vipy.geometry.BoundingBox.blx">blx</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.bly" href="geometry.html#vipy.geometry.BoundingBox.bly">bly</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.bottom" href="geometry.html#vipy.geometry.BoundingBox.bottom">bottom</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.bottomleft" href="geometry.html#vipy.geometry.BoundingBox.bottomleft">bottomleft</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.bottomright" href="geometry.html#vipy.geometry.BoundingBox.bottomright">bottomright</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.br" href="geometry.html#vipy.geometry.BoundingBox.br">br</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.brx" href="geometry.html#vipy.geometry.BoundingBox.brx">brx</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.bry" href="geometry.html#vipy.geometry.BoundingBox.bry">bry</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.centroid" href="geometry.html#vipy.geometry.BoundingBox.centroid">centroid</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.centroid_x" href="geometry.html#vipy.geometry.BoundingBox.centroid_x">centroid_x</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.centroid_y" href="geometry.html#vipy.geometry.BoundingBox.centroid_y">centroid_y</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.convexhull" href="geometry.html#vipy.geometry.BoundingBox.convexhull">convexhull</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.cover" href="geometry.html#vipy.geometry.BoundingBox.cover">cover</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.crop" href="geometry.html#vipy.geometry.BoundingBox.crop">crop</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.cxywh" href="geometry.html#vipy.geometry.BoundingBox.cxywh">cxywh</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.dict" href="geometry.html#vipy.geometry.BoundingBox.dict">dict</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.dilate" href="geometry.html#vipy.geometry.BoundingBox.dilate">dilate</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.dilate_height" href="geometry.html#vipy.geometry.BoundingBox.dilate_height">dilate_height</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.dilate_width" href="geometry.html#vipy.geometry.BoundingBox.dilate_width">dilate_width</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.dilatepx" href="geometry.html#vipy.geometry.BoundingBox.dilatepx">dilatepx</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.dist" href="geometry.html#vipy.geometry.BoundingBox.dist">dist</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.dx" href="geometry.html#vipy.geometry.BoundingBox.dx">dx</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.dy" href="geometry.html#vipy.geometry.BoundingBox.dy">dy</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.ellipse" href="geometry.html#vipy.geometry.BoundingBox.ellipse">ellipse</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.even" href="geometry.html#vipy.geometry.BoundingBox.even">even</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.fliplr" href="geometry.html#vipy.geometry.BoundingBox.fliplr">fliplr</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.flipud" href="geometry.html#vipy.geometry.BoundingBox.flipud">flipud</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.float" href="geometry.html#vipy.geometry.BoundingBox.float">float</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.grid" href="geometry.html#vipy.geometry.BoundingBox.grid">grid</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.hasintersection" href="geometry.html#vipy.geometry.BoundingBox.hasintersection">hasintersection</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.hasoverlap" href="geometry.html#vipy.geometry.BoundingBox.hasoverlap">hasoverlap</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.imclip" href="geometry.html#vipy.geometry.BoundingBox.imclip">imclip</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.imclipshape" href="geometry.html#vipy.geometry.BoundingBox.imclipshape">imclipshape</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.iminterior" href="geometry.html#vipy.geometry.BoundingBox.iminterior">iminterior</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.imscale" href="geometry.html#vipy.geometry.BoundingBox.imscale">imscale</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.int" href="geometry.html#vipy.geometry.BoundingBox.int">int</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.intersection" href="geometry.html#vipy.geometry.BoundingBox.intersection">intersection</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.intersection_over_union" href="geometry.html#vipy.geometry.BoundingBox.intersection_over_union">intersection_over_union</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.invalid" href="geometry.html#vipy.geometry.BoundingBox.invalid">invalid</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.iou" href="geometry.html#vipy.geometry.BoundingBox.iou">iou</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.is_point_inside" href="geometry.html#vipy.geometry.BoundingBox.is_point_inside">is_point_inside</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.iseven" href="geometry.html#vipy.geometry.BoundingBox.iseven">iseven</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.isinside" href="geometry.html#vipy.geometry.BoundingBox.isinside">isinside</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.isinterior" href="geometry.html#vipy.geometry.BoundingBox.isinterior">isinterior</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.ispointinside" href="geometry.html#vipy.geometry.BoundingBox.ispointinside">ispointinside</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.left" href="geometry.html#vipy.geometry.BoundingBox.left">left</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.ll" href="geometry.html#vipy.geometry.BoundingBox.ll">ll</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.lr" href="geometry.html#vipy.geometry.BoundingBox.lr">lr</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.maxcover" href="geometry.html#vipy.geometry.BoundingBox.maxcover">maxcover</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.maxdim" href="geometry.html#vipy.geometry.BoundingBox.maxdim">maxdim</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.maxsquare" href="geometry.html#vipy.geometry.BoundingBox.maxsquare">maxsquare</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.medianshape" href="geometry.html#vipy.geometry.BoundingBox.medianshape">medianshape</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.mindim" href="geometry.html#vipy.geometry.BoundingBox.mindim">mindim</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.mindimension" href="geometry.html#vipy.geometry.BoundingBox.mindimension">mindimension</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.minsquare" href="geometry.html#vipy.geometry.BoundingBox.minsquare">minsquare</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.offset" href="geometry.html#vipy.geometry.BoundingBox.offset">offset</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.pdist" href="geometry.html#vipy.geometry.BoundingBox.pdist">pdist</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.projective" href="geometry.html#vipy.geometry.BoundingBox.projective">projective</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.rescale" href="geometry.html#vipy.geometry.BoundingBox.rescale">rescale</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.resize" href="geometry.html#vipy.geometry.BoundingBox.resize">resize</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.right" href="geometry.html#vipy.geometry.BoundingBox.right">right</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.rot90ccw" href="geometry.html#vipy.geometry.BoundingBox.rot90ccw">rot90ccw</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.rot90cw" href="geometry.html#vipy.geometry.BoundingBox.rot90cw">rot90cw</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.scale_x" href="geometry.html#vipy.geometry.BoundingBox.scale_x">scale_x</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.scale_y" href="geometry.html#vipy.geometry.BoundingBox.scale_y">scale_y</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.set_origin" href="geometry.html#vipy.geometry.BoundingBox.set_origin">set_origin</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.setheight" href="geometry.html#vipy.geometry.BoundingBox.setheight">setheight</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.setwidth" href="geometry.html#vipy.geometry.BoundingBox.setwidth">setwidth</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.shape" href="geometry.html#vipy.geometry.BoundingBox.shape">shape</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.shapedist" href="geometry.html#vipy.geometry.BoundingBox.shapedist">shapedist</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.shapeiou" href="geometry.html#vipy.geometry.BoundingBox.shapeiou">shapeiou</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.significant_digits" href="geometry.html#vipy.geometry.BoundingBox.significant_digits">significant_digits</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.sqdist" href="geometry.html#vipy.geometry.BoundingBox.sqdist">sqdist</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.to_origin" href="geometry.html#vipy.geometry.BoundingBox.to_origin">to_origin</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.to_ulbr" href="geometry.html#vipy.geometry.BoundingBox.to_ulbr">to_ulbr</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.to_xywh" href="geometry.html#vipy.geometry.BoundingBox.to_xywh">to_xywh</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.top" href="geometry.html#vipy.geometry.BoundingBox.top">top</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.translate" href="geometry.html#vipy.geometry.BoundingBox.translate">translate</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.ul" href="geometry.html#vipy.geometry.BoundingBox.ul">ul</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.ulbr" href="geometry.html#vipy.geometry.BoundingBox.ulbr">ulbr</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.ulx" href="geometry.html#vipy.geometry.BoundingBox.ulx">ulx</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.uly" href="geometry.html#vipy.geometry.BoundingBox.uly">uly</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.union" href="geometry.html#vipy.geometry.BoundingBox.union">union</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.upperleft" href="geometry.html#vipy.geometry.BoundingBox.upperleft">upperleft</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.upperright" href="geometry.html#vipy.geometry.BoundingBox.upperright">upperright</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.ur" href="geometry.html#vipy.geometry.BoundingBox.ur">ur</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.urx" href="geometry.html#vipy.geometry.BoundingBox.urx">urx</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.ury" href="geometry.html#vipy.geometry.BoundingBox.ury">ury</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.xcentroid" href="geometry.html#vipy.geometry.BoundingBox.xcentroid">xcentroid</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.xmax" href="geometry.html#vipy.geometry.BoundingBox.xmax">xmax</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.xmin" href="geometry.html#vipy.geometry.BoundingBox.xmin">xmin</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.xywh" href="geometry.html#vipy.geometry.BoundingBox.xywh">xywh</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.ycentroid" href="geometry.html#vipy.geometry.BoundingBox.ycentroid">ycentroid</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.ymax" href="geometry.html#vipy.geometry.BoundingBox.ymax">ymax</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.ymin" href="geometry.html#vipy.geometry.BoundingBox.ymin">ymin</a></code></li>
</ul>
</li>
<li><code><b><a title="vipy.object.Object" href="#vipy.object.Object">Object</a></b></code>:
<ul class="hlist">
<li><code><a title="vipy.object.Object.append_attribute" href="#vipy.object.Object.append_attribute">append_attribute</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vipy.object.Keypoint2d"><code class="flex name class">
<span>class <span class="ident">Keypoint2d</span></span>
<span>(</span><span>x, y, radius=1, attributes=None, confidence=None, id=None, category=None, tags=None, normalized_coordinates=False)</span>
</code></dt>
<dd>
<div class="desc"><p>vipy.object.Keypoint2d class</p>
<p>2D point parameterization</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L193-L258" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Keypoint2d(Point2d, Object):
    &#34;&#34;&#34;vipy.object.Keypoint2d class&#34;&#34;&#34;

    __slots__ = [&#39;_x&#39;, &#39;_y&#39;, &#39;_r&#39;, &#39;attributes&#39;, &#39;_id&#39;]        
    def __init__(self, x, y, radius=1, attributes=None, confidence=None, id=None, category=None, tags=None, normalized_coordinates=False):
        super().__init__(x, y, r=radius)
        
        assert attributes is None or isinstance(attributes, dict)        
        self.attributes = attributes if attributes is not None else {}
        
        self._id = shortuuid() if id is True else (str(id) if id is not None else id)

        if category is not None:
            self.add_tag(category, confidence)        
        if tags is not None:
            for t in to_iterable(tags):
                self.add_tag(t)

        if normalized_coordinates:
            self.set_attribute(&#39;normalized_coordinates&#39;, True)  # updated on load after size is available

    @classmethod
    def cast(cls, obj):
        if isinstance(obj, Detection):
            return cls(obj.centroid_x(), obj.centroid_y(), min(obj.width()/2, obj.height()/2), attributes=obj.attributes)
        elif isinstance(obj, Keypoint2d):
            return self
        else:
            raise TypeError(&#39;unsupported type &#34;%s&#34;&#39; % (type(obj)))
                
    def clone(self, deep=False):
        &#34;&#34;&#34;Copy the object, if deep=True, then include a deep copy of the attribute dictionary, else a shallow copy.  Cloned object has the same id()&#34;&#34;&#34;
        #return copy.deepcopy(self)
        d = Keypoint2d.from_json(self.json(encode=False))
        if deep:
            d.attributes = copy.deepcopy(self.attributes)
        else:
            d.attributes = self.attributes.copy()            
        return d
    
    @property
    def guid(self):
        return self._id

    def id(self):
        return self._id

    def __repr__(self):
        fields  = [&#39;x=%s&#39; % self.x]
        fields += [&#39;y=%s&#39; % self.y]
        fields += [&#39;r=%s&#39; % self.r]        
        fields += [&#39;category=%s&#39; % truncate_string(str(self.category()), 40)] if self.category() is not None else []
        fields += [&#39;conf=%1.3f&#39; % self.confidence()] if self.category() is not None and self.confidence() is not None else []
        fields += [&#39;tags=%s&#39; % truncate_string(str(self.tags()), 40)] if len(self.tags())&gt;1 else []        
        return str(&#39;&lt;vipy.object.Keypoint2d: %s&gt;&#39; % (&#39;, &#39;.join(fields)))
    
    @classmethod
    def from_json(cls, s):
        d = json.loads(s) if not isinstance(s, dict) else s
        return cls(x=d[&#39;x&#39;], y=d[&#39;y&#39;], radius=d[&#39;r&#39;],
                   attributes=d[&#39;attributes&#39;] if &#39;attributes&#39; in d else None,
                   id=d[&#39;id&#39;] if &#39;id&#39; in d else True)
    
    def json(self, encode=True):
        d = {k.lstrip(&#39;_&#39;):getattr(self, k) for k in Keypoint2d.__slots__ if getattr(self, k) is not None}  # prettyjson (remove &#34;_&#34; prefix to attributes)  
        return json.dumps(d) if encode else d</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="vipy.geometry.Point2d" href="geometry.html#vipy.geometry.Point2d">Point2d</a></li>
<li><a title="vipy.object.Object" href="#vipy.object.Object">Object</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="vipy.object.Keypoint2d.cast"><code class="name flex">
<span>def <span class="ident">cast</span></span>(<span>obj)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="vipy.object.Keypoint2d.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>s)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="vipy.object.Keypoint2d.attributes"><code class="name">var <span class="ident">attributes</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L193-L258" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Keypoint2d(Point2d, Object):
    &#34;&#34;&#34;vipy.object.Keypoint2d class&#34;&#34;&#34;

    __slots__ = [&#39;_x&#39;, &#39;_y&#39;, &#39;_r&#39;, &#39;attributes&#39;, &#39;_id&#39;]        
    def __init__(self, x, y, radius=1, attributes=None, confidence=None, id=None, category=None, tags=None, normalized_coordinates=False):
        super().__init__(x, y, r=radius)
        
        assert attributes is None or isinstance(attributes, dict)        
        self.attributes = attributes if attributes is not None else {}
        
        self._id = shortuuid() if id is True else (str(id) if id is not None else id)

        if category is not None:
            self.add_tag(category, confidence)        
        if tags is not None:
            for t in to_iterable(tags):
                self.add_tag(t)

        if normalized_coordinates:
            self.set_attribute(&#39;normalized_coordinates&#39;, True)  # updated on load after size is available

    @classmethod
    def cast(cls, obj):
        if isinstance(obj, Detection):
            return cls(obj.centroid_x(), obj.centroid_y(), min(obj.width()/2, obj.height()/2), attributes=obj.attributes)
        elif isinstance(obj, Keypoint2d):
            return self
        else:
            raise TypeError(&#39;unsupported type &#34;%s&#34;&#39; % (type(obj)))
                
    def clone(self, deep=False):
        &#34;&#34;&#34;Copy the object, if deep=True, then include a deep copy of the attribute dictionary, else a shallow copy.  Cloned object has the same id()&#34;&#34;&#34;
        #return copy.deepcopy(self)
        d = Keypoint2d.from_json(self.json(encode=False))
        if deep:
            d.attributes = copy.deepcopy(self.attributes)
        else:
            d.attributes = self.attributes.copy()            
        return d
    
    @property
    def guid(self):
        return self._id

    def id(self):
        return self._id

    def __repr__(self):
        fields  = [&#39;x=%s&#39; % self.x]
        fields += [&#39;y=%s&#39; % self.y]
        fields += [&#39;r=%s&#39; % self.r]        
        fields += [&#39;category=%s&#39; % truncate_string(str(self.category()), 40)] if self.category() is not None else []
        fields += [&#39;conf=%1.3f&#39; % self.confidence()] if self.category() is not None and self.confidence() is not None else []
        fields += [&#39;tags=%s&#39; % truncate_string(str(self.tags()), 40)] if len(self.tags())&gt;1 else []        
        return str(&#39;&lt;vipy.object.Keypoint2d: %s&gt;&#39; % (&#39;, &#39;.join(fields)))
    
    @classmethod
    def from_json(cls, s):
        d = json.loads(s) if not isinstance(s, dict) else s
        return cls(x=d[&#39;x&#39;], y=d[&#39;y&#39;], radius=d[&#39;r&#39;],
                   attributes=d[&#39;attributes&#39;] if &#39;attributes&#39; in d else None,
                   id=d[&#39;id&#39;] if &#39;id&#39; in d else True)
    
    def json(self, encode=True):
        d = {k.lstrip(&#39;_&#39;):getattr(self, k) for k in Keypoint2d.__slots__ if getattr(self, k) is not None}  # prettyjson (remove &#34;_&#34; prefix to attributes)  
        return json.dumps(d) if encode else d</code></pre>
</details>
</dd>
<dt id="vipy.object.Keypoint2d.guid"><code class="name">var <span class="ident">guid</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L233-L235" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def guid(self):
    return self._id</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="vipy.object.Keypoint2d.clone"><code class="name flex">
<span>def <span class="ident">clone</span></span>(<span>self, deep=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Copy the object, if deep=True, then include a deep copy of the attribute dictionary, else a shallow copy.
Cloned object has the same id()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L223-L231" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def clone(self, deep=False):
    &#34;&#34;&#34;Copy the object, if deep=True, then include a deep copy of the attribute dictionary, else a shallow copy.  Cloned object has the same id()&#34;&#34;&#34;
    #return copy.deepcopy(self)
    d = Keypoint2d.from_json(self.json(encode=False))
    if deep:
        d.attributes = copy.deepcopy(self.attributes)
    else:
        d.attributes = self.attributes.copy()            
    return d</code></pre>
</details>
</dd>
<dt id="vipy.object.Keypoint2d.id"><code class="name flex">
<span>def <span class="ident">id</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L237-L238" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def id(self):
    return self._id</code></pre>
</details>
</dd>
<dt id="vipy.object.Keypoint2d.json"><code class="name flex">
<span>def <span class="ident">json</span></span>(<span>self, encode=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L256-L258" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def json(self, encode=True):
    d = {k.lstrip(&#39;_&#39;):getattr(self, k) for k in Keypoint2d.__slots__ if getattr(self, k) is not None}  # prettyjson (remove &#34;_&#34; prefix to attributes)  
    return json.dumps(d) if encode else d</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vipy.geometry.Point2d" href="geometry.html#vipy.geometry.Point2d">Point2d</a></b></code>:
<ul class="hlist">
<li><code><a title="vipy.geometry.Point2d.area_of_intersection" href="geometry.html#vipy.geometry.Point2d.area_of_intersection">area_of_intersection</a></code></li>
<li><code><a title="vipy.geometry.Point2d.fliplr" href="geometry.html#vipy.geometry.Point2d.fliplr">fliplr</a></code></li>
<li><code><a title="vipy.geometry.Point2d.flipud" href="geometry.html#vipy.geometry.Point2d.flipud">flipud</a></code></li>
<li><code><a title="vipy.geometry.Point2d.float" href="geometry.html#vipy.geometry.Point2d.float">float</a></code></li>
<li><code><a title="vipy.geometry.Point2d.hasoverlap" href="geometry.html#vipy.geometry.Point2d.hasoverlap">hasoverlap</a></code></li>
<li><code><a title="vipy.geometry.Point2d.imclip" href="geometry.html#vipy.geometry.Point2d.imclip">imclip</a></code></li>
<li><code><a title="vipy.geometry.Point2d.int" href="geometry.html#vipy.geometry.Point2d.int">int</a></code></li>
<li><code><a title="vipy.geometry.Point2d.offset" href="geometry.html#vipy.geometry.Point2d.offset">offset</a></code></li>
<li><code><a title="vipy.geometry.Point2d.rescale" href="geometry.html#vipy.geometry.Point2d.rescale">rescale</a></code></li>
<li><code><a title="vipy.geometry.Point2d.rot90ccw" href="geometry.html#vipy.geometry.Point2d.rot90ccw">rot90ccw</a></code></li>
<li><code><a title="vipy.geometry.Point2d.rot90cw" href="geometry.html#vipy.geometry.Point2d.rot90cw">rot90cw</a></code></li>
<li><code><a title="vipy.geometry.Point2d.scale_r" href="geometry.html#vipy.geometry.Point2d.scale_r">scale_r</a></code></li>
<li><code><a title="vipy.geometry.Point2d.scale_x" href="geometry.html#vipy.geometry.Point2d.scale_x">scale_x</a></code></li>
<li><code><a title="vipy.geometry.Point2d.scale_y" href="geometry.html#vipy.geometry.Point2d.scale_y">scale_y</a></code></li>
<li><code><a title="vipy.geometry.Point2d.significant_digits" href="geometry.html#vipy.geometry.Point2d.significant_digits">significant_digits</a></code></li>
<li><code><a title="vipy.geometry.Point2d.translate" href="geometry.html#vipy.geometry.Point2d.translate">translate</a></code></li>
</ul>
</li>
<li><code><b><a title="vipy.object.Object" href="#vipy.object.Object">Object</a></b></code>:
<ul class="hlist">
<li><code><a title="vipy.object.Object.append_attribute" href="#vipy.object.Object.append_attribute">append_attribute</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vipy.object.Object"><code class="flex name class">
<span>class <span class="ident">Object</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L16-L75" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Object():
    __slots__ = ()

    def category(self):
        return self.attributes[&#39;tags&#39;][0] if &#39;tags&#39; in self.attributes else None

    def new_category(self, category, confidence=None):
        return self.del_attribute(&#39;confidences&#39;).del_attribute(&#39;tags&#39;).add_tag(category, confidence)
    
    def confidence(self):
        return self.get_attribute(&#39;confidences&#39;)[self.category()] if self.has_attribute(&#39;confidences&#39;) and self.category() in self.attributes[&#39;confidences&#39;] else None
    
    def tags(self, tags=None):
        if tags is not None:
            return self.set_attribute(&#39;tags&#39;, tolist(tags))
        return self.attributes[&#39;tags&#39;] if &#39;tags&#39; in self.attributes else []
    
    def confidences(self):
        return tuple(self.attributes[&#39;confidences&#39;][t] if t in self.aattributes[&#39;confidences&#39;] else None for t in self.tags())
    
    def add_tag(self, tag, confidence=None):
        self.append_attribute(&#39;tags&#39;, tag)
        if confidence is not None:
            if not self.has_attribute(&#39;confidences&#39;):
                self.set_attribute(&#39;confidences&#39;, {})
            self.attributes[&#39;confidences&#39;][tag] = confidence
        return self

    def add_tags(self, tags, confidences=[]):
        for (t,c) in zip_longest(tags, confidences):
            self.add_tag(t, c)
        return self
    
    def has_attribute(self, k):
        return k in self.attributes

    def get_attribute(self, k):
        return self.attributes[k] if k in self.attributes else None

    def set_attribute(self, k, v):
        self.attributes[k] = v
        return self
    
    def del_attribute(self, k):
        self.attributes.pop(k, None)
        return self

    def clear_attributes(self):
        self.attributes = {}
        return self
    
    def append_attribute(self, key, value):
        &#34;&#34;&#34;Append the value to attribute key, creating the key as an empty list if it does not exist&#34;&#34;&#34;
        if key not in self.attributes:
            self.attributes[key] = []
        self.attributes[key].append(value)
        return self

    def has_normalized_coordinates(self):
        return self.get_attribute(&#39;normalized_coordinates&#39;) == True</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="vipy.object.Detection" href="#vipy.object.Detection">Detection</a></li>
<li><a title="vipy.object.Keypoint2d" href="#vipy.object.Keypoint2d">Keypoint2d</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="vipy.object.Object.add_tag"><code class="name flex">
<span>def <span class="ident">add_tag</span></span>(<span>self, tag, confidence=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L36-L42" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def add_tag(self, tag, confidence=None):
    self.append_attribute(&#39;tags&#39;, tag)
    if confidence is not None:
        if not self.has_attribute(&#39;confidences&#39;):
            self.set_attribute(&#39;confidences&#39;, {})
        self.attributes[&#39;confidences&#39;][tag] = confidence
    return self</code></pre>
</details>
</dd>
<dt id="vipy.object.Object.add_tags"><code class="name flex">
<span>def <span class="ident">add_tags</span></span>(<span>self, tags, confidences=[])</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L44-L47" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def add_tags(self, tags, confidences=[]):
    for (t,c) in zip_longest(tags, confidences):
        self.add_tag(t, c)
    return self</code></pre>
</details>
</dd>
<dt id="vipy.object.Object.append_attribute"><code class="name flex">
<span>def <span class="ident">append_attribute</span></span>(<span>self, key, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Append the value to attribute key, creating the key as an empty list if it does not exist</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L67-L72" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def append_attribute(self, key, value):
    &#34;&#34;&#34;Append the value to attribute key, creating the key as an empty list if it does not exist&#34;&#34;&#34;
    if key not in self.attributes:
        self.attributes[key] = []
    self.attributes[key].append(value)
    return self</code></pre>
</details>
</dd>
<dt id="vipy.object.Object.category"><code class="name flex">
<span>def <span class="ident">category</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L19-L20" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def category(self):
    return self.attributes[&#39;tags&#39;][0] if &#39;tags&#39; in self.attributes else None</code></pre>
</details>
</dd>
<dt id="vipy.object.Object.clear_attributes"><code class="name flex">
<span>def <span class="ident">clear_attributes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L63-L65" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def clear_attributes(self):
    self.attributes = {}
    return self</code></pre>
</details>
</dd>
<dt id="vipy.object.Object.confidence"><code class="name flex">
<span>def <span class="ident">confidence</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L25-L26" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def confidence(self):
    return self.get_attribute(&#39;confidences&#39;)[self.category()] if self.has_attribute(&#39;confidences&#39;) and self.category() in self.attributes[&#39;confidences&#39;] else None</code></pre>
</details>
</dd>
<dt id="vipy.object.Object.confidences"><code class="name flex">
<span>def <span class="ident">confidences</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L33-L34" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def confidences(self):
    return tuple(self.attributes[&#39;confidences&#39;][t] if t in self.aattributes[&#39;confidences&#39;] else None for t in self.tags())</code></pre>
</details>
</dd>
<dt id="vipy.object.Object.del_attribute"><code class="name flex">
<span>def <span class="ident">del_attribute</span></span>(<span>self, k)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L59-L61" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def del_attribute(self, k):
    self.attributes.pop(k, None)
    return self</code></pre>
</details>
</dd>
<dt id="vipy.object.Object.get_attribute"><code class="name flex">
<span>def <span class="ident">get_attribute</span></span>(<span>self, k)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L52-L53" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def get_attribute(self, k):
    return self.attributes[k] if k in self.attributes else None</code></pre>
</details>
</dd>
<dt id="vipy.object.Object.has_attribute"><code class="name flex">
<span>def <span class="ident">has_attribute</span></span>(<span>self, k)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L49-L50" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def has_attribute(self, k):
    return k in self.attributes</code></pre>
</details>
</dd>
<dt id="vipy.object.Object.has_normalized_coordinates"><code class="name flex">
<span>def <span class="ident">has_normalized_coordinates</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L74-L75" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def has_normalized_coordinates(self):
    return self.get_attribute(&#39;normalized_coordinates&#39;) == True</code></pre>
</details>
</dd>
<dt id="vipy.object.Object.new_category"><code class="name flex">
<span>def <span class="ident">new_category</span></span>(<span>self, category, confidence=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L22-L23" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def new_category(self, category, confidence=None):
    return self.del_attribute(&#39;confidences&#39;).del_attribute(&#39;tags&#39;).add_tag(category, confidence)</code></pre>
</details>
</dd>
<dt id="vipy.object.Object.set_attribute"><code class="name flex">
<span>def <span class="ident">set_attribute</span></span>(<span>self, k, v)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L55-L57" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def set_attribute(self, k, v):
    self.attributes[k] = v
    return self</code></pre>
</details>
</dd>
<dt id="vipy.object.Object.tags"><code class="name flex">
<span>def <span class="ident">tags</span></span>(<span>self, tags=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L28-L31" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def tags(self, tags=None):
    if tags is not None:
        return self.set_attribute(&#39;tags&#39;, tolist(tags))
    return self.attributes[&#39;tags&#39;] if &#39;tags&#39; in self.attributes else []</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="vipy.object.Track"><code class="flex name class">
<span>class <span class="ident">Track</span></span>
<span>(</span><span>keyframes, boxes, category=None, label=None, framerate=30, interpolation='linear', boundary='strict', attributes=None, id=None, filterbox=False)</span>
</code></dt>
<dd>
<div class="desc"><p>vipy.object.Track class</p>
<p>A track represents one or more labeled bounding boxes of an object instance through time.
A track is defined as a finite set of labeled boxes observed
at keyframes, which are discrete observations of this instance.
Each keyframe has an associated vipy.geometry.BoundingBox() which defines the spatial bounding box
of the instance in this keyframe.
The kwarg "interpolation" defines how the track is interpolated between keyframes, and the kwarg "boundary" defines how the
track is interpolated outside the (min,max) of the keyframes.
</p>
<p>Valid constructors are:</p>
<pre><code class="language-python">t = vipy.object.Track(keyframes=[0,100], boxes=[vipy.geometry.BoundingBox(0,0,10,10), vipy.geometry.BoundingBox(0,0,20,20)], label='Person')
t = vipy.object.Track(keyframes=[0,100], boxes=[vipy.geometry.BoundingBox(0,0,10,10), vipy.geometry.BoundingBox(0,0,20,20)], label='Person', interpolation='linear')
t = vipy.object.Track(keyframes=[10,100], boxes=[vipy.geometry.BoundingBox(0,0,10,10), vipy.geometry.BoundingBox(0,0,20,20)], label='Person', boundary='strict')
</code></pre>
<p>Tracks can be constructed incrementally:</p>
<pre><code class="language-python">t = vipy.object.Track('Person')
t.add(0, vipy.geometry.BoundingBox(0,0,10,10))
t.add(100, vipy.geometry.BoundingBox(0,0,20,20))
</code></pre>
<p>Tracks can be resampled at a new framerate, as long as the framerate is known when the keyframes are extracted</p>
<pre><code class="language-python">t.framerate(newfps)
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L262-L1180" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Track():
    &#34;&#34;&#34;vipy.object.Track class
    
    A track represents one or more labeled bounding boxes of an object instance through time.  A track is defined as a finite set of labeled boxes observed 
    at keyframes, which are discrete observations of this instance.  Each keyframe has an associated vipy.geometry.BoundingBox() which defines the spatial bounding box
    of the instance in this keyframe.  The kwarg &#34;interpolation&#34; defines how the track is interpolated between keyframes, and the kwarg &#34;boundary&#34; defines how the 
    track is interpolated outside the (min,max) of the keyframes.  

    Valid constructors are:

    ```python
    t = vipy.object.Track(keyframes=[0,100], boxes=[vipy.geometry.BoundingBox(0,0,10,10), vipy.geometry.BoundingBox(0,0,20,20)], label=&#39;Person&#39;)
    t = vipy.object.Track(keyframes=[0,100], boxes=[vipy.geometry.BoundingBox(0,0,10,10), vipy.geometry.BoundingBox(0,0,20,20)], label=&#39;Person&#39;, interpolation=&#39;linear&#39;)
    t = vipy.object.Track(keyframes=[10,100], boxes=[vipy.geometry.BoundingBox(0,0,10,10), vipy.geometry.BoundingBox(0,0,20,20)], label=&#39;Person&#39;, boundary=&#39;strict&#39;)
    ```

    Tracks can be constructed incrementally:

    ```python
    t = vipy.object.Track(&#39;Person&#39;)
    t.add(0, vipy.geometry.BoundingBox(0,0,10,10))
    t.add(100, vipy.geometry.BoundingBox(0,0,20,20))
    ```

    Tracks can be resampled at a new framerate, as long as the framerate is known when the keyframes are extracted

    ```python
    t.framerate(newfps)
    ```

    &#34;&#34;&#34;
    __slots__ = [&#39;_id&#39;, &#39;_label&#39;, &#39;_framerate&#39;, &#39;_interpolation&#39;, &#39;_boundary&#39;, &#39;attributes&#39;, &#39;_keyframes&#39;, &#39;_keyboxes&#39;]    
    def __init__(self, keyframes, boxes, category=None, label=None, framerate=30, interpolation=&#39;linear&#39;, boundary=&#39;strict&#39;, attributes=None, id=None, filterbox=False):
        keyframes = tolist(keyframes)
        boxes = tolist(boxes)        
        assert isinstance(keyframes, tuple) or isinstance(keyframes, list), &#34;Keyframes are required and must be tuple or list&#34;
        assert isinstance(boxes, tuple) or isinstance(boxes, list), &#34;Keyframe boundingboxes are required and must be tuple or list&#34;
        assert all([isinstance(bb, BoundingBox) for bb in boxes]), &#34;Keyframe bounding boxes must be vipy.geometry.BoundingBox objects&#34;
        assert filterbox or all([bb.isvalid() for bb in boxes]), &#34;All keyframe bounding boxes must be valid&#34;        
        assert not (label is not None and category is not None), &#34;Constructor requires either label or category kwargs, not both&#34;                
        assert len(keyframes) == len(boxes), &#34;Boxes and keyframes must be the same length, there must be a one to one mapping of frames to boxes&#34;
        assert boundary in set([&#39;extend&#39;, &#39;strict&#39;]), &#34;Invalid interpolation boundary - Must be [&#39;extend&#39;, &#39;strict&#39;]&#34;
        assert interpolation in set([&#39;linear&#39;]), &#34;Invalid interpolation - Must be [&#39;linear&#39;]&#34;
        assert framerate is not None, &#34;initial framerate for keyframes is required for framerate conversion&#34;
        
        self._id = shortuuid() if id is None else str(id)
        self._label = category if category is not None else label
        self._framerate = float(framerate) 
        self._interpolation = interpolation
        self._boundary = boundary
        self.attributes = attributes if attributes is not None else {}  # user must copy if needed
        self._keyframes = [int(np.round(f)) for f in keyframes]  # coerce to int
        self._keyboxes = boxes
        
        # Sorted increasing frame order
        if len(keyframes) &gt; 0 and len(boxes) &gt; 0 and not all([keyframes[i-1] &lt;= keyframes[i] for i in range(1,len(keyframes))]):
            (keyframes, boxes) = zip(*sorted([(f,bb) for (f,bb) in zip(keyframes, boxes)], key=lambda x: x[0]))
            self._keyframes = list(keyframes)
            self._keyboxes = list(boxes)

        # Filter boxes:  remove invalid boxes and keyframes
        if filterbox and len(keyframes) &gt; 0 and len(boxes) &gt; 0:
            kfbb = [(f,bb) for (f,bb) in zip(keyframes, boxes) if bb.isvalid()]
            (keyframes, boxes) = zip(*kfbb) if len(kfbb)&gt;0 else ([],[])
            self._keyframes = list(keyframes)
            self._keyboxes = list(boxes)
            if len(self) == 0:
                log.warning(&#39;vipy.object.Track - filtering invalid boxes with filterbox=True resulted in zero length track for track ID %s&#39; % str(self.id()))            
            
    @classmethod
    def from_json(cls, s):
        d = json.loads(s) if not isinstance(s, dict) else s
        d = {k.lstrip(&#39;_&#39;):v for (k,v) in d.items()}  # prettyjson (remove &#34;_&#34; prefix to attributes), legacy support
        return cls(keyframes=tuple(int(f) for f in d[&#39;keyframes&#39;]),
                   boxes=tuple([Detection.from_json(bbs) for bbs in d[&#39;keyboxes&#39;]]),
                   category=d[&#39;label&#39;] if &#39;label&#39; in d else None,
                   framerate=d[&#39;framerate&#39;] if &#39;framerate&#39; in d and d[&#39;framerate&#39;] is not None else 30,  # legacy support (pip_175k)
                   interpolation=d[&#39;interpolation&#39;] if &#39;interpolation&#39; in d else &#39;linear&#39;,
                   boundary=d[&#39;boundary&#39;],
                   attributes=d[&#39;attributes&#39;],
                   id=d[&#39;id&#39;] if &#39;id&#39; in d else None)

    def __json__(self):
        &#34;&#34;&#34;Serialization method for json package&#34;&#34;&#34;
        return self.json(encode=True)
    
    def json(self, encode=True):
        d = {k:getattr(self, k) if k != &#39;_keyboxes&#39; else tuple([bb.json(encode=False) for bb in getattr(self, k)]) for k in Track.__slots__}        
        d = {k.lstrip(&#39;_&#39;):v for (k,v) in d.items() if v is not None}  # prettyjson (remove &#34;_&#34; prefix to attributes)                
        d[&#39;keyframes&#39;] = tuple([int(f) for f in self._keyframes])
        return json.dumps(d) if encode else d

    def __repr__(self):
        strlist = []
        if self.category() is not None:
            strlist.append(&#39;category=&#34;%s&#34;&#39; % self.category())
        if self.endframe() is not None and self.startframe() is not None:
            strlist.append(&#39;startframe=%d, endframe=%d&#39; % (self.startframe(), self.endframe()))
        strlist.append(&#39;keyframes=%d&#39; % len(self._keyframes))
        return str(&#39;&lt;vipy.object.Track: %s&gt;&#39; % (&#39;, &#39;.join(strlist)))

    def __getitem__(self, k):
        &#34;&#34;&#34;Interpolate the track at frame k&#34;&#34;&#34;
        return self.linear_interpolation(k)

    def __iter__(self):
        &#34;&#34;&#34;Iterate over the track interpolating each frame from min(keyframes) to max(keyframes)&#34;&#34;&#34;
        for k in range(self.startframe(), self.endframe()+1):
            yield self.linear_interpolation(k)

    def __len__(self):
        &#34;&#34;&#34;The length of a track is the total number of interpolated frames, or zero if degenerate&#34;&#34;&#34;
        return max(0, self.endframe() - self.startframe() + 1) if (len(self._keyframes)&gt;0 and len(self._keyboxes)&gt;0) else 0

    def isempty(self):
        return self.__len__() == 0

    def has_normalized_coordinates(self):
        return all(isinstance(bb, Detection) and bb.has_normalized_coordinates() for bb in self.keyboxes())
    
    def confidence(self, last=None, samples=None):
        &#34;&#34;&#34;The confidence of a track is the mean confidence of all (or just last=last frames, or samples=samples uniformly spaced) keyboxes (if confidences are available) else 0&#34;&#34;&#34;
        if samples is not None:
            dt = max(1, int(round(len(self._keyframes)/float(samples))))
            C = [self._keyboxes[i]._confidence for i in range(len(self._keyframes)-1, -1, -dt) if (hasattr(self._keyboxes[i], &#39;_confidence&#39;) and self._keyboxes[i]._confidence is not None)]
        elif last == 1:
            return self.endbox().confidence() if len(self)&gt;0 else 0
        else:
            ef = self.endframe() - last if last is not None else 0
            C = [d._confidence for (f,d) in zip(self.keyframes(), self.keyboxes()) if f &gt;= ef and (hasattr(d, &#39;_confidence&#39;) and d._confidence is not None)]
        return C[0] if len(C) == 1 else (float(np.mean(C)) if len(C) &gt; 0 else 0)
        
    def isdegenerate(self):
        &#34;&#34;&#34;Is the track degenerate?  
        
        A degenerate track has:
            - Unequal length keyboxes and keyframes
            - length zero track
            - Non increasing keyframes
            - Invalid keyboxes
        &#34;&#34;&#34;
        return not (len(self.keyboxes()) == len(self.keyframes()) and
                    (len(self) == 0 or all([bb.isvalid() for bb in self.keyboxes()])) and
                    sorted(self.keyframes()) == list(self.keyframes()))
    
    def dict(self):
        &#34;&#34;&#34;Return a python dictionary containing the relevant serialized attributes suitable for JSON encoding&#34;&#34;&#34;
        return self.json(encode=False)

    
    def add(self, keyframe, bbox, strict=True):
        &#34;&#34;&#34;Add a new keyframe and associated box to track, preserve sorted order of keyframes.  If keyframe is already in track, throw an exception.  In this case use update() instead

           -strict [bool]:  If box is degenerate, throw an exception if strict=True, otherwise just don&#39;t add it
        
        .. note::  The BoundingBox is added by reference.  If you want to this to be a copy, pass in bbox.clone()
        &#34;&#34;&#34;
        assert isinstance(bbox, BoundingBox), &#34;Invalid input - Box must be vipy.geometry.BoundingBox()&#34;
        assert strict is False or bbox.isvalid(), &#34;Invalid input - Box must be non-degenerate&#34;
        assert int(keyframe) not in self._keyframes, &#34;Invalid input - repeated keyframe&#34;
        if not bbox.isvalid():            
            return self  # just don&#39;t add it 
        self._keyframes.append(int(keyframe))
        self._keyboxes.append(bbox)  # not cloned()
        if len(self._keyframes) &gt; 1 and keyframe &lt; self._keyframes[-2]:
            # Preserve sorted order if inserting into the middle somewhere
            (self._keyframes, self._keyboxes) = zip(*sorted([(f,bb) for (f,bb) in zip(self._keyframes, self._keyboxes)], key=lambda x: x[0]))        
            self._keyframes = list(self._keyframes)
            self._keyboxes = list(self._keyboxes)
        return self

    def update(self, keyframe, bbox):
        if keyframe in self._keyframes:
            self.delete(keyframe)
        self.add(keyframe, bbox)
        return self
        
    def replace(self, keyframe, box):
        &#34;&#34;&#34;Replace the keyframe and associated box(es), preserve sorted order of keyframes&#34;&#34;&#34;
        return self.delete(keyframe).add(keyframe, box)

    def delete(self, keyframe):
        &#34;&#34;&#34;Replace a keyframe and associated box to track, preserve sorted order of keyframes&#34;&#34;&#34;
        while keyframe in self._keyframes:
            k = self._keyframes.index(keyframe)
            del self._keyboxes[k]
            del self._keyframes[k]
        return self
    
    def keyframes(self):
        &#34;&#34;&#34;Return keyframe frame indexes where there are track observations&#34;&#34;&#34;
        return self._keyframes

    def num_keyframes(self):
        return len(self._keyframes)

    def keyboxes(self, boxes=None, keyframes=None):
        &#34;&#34;&#34;Return keyboxes where there are track observations&#34;&#34;&#34;
        if boxes is None and keyframes is None:
            return self._keyboxes
        else:
            assert all([isinstance(bb, BoundingBox) for bb in boxes])
            self._keyboxes = boxes
            self._keyframes = keyframes if keyframes is not None else self._keyframes
            assert not self.isdegenerate()
            return self
        
    def meanshape(self):
        &#34;&#34;&#34;Return the mean (width,height) of the box during the track, or None if the track is degenerate&#34;&#34;&#34;
        s = np.mean([bb.shape() for bb in self.keyboxes()], axis=0) if len(self.keyboxes()) &gt; 0 else None
        return (float(s[0]), float(s[1])) if s is not None else None

    def meanbox(self):
        &#34;&#34;&#34;Return the mean bounding box during the track, or None if the track is degenerate&#34;&#34;&#34;
        return BoundingBox(ulbr=np.mean([bb.ulbr() for bb in self.keyboxes()], axis=0)) if len(self.keyboxes()) &gt; 0 else None 
    
    def shapevariance(self):
        &#34;&#34;&#34;Return the variance (width, height) of the box shape relative to `vipy.object.Track.meanbox` during the track or None if the track is degenerate.  

        This is useful for filtering spurious tracks where the aspect ratio changes rapidly and randomly

        Returns:
            (width_variance, height_variance) of the box shape during the track (or None)
        &#34;&#34;&#34;
        m = self.meanshape()
        return (float(np.mean([(bb.width() - m[0])**2 for bb in self.keyboxes()])), 
                float(np.mean([(bb.height() - m[1])**2 for bb in self.keyboxes()]))) if m is not None else None


    def framerate(self, fps=None, speed=None):
        &#34;&#34;&#34;Resample keyframes from known original framerate set by constructor to be new framerate fps.

        Args:
            fps: [float]  The new frame rate in frames per second
            speed: [float]  An optional speed factor which will multiply the current framerate by this factor (e.g. speed=2 --&gt; fps=self.framerate()*2)

        Returns:
            This track object with the keyframes resampled to the new framerate

        &#34;&#34;&#34;
        if fps is None and speed is None:
            return self._framerate
        
        assert self._framerate is not None, &#34;Framerate conversion requires that the framerate is known for current keyframes.  This must be provided to the vipy.object.Track() constructor.&#34;
        assert fps is not None or speed is not None, &#34;Invalid input&#34;
        assert not (fps is not None and speed is not None), &#34;Invalid input&#34;
        assert speed is None or speed &gt; 0, &#34;Invalid speed, must specify speed multiplier s=1, s=2 for 2x faster, s=0.5 for half slower&#34;
        
        fps = float(fps) if fps is not None else (1.0/speed)*self._framerate
        self._keyframes = [int(np.round(f*(fps/float(self._framerate)))) for f in self._keyframes]
        self._framerate = fps
        return self
        
    def startframe(self):
        &#34;&#34;&#34;Return the startframe of the track or None if there are no keyframes.  
        
        The frame index is relative to the framerate set in the constructor.

        &#34;&#34;&#34;        
        return int(self._keyframes[0]) if len(self._keyframes)&gt;0 else None  # assumes sorted order

    def endframe(self):
        &#34;&#34;&#34;Return the endframe of the track or None if there are no keyframes.

        The frame index is relative to the framerate set in the constructor.
        &#34;&#34;&#34;
        return int(self._keyframes[-1]) if len(self._keyframes)&gt;0 else None  # assumes sorted order

    def duration(self):
        &#34;&#34;&#34;The length of the track in seconds.

        Returns:
            The duration in seconds of this track object
        &#34;&#34;&#34;
        assert self.framerate() is not None, &#34;Framerate must be set in constructor&#34;
        return len(self) / float(self.framerate())
    
    def linear_interpolation(self, f):
        &#34;&#34;&#34;Linear bounding box interpolation at frame=f given observed boxes (x,y,w,h) at keyframes.  

        This returns a `vipy.object.Detection` which is the interpolation of the `vipy.object.Track` at frame k

        - If self._boundary=&#39;extend&#39;, then boxes are repeated if the interpolation is outside the keyframes
        - If self._boundary=&#39;strict&#39;, then interpolation returns None if the interpolation is outside the keyframes
        
        .. note::  
            - The returned BoundingBox object is not cloned when possible for speed purposes, be careful when modifying this object.  clone() the returned object if necessary
            - This means that we return a reference to the underlying keybox upgraded with track properties and cast as `vipy.object.Detection`.  If you modify this object, then the track keybox will be modfied.
        &#34;&#34;&#34;
        assert len(self._keyboxes) &gt; 0, &#34;Degenerate object for interpolation&#34;   # not self.isempty()
        if len(self._keyboxes) == 1:
            return Detection.cast(self._keyboxes[0].clone()).new_category(self.category()).set_attribute(&#39;__trackid&#39;, self.id()) if (self._boundary == &#39;extend&#39; or self.during(f)) else None
        if f in self._keyframes:            
            return Detection.cast(self._keyboxes[self._keyframes.index(f)].clone()).new_category(self.category()).set_attribute(&#39;__trackid&#39;, self.id())  # clone requuired to not pollute attributes

        kf = self._keyframes
        ft = min(max(f, kf[0]), kf[-1])  # truncated frame index
        for i in reversed(range(0, len(kf)-1)):
            if kf[i] &lt;= ft and kf[i+1] &gt;= ft:
                break  # floor keyframe index
        c = (ft - kf[i]) / max(1, float(kf[i+1] - kf[i]))  # interpolation coefficient
        (bi, bj) = (self._keyboxes[i], self._keyboxes[i+1])
        d = Detection(xmin=bi._xmin + c*(bj._xmin - bi._xmin),   # float(np.interp(k, self._keyframes, [bb._xmin for bb in self._keyboxes])),
                      ymin=bi._ymin + c*(bj._ymin - bi._ymin),   # float(np.interp(k, self._keyframes, [bb._ymin for bb in self._keyboxes])),
                      xmax=bi._xmax + c*(bj._xmax - bi._xmax),   # float(np.interp(k, self._keyframes, [bb._xmax for bb in self._keyboxes])),
                      ymax=bi._ymax + c*(bj._ymax - bi._ymax),   # float(np.interp(k, self._keyframes, [bb._ymax for bb in self._keyboxes])),
                      confidence=bi.confidence() if isinstance(bi, Detection) else None,
                      attributes=bi.attributes.copy() if isinstance(bi, Detection) else None,  # unshared attributes (to allow for __trackid)
                      category=self.category())

        d.attributes[&#39;__trackid&#39;] = self.id()  # for correspondence of detections to tracks
        return d if self._boundary == &#39;extend&#39; or self.during(f) else None

    def category(self, label=None):
        &#34;&#34;&#34;Set the track category to label.  Updates all keyboxes&#34;&#34;&#34;
        if label is not None:
            self._label = label
            self.boxmap(lambda bb: bb.category(self._label) if isinstance(bb, Detection) else bb)
            return self
        else:
            return self._label
    
    def categoryif(self, ifcategory, tocategory=None):
        &#34;&#34;&#34;If the current category is equal to ifcategory, then change it to newcategory.

        Args:
            
            ifcategory [dict, str]: May be a dictionary {ifcategory:tocategory}, or just an ifcategory
            tocategory [str]:  the target category 

        Returns:
        
            this object with the category changed.

        .. note:: This is useful for converting synonyms such as self.categoryif(&#39;motorbike&#39;, &#39;motorcycle&#39;)
        &#34;&#34;&#34;
        assert (isinstance(ifcategory, dict) and tocategory is None) or tocategory is not None

        if isinstance(ifcategory, dict):
            for (k,v) in ifcategory.items():
                self.categoryif(k, v)
        elif self.category() == ifcategory:
            self.category(tocategory)
        return self

    def label(self, label):
        &#34;&#34;&#34;Alias for category&#34;&#34;&#34;
        return self.category(label)
        
    def during(self, k_start, k_end=None):
        &#34;&#34;&#34;Does the track contain a keyframe during the time interval (startframe, endframe) inclusive?&#34;&#34;&#34;        
        k_end = k_start+1 if k_end is None else k_end
        (startframe, endframe) = (self.startframe(), self.endframe())
        return len(self)&gt;0 and ((k_start &gt;= startframe and k_start &lt;= endframe) or (k_end &gt;= startframe and k_end &lt;= endframe) or (k_start &lt;= startframe and k_end &gt;= endframe))
        
    def during_interval(self, k_start, k_end):
        &#34;&#34;&#34;Does the track contain a keyframe during the inclusive frame interval (startframe, endframe)?

        .. note:: The start and end frames are inclusive
        &#34;&#34;&#34;
        return self.during(k_start, k_end)

    def within(self, starframe, endframe):
        &#34;&#34;&#34;Is the track within the frame range (startframe, endframe)?&#34;&#34;&#34;
        return self.startframe() &gt;= startframe and self.endframe() &lt;= endframe
    
    def offset(self, dt=0, dx=0, dy=0):
        &#34;&#34;&#34;Apply a temporal shift of dt frames, and a spatial shift of (dx, dy) pixels.
        
        Args:
            dt: [int] frame offset
            dx: [float] horizontal spatial offset 
            dy: [float] vertical spatial offset 

        Returns:
            This box updated in place
        &#34;&#34;&#34;
        dt = int(np.round(dt*self.framerate())) if isinstance(dt, float) else dt
        self._keyboxes = [bb.offset(dx, dy) for bb in self._keyboxes]
        self._keyframes = [(f+dt) for f in self._keyframes]
        return self

    def uncrop(self, bb, s=1):
        &#34;&#34;&#34;Apply a transformation to the track that will undo a crop of a bounding box with an optional scale factor.

        A typical operation is as follows.  A video is cropped and zommed in order to run a detector on a region of interest.  However, we want to align the resulting tracks on the original video before the crop and zoom.  

        Args:
            bb: [`vipy.geometry.BoundingBox`].  A bounding box which was used to crop this track
            s: [float]  A scale factor applied after the bounding box crop

        Returns:
            This track after undoing the scale and crop 
        &#34;&#34;&#34;
        assert isinstance(bb, BoundingBox)
        return self.rescale(1/s).offset(dt=0, dx=bb.xmin(), dy=bb.ymin())

    def frameoffset(self, dx, dy):
        &#34;&#34;&#34;Offset boxes by (dx,dy) in each frame.
        
        This is used to apply a different offset for each frame.  To apply one offset to all frames, use `vipy.object.Track.offset`.
        Args:
            dx: [list]  This should be a list of frame offsets at each keyframe the same length as the number of keyboxes
            dy: [list]  This should be a list of frame offsets at each keyframe the same length as the number of keyboxes

        Returns:
            This track updated in place
        &#34;&#34;&#34;
        assert isinstance(dx, list) or isinstance(dx, tuple)
        assert isinstance(dy, list) or isinstance(dy, tuple)
        assert len(self.keyboxes()) == len(dx) and len(self.keyboxes()) == len(dy)
        self._keyboxes = [bb.offset(dx=x, dy=y) for (bb, (x, y)) in zip(self._keyboxes, zip(dx, dy))]
        return self

    def truncate(self, start=None, end=None):
        &#34;&#34;&#34;Truncate a track so that any keyframes less than startframe or greater than endframe (inclusive) are removed.  Interpolate keyboxes at (startframe, endframe) endpoints.

        Args:
            start: [int|float] The start of the truncation relative to the track framerate.  All keyframes less than or equal to startframe are included.  If the keyframe does not exist at startframe, one is interpolated and added.
            end: [int|float] The end of the truncation relative to the track framerate.  All keyframes greater than or equal to the endframe are included.  If the keyfrmae does not exist at endframe, one is interpolated and added.

        Returns:
            This track such that all keyboxes &lt;= startframe or &gt;= endframe are removed.

        .. note::  The startframe and endframe for truncation are inclusive.  
        &#34;&#34;&#34;
        startframe = int(np.round(start*self.framerate())) if isinstance(start, float) else start
        endframe = int(np.round(end*self.framerate())) if isinstance(end, float) else end        
        
        if startframe is not None and startframe not in self._keyframes and self[startframe] is not None:
            self.add(startframe, self[startframe].clone())  # interpolated boundary condition
        if endframe is not None and endframe not in self._keyframes and self[endframe] is not None:
            self.add(endframe, self[endframe].clone())  # intepolated boundary condition
        kfkb = [(kf,kb) for (kf,kb) in zip(self._keyframes, self._keyboxes) if ((startframe is None or kf &gt;= startframe) and (endframe is None or kf &lt;= endframe))]
        (self._keyframes, self._keyboxes) = zip(*kfkb) if len(kfkb) &gt; 0 else ([], [])
        return self
        
    def rescale(self, s):
        &#34;&#34;&#34;Rescale track boxes by scale factor s&#34;&#34;&#34;
        if s != 1.0:
            self._keyboxes = [bb.rescale(s) for bb in self._keyboxes]
        return self

    def scale(self, s):
        &#34;&#34;&#34;Alias for rescale&#34;&#34;&#34;
        return self.rescale(s)

    def scale_x(self, sx):
        &#34;&#34;&#34;Rescale track boxes by scale factor sx&#34;&#34;&#34;
        self._keyboxes = [bb.scale_x(sx) for bb in self._keyboxes]
        return self

    def scale_y(self, sy):
        &#34;&#34;&#34;Rescale track boxes by scale factor sx&#34;&#34;&#34;
        self._keyboxes = [bb.scale_y(sy) for bb in self._keyboxes]
        return self

    def dilate(self, s):
        &#34;&#34;&#34;Dilate track boxes by scale factor s&#34;&#34;&#34;
        self._keyboxes = [bb.dilate(s) for bb in self._keyboxes]
        return self

    def maxsquare(self):
        &#34;&#34;&#34;Set all of the track boxes to maxsquare&#34;&#34;&#34;
        self._keyboxes = [bb.maxsquare() for bb in self._keyboxes]
        return self
    
    def rot90cw(self, H, W):
        &#34;&#34;&#34;Rotate an image with (H,W)=shape 90 degrees clockwise and update all boxes to be consistent&#34;&#34;&#34;
        self._keyboxes = [bb.rot90cw(H, W) for bb in self._keyboxes]
        return self

    def rot90ccw(self, H, W):
        &#34;&#34;&#34;Rotate an image with (H,W)=shape 90 degrees clockwise and update all boxes to be consistent&#34;&#34;&#34;
        self._keyboxes = [bb.rot90ccw(H, W) for bb in self._keyboxes]
        return self

    def fliplr(self, H, W):
        &#34;&#34;&#34;Flip an image left and right (mirror about vertical axis)&#34;&#34;&#34;
        self._keyboxes = [bb.fliplr(width=W) for bb in self._keyboxes]
        return self

    def flipud(self, H, W):
        &#34;&#34;&#34;Flip an image left and right (mirror about vertical axis)&#34;&#34;&#34;
        self._keyboxes = [bb.flipud(height=H) for bb in self._keyboxes]
        return self

    def id(self, newid=None):
        if newid is None:
            return self._id
        else:
            self._id = newid
            return self

    def clone(self, startframe=None, endframe=None, rekey=False):
        #return copy.deepcopy(self)  
        t = Track.from_json(self.json(encode=False)) if (startframe is None and endframe is None) else self.clone_during(startframe, endframe)  # 2x faster than deepcopy
        t.attributes = t.attributes.copy()
        if rekey:
            t.id(newid=shortuuid())
        return t
    
    def clone_during(self, startframe, endframe):
        &#34;&#34;&#34;Clone a track during a specific interval (startframe, endframe) relative to the framerate of the track.

        - This is useful for copying a small segment of a long track without the expense of copying the whole track.  
        - All keyframes and keyboxes not in (startframe, endframe) are not copied.
        - Boundary keyframes are copied to enable proper interpolation.        
        &#34;&#34;&#34;
        # Update (startframe,endframe) to be the keyframes just before startframe and the keyframe just after endframe so that interpolation will work correctly
        (startframe, endframe) = (([kf for kf in self._keyframes if kf &lt;= startframe][-1]) if self.during(startframe, startframe) else startframe,
                                  ([kf for kf in self._keyframes if kf &gt;= endframe][0]) if self.during(endframe, endframe) else endframe)
        kfkb = [(kf,kb.clone()) for (kf,kb) in zip(self._keyframes, self._keyboxes) if ((startframe is None or kf &gt;= startframe) and (endframe is None or kf &lt;= endframe))]
        (kf, kb) = zip(*kfkb) if len(kfkb) &gt; 0 else ([], [])        
        return Track(keyframes=kf, boxes=kb, category=self.category(), framerate=self._framerate, interpolation=self._interpolation, boundary=self._boundary, attributes=self.attributes.copy(), id=self._id)
    
    def boundingbox(self, startframe=None, endframe=None):
        &#34;&#34;&#34;The bounding box of a track is the smallest spatial box that contains all of the BoundingBoxes of the track  within startframe and endframe, or None if there are no detections.
        
        Args:
            startframe: [int] the startframe of the track to compute the bounding box.
            endframe: [int] the endframe of the track to compute the bounding box.
        
        Returns:
            `vipy.geometry.BoundingBox` which is the smallest box that contains all boxes of the track from (startframe, endframe)
        &#34;&#34;&#34;
        t = self.clone() if (startframe is None and endframe is None) else self.clone().truncate(startframe, endframe)
        d = t._keyboxes[0].clone() if len(t._keyboxes) &gt;= 1 else None
        return d.union([bb for (k,bb) in zip(t._keyframes[1:], t._keyboxes[1:]) if t.during(k)]) if (d is not None and len(t._keyboxes) &gt;= 2) else d

    def smallestbox(self):
        &#34;&#34;&#34;The smallest box of a track is the smallest spatial box in area along the track&#34;&#34;&#34;
        k = np.argmin([bb.area() for bb in self._keyboxes]) if len(self._keyboxes) &gt; 0 else None
        return self._keyboxes[k] if k is not None else None

    def biggestbox(self):
        &#34;&#34;&#34;The biggest box of a track is the largest spatial box in area along the track&#34;&#34;&#34;
        k = np.argmax([bb.area() for bb in self._keyboxes]) if len(self._keyboxes) &gt; 0 else None
        return self._keyboxes[k] if k is not None else None
        
    def pathlength(self):
        &#34;&#34;&#34;The path length of a track is the cumulative Euclidean distance in pixels that the box travels&#34;&#34;&#34;
        return float(np.sum([bb_next.dist(bb_prev) for (bb_next, bb_prev) in zip(self._keyboxes[1:], self._keyboxes[0:-1])])) if len(self._keyboxes)&gt;1 else 0.0
        
    def startbox(self):
        &#34;&#34;&#34;The startbox is the first bounding box in the track&#34;&#34;&#34;
        return self._keyboxes[0] if len(self._keyboxes) &gt; 0 else None

    def endbox(self):
        &#34;&#34;&#34;The endbox is the last box in the track&#34;&#34;&#34;
        return self._keyboxes[-1] if len(self._keyboxes) &gt; 0 else None

    def loop_closure_distance(self):
        &#34;&#34;&#34;The loop closure track distance is the Euclidean distance in pixels between the start frame bounding box and end frame bounding box&#34;&#34;&#34;
        return self.startbox().dist(self.endbox()) if not self.isdegenerate() else None

    def boundary(self, b=None):
        if b is None:
            return self._boundary
        else:
            assert b in [&#39;strict&#39;, &#39;extend&#39;]
            self._boundary = b
            return self
        
    def clip(self, start, end):
        &#34;&#34;&#34;Clip a track to be within (start,end) with strict boundary handling.  

        Start and end may be frame numbers (int) or seconds (float).  Frames are relative to the current frame rate.

        Args:
            start [int|float]:  The start of the clip in frames|seconds
            end [int|float|None]:  The end of the clip in frames|seconds (if provided)
        &#34;&#34;&#34;
        startframe = int(np.round(start*self.framerate())) if isinstance(start, float) else start
        endframe = int(np.round(end*self.framerate())) if isinstance(end, float) else start        
        
        if self[startframe] is not None:
            self.add(startframe, self[startframe])
        if self[endframe] is not None:
            self.add(endframe, self[endframe])
        keyframes = [f for (f,bb) in zip(self._keyframes, self._keyboxes) if f&gt;=startframe and f&lt;=endframe]  # may be empty
        keyboxes = [bb for (f,bb) in zip(self._keyframes, self._keyboxes) if f&gt;=startframe and f&lt;=endframe]  # may be empty
        if len(keyframes) == 0 or len(keyboxes) == 0:
            raise ValueError(&#39;Track does not contain any keyboxes within the requested frames (%d,%d)&#39; % (startframe, endframe))
        self._keyframes = keyframes
        self._keyboxes = keyboxes
        self._boundary = &#39;strict&#39;
        return self

    def iou(self, other, dt=1):
        &#34;&#34;&#34;Compute the spatial IoU between two tracks as the mean IoU per frame in the range (self.startframe(), self.endframe())&#34;&#34;&#34;
        return self.rankiou(other, rank=len(self), dt=dt)

    def segment_maxiou(self, other, startframe, endframe):
        &#34;&#34;&#34;Return the maximum framewise bounding box IOU between self and other in the range (startframe, endframe)&#34;&#34;&#34;
        assert isinstance(other, Track), &#34;invalid input - Must be vipy.object.Track()&#34;
        assert startframe &lt; endframe
        return max([self[k].iou(other[k]) if (self[k] is not None) else 0 for k in range(startframe, endframe)])
    
    def maxiou(self, other, dt=1):
        &#34;&#34;&#34;Compute the maximum spatial IoU between two tracks per frame in the range (self.startframe(), self.endframe())&#34;&#34;&#34;        
        return self.rankiou(other, rank=1, dt=dt)

    def fragmentiou(self, other, dt=5):
        &#34;&#34;&#34;A fragment is a track that is fully contained within self&#34;&#34;&#34;
        assert isinstance(other, Track), &#34;invalid input - Must be vipy.object.Track()&#34;        
        startframe = max(self.startframe(), other.startframe())
        endframe = min(self.endframe(), other.endframe())
        return float(np.min([self[min(k,endframe)].iou(other[min(k,endframe)]) for k in range(startframe, endframe, dt)])) if (other.startframe() &gt;= self.startframe() and other.endframe() &lt;= self.endframe() and endframe &gt; startframe) else 0
        
    def endpointiou(self, other):
        &#34;&#34;&#34;Compute the mean spatial IoU between two tracks at the two overlapping endpoints.  useful for track continuation&#34;&#34;&#34;        
        assert isinstance(other, Track), &#34;invalid input - Must be vipy.object.Track()&#34;
        startframe = max(self.startframe(), other.startframe())
        endframe = min(self.endframe(), other.endframe())
        return float(np.mean([self[startframe].iou(other[startframe]), self[endframe].iou(other[endframe])]) if endframe &gt; startframe else 0.0)

    def segmentiou(self, other, dt=5):
        &#34;&#34;&#34;Compute the mean spatial IoU between two tracks at the overlapping segment, sampling by dt.  Useful for track continuation for densely overlapping tracks&#34;&#34;&#34;
        assert isinstance(other, Track), &#34;invalid input - Must be vipy.object.Track()&#34;
        startframe = max(self.startframe(), other.startframe())
        endframe = min(self.endframe(), other.endframe())   # inclusive
        return float(np.mean([self[min(k,endframe)].iou(other[min(k,endframe)]) for k in range(startframe, endframe, dt)]) if endframe &gt; startframe else 0.0)

    def segmentcover(self, other, dt=5):
        &#34;&#34;&#34;Compute the mean spatial cover between two tracks at the overlapping segment, sampling by dt.  Useful for track continuation for densely overlapping tracks&#34;&#34;&#34;
        assert isinstance(other, Track), &#34;invalid input - Must be vipy.object.Track()&#34;
        startframe = max(self.startframe(), other.startframe())
        endframe = min(self.endframe(), other.endframe())   # inclusive
        return float(np.mean([self[min(k,endframe)].maxcover(other[min(k,endframe)]) for k in range(startframe, endframe, dt)]) if endframe &gt; startframe else 0.0)
        
    def rankiou(self, other, rank, dt=1):
        &#34;&#34;&#34;Compute the mean spatial IoU between two tracks per frame in the range (self.startframe(), self.endframe()) using only the top-k (rank) frame overlaps
           Sample tracks at endpoints and n uniformly spaced frames or a stride of dt frames.  
        
           - rank [&gt;1]:  The top-k best IOU overlaps to average when computing the rank IOU
           - This is useful for track continuation where the box deforms in the overlapping segment at the end due to occlusion. 
           - This is useful for track correspondence where a ground truth box does not match an estimated box precisely (e.g. loose box, non-visually grounded box)
           - This is the robust version of segmentiou.
           - Use percentileiou to determine the rank based a fraction of the length of the overlap, which will be more efficient for long tracks
        &#34;&#34;&#34;
        assert rank &gt;= 1 and rank &lt;= len(self)
        assert isinstance(other, Track), &#34;Invalid input - must be vipy.object.Track()&#34;
        assert dt &gt;= 1
        frames = [self.startframe()] + list(range(self.startframe()+dt, self.endframe(), dt)) + [self.endframe()]
        return float(np.mean(sorted([self[k].iou(other[k]) if (self.during(k) and other.during(k)) else 0.0 for k in frames])[-rank:]))

    def percentileiou(self, other, percentile, samples=100):
        &#34;&#34;&#34;Percentile iou returns rankiou for rank=percentile*len(overlap(self, other))
        
           -other [Track]
           -percentile [0,1]:  The top-k best overlaps to average when computing rankiou
           -samples:  The number of uniformly spaced samples to take along the track for computing the rankiou
        &#34;&#34;&#34;
        assert percentile &gt; 0 and percentile &lt;= 1
        assert isinstance(other, Track), &#34;invalid input - Must be vipy.object.Track()&#34;
        assert self.framerate() == other.framerate()
        
        startframe = max(self.startframe(), other.startframe())
        endframe = min(self.endframe(), other.endframe())
        segmentlen = endframe - startframe
        dt = max(1, int(np.floor(segmentlen/samples)))
        return self.rankiou(other, max(1, int(segmentlen*percentile)), dt=dt) if segmentlen &gt; 0 else 0

    def segment_percentileiou(self, other, percentile, samples=100):
        &#34;&#34;&#34;percentiliou on the overlapping segment with other&#34;&#34;&#34;
        assert percentile &gt; 0 and percentile &lt;= 1
        assert isinstance(other, Track), &#34;invalid input - Must be vipy.object.Track()&#34;
        assert self.framerate() == other.framerate()
        
        startframe = max(self.startframe(), other.startframe())
        endframe = min(self.endframe(), other.endframe())
        segmentlen = endframe - startframe
        rank = int(segmentlen*percentile)
        dt = max(1, int(np.floor(segmentlen/samples)))
        iou = sorted([self[min(k,endframe)].iou(other[min(k,endframe)]) for k in range(startframe, endframe, dt)]) if endframe &gt; startframe else []
        return float(np.mean(iou[-rank:]) if endframe &gt; startframe else 0.0)


    def segment_percentilecover(self, other, percentile, samples=100):
        &#34;&#34;&#34;percentile cover on the overlapping segment with other&#34;&#34;&#34;
        assert percentile &gt; 0 and percentile &lt;= 1
        assert isinstance(other, Track), &#34;invalid input - Must be vipy.object.Track()&#34;
        assert self.framerate() == other.framerate()
        
        startframe = max(self.startframe(), other.startframe())
        endframe = min(self.endframe(), other.endframe())
        segmentlen = endframe - startframe
        rank = int(segmentlen*percentile)
        dt = max(1, int(np.floor(segmentlen/samples)))
        bblist = [(self[min(k,endframe)], other[min(k,endframe)]) for k in range(startframe, endframe, dt)] if endframe &gt; startframe else []
        cover = [max(bbself.cover(bbother), bbother.cover(bbself)) for (bbself, bbother) in bblist]
        return float(np.mean(cover[-rank:]) if endframe &gt; startframe else 0.0)

    def union(self, other, overlap=&#39;average&#39;):
        &#34;&#34;&#34;Compute the union of two tracks.  Overlapping boxes between self and other:
        
           Inputs
             - average [bool]:  average framewise interpolated boxes at overlapping keyframes
             - replace [bool]:  replace the box with other if other and self overlap at a keyframe
             - keep [bool]:  keep the box from self (discard other) at a keyframe
        &#34;&#34;&#34;
        assert isinstance(other, Track), &#34;Invalid input - must be vipy.object.Track()&#34;
        assert other.category() == self.category(), &#34;Category mismatch&#34;
        assert overlap in [&#39;average&#39;, &#39;replace&#39;, &#39;keep&#39;], &#34;Invalid input - &#39;overlap&#39; must be in [average, replace, keep]&#34;
        T = self.clone()
        keyframes = sorted(set(T._keyframes+other._keyframes))
        T._keyboxes = [((self[k].average(other[k]) if (overlap == &#39;average&#39;) else (self[k] if (overlap == &#39;keep&#39;) else other[k]))
                        if (self.during(k) and other.during(k)) else 
                        (self[k] if (self.during(k) and not other.during(k)) else (other[k])))
                       for k in keyframes] 
        T._keyframes = keyframes
        return T  


    def average(self, other):
        &#34;&#34;&#34;Compute the average of two tracks by the framewise interpolated boxes at the keyframes of this track&#34;&#34;&#34;
        assert isinstance(other, Track), &#34;Invalid input - must be vipy.object.Track()&#34;
        assert other.category() == self.category(), &#34;Category mismatch&#34;
        T = self.clone()
        T._keyboxes = [(self[k].average(other[k]) 
                        if (self.during(k) and other.during(k)) else (self[k] if (self.during(k) and not other.during(k)) else (other[k])))
                       for k in T._keyframes]  
        return T  

    def temporal_distance(self, other):
        &#34;&#34;&#34;The temporal distance between two tracks is the minimum number of frames separating them&#34;&#34;&#34;
        assert isinstance(other, Track), &#34;Invalid input - must be vipy.object.Track()&#34;
        return max(max(self.startframe() - other.endframe(), other.startframe() - self.endframe()), 0)

    def smooth(self, width):
        &#34;&#34;&#34;Track smoothing by averaging neighboring keyboxes&#34;&#34;&#34;
        assert isinstance(width, int) and width &gt; 0
        if len(self._keyboxes) &gt; width:
            self._keyboxes = [bb.clone().average(bbnbrs) for (bb, bbnbrs) in zip(self._keyboxes, chunklistwithoverlap(self._keyboxes, width, width-1))] 
        return self

    def smoothshape(self, width):
        &#34;&#34;&#34;Track smoothing by averaging width and height of neighboring keyboxes&#34;&#34;&#34;
        assert isinstance(width, int) and width &gt; 0
        if len(self._keyboxes) &gt; width:
            self._keyboxes = [bb.clone().averageshape(bbnbrs) for (bb, bbnbrs) in zip(self._keyboxes, chunklistwithoverlap(self._keyboxes, width, width-1))]
        return self

    def medianshape(self, width):
        &#34;&#34;&#34;Track smoothing by median width and height of neighboring keyboxes&#34;&#34;&#34;
        assert isinstance(width, int) and width &gt; 0
        if len(self._keyboxes) &gt; width:
            self._keyboxes = [bb.clone().medianshape(bbnbrs) for (bb, bbnbrs) in zip(self._keyboxes, chunklistwithoverlap(self._keyboxes, width, width-1))]
        return self

    def spline(self, smoothingfactor=None, strict=True, startframe=None, endframe=None):
        &#34;&#34;&#34;Track smoothing by cubic spline fit, will return resampled dt=1 track.  Smoothing factor will increase with smoothing &gt; 1 and decrease with 0 &lt; smoothing &lt; 1
        
           This function requires optional package scipy
        &#34;&#34;&#34;
        try_import(&#39;scipy&#39;, &#39;scipy&#39;);  import scipy.interpolate;
        assert smoothingfactor is None or smoothingfactor &gt; 0
        t = self.clone().resample(dt=1)
        (startframe, endframe) = (self.startframe() if startframe is None else startframe, self.endframe() if endframe is None else endframe)
        try:
            assert len(t._keyframes) &gt; 4, &#34;Invalid length for spline interpolation&#34;        
            s = smoothingfactor * len(self._keyframes) if smoothingfactor is not None else None
            (xmin, ymin, xmax, ymax) = zip(*[bb.to_ulbr() for bb in t._keyboxes])
            f_xmin = scipy.interpolate.UnivariateSpline(t._keyframes, xmin, check_finite=False, s=s)
            f_ymin = scipy.interpolate.UnivariateSpline(t._keyframes, ymin, check_finite=False, s=s)
            f_xmax = scipy.interpolate.UnivariateSpline(t._keyframes, xmax, check_finite=False, s=s)
            f_ymax = scipy.interpolate.UnivariateSpline(t._keyframes, ymax, check_finite=False, s=s)
            (self._keyframes, self._keyboxes) = zip(*[(k, BoundingBox(xmin=float(f_xmin(k)), ymin=float(f_ymin(k)), xmax=float(f_xmax(k)), ymax=float(f_ymax(k)))) for k in range(startframe, endframe)])
        except Exception as e:
            if not strict:
                log.warning(&#39;[vipy.object.track]: spline smoothing failed with error &#34;%s&#34; - Returning unsmoothed track&#39; % (str(e)))
                return self
            else:
                raise
        return self

    def linear_extrapolation(self, k, shape=False, dt=30):
        &#34;&#34;&#34;Track extrapolation by linear fit.
        
           * Requires at least 2 keyboxes.
           * Returned boxes may be degenerate.
           * shape=True then both the position and shape (width, height) of the box is extrapolated
        &#34;&#34;&#34;
        if self.during(k):
            return self[k]
        elif len(self._keyboxes) == 1:
            return self.nearest_keybox(k)
        else:
            n = self.endframe() if k &gt; self.endframe() else self.startframe()+1
            d = self.endbox().clone() if k &gt; self.endframe() else self.startbox().clone()
            (vx, vy) = self.shape_invariant_velocity(n, dt=dt) if not shape else self.velocity(n, dt=dt)
            (vw, vh) = (self.velocity_w(n, dt=dt), self.velocity_h(n, dt=dt)) if shape else (0,0)
            d = d.translate((k-n)*vx, (k-n)*vy)
            return d if not shape else d.top( ((k-n)*vh)/2.0).bottom( ((k-n)*vh)/2.0).left( ((k-n)*vw)/2.0).right( ((k-n)*vw)/2.0)
            
    def imclip(self, width, height):
        &#34;&#34;&#34;Clip the track to the image rectangle (width, height).  If a keybox is outside the image rectangle, remove it otherwise clip to the image rectangle. 
           This operation can change the length of the track and the size of the keyboxes.  The result may be an empty track if the track is completely outside
           the image rectangle, which results in an exception.
        &#34;&#34;&#34;
        clipped = [(f, bb.imclip(width=width, height=height)) for (f,bb) in zip(self._keyframes, self._keyboxes) if bb.hasoverlap(width=width, height=height)]
        if len(clipped) &gt; 0:
            (self._keyframes, self._keyboxes) = zip(*clipped)
            (self._keyframes, self._keyboxes) = (list(self._keyframes), list(self._keyboxes))
            return self
        else:
            raise ValueError(&#39;All key boxes for track outside image rectangle&#39;)

    def resample(self, dt):
        &#34;&#34;&#34;Resample the track using a stride of dt frames.  This reduces the density of keyframes by interpolating new keyframes as a uniform stride of dt.  This is useful for track compression&#34;&#34;&#34;
        assert dt &gt;= 1 and dt &lt; len(self)
        frames =  list(range(self.startframe(), self.endframe(), dt)) + [self.endframe()]
        (self._keyboxes, self._keyframes) = zip(*[(self[k], k) for k in frames])
        (self._keyboxes, self._keyframes) = (list(self._keyboxes), list(self._keyframes))
        return self

    def significant_digits(self, n):
        &#34;&#34;&#34;Round the coordinates of all boxes so that they have n significant digits for efficient serialization&#34;&#34;&#34;
        self._keyboxes = [bb.significant_digits(n) for bb in self._keyboxes]
        return self

    def bearing(self, f, dt=30, minspeed=1):
        &#34;&#34;&#34;The bearing of a track at frame f is the angle of the velocity vector relative to the (x,y) image coordinate frame, in radians [-pi, pi]&#34;&#34;&#34;
        v = self.shape_invariant_velocity(f, dt)
        return float(np.arctan2(v[1], v[0])) if self.speed(f, dt) &gt; minspeed else None  # atan2(y,x)

    def bearing_change(self, f1=None, f2=None, dt=30, minspeed=1, samples=None):
        &#34;&#34;&#34;The bearing change of a track from frame f1 (or start) and frame f2 (or end) is the relative angle of the velocity vectors in radians [-pi,pi].
        
        Args:
            f1: [int] the start frame for computing the bearing change.  If None, then use self.startframe()
            f2: [int] the end frame for computing the bearing change.  if None, then use self.endframe()
            dt: [int] The number of frames between computations of the velocity vector for bearing
            minspeed: [float] The minimum speed in frames per second used to threshold bearing computations if there is no motion
            samples: [int] The number of samples to average for computing the bearing change
        
        Returns:
            The floating point bearing change in radians in [-pi, pi] from (f1,f2) where bearing is computed at samples=n points, and each bearing is computed with a velocity stride of dt frames.

        &#34;&#34;&#34;
        dt = min(dt, len(self))
        (sf, ef) = (f1 if f1 is not None else self.startframe(), f2 if f2 is not None else self.endframe())
        df = 1 if samples is None else int(np.floor((ef-sf)/samples))
        B = [self.bearing(k, dt=dt, minspeed=minspeed) for k in range(sf, ef+df, df) if k&gt;=sf and k&lt;=ef]
        B = [b for b in B if b is not None]  # valid bearing estimates only
        dr = np.sum(np.diff(B)) if len(B) &gt; 0 else 0  # cumulative bearing angle change 
        return float(dr if np.abs(dr)&lt;=np.pi else ((2*np.pi - dr) if (dr &gt; np.pi) else (2*np.pi + dr)))

    def acceleration(self, f, dt=30):
        &#34;&#34;&#34;Return the (x,y) track acceleration magnitude at frame f computed using central finite differences of velocity.
        
        Returns:
            acceleration in (pixels / seconds^2) using velocity computed at (f-2*dt, f-dt), (f+dt, f+2*dt)
        &#34;&#34;&#34;
        (u, v) = (self.shape_invariant_velocity(f-dt, dt), self.shape_invariant_velocity(f+2*dt, dt))  # ((f-2*dt, (f-dt)), (f+dt, f+2*dt))
        (ax, ay) = ((v[0] - u[0])/float(2*dt), (v[1] - u[1])/float(2*dt))
        return float(np.sqrt(ax**2 + ay**2))  # acceleration magnitude in pixels    
        
    def velocity(self, f, dt=30):
        &#34;&#34;&#34;Return the (x,y) track velocity at frame f in units of pixels per frame computed by mean finite difference of the box centroid&#34;&#34;&#34;
        return (self.velocity_x(f, dt), self.velocity_y(f, dt))

    def speed(self, f, dt=30):
        (u,v) = self.shape_invariant_velocity(f, dt)
        return float(np.sqrt(u**2 + v**2))
    
    def boxmap(self, f):
        &#34;&#34;&#34;Apply the lambda function to each keybox&#34;&#34;&#34;
        assert callable(f)
        self._keyboxes = [f(bb) for bb in self._keyboxes]        
        return self

    def shape_invariant_velocity(self, f, dt=30):
        &#34;&#34;&#34;Return the (x,y) track velocity at frame f in units of pixels per frame computed by minimum mean finite differences of any box corner independent of changes in shape, over a finite time window of [f-dt, f]&#34;&#34;&#34;
        assert f &gt;= 0 and dt &gt; 0
        if len(self) &lt; 2 or not (self.during(f) and self.during(f-dt)) :
            return (0,0)
        
        kb = [((f-dt), self.linear_interpolation(f-dt))] + [(kf, bb) for (kf,bb) in zip(self._keyframes, self._keyboxes) if (kf &gt; f-dt) and (kf &lt; f)]
        (kfe, bbe) = (f, self.linear_interpolation(f))
        vx = float((1.0/len(kb))*sum([min([(bbe._xmin - bb._xmin), (bbe._xmax - bb._xmax)], key=abs)/float(kfe-kf) for (kf,bb) in kb]))
        vy = float((1.0/len(kb))*sum([min([(bbe._ymin - bb._ymin), (bbe._ymax - bb._ymax)], key=abs)/float(kfe-kf) for (kf,bb) in kb]))
        return (vx, vy)

    def velocity_x(self, f, dt=30):
        &#34;&#34;&#34;Return the left/right velocity at frame f in units of pixels per frame computed by mean finite difference over a fixed time window (dt, frames) of the box centroid&#34;&#34;&#34;
        assert f &gt;= 0 and dt &gt; 0
        return float(np.mean([(self[f].centroid_x() - self[f-k].centroid_x())/float(k) for k in range(1,dt) if self.during(f-k)])) if (self.during(f-1) and self.during(f)) else 0

    def velocity_y(self, f, dt=30):
        &#34;&#34;&#34;Return the up/down velocity at frame f in units of pixels per frame computed by mean finite difference over a fixed time window (dt, frames) of the box centroid&#34;&#34;&#34;
        assert f &gt;= 0 and dt &gt; 0
        return float(np.mean([(self[f].centroid_y() - self[f-k].centroid_y())/float(k) for k in range(1,dt) if self.during(f-k)])) if (self.during(f-1) and self.during(f)) else 0

    def velocity_w(self, f, dt=30):
        &#34;&#34;&#34;Return the width velocity at frame f in units of pixels per frame computed by finite difference&#34;&#34;&#34;
        assert f &gt;= 0 and dt &gt; 0 and self.during(f)
        return float(np.mean([(self[f].width() - self[f-k].width())/float(k) for k in range(1,dt) if self.during(f-k)])) if self.during(f-1) else 0

    def velocity_h(self, f, dt=30):
        &#34;&#34;&#34;Return the height velocity at frame f in units of pixels per frame computed by finite difference&#34;&#34;&#34;
        assert f &gt;= 0 and dt &gt; 0 and self.during(f)
        return float(np.mean([(self[f].height() - self[f-k].height())/float(k) for k in range(1,dt) if self.during(f-k)])) if self.during(f-1) else 0
    
    def nearest_keyframe(self, f):
        &#34;&#34;&#34;Nearest keyframe to frame f&#34;&#34;&#34;
        assert len(self._keyframes) &gt; 0
        return self._keyframes[int(np.abs(np.array(self._keyframes) - f).argmin())]

    def nearest_keybox(self, f):
        &#34;&#34;&#34;Nearest keybox to frame f&#34;&#34;&#34;
        assert len(self._keyframes) &gt; 0
        return self._keyboxes[int(np.abs(np.array(self._keyframes) - f).argmin())]  # by-reference
    
    def ismoving(self, startframe=None, endframe=None, mincover=0.9):
        &#34;&#34;&#34;Is the track moving in the frame range (startframe,endframe)?&#34;&#34;&#34;
        (bbs, bbe) = (self[max(self.startframe(), startframe)] if startframe is not None else self.startbox(), self[min(self.endframe(), endframe)] if endframe is not None else self.endbox())
        return (bbs.maxcover(bbe) &lt; mincover) if (bbs is not None and bbe is not None) else False</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="vipy.object.Track.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>s)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="vipy.object.Track.attributes"><code class="name">var <span class="ident">attributes</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L262-L1180" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Track():
    &#34;&#34;&#34;vipy.object.Track class
    
    A track represents one or more labeled bounding boxes of an object instance through time.  A track is defined as a finite set of labeled boxes observed 
    at keyframes, which are discrete observations of this instance.  Each keyframe has an associated vipy.geometry.BoundingBox() which defines the spatial bounding box
    of the instance in this keyframe.  The kwarg &#34;interpolation&#34; defines how the track is interpolated between keyframes, and the kwarg &#34;boundary&#34; defines how the 
    track is interpolated outside the (min,max) of the keyframes.  

    Valid constructors are:

    ```python
    t = vipy.object.Track(keyframes=[0,100], boxes=[vipy.geometry.BoundingBox(0,0,10,10), vipy.geometry.BoundingBox(0,0,20,20)], label=&#39;Person&#39;)
    t = vipy.object.Track(keyframes=[0,100], boxes=[vipy.geometry.BoundingBox(0,0,10,10), vipy.geometry.BoundingBox(0,0,20,20)], label=&#39;Person&#39;, interpolation=&#39;linear&#39;)
    t = vipy.object.Track(keyframes=[10,100], boxes=[vipy.geometry.BoundingBox(0,0,10,10), vipy.geometry.BoundingBox(0,0,20,20)], label=&#39;Person&#39;, boundary=&#39;strict&#39;)
    ```

    Tracks can be constructed incrementally:

    ```python
    t = vipy.object.Track(&#39;Person&#39;)
    t.add(0, vipy.geometry.BoundingBox(0,0,10,10))
    t.add(100, vipy.geometry.BoundingBox(0,0,20,20))
    ```

    Tracks can be resampled at a new framerate, as long as the framerate is known when the keyframes are extracted

    ```python
    t.framerate(newfps)
    ```

    &#34;&#34;&#34;
    __slots__ = [&#39;_id&#39;, &#39;_label&#39;, &#39;_framerate&#39;, &#39;_interpolation&#39;, &#39;_boundary&#39;, &#39;attributes&#39;, &#39;_keyframes&#39;, &#39;_keyboxes&#39;]    
    def __init__(self, keyframes, boxes, category=None, label=None, framerate=30, interpolation=&#39;linear&#39;, boundary=&#39;strict&#39;, attributes=None, id=None, filterbox=False):
        keyframes = tolist(keyframes)
        boxes = tolist(boxes)        
        assert isinstance(keyframes, tuple) or isinstance(keyframes, list), &#34;Keyframes are required and must be tuple or list&#34;
        assert isinstance(boxes, tuple) or isinstance(boxes, list), &#34;Keyframe boundingboxes are required and must be tuple or list&#34;
        assert all([isinstance(bb, BoundingBox) for bb in boxes]), &#34;Keyframe bounding boxes must be vipy.geometry.BoundingBox objects&#34;
        assert filterbox or all([bb.isvalid() for bb in boxes]), &#34;All keyframe bounding boxes must be valid&#34;        
        assert not (label is not None and category is not None), &#34;Constructor requires either label or category kwargs, not both&#34;                
        assert len(keyframes) == len(boxes), &#34;Boxes and keyframes must be the same length, there must be a one to one mapping of frames to boxes&#34;
        assert boundary in set([&#39;extend&#39;, &#39;strict&#39;]), &#34;Invalid interpolation boundary - Must be [&#39;extend&#39;, &#39;strict&#39;]&#34;
        assert interpolation in set([&#39;linear&#39;]), &#34;Invalid interpolation - Must be [&#39;linear&#39;]&#34;
        assert framerate is not None, &#34;initial framerate for keyframes is required for framerate conversion&#34;
        
        self._id = shortuuid() if id is None else str(id)
        self._label = category if category is not None else label
        self._framerate = float(framerate) 
        self._interpolation = interpolation
        self._boundary = boundary
        self.attributes = attributes if attributes is not None else {}  # user must copy if needed
        self._keyframes = [int(np.round(f)) for f in keyframes]  # coerce to int
        self._keyboxes = boxes
        
        # Sorted increasing frame order
        if len(keyframes) &gt; 0 and len(boxes) &gt; 0 and not all([keyframes[i-1] &lt;= keyframes[i] for i in range(1,len(keyframes))]):
            (keyframes, boxes) = zip(*sorted([(f,bb) for (f,bb) in zip(keyframes, boxes)], key=lambda x: x[0]))
            self._keyframes = list(keyframes)
            self._keyboxes = list(boxes)

        # Filter boxes:  remove invalid boxes and keyframes
        if filterbox and len(keyframes) &gt; 0 and len(boxes) &gt; 0:
            kfbb = [(f,bb) for (f,bb) in zip(keyframes, boxes) if bb.isvalid()]
            (keyframes, boxes) = zip(*kfbb) if len(kfbb)&gt;0 else ([],[])
            self._keyframes = list(keyframes)
            self._keyboxes = list(boxes)
            if len(self) == 0:
                log.warning(&#39;vipy.object.Track - filtering invalid boxes with filterbox=True resulted in zero length track for track ID %s&#39; % str(self.id()))            
            
    @classmethod
    def from_json(cls, s):
        d = json.loads(s) if not isinstance(s, dict) else s
        d = {k.lstrip(&#39;_&#39;):v for (k,v) in d.items()}  # prettyjson (remove &#34;_&#34; prefix to attributes), legacy support
        return cls(keyframes=tuple(int(f) for f in d[&#39;keyframes&#39;]),
                   boxes=tuple([Detection.from_json(bbs) for bbs in d[&#39;keyboxes&#39;]]),
                   category=d[&#39;label&#39;] if &#39;label&#39; in d else None,
                   framerate=d[&#39;framerate&#39;] if &#39;framerate&#39; in d and d[&#39;framerate&#39;] is not None else 30,  # legacy support (pip_175k)
                   interpolation=d[&#39;interpolation&#39;] if &#39;interpolation&#39; in d else &#39;linear&#39;,
                   boundary=d[&#39;boundary&#39;],
                   attributes=d[&#39;attributes&#39;],
                   id=d[&#39;id&#39;] if &#39;id&#39; in d else None)

    def __json__(self):
        &#34;&#34;&#34;Serialization method for json package&#34;&#34;&#34;
        return self.json(encode=True)
    
    def json(self, encode=True):
        d = {k:getattr(self, k) if k != &#39;_keyboxes&#39; else tuple([bb.json(encode=False) for bb in getattr(self, k)]) for k in Track.__slots__}        
        d = {k.lstrip(&#39;_&#39;):v for (k,v) in d.items() if v is not None}  # prettyjson (remove &#34;_&#34; prefix to attributes)                
        d[&#39;keyframes&#39;] = tuple([int(f) for f in self._keyframes])
        return json.dumps(d) if encode else d

    def __repr__(self):
        strlist = []
        if self.category() is not None:
            strlist.append(&#39;category=&#34;%s&#34;&#39; % self.category())
        if self.endframe() is not None and self.startframe() is not None:
            strlist.append(&#39;startframe=%d, endframe=%d&#39; % (self.startframe(), self.endframe()))
        strlist.append(&#39;keyframes=%d&#39; % len(self._keyframes))
        return str(&#39;&lt;vipy.object.Track: %s&gt;&#39; % (&#39;, &#39;.join(strlist)))

    def __getitem__(self, k):
        &#34;&#34;&#34;Interpolate the track at frame k&#34;&#34;&#34;
        return self.linear_interpolation(k)

    def __iter__(self):
        &#34;&#34;&#34;Iterate over the track interpolating each frame from min(keyframes) to max(keyframes)&#34;&#34;&#34;
        for k in range(self.startframe(), self.endframe()+1):
            yield self.linear_interpolation(k)

    def __len__(self):
        &#34;&#34;&#34;The length of a track is the total number of interpolated frames, or zero if degenerate&#34;&#34;&#34;
        return max(0, self.endframe() - self.startframe() + 1) if (len(self._keyframes)&gt;0 and len(self._keyboxes)&gt;0) else 0

    def isempty(self):
        return self.__len__() == 0

    def has_normalized_coordinates(self):
        return all(isinstance(bb, Detection) and bb.has_normalized_coordinates() for bb in self.keyboxes())
    
    def confidence(self, last=None, samples=None):
        &#34;&#34;&#34;The confidence of a track is the mean confidence of all (or just last=last frames, or samples=samples uniformly spaced) keyboxes (if confidences are available) else 0&#34;&#34;&#34;
        if samples is not None:
            dt = max(1, int(round(len(self._keyframes)/float(samples))))
            C = [self._keyboxes[i]._confidence for i in range(len(self._keyframes)-1, -1, -dt) if (hasattr(self._keyboxes[i], &#39;_confidence&#39;) and self._keyboxes[i]._confidence is not None)]
        elif last == 1:
            return self.endbox().confidence() if len(self)&gt;0 else 0
        else:
            ef = self.endframe() - last if last is not None else 0
            C = [d._confidence for (f,d) in zip(self.keyframes(), self.keyboxes()) if f &gt;= ef and (hasattr(d, &#39;_confidence&#39;) and d._confidence is not None)]
        return C[0] if len(C) == 1 else (float(np.mean(C)) if len(C) &gt; 0 else 0)
        
    def isdegenerate(self):
        &#34;&#34;&#34;Is the track degenerate?  
        
        A degenerate track has:
            - Unequal length keyboxes and keyframes
            - length zero track
            - Non increasing keyframes
            - Invalid keyboxes
        &#34;&#34;&#34;
        return not (len(self.keyboxes()) == len(self.keyframes()) and
                    (len(self) == 0 or all([bb.isvalid() for bb in self.keyboxes()])) and
                    sorted(self.keyframes()) == list(self.keyframes()))
    
    def dict(self):
        &#34;&#34;&#34;Return a python dictionary containing the relevant serialized attributes suitable for JSON encoding&#34;&#34;&#34;
        return self.json(encode=False)

    
    def add(self, keyframe, bbox, strict=True):
        &#34;&#34;&#34;Add a new keyframe and associated box to track, preserve sorted order of keyframes.  If keyframe is already in track, throw an exception.  In this case use update() instead

           -strict [bool]:  If box is degenerate, throw an exception if strict=True, otherwise just don&#39;t add it
        
        .. note::  The BoundingBox is added by reference.  If you want to this to be a copy, pass in bbox.clone()
        &#34;&#34;&#34;
        assert isinstance(bbox, BoundingBox), &#34;Invalid input - Box must be vipy.geometry.BoundingBox()&#34;
        assert strict is False or bbox.isvalid(), &#34;Invalid input - Box must be non-degenerate&#34;
        assert int(keyframe) not in self._keyframes, &#34;Invalid input - repeated keyframe&#34;
        if not bbox.isvalid():            
            return self  # just don&#39;t add it 
        self._keyframes.append(int(keyframe))
        self._keyboxes.append(bbox)  # not cloned()
        if len(self._keyframes) &gt; 1 and keyframe &lt; self._keyframes[-2]:
            # Preserve sorted order if inserting into the middle somewhere
            (self._keyframes, self._keyboxes) = zip(*sorted([(f,bb) for (f,bb) in zip(self._keyframes, self._keyboxes)], key=lambda x: x[0]))        
            self._keyframes = list(self._keyframes)
            self._keyboxes = list(self._keyboxes)
        return self

    def update(self, keyframe, bbox):
        if keyframe in self._keyframes:
            self.delete(keyframe)
        self.add(keyframe, bbox)
        return self
        
    def replace(self, keyframe, box):
        &#34;&#34;&#34;Replace the keyframe and associated box(es), preserve sorted order of keyframes&#34;&#34;&#34;
        return self.delete(keyframe).add(keyframe, box)

    def delete(self, keyframe):
        &#34;&#34;&#34;Replace a keyframe and associated box to track, preserve sorted order of keyframes&#34;&#34;&#34;
        while keyframe in self._keyframes:
            k = self._keyframes.index(keyframe)
            del self._keyboxes[k]
            del self._keyframes[k]
        return self
    
    def keyframes(self):
        &#34;&#34;&#34;Return keyframe frame indexes where there are track observations&#34;&#34;&#34;
        return self._keyframes

    def num_keyframes(self):
        return len(self._keyframes)

    def keyboxes(self, boxes=None, keyframes=None):
        &#34;&#34;&#34;Return keyboxes where there are track observations&#34;&#34;&#34;
        if boxes is None and keyframes is None:
            return self._keyboxes
        else:
            assert all([isinstance(bb, BoundingBox) for bb in boxes])
            self._keyboxes = boxes
            self._keyframes = keyframes if keyframes is not None else self._keyframes
            assert not self.isdegenerate()
            return self
        
    def meanshape(self):
        &#34;&#34;&#34;Return the mean (width,height) of the box during the track, or None if the track is degenerate&#34;&#34;&#34;
        s = np.mean([bb.shape() for bb in self.keyboxes()], axis=0) if len(self.keyboxes()) &gt; 0 else None
        return (float(s[0]), float(s[1])) if s is not None else None

    def meanbox(self):
        &#34;&#34;&#34;Return the mean bounding box during the track, or None if the track is degenerate&#34;&#34;&#34;
        return BoundingBox(ulbr=np.mean([bb.ulbr() for bb in self.keyboxes()], axis=0)) if len(self.keyboxes()) &gt; 0 else None 
    
    def shapevariance(self):
        &#34;&#34;&#34;Return the variance (width, height) of the box shape relative to `vipy.object.Track.meanbox` during the track or None if the track is degenerate.  

        This is useful for filtering spurious tracks where the aspect ratio changes rapidly and randomly

        Returns:
            (width_variance, height_variance) of the box shape during the track (or None)
        &#34;&#34;&#34;
        m = self.meanshape()
        return (float(np.mean([(bb.width() - m[0])**2 for bb in self.keyboxes()])), 
                float(np.mean([(bb.height() - m[1])**2 for bb in self.keyboxes()]))) if m is not None else None


    def framerate(self, fps=None, speed=None):
        &#34;&#34;&#34;Resample keyframes from known original framerate set by constructor to be new framerate fps.

        Args:
            fps: [float]  The new frame rate in frames per second
            speed: [float]  An optional speed factor which will multiply the current framerate by this factor (e.g. speed=2 --&gt; fps=self.framerate()*2)

        Returns:
            This track object with the keyframes resampled to the new framerate

        &#34;&#34;&#34;
        if fps is None and speed is None:
            return self._framerate
        
        assert self._framerate is not None, &#34;Framerate conversion requires that the framerate is known for current keyframes.  This must be provided to the vipy.object.Track() constructor.&#34;
        assert fps is not None or speed is not None, &#34;Invalid input&#34;
        assert not (fps is not None and speed is not None), &#34;Invalid input&#34;
        assert speed is None or speed &gt; 0, &#34;Invalid speed, must specify speed multiplier s=1, s=2 for 2x faster, s=0.5 for half slower&#34;
        
        fps = float(fps) if fps is not None else (1.0/speed)*self._framerate
        self._keyframes = [int(np.round(f*(fps/float(self._framerate)))) for f in self._keyframes]
        self._framerate = fps
        return self
        
    def startframe(self):
        &#34;&#34;&#34;Return the startframe of the track or None if there are no keyframes.  
        
        The frame index is relative to the framerate set in the constructor.

        &#34;&#34;&#34;        
        return int(self._keyframes[0]) if len(self._keyframes)&gt;0 else None  # assumes sorted order

    def endframe(self):
        &#34;&#34;&#34;Return the endframe of the track or None if there are no keyframes.

        The frame index is relative to the framerate set in the constructor.
        &#34;&#34;&#34;
        return int(self._keyframes[-1]) if len(self._keyframes)&gt;0 else None  # assumes sorted order

    def duration(self):
        &#34;&#34;&#34;The length of the track in seconds.

        Returns:
            The duration in seconds of this track object
        &#34;&#34;&#34;
        assert self.framerate() is not None, &#34;Framerate must be set in constructor&#34;
        return len(self) / float(self.framerate())
    
    def linear_interpolation(self, f):
        &#34;&#34;&#34;Linear bounding box interpolation at frame=f given observed boxes (x,y,w,h) at keyframes.  

        This returns a `vipy.object.Detection` which is the interpolation of the `vipy.object.Track` at frame k

        - If self._boundary=&#39;extend&#39;, then boxes are repeated if the interpolation is outside the keyframes
        - If self._boundary=&#39;strict&#39;, then interpolation returns None if the interpolation is outside the keyframes
        
        .. note::  
            - The returned BoundingBox object is not cloned when possible for speed purposes, be careful when modifying this object.  clone() the returned object if necessary
            - This means that we return a reference to the underlying keybox upgraded with track properties and cast as `vipy.object.Detection`.  If you modify this object, then the track keybox will be modfied.
        &#34;&#34;&#34;
        assert len(self._keyboxes) &gt; 0, &#34;Degenerate object for interpolation&#34;   # not self.isempty()
        if len(self._keyboxes) == 1:
            return Detection.cast(self._keyboxes[0].clone()).new_category(self.category()).set_attribute(&#39;__trackid&#39;, self.id()) if (self._boundary == &#39;extend&#39; or self.during(f)) else None
        if f in self._keyframes:            
            return Detection.cast(self._keyboxes[self._keyframes.index(f)].clone()).new_category(self.category()).set_attribute(&#39;__trackid&#39;, self.id())  # clone requuired to not pollute attributes

        kf = self._keyframes
        ft = min(max(f, kf[0]), kf[-1])  # truncated frame index
        for i in reversed(range(0, len(kf)-1)):
            if kf[i] &lt;= ft and kf[i+1] &gt;= ft:
                break  # floor keyframe index
        c = (ft - kf[i]) / max(1, float(kf[i+1] - kf[i]))  # interpolation coefficient
        (bi, bj) = (self._keyboxes[i], self._keyboxes[i+1])
        d = Detection(xmin=bi._xmin + c*(bj._xmin - bi._xmin),   # float(np.interp(k, self._keyframes, [bb._xmin for bb in self._keyboxes])),
                      ymin=bi._ymin + c*(bj._ymin - bi._ymin),   # float(np.interp(k, self._keyframes, [bb._ymin for bb in self._keyboxes])),
                      xmax=bi._xmax + c*(bj._xmax - bi._xmax),   # float(np.interp(k, self._keyframes, [bb._xmax for bb in self._keyboxes])),
                      ymax=bi._ymax + c*(bj._ymax - bi._ymax),   # float(np.interp(k, self._keyframes, [bb._ymax for bb in self._keyboxes])),
                      confidence=bi.confidence() if isinstance(bi, Detection) else None,
                      attributes=bi.attributes.copy() if isinstance(bi, Detection) else None,  # unshared attributes (to allow for __trackid)
                      category=self.category())

        d.attributes[&#39;__trackid&#39;] = self.id()  # for correspondence of detections to tracks
        return d if self._boundary == &#39;extend&#39; or self.during(f) else None

    def category(self, label=None):
        &#34;&#34;&#34;Set the track category to label.  Updates all keyboxes&#34;&#34;&#34;
        if label is not None:
            self._label = label
            self.boxmap(lambda bb: bb.category(self._label) if isinstance(bb, Detection) else bb)
            return self
        else:
            return self._label
    
    def categoryif(self, ifcategory, tocategory=None):
        &#34;&#34;&#34;If the current category is equal to ifcategory, then change it to newcategory.

        Args:
            
            ifcategory [dict, str]: May be a dictionary {ifcategory:tocategory}, or just an ifcategory
            tocategory [str]:  the target category 

        Returns:
        
            this object with the category changed.

        .. note:: This is useful for converting synonyms such as self.categoryif(&#39;motorbike&#39;, &#39;motorcycle&#39;)
        &#34;&#34;&#34;
        assert (isinstance(ifcategory, dict) and tocategory is None) or tocategory is not None

        if isinstance(ifcategory, dict):
            for (k,v) in ifcategory.items():
                self.categoryif(k, v)
        elif self.category() == ifcategory:
            self.category(tocategory)
        return self

    def label(self, label):
        &#34;&#34;&#34;Alias for category&#34;&#34;&#34;
        return self.category(label)
        
    def during(self, k_start, k_end=None):
        &#34;&#34;&#34;Does the track contain a keyframe during the time interval (startframe, endframe) inclusive?&#34;&#34;&#34;        
        k_end = k_start+1 if k_end is None else k_end
        (startframe, endframe) = (self.startframe(), self.endframe())
        return len(self)&gt;0 and ((k_start &gt;= startframe and k_start &lt;= endframe) or (k_end &gt;= startframe and k_end &lt;= endframe) or (k_start &lt;= startframe and k_end &gt;= endframe))
        
    def during_interval(self, k_start, k_end):
        &#34;&#34;&#34;Does the track contain a keyframe during the inclusive frame interval (startframe, endframe)?

        .. note:: The start and end frames are inclusive
        &#34;&#34;&#34;
        return self.during(k_start, k_end)

    def within(self, starframe, endframe):
        &#34;&#34;&#34;Is the track within the frame range (startframe, endframe)?&#34;&#34;&#34;
        return self.startframe() &gt;= startframe and self.endframe() &lt;= endframe
    
    def offset(self, dt=0, dx=0, dy=0):
        &#34;&#34;&#34;Apply a temporal shift of dt frames, and a spatial shift of (dx, dy) pixels.
        
        Args:
            dt: [int] frame offset
            dx: [float] horizontal spatial offset 
            dy: [float] vertical spatial offset 

        Returns:
            This box updated in place
        &#34;&#34;&#34;
        dt = int(np.round(dt*self.framerate())) if isinstance(dt, float) else dt
        self._keyboxes = [bb.offset(dx, dy) for bb in self._keyboxes]
        self._keyframes = [(f+dt) for f in self._keyframes]
        return self

    def uncrop(self, bb, s=1):
        &#34;&#34;&#34;Apply a transformation to the track that will undo a crop of a bounding box with an optional scale factor.

        A typical operation is as follows.  A video is cropped and zommed in order to run a detector on a region of interest.  However, we want to align the resulting tracks on the original video before the crop and zoom.  

        Args:
            bb: [`vipy.geometry.BoundingBox`].  A bounding box which was used to crop this track
            s: [float]  A scale factor applied after the bounding box crop

        Returns:
            This track after undoing the scale and crop 
        &#34;&#34;&#34;
        assert isinstance(bb, BoundingBox)
        return self.rescale(1/s).offset(dt=0, dx=bb.xmin(), dy=bb.ymin())

    def frameoffset(self, dx, dy):
        &#34;&#34;&#34;Offset boxes by (dx,dy) in each frame.
        
        This is used to apply a different offset for each frame.  To apply one offset to all frames, use `vipy.object.Track.offset`.
        Args:
            dx: [list]  This should be a list of frame offsets at each keyframe the same length as the number of keyboxes
            dy: [list]  This should be a list of frame offsets at each keyframe the same length as the number of keyboxes

        Returns:
            This track updated in place
        &#34;&#34;&#34;
        assert isinstance(dx, list) or isinstance(dx, tuple)
        assert isinstance(dy, list) or isinstance(dy, tuple)
        assert len(self.keyboxes()) == len(dx) and len(self.keyboxes()) == len(dy)
        self._keyboxes = [bb.offset(dx=x, dy=y) for (bb, (x, y)) in zip(self._keyboxes, zip(dx, dy))]
        return self

    def truncate(self, start=None, end=None):
        &#34;&#34;&#34;Truncate a track so that any keyframes less than startframe or greater than endframe (inclusive) are removed.  Interpolate keyboxes at (startframe, endframe) endpoints.

        Args:
            start: [int|float] The start of the truncation relative to the track framerate.  All keyframes less than or equal to startframe are included.  If the keyframe does not exist at startframe, one is interpolated and added.
            end: [int|float] The end of the truncation relative to the track framerate.  All keyframes greater than or equal to the endframe are included.  If the keyfrmae does not exist at endframe, one is interpolated and added.

        Returns:
            This track such that all keyboxes &lt;= startframe or &gt;= endframe are removed.

        .. note::  The startframe and endframe for truncation are inclusive.  
        &#34;&#34;&#34;
        startframe = int(np.round(start*self.framerate())) if isinstance(start, float) else start
        endframe = int(np.round(end*self.framerate())) if isinstance(end, float) else end        
        
        if startframe is not None and startframe not in self._keyframes and self[startframe] is not None:
            self.add(startframe, self[startframe].clone())  # interpolated boundary condition
        if endframe is not None and endframe not in self._keyframes and self[endframe] is not None:
            self.add(endframe, self[endframe].clone())  # intepolated boundary condition
        kfkb = [(kf,kb) for (kf,kb) in zip(self._keyframes, self._keyboxes) if ((startframe is None or kf &gt;= startframe) and (endframe is None or kf &lt;= endframe))]
        (self._keyframes, self._keyboxes) = zip(*kfkb) if len(kfkb) &gt; 0 else ([], [])
        return self
        
    def rescale(self, s):
        &#34;&#34;&#34;Rescale track boxes by scale factor s&#34;&#34;&#34;
        if s != 1.0:
            self._keyboxes = [bb.rescale(s) for bb in self._keyboxes]
        return self

    def scale(self, s):
        &#34;&#34;&#34;Alias for rescale&#34;&#34;&#34;
        return self.rescale(s)

    def scale_x(self, sx):
        &#34;&#34;&#34;Rescale track boxes by scale factor sx&#34;&#34;&#34;
        self._keyboxes = [bb.scale_x(sx) for bb in self._keyboxes]
        return self

    def scale_y(self, sy):
        &#34;&#34;&#34;Rescale track boxes by scale factor sx&#34;&#34;&#34;
        self._keyboxes = [bb.scale_y(sy) for bb in self._keyboxes]
        return self

    def dilate(self, s):
        &#34;&#34;&#34;Dilate track boxes by scale factor s&#34;&#34;&#34;
        self._keyboxes = [bb.dilate(s) for bb in self._keyboxes]
        return self

    def maxsquare(self):
        &#34;&#34;&#34;Set all of the track boxes to maxsquare&#34;&#34;&#34;
        self._keyboxes = [bb.maxsquare() for bb in self._keyboxes]
        return self
    
    def rot90cw(self, H, W):
        &#34;&#34;&#34;Rotate an image with (H,W)=shape 90 degrees clockwise and update all boxes to be consistent&#34;&#34;&#34;
        self._keyboxes = [bb.rot90cw(H, W) for bb in self._keyboxes]
        return self

    def rot90ccw(self, H, W):
        &#34;&#34;&#34;Rotate an image with (H,W)=shape 90 degrees clockwise and update all boxes to be consistent&#34;&#34;&#34;
        self._keyboxes = [bb.rot90ccw(H, W) for bb in self._keyboxes]
        return self

    def fliplr(self, H, W):
        &#34;&#34;&#34;Flip an image left and right (mirror about vertical axis)&#34;&#34;&#34;
        self._keyboxes = [bb.fliplr(width=W) for bb in self._keyboxes]
        return self

    def flipud(self, H, W):
        &#34;&#34;&#34;Flip an image left and right (mirror about vertical axis)&#34;&#34;&#34;
        self._keyboxes = [bb.flipud(height=H) for bb in self._keyboxes]
        return self

    def id(self, newid=None):
        if newid is None:
            return self._id
        else:
            self._id = newid
            return self

    def clone(self, startframe=None, endframe=None, rekey=False):
        #return copy.deepcopy(self)  
        t = Track.from_json(self.json(encode=False)) if (startframe is None and endframe is None) else self.clone_during(startframe, endframe)  # 2x faster than deepcopy
        t.attributes = t.attributes.copy()
        if rekey:
            t.id(newid=shortuuid())
        return t
    
    def clone_during(self, startframe, endframe):
        &#34;&#34;&#34;Clone a track during a specific interval (startframe, endframe) relative to the framerate of the track.

        - This is useful for copying a small segment of a long track without the expense of copying the whole track.  
        - All keyframes and keyboxes not in (startframe, endframe) are not copied.
        - Boundary keyframes are copied to enable proper interpolation.        
        &#34;&#34;&#34;
        # Update (startframe,endframe) to be the keyframes just before startframe and the keyframe just after endframe so that interpolation will work correctly
        (startframe, endframe) = (([kf for kf in self._keyframes if kf &lt;= startframe][-1]) if self.during(startframe, startframe) else startframe,
                                  ([kf for kf in self._keyframes if kf &gt;= endframe][0]) if self.during(endframe, endframe) else endframe)
        kfkb = [(kf,kb.clone()) for (kf,kb) in zip(self._keyframes, self._keyboxes) if ((startframe is None or kf &gt;= startframe) and (endframe is None or kf &lt;= endframe))]
        (kf, kb) = zip(*kfkb) if len(kfkb) &gt; 0 else ([], [])        
        return Track(keyframes=kf, boxes=kb, category=self.category(), framerate=self._framerate, interpolation=self._interpolation, boundary=self._boundary, attributes=self.attributes.copy(), id=self._id)
    
    def boundingbox(self, startframe=None, endframe=None):
        &#34;&#34;&#34;The bounding box of a track is the smallest spatial box that contains all of the BoundingBoxes of the track  within startframe and endframe, or None if there are no detections.
        
        Args:
            startframe: [int] the startframe of the track to compute the bounding box.
            endframe: [int] the endframe of the track to compute the bounding box.
        
        Returns:
            `vipy.geometry.BoundingBox` which is the smallest box that contains all boxes of the track from (startframe, endframe)
        &#34;&#34;&#34;
        t = self.clone() if (startframe is None and endframe is None) else self.clone().truncate(startframe, endframe)
        d = t._keyboxes[0].clone() if len(t._keyboxes) &gt;= 1 else None
        return d.union([bb for (k,bb) in zip(t._keyframes[1:], t._keyboxes[1:]) if t.during(k)]) if (d is not None and len(t._keyboxes) &gt;= 2) else d

    def smallestbox(self):
        &#34;&#34;&#34;The smallest box of a track is the smallest spatial box in area along the track&#34;&#34;&#34;
        k = np.argmin([bb.area() for bb in self._keyboxes]) if len(self._keyboxes) &gt; 0 else None
        return self._keyboxes[k] if k is not None else None

    def biggestbox(self):
        &#34;&#34;&#34;The biggest box of a track is the largest spatial box in area along the track&#34;&#34;&#34;
        k = np.argmax([bb.area() for bb in self._keyboxes]) if len(self._keyboxes) &gt; 0 else None
        return self._keyboxes[k] if k is not None else None
        
    def pathlength(self):
        &#34;&#34;&#34;The path length of a track is the cumulative Euclidean distance in pixels that the box travels&#34;&#34;&#34;
        return float(np.sum([bb_next.dist(bb_prev) for (bb_next, bb_prev) in zip(self._keyboxes[1:], self._keyboxes[0:-1])])) if len(self._keyboxes)&gt;1 else 0.0
        
    def startbox(self):
        &#34;&#34;&#34;The startbox is the first bounding box in the track&#34;&#34;&#34;
        return self._keyboxes[0] if len(self._keyboxes) &gt; 0 else None

    def endbox(self):
        &#34;&#34;&#34;The endbox is the last box in the track&#34;&#34;&#34;
        return self._keyboxes[-1] if len(self._keyboxes) &gt; 0 else None

    def loop_closure_distance(self):
        &#34;&#34;&#34;The loop closure track distance is the Euclidean distance in pixels between the start frame bounding box and end frame bounding box&#34;&#34;&#34;
        return self.startbox().dist(self.endbox()) if not self.isdegenerate() else None

    def boundary(self, b=None):
        if b is None:
            return self._boundary
        else:
            assert b in [&#39;strict&#39;, &#39;extend&#39;]
            self._boundary = b
            return self
        
    def clip(self, start, end):
        &#34;&#34;&#34;Clip a track to be within (start,end) with strict boundary handling.  

        Start and end may be frame numbers (int) or seconds (float).  Frames are relative to the current frame rate.

        Args:
            start [int|float]:  The start of the clip in frames|seconds
            end [int|float|None]:  The end of the clip in frames|seconds (if provided)
        &#34;&#34;&#34;
        startframe = int(np.round(start*self.framerate())) if isinstance(start, float) else start
        endframe = int(np.round(end*self.framerate())) if isinstance(end, float) else start        
        
        if self[startframe] is not None:
            self.add(startframe, self[startframe])
        if self[endframe] is not None:
            self.add(endframe, self[endframe])
        keyframes = [f for (f,bb) in zip(self._keyframes, self._keyboxes) if f&gt;=startframe and f&lt;=endframe]  # may be empty
        keyboxes = [bb for (f,bb) in zip(self._keyframes, self._keyboxes) if f&gt;=startframe and f&lt;=endframe]  # may be empty
        if len(keyframes) == 0 or len(keyboxes) == 0:
            raise ValueError(&#39;Track does not contain any keyboxes within the requested frames (%d,%d)&#39; % (startframe, endframe))
        self._keyframes = keyframes
        self._keyboxes = keyboxes
        self._boundary = &#39;strict&#39;
        return self

    def iou(self, other, dt=1):
        &#34;&#34;&#34;Compute the spatial IoU between two tracks as the mean IoU per frame in the range (self.startframe(), self.endframe())&#34;&#34;&#34;
        return self.rankiou(other, rank=len(self), dt=dt)

    def segment_maxiou(self, other, startframe, endframe):
        &#34;&#34;&#34;Return the maximum framewise bounding box IOU between self and other in the range (startframe, endframe)&#34;&#34;&#34;
        assert isinstance(other, Track), &#34;invalid input - Must be vipy.object.Track()&#34;
        assert startframe &lt; endframe
        return max([self[k].iou(other[k]) if (self[k] is not None) else 0 for k in range(startframe, endframe)])
    
    def maxiou(self, other, dt=1):
        &#34;&#34;&#34;Compute the maximum spatial IoU between two tracks per frame in the range (self.startframe(), self.endframe())&#34;&#34;&#34;        
        return self.rankiou(other, rank=1, dt=dt)

    def fragmentiou(self, other, dt=5):
        &#34;&#34;&#34;A fragment is a track that is fully contained within self&#34;&#34;&#34;
        assert isinstance(other, Track), &#34;invalid input - Must be vipy.object.Track()&#34;        
        startframe = max(self.startframe(), other.startframe())
        endframe = min(self.endframe(), other.endframe())
        return float(np.min([self[min(k,endframe)].iou(other[min(k,endframe)]) for k in range(startframe, endframe, dt)])) if (other.startframe() &gt;= self.startframe() and other.endframe() &lt;= self.endframe() and endframe &gt; startframe) else 0
        
    def endpointiou(self, other):
        &#34;&#34;&#34;Compute the mean spatial IoU between two tracks at the two overlapping endpoints.  useful for track continuation&#34;&#34;&#34;        
        assert isinstance(other, Track), &#34;invalid input - Must be vipy.object.Track()&#34;
        startframe = max(self.startframe(), other.startframe())
        endframe = min(self.endframe(), other.endframe())
        return float(np.mean([self[startframe].iou(other[startframe]), self[endframe].iou(other[endframe])]) if endframe &gt; startframe else 0.0)

    def segmentiou(self, other, dt=5):
        &#34;&#34;&#34;Compute the mean spatial IoU between two tracks at the overlapping segment, sampling by dt.  Useful for track continuation for densely overlapping tracks&#34;&#34;&#34;
        assert isinstance(other, Track), &#34;invalid input - Must be vipy.object.Track()&#34;
        startframe = max(self.startframe(), other.startframe())
        endframe = min(self.endframe(), other.endframe())   # inclusive
        return float(np.mean([self[min(k,endframe)].iou(other[min(k,endframe)]) for k in range(startframe, endframe, dt)]) if endframe &gt; startframe else 0.0)

    def segmentcover(self, other, dt=5):
        &#34;&#34;&#34;Compute the mean spatial cover between two tracks at the overlapping segment, sampling by dt.  Useful for track continuation for densely overlapping tracks&#34;&#34;&#34;
        assert isinstance(other, Track), &#34;invalid input - Must be vipy.object.Track()&#34;
        startframe = max(self.startframe(), other.startframe())
        endframe = min(self.endframe(), other.endframe())   # inclusive
        return float(np.mean([self[min(k,endframe)].maxcover(other[min(k,endframe)]) for k in range(startframe, endframe, dt)]) if endframe &gt; startframe else 0.0)
        
    def rankiou(self, other, rank, dt=1):
        &#34;&#34;&#34;Compute the mean spatial IoU between two tracks per frame in the range (self.startframe(), self.endframe()) using only the top-k (rank) frame overlaps
           Sample tracks at endpoints and n uniformly spaced frames or a stride of dt frames.  
        
           - rank [&gt;1]:  The top-k best IOU overlaps to average when computing the rank IOU
           - This is useful for track continuation where the box deforms in the overlapping segment at the end due to occlusion. 
           - This is useful for track correspondence where a ground truth box does not match an estimated box precisely (e.g. loose box, non-visually grounded box)
           - This is the robust version of segmentiou.
           - Use percentileiou to determine the rank based a fraction of the length of the overlap, which will be more efficient for long tracks
        &#34;&#34;&#34;
        assert rank &gt;= 1 and rank &lt;= len(self)
        assert isinstance(other, Track), &#34;Invalid input - must be vipy.object.Track()&#34;
        assert dt &gt;= 1
        frames = [self.startframe()] + list(range(self.startframe()+dt, self.endframe(), dt)) + [self.endframe()]
        return float(np.mean(sorted([self[k].iou(other[k]) if (self.during(k) and other.during(k)) else 0.0 for k in frames])[-rank:]))

    def percentileiou(self, other, percentile, samples=100):
        &#34;&#34;&#34;Percentile iou returns rankiou for rank=percentile*len(overlap(self, other))
        
           -other [Track]
           -percentile [0,1]:  The top-k best overlaps to average when computing rankiou
           -samples:  The number of uniformly spaced samples to take along the track for computing the rankiou
        &#34;&#34;&#34;
        assert percentile &gt; 0 and percentile &lt;= 1
        assert isinstance(other, Track), &#34;invalid input - Must be vipy.object.Track()&#34;
        assert self.framerate() == other.framerate()
        
        startframe = max(self.startframe(), other.startframe())
        endframe = min(self.endframe(), other.endframe())
        segmentlen = endframe - startframe
        dt = max(1, int(np.floor(segmentlen/samples)))
        return self.rankiou(other, max(1, int(segmentlen*percentile)), dt=dt) if segmentlen &gt; 0 else 0

    def segment_percentileiou(self, other, percentile, samples=100):
        &#34;&#34;&#34;percentiliou on the overlapping segment with other&#34;&#34;&#34;
        assert percentile &gt; 0 and percentile &lt;= 1
        assert isinstance(other, Track), &#34;invalid input - Must be vipy.object.Track()&#34;
        assert self.framerate() == other.framerate()
        
        startframe = max(self.startframe(), other.startframe())
        endframe = min(self.endframe(), other.endframe())
        segmentlen = endframe - startframe
        rank = int(segmentlen*percentile)
        dt = max(1, int(np.floor(segmentlen/samples)))
        iou = sorted([self[min(k,endframe)].iou(other[min(k,endframe)]) for k in range(startframe, endframe, dt)]) if endframe &gt; startframe else []
        return float(np.mean(iou[-rank:]) if endframe &gt; startframe else 0.0)


    def segment_percentilecover(self, other, percentile, samples=100):
        &#34;&#34;&#34;percentile cover on the overlapping segment with other&#34;&#34;&#34;
        assert percentile &gt; 0 and percentile &lt;= 1
        assert isinstance(other, Track), &#34;invalid input - Must be vipy.object.Track()&#34;
        assert self.framerate() == other.framerate()
        
        startframe = max(self.startframe(), other.startframe())
        endframe = min(self.endframe(), other.endframe())
        segmentlen = endframe - startframe
        rank = int(segmentlen*percentile)
        dt = max(1, int(np.floor(segmentlen/samples)))
        bblist = [(self[min(k,endframe)], other[min(k,endframe)]) for k in range(startframe, endframe, dt)] if endframe &gt; startframe else []
        cover = [max(bbself.cover(bbother), bbother.cover(bbself)) for (bbself, bbother) in bblist]
        return float(np.mean(cover[-rank:]) if endframe &gt; startframe else 0.0)

    def union(self, other, overlap=&#39;average&#39;):
        &#34;&#34;&#34;Compute the union of two tracks.  Overlapping boxes between self and other:
        
           Inputs
             - average [bool]:  average framewise interpolated boxes at overlapping keyframes
             - replace [bool]:  replace the box with other if other and self overlap at a keyframe
             - keep [bool]:  keep the box from self (discard other) at a keyframe
        &#34;&#34;&#34;
        assert isinstance(other, Track), &#34;Invalid input - must be vipy.object.Track()&#34;
        assert other.category() == self.category(), &#34;Category mismatch&#34;
        assert overlap in [&#39;average&#39;, &#39;replace&#39;, &#39;keep&#39;], &#34;Invalid input - &#39;overlap&#39; must be in [average, replace, keep]&#34;
        T = self.clone()
        keyframes = sorted(set(T._keyframes+other._keyframes))
        T._keyboxes = [((self[k].average(other[k]) if (overlap == &#39;average&#39;) else (self[k] if (overlap == &#39;keep&#39;) else other[k]))
                        if (self.during(k) and other.during(k)) else 
                        (self[k] if (self.during(k) and not other.during(k)) else (other[k])))
                       for k in keyframes] 
        T._keyframes = keyframes
        return T  


    def average(self, other):
        &#34;&#34;&#34;Compute the average of two tracks by the framewise interpolated boxes at the keyframes of this track&#34;&#34;&#34;
        assert isinstance(other, Track), &#34;Invalid input - must be vipy.object.Track()&#34;
        assert other.category() == self.category(), &#34;Category mismatch&#34;
        T = self.clone()
        T._keyboxes = [(self[k].average(other[k]) 
                        if (self.during(k) and other.during(k)) else (self[k] if (self.during(k) and not other.during(k)) else (other[k])))
                       for k in T._keyframes]  
        return T  

    def temporal_distance(self, other):
        &#34;&#34;&#34;The temporal distance between two tracks is the minimum number of frames separating them&#34;&#34;&#34;
        assert isinstance(other, Track), &#34;Invalid input - must be vipy.object.Track()&#34;
        return max(max(self.startframe() - other.endframe(), other.startframe() - self.endframe()), 0)

    def smooth(self, width):
        &#34;&#34;&#34;Track smoothing by averaging neighboring keyboxes&#34;&#34;&#34;
        assert isinstance(width, int) and width &gt; 0
        if len(self._keyboxes) &gt; width:
            self._keyboxes = [bb.clone().average(bbnbrs) for (bb, bbnbrs) in zip(self._keyboxes, chunklistwithoverlap(self._keyboxes, width, width-1))] 
        return self

    def smoothshape(self, width):
        &#34;&#34;&#34;Track smoothing by averaging width and height of neighboring keyboxes&#34;&#34;&#34;
        assert isinstance(width, int) and width &gt; 0
        if len(self._keyboxes) &gt; width:
            self._keyboxes = [bb.clone().averageshape(bbnbrs) for (bb, bbnbrs) in zip(self._keyboxes, chunklistwithoverlap(self._keyboxes, width, width-1))]
        return self

    def medianshape(self, width):
        &#34;&#34;&#34;Track smoothing by median width and height of neighboring keyboxes&#34;&#34;&#34;
        assert isinstance(width, int) and width &gt; 0
        if len(self._keyboxes) &gt; width:
            self._keyboxes = [bb.clone().medianshape(bbnbrs) for (bb, bbnbrs) in zip(self._keyboxes, chunklistwithoverlap(self._keyboxes, width, width-1))]
        return self

    def spline(self, smoothingfactor=None, strict=True, startframe=None, endframe=None):
        &#34;&#34;&#34;Track smoothing by cubic spline fit, will return resampled dt=1 track.  Smoothing factor will increase with smoothing &gt; 1 and decrease with 0 &lt; smoothing &lt; 1
        
           This function requires optional package scipy
        &#34;&#34;&#34;
        try_import(&#39;scipy&#39;, &#39;scipy&#39;);  import scipy.interpolate;
        assert smoothingfactor is None or smoothingfactor &gt; 0
        t = self.clone().resample(dt=1)
        (startframe, endframe) = (self.startframe() if startframe is None else startframe, self.endframe() if endframe is None else endframe)
        try:
            assert len(t._keyframes) &gt; 4, &#34;Invalid length for spline interpolation&#34;        
            s = smoothingfactor * len(self._keyframes) if smoothingfactor is not None else None
            (xmin, ymin, xmax, ymax) = zip(*[bb.to_ulbr() for bb in t._keyboxes])
            f_xmin = scipy.interpolate.UnivariateSpline(t._keyframes, xmin, check_finite=False, s=s)
            f_ymin = scipy.interpolate.UnivariateSpline(t._keyframes, ymin, check_finite=False, s=s)
            f_xmax = scipy.interpolate.UnivariateSpline(t._keyframes, xmax, check_finite=False, s=s)
            f_ymax = scipy.interpolate.UnivariateSpline(t._keyframes, ymax, check_finite=False, s=s)
            (self._keyframes, self._keyboxes) = zip(*[(k, BoundingBox(xmin=float(f_xmin(k)), ymin=float(f_ymin(k)), xmax=float(f_xmax(k)), ymax=float(f_ymax(k)))) for k in range(startframe, endframe)])
        except Exception as e:
            if not strict:
                log.warning(&#39;[vipy.object.track]: spline smoothing failed with error &#34;%s&#34; - Returning unsmoothed track&#39; % (str(e)))
                return self
            else:
                raise
        return self

    def linear_extrapolation(self, k, shape=False, dt=30):
        &#34;&#34;&#34;Track extrapolation by linear fit.
        
           * Requires at least 2 keyboxes.
           * Returned boxes may be degenerate.
           * shape=True then both the position and shape (width, height) of the box is extrapolated
        &#34;&#34;&#34;
        if self.during(k):
            return self[k]
        elif len(self._keyboxes) == 1:
            return self.nearest_keybox(k)
        else:
            n = self.endframe() if k &gt; self.endframe() else self.startframe()+1
            d = self.endbox().clone() if k &gt; self.endframe() else self.startbox().clone()
            (vx, vy) = self.shape_invariant_velocity(n, dt=dt) if not shape else self.velocity(n, dt=dt)
            (vw, vh) = (self.velocity_w(n, dt=dt), self.velocity_h(n, dt=dt)) if shape else (0,0)
            d = d.translate((k-n)*vx, (k-n)*vy)
            return d if not shape else d.top( ((k-n)*vh)/2.0).bottom( ((k-n)*vh)/2.0).left( ((k-n)*vw)/2.0).right( ((k-n)*vw)/2.0)
            
    def imclip(self, width, height):
        &#34;&#34;&#34;Clip the track to the image rectangle (width, height).  If a keybox is outside the image rectangle, remove it otherwise clip to the image rectangle. 
           This operation can change the length of the track and the size of the keyboxes.  The result may be an empty track if the track is completely outside
           the image rectangle, which results in an exception.
        &#34;&#34;&#34;
        clipped = [(f, bb.imclip(width=width, height=height)) for (f,bb) in zip(self._keyframes, self._keyboxes) if bb.hasoverlap(width=width, height=height)]
        if len(clipped) &gt; 0:
            (self._keyframes, self._keyboxes) = zip(*clipped)
            (self._keyframes, self._keyboxes) = (list(self._keyframes), list(self._keyboxes))
            return self
        else:
            raise ValueError(&#39;All key boxes for track outside image rectangle&#39;)

    def resample(self, dt):
        &#34;&#34;&#34;Resample the track using a stride of dt frames.  This reduces the density of keyframes by interpolating new keyframes as a uniform stride of dt.  This is useful for track compression&#34;&#34;&#34;
        assert dt &gt;= 1 and dt &lt; len(self)
        frames =  list(range(self.startframe(), self.endframe(), dt)) + [self.endframe()]
        (self._keyboxes, self._keyframes) = zip(*[(self[k], k) for k in frames])
        (self._keyboxes, self._keyframes) = (list(self._keyboxes), list(self._keyframes))
        return self

    def significant_digits(self, n):
        &#34;&#34;&#34;Round the coordinates of all boxes so that they have n significant digits for efficient serialization&#34;&#34;&#34;
        self._keyboxes = [bb.significant_digits(n) for bb in self._keyboxes]
        return self

    def bearing(self, f, dt=30, minspeed=1):
        &#34;&#34;&#34;The bearing of a track at frame f is the angle of the velocity vector relative to the (x,y) image coordinate frame, in radians [-pi, pi]&#34;&#34;&#34;
        v = self.shape_invariant_velocity(f, dt)
        return float(np.arctan2(v[1], v[0])) if self.speed(f, dt) &gt; minspeed else None  # atan2(y,x)

    def bearing_change(self, f1=None, f2=None, dt=30, minspeed=1, samples=None):
        &#34;&#34;&#34;The bearing change of a track from frame f1 (or start) and frame f2 (or end) is the relative angle of the velocity vectors in radians [-pi,pi].
        
        Args:
            f1: [int] the start frame for computing the bearing change.  If None, then use self.startframe()
            f2: [int] the end frame for computing the bearing change.  if None, then use self.endframe()
            dt: [int] The number of frames between computations of the velocity vector for bearing
            minspeed: [float] The minimum speed in frames per second used to threshold bearing computations if there is no motion
            samples: [int] The number of samples to average for computing the bearing change
        
        Returns:
            The floating point bearing change in radians in [-pi, pi] from (f1,f2) where bearing is computed at samples=n points, and each bearing is computed with a velocity stride of dt frames.

        &#34;&#34;&#34;
        dt = min(dt, len(self))
        (sf, ef) = (f1 if f1 is not None else self.startframe(), f2 if f2 is not None else self.endframe())
        df = 1 if samples is None else int(np.floor((ef-sf)/samples))
        B = [self.bearing(k, dt=dt, minspeed=minspeed) for k in range(sf, ef+df, df) if k&gt;=sf and k&lt;=ef]
        B = [b for b in B if b is not None]  # valid bearing estimates only
        dr = np.sum(np.diff(B)) if len(B) &gt; 0 else 0  # cumulative bearing angle change 
        return float(dr if np.abs(dr)&lt;=np.pi else ((2*np.pi - dr) if (dr &gt; np.pi) else (2*np.pi + dr)))

    def acceleration(self, f, dt=30):
        &#34;&#34;&#34;Return the (x,y) track acceleration magnitude at frame f computed using central finite differences of velocity.
        
        Returns:
            acceleration in (pixels / seconds^2) using velocity computed at (f-2*dt, f-dt), (f+dt, f+2*dt)
        &#34;&#34;&#34;
        (u, v) = (self.shape_invariant_velocity(f-dt, dt), self.shape_invariant_velocity(f+2*dt, dt))  # ((f-2*dt, (f-dt)), (f+dt, f+2*dt))
        (ax, ay) = ((v[0] - u[0])/float(2*dt), (v[1] - u[1])/float(2*dt))
        return float(np.sqrt(ax**2 + ay**2))  # acceleration magnitude in pixels    
        
    def velocity(self, f, dt=30):
        &#34;&#34;&#34;Return the (x,y) track velocity at frame f in units of pixels per frame computed by mean finite difference of the box centroid&#34;&#34;&#34;
        return (self.velocity_x(f, dt), self.velocity_y(f, dt))

    def speed(self, f, dt=30):
        (u,v) = self.shape_invariant_velocity(f, dt)
        return float(np.sqrt(u**2 + v**2))
    
    def boxmap(self, f):
        &#34;&#34;&#34;Apply the lambda function to each keybox&#34;&#34;&#34;
        assert callable(f)
        self._keyboxes = [f(bb) for bb in self._keyboxes]        
        return self

    def shape_invariant_velocity(self, f, dt=30):
        &#34;&#34;&#34;Return the (x,y) track velocity at frame f in units of pixels per frame computed by minimum mean finite differences of any box corner independent of changes in shape, over a finite time window of [f-dt, f]&#34;&#34;&#34;
        assert f &gt;= 0 and dt &gt; 0
        if len(self) &lt; 2 or not (self.during(f) and self.during(f-dt)) :
            return (0,0)
        
        kb = [((f-dt), self.linear_interpolation(f-dt))] + [(kf, bb) for (kf,bb) in zip(self._keyframes, self._keyboxes) if (kf &gt; f-dt) and (kf &lt; f)]
        (kfe, bbe) = (f, self.linear_interpolation(f))
        vx = float((1.0/len(kb))*sum([min([(bbe._xmin - bb._xmin), (bbe._xmax - bb._xmax)], key=abs)/float(kfe-kf) for (kf,bb) in kb]))
        vy = float((1.0/len(kb))*sum([min([(bbe._ymin - bb._ymin), (bbe._ymax - bb._ymax)], key=abs)/float(kfe-kf) for (kf,bb) in kb]))
        return (vx, vy)

    def velocity_x(self, f, dt=30):
        &#34;&#34;&#34;Return the left/right velocity at frame f in units of pixels per frame computed by mean finite difference over a fixed time window (dt, frames) of the box centroid&#34;&#34;&#34;
        assert f &gt;= 0 and dt &gt; 0
        return float(np.mean([(self[f].centroid_x() - self[f-k].centroid_x())/float(k) for k in range(1,dt) if self.during(f-k)])) if (self.during(f-1) and self.during(f)) else 0

    def velocity_y(self, f, dt=30):
        &#34;&#34;&#34;Return the up/down velocity at frame f in units of pixels per frame computed by mean finite difference over a fixed time window (dt, frames) of the box centroid&#34;&#34;&#34;
        assert f &gt;= 0 and dt &gt; 0
        return float(np.mean([(self[f].centroid_y() - self[f-k].centroid_y())/float(k) for k in range(1,dt) if self.during(f-k)])) if (self.during(f-1) and self.during(f)) else 0

    def velocity_w(self, f, dt=30):
        &#34;&#34;&#34;Return the width velocity at frame f in units of pixels per frame computed by finite difference&#34;&#34;&#34;
        assert f &gt;= 0 and dt &gt; 0 and self.during(f)
        return float(np.mean([(self[f].width() - self[f-k].width())/float(k) for k in range(1,dt) if self.during(f-k)])) if self.during(f-1) else 0

    def velocity_h(self, f, dt=30):
        &#34;&#34;&#34;Return the height velocity at frame f in units of pixels per frame computed by finite difference&#34;&#34;&#34;
        assert f &gt;= 0 and dt &gt; 0 and self.during(f)
        return float(np.mean([(self[f].height() - self[f-k].height())/float(k) for k in range(1,dt) if self.during(f-k)])) if self.during(f-1) else 0
    
    def nearest_keyframe(self, f):
        &#34;&#34;&#34;Nearest keyframe to frame f&#34;&#34;&#34;
        assert len(self._keyframes) &gt; 0
        return self._keyframes[int(np.abs(np.array(self._keyframes) - f).argmin())]

    def nearest_keybox(self, f):
        &#34;&#34;&#34;Nearest keybox to frame f&#34;&#34;&#34;
        assert len(self._keyframes) &gt; 0
        return self._keyboxes[int(np.abs(np.array(self._keyframes) - f).argmin())]  # by-reference
    
    def ismoving(self, startframe=None, endframe=None, mincover=0.9):
        &#34;&#34;&#34;Is the track moving in the frame range (startframe,endframe)?&#34;&#34;&#34;
        (bbs, bbe) = (self[max(self.startframe(), startframe)] if startframe is not None else self.startbox(), self[min(self.endframe(), endframe)] if endframe is not None else self.endbox())
        return (bbs.maxcover(bbe) &lt; mincover) if (bbs is not None and bbe is not None) else False</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="vipy.object.Track.acceleration"><code class="name flex">
<span>def <span class="ident">acceleration</span></span>(<span>self, f, dt=30)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the (x,y) track acceleration magnitude at frame f computed using central finite differences of velocity.</p>
<h2 id="returns">Returns</h2>
<p>acceleration in (pixels / seconds^2) using velocity computed at (f-2<em>dt, f-dt), (f+dt, f+2</em>dt)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L1111-L1119" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def acceleration(self, f, dt=30):
    &#34;&#34;&#34;Return the (x,y) track acceleration magnitude at frame f computed using central finite differences of velocity.
    
    Returns:
        acceleration in (pixels / seconds^2) using velocity computed at (f-2*dt, f-dt), (f+dt, f+2*dt)
    &#34;&#34;&#34;
    (u, v) = (self.shape_invariant_velocity(f-dt, dt), self.shape_invariant_velocity(f+2*dt, dt))  # ((f-2*dt, (f-dt)), (f+dt, f+2*dt))
    (ax, ay) = ((v[0] - u[0])/float(2*dt), (v[1] - u[1])/float(2*dt))
    return float(np.sqrt(ax**2 + ay**2))  # acceleration magnitude in pixels    </code></pre>
</details>
</dd>
<dt id="vipy.object.Track.add"><code class="name flex">
<span>def <span class="ident">add</span></span>(<span>self, keyframe, bbox, strict=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Add a new keyframe and associated box to track, preserve sorted order of keyframes.
If keyframe is already in track, throw an exception.
In this case use update() instead</p>
<p>-strict [bool]:
If box is degenerate, throw an exception if strict=True, otherwise just don't add it</p>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;The BoundingBox is added by reference.
If you want to this to be a copy, pass in bbox.clone()</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L412-L431" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def add(self, keyframe, bbox, strict=True):
    &#34;&#34;&#34;Add a new keyframe and associated box to track, preserve sorted order of keyframes.  If keyframe is already in track, throw an exception.  In this case use update() instead

       -strict [bool]:  If box is degenerate, throw an exception if strict=True, otherwise just don&#39;t add it
    
    .. note::  The BoundingBox is added by reference.  If you want to this to be a copy, pass in bbox.clone()
    &#34;&#34;&#34;
    assert isinstance(bbox, BoundingBox), &#34;Invalid input - Box must be vipy.geometry.BoundingBox()&#34;
    assert strict is False or bbox.isvalid(), &#34;Invalid input - Box must be non-degenerate&#34;
    assert int(keyframe) not in self._keyframes, &#34;Invalid input - repeated keyframe&#34;
    if not bbox.isvalid():            
        return self  # just don&#39;t add it 
    self._keyframes.append(int(keyframe))
    self._keyboxes.append(bbox)  # not cloned()
    if len(self._keyframes) &gt; 1 and keyframe &lt; self._keyframes[-2]:
        # Preserve sorted order if inserting into the middle somewhere
        (self._keyframes, self._keyboxes) = zip(*sorted([(f,bb) for (f,bb) in zip(self._keyframes, self._keyboxes)], key=lambda x: x[0]))        
        self._keyframes = list(self._keyframes)
        self._keyboxes = list(self._keyboxes)
    return self</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.average"><code class="name flex">
<span>def <span class="ident">average</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the average of two tracks by the framewise interpolated boxes at the keyframes of this track</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L977-L985" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def average(self, other):
    &#34;&#34;&#34;Compute the average of two tracks by the framewise interpolated boxes at the keyframes of this track&#34;&#34;&#34;
    assert isinstance(other, Track), &#34;Invalid input - must be vipy.object.Track()&#34;
    assert other.category() == self.category(), &#34;Category mismatch&#34;
    T = self.clone()
    T._keyboxes = [(self[k].average(other[k]) 
                    if (self.during(k) and other.during(k)) else (self[k] if (self.during(k) and not other.during(k)) else (other[k])))
                   for k in T._keyframes]  
    return T  </code></pre>
</details>
</dd>
<dt id="vipy.object.Track.bearing"><code class="name flex">
<span>def <span class="ident">bearing</span></span>(<span>self, f, dt=30, minspeed=1)</span>
</code></dt>
<dd>
<div class="desc"><p>The bearing of a track at frame f is the angle of the velocity vector relative to the (x,y) image coordinate frame, in radians [-pi, pi]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L1084-L1087" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def bearing(self, f, dt=30, minspeed=1):
    &#34;&#34;&#34;The bearing of a track at frame f is the angle of the velocity vector relative to the (x,y) image coordinate frame, in radians [-pi, pi]&#34;&#34;&#34;
    v = self.shape_invariant_velocity(f, dt)
    return float(np.arctan2(v[1], v[0])) if self.speed(f, dt) &gt; minspeed else None  # atan2(y,x)</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.bearing_change"><code class="name flex">
<span>def <span class="ident">bearing_change</span></span>(<span>self, f1=None, f2=None, dt=30, minspeed=1, samples=None)</span>
</code></dt>
<dd>
<div class="desc"><p>The bearing change of a track from frame f1 (or start) and frame f2 (or end) is the relative angle of the velocity vectors in radians [-pi,pi].</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>f1</code></strong></dt>
<dd>[int] the start frame for computing the bearing change.
If None, then use self.startframe()</dd>
<dt><strong><code>f2</code></strong></dt>
<dd>[int] the end frame for computing the bearing change.
if None, then use self.endframe()</dd>
<dt><strong><code>dt</code></strong></dt>
<dd>[int] The number of frames between computations of the velocity vector for bearing</dd>
<dt><strong><code>minspeed</code></strong></dt>
<dd>[float] The minimum speed in frames per second used to threshold bearing computations if there is no motion</dd>
<dt><strong><code>samples</code></strong></dt>
<dd>[int] The number of samples to average for computing the bearing change</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>The floating point bearing change in radians in [-pi, pi] from (f1,f2) where bearing is computed at samples=n points, and each bearing is computed with a velocity stride of dt frames.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L1089-L1109" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def bearing_change(self, f1=None, f2=None, dt=30, minspeed=1, samples=None):
    &#34;&#34;&#34;The bearing change of a track from frame f1 (or start) and frame f2 (or end) is the relative angle of the velocity vectors in radians [-pi,pi].
    
    Args:
        f1: [int] the start frame for computing the bearing change.  If None, then use self.startframe()
        f2: [int] the end frame for computing the bearing change.  if None, then use self.endframe()
        dt: [int] The number of frames between computations of the velocity vector for bearing
        minspeed: [float] The minimum speed in frames per second used to threshold bearing computations if there is no motion
        samples: [int] The number of samples to average for computing the bearing change
    
    Returns:
        The floating point bearing change in radians in [-pi, pi] from (f1,f2) where bearing is computed at samples=n points, and each bearing is computed with a velocity stride of dt frames.

    &#34;&#34;&#34;
    dt = min(dt, len(self))
    (sf, ef) = (f1 if f1 is not None else self.startframe(), f2 if f2 is not None else self.endframe())
    df = 1 if samples is None else int(np.floor((ef-sf)/samples))
    B = [self.bearing(k, dt=dt, minspeed=minspeed) for k in range(sf, ef+df, df) if k&gt;=sf and k&lt;=ef]
    B = [b for b in B if b is not None]  # valid bearing estimates only
    dr = np.sum(np.diff(B)) if len(B) &gt; 0 else 0  # cumulative bearing angle change 
    return float(dr if np.abs(dr)&lt;=np.pi else ((2*np.pi - dr) if (dr &gt; np.pi) else (2*np.pi + dr)))</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.biggestbox"><code class="name flex">
<span>def <span class="ident">biggestbox</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>The biggest box of a track is the largest spatial box in area along the track</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L797-L800" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def biggestbox(self):
    &#34;&#34;&#34;The biggest box of a track is the largest spatial box in area along the track&#34;&#34;&#34;
    k = np.argmax([bb.area() for bb in self._keyboxes]) if len(self._keyboxes) &gt; 0 else None
    return self._keyboxes[k] if k is not None else None</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.boundary"><code class="name flex">
<span>def <span class="ident">boundary</span></span>(<span>self, b=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L818-L824" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def boundary(self, b=None):
    if b is None:
        return self._boundary
    else:
        assert b in [&#39;strict&#39;, &#39;extend&#39;]
        self._boundary = b
        return self</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.boundingbox"><code class="name flex">
<span>def <span class="ident">boundingbox</span></span>(<span>self, startframe=None, endframe=None)</span>
</code></dt>
<dd>
<div class="desc"><p>The bounding box of a track is the smallest spatial box that contains all of the BoundingBoxes of the track
within startframe and endframe, or None if there are no detections.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>startframe</code></strong></dt>
<dd>[int] the startframe of the track to compute the bounding box.</dd>
<dt><strong><code>endframe</code></strong></dt>
<dd>[int] the endframe of the track to compute the bounding box.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p><code><a title="vipy.geometry.BoundingBox" href="geometry.html#vipy.geometry.BoundingBox">BoundingBox</a></code> which is the smallest box that contains all boxes of the track from (startframe, endframe)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L778-L790" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def boundingbox(self, startframe=None, endframe=None):
    &#34;&#34;&#34;The bounding box of a track is the smallest spatial box that contains all of the BoundingBoxes of the track  within startframe and endframe, or None if there are no detections.
    
    Args:
        startframe: [int] the startframe of the track to compute the bounding box.
        endframe: [int] the endframe of the track to compute the bounding box.
    
    Returns:
        `vipy.geometry.BoundingBox` which is the smallest box that contains all boxes of the track from (startframe, endframe)
    &#34;&#34;&#34;
    t = self.clone() if (startframe is None and endframe is None) else self.clone().truncate(startframe, endframe)
    d = t._keyboxes[0].clone() if len(t._keyboxes) &gt;= 1 else None
    return d.union([bb for (k,bb) in zip(t._keyframes[1:], t._keyboxes[1:]) if t.during(k)]) if (d is not None and len(t._keyboxes) &gt;= 2) else d</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.boxmap"><code class="name flex">
<span>def <span class="ident">boxmap</span></span>(<span>self, f)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply the lambda function to each keybox</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L1129-L1133" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def boxmap(self, f):
    &#34;&#34;&#34;Apply the lambda function to each keybox&#34;&#34;&#34;
    assert callable(f)
    self._keyboxes = [f(bb) for bb in self._keyboxes]        
    return self</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.category"><code class="name flex">
<span>def <span class="ident">category</span></span>(<span>self, label=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the track category to label.
Updates all keyboxes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L575-L582" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def category(self, label=None):
    &#34;&#34;&#34;Set the track category to label.  Updates all keyboxes&#34;&#34;&#34;
    if label is not None:
        self._label = label
        self.boxmap(lambda bb: bb.category(self._label) if isinstance(bb, Detection) else bb)
        return self
    else:
        return self._label</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.categoryif"><code class="name flex">
<span>def <span class="ident">categoryif</span></span>(<span>self, ifcategory, tocategory=None)</span>
</code></dt>
<dd>
<div class="desc"><p>If the current category is equal to ifcategory, then change it to newcategory.</p>
<h2 id="args">Args</h2>
<p>ifcategory [dict, str]: May be a dictionary {ifcategory:tocategory}, or just an ifcategory
tocategory [str]:
the target category </p>
<h2 id="returns">Returns</h2>
<p>this object with the category changed.</p>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;This is useful for converting synonyms such as self.categoryif('motorbike', 'motorcycle')</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L584-L605" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def categoryif(self, ifcategory, tocategory=None):
    &#34;&#34;&#34;If the current category is equal to ifcategory, then change it to newcategory.

    Args:
        
        ifcategory [dict, str]: May be a dictionary {ifcategory:tocategory}, or just an ifcategory
        tocategory [str]:  the target category 

    Returns:
    
        this object with the category changed.

    .. note:: This is useful for converting synonyms such as self.categoryif(&#39;motorbike&#39;, &#39;motorcycle&#39;)
    &#34;&#34;&#34;
    assert (isinstance(ifcategory, dict) and tocategory is None) or tocategory is not None

    if isinstance(ifcategory, dict):
        for (k,v) in ifcategory.items():
            self.categoryif(k, v)
    elif self.category() == ifcategory:
        self.category(tocategory)
    return self</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.clip"><code class="name flex">
<span>def <span class="ident">clip</span></span>(<span>self, start, end)</span>
</code></dt>
<dd>
<div class="desc"><p>Clip a track to be within (start,end) with strict boundary handling.
</p>
<p>Start and end may be frame numbers (int) or seconds (float).
Frames are relative to the current frame rate.</p>
<h2 id="args">Args</h2>
<p>start [int|float]:
The start of the clip in frames|seconds
end [int|float|None]:
The end of the clip in frames|seconds (if provided)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L826-L849" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def clip(self, start, end):
    &#34;&#34;&#34;Clip a track to be within (start,end) with strict boundary handling.  

    Start and end may be frame numbers (int) or seconds (float).  Frames are relative to the current frame rate.

    Args:
        start [int|float]:  The start of the clip in frames|seconds
        end [int|float|None]:  The end of the clip in frames|seconds (if provided)
    &#34;&#34;&#34;
    startframe = int(np.round(start*self.framerate())) if isinstance(start, float) else start
    endframe = int(np.round(end*self.framerate())) if isinstance(end, float) else start        
    
    if self[startframe] is not None:
        self.add(startframe, self[startframe])
    if self[endframe] is not None:
        self.add(endframe, self[endframe])
    keyframes = [f for (f,bb) in zip(self._keyframes, self._keyboxes) if f&gt;=startframe and f&lt;=endframe]  # may be empty
    keyboxes = [bb for (f,bb) in zip(self._keyframes, self._keyboxes) if f&gt;=startframe and f&lt;=endframe]  # may be empty
    if len(keyframes) == 0 or len(keyboxes) == 0:
        raise ValueError(&#39;Track does not contain any keyboxes within the requested frames (%d,%d)&#39; % (startframe, endframe))
    self._keyframes = keyframes
    self._keyboxes = keyboxes
    self._boundary = &#39;strict&#39;
    return self</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.clone"><code class="name flex">
<span>def <span class="ident">clone</span></span>(<span>self, startframe=None, endframe=None, rekey=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L756-L762" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def clone(self, startframe=None, endframe=None, rekey=False):
    #return copy.deepcopy(self)  
    t = Track.from_json(self.json(encode=False)) if (startframe is None and endframe is None) else self.clone_during(startframe, endframe)  # 2x faster than deepcopy
    t.attributes = t.attributes.copy()
    if rekey:
        t.id(newid=shortuuid())
    return t</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.clone_during"><code class="name flex">
<span>def <span class="ident">clone_during</span></span>(<span>self, startframe, endframe)</span>
</code></dt>
<dd>
<div class="desc"><p>Clone a track during a specific interval (startframe, endframe) relative to the framerate of the track.</p>
<ul>
<li>This is useful for copying a small segment of a long track without the expense of copying the whole track.
</li>
<li>All keyframes and keyboxes not in (startframe, endframe) are not copied.</li>
<li>Boundary keyframes are copied to enable proper interpolation.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L764-L776" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def clone_during(self, startframe, endframe):
    &#34;&#34;&#34;Clone a track during a specific interval (startframe, endframe) relative to the framerate of the track.

    - This is useful for copying a small segment of a long track without the expense of copying the whole track.  
    - All keyframes and keyboxes not in (startframe, endframe) are not copied.
    - Boundary keyframes are copied to enable proper interpolation.        
    &#34;&#34;&#34;
    # Update (startframe,endframe) to be the keyframes just before startframe and the keyframe just after endframe so that interpolation will work correctly
    (startframe, endframe) = (([kf for kf in self._keyframes if kf &lt;= startframe][-1]) if self.during(startframe, startframe) else startframe,
                              ([kf for kf in self._keyframes if kf &gt;= endframe][0]) if self.during(endframe, endframe) else endframe)
    kfkb = [(kf,kb.clone()) for (kf,kb) in zip(self._keyframes, self._keyboxes) if ((startframe is None or kf &gt;= startframe) and (endframe is None or kf &lt;= endframe))]
    (kf, kb) = zip(*kfkb) if len(kfkb) &gt; 0 else ([], [])        
    return Track(keyframes=kf, boxes=kb, category=self.category(), framerate=self._framerate, interpolation=self._interpolation, boundary=self._boundary, attributes=self.attributes.copy(), id=self._id)</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.confidence"><code class="name flex">
<span>def <span class="ident">confidence</span></span>(<span>self, last=None, samples=None)</span>
</code></dt>
<dd>
<div class="desc"><p>The confidence of a track is the mean confidence of all (or just last=last frames, or samples=samples uniformly spaced) keyboxes (if confidences are available) else 0</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L382-L392" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def confidence(self, last=None, samples=None):
    &#34;&#34;&#34;The confidence of a track is the mean confidence of all (or just last=last frames, or samples=samples uniformly spaced) keyboxes (if confidences are available) else 0&#34;&#34;&#34;
    if samples is not None:
        dt = max(1, int(round(len(self._keyframes)/float(samples))))
        C = [self._keyboxes[i]._confidence for i in range(len(self._keyframes)-1, -1, -dt) if (hasattr(self._keyboxes[i], &#39;_confidence&#39;) and self._keyboxes[i]._confidence is not None)]
    elif last == 1:
        return self.endbox().confidence() if len(self)&gt;0 else 0
    else:
        ef = self.endframe() - last if last is not None else 0
        C = [d._confidence for (f,d) in zip(self.keyframes(), self.keyboxes()) if f &gt;= ef and (hasattr(d, &#39;_confidence&#39;) and d._confidence is not None)]
    return C[0] if len(C) == 1 else (float(np.mean(C)) if len(C) &gt; 0 else 0)</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>self, keyframe)</span>
</code></dt>
<dd>
<div class="desc"><p>Replace a keyframe and associated box to track, preserve sorted order of keyframes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L443-L449" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def delete(self, keyframe):
    &#34;&#34;&#34;Replace a keyframe and associated box to track, preserve sorted order of keyframes&#34;&#34;&#34;
    while keyframe in self._keyframes:
        k = self._keyframes.index(keyframe)
        del self._keyboxes[k]
        del self._keyframes[k]
    return self</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.dict"><code class="name flex">
<span>def <span class="ident">dict</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a python dictionary containing the relevant serialized attributes suitable for JSON encoding</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L407-L409" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dict(self):
    &#34;&#34;&#34;Return a python dictionary containing the relevant serialized attributes suitable for JSON encoding&#34;&#34;&#34;
    return self.json(encode=False)</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.dilate"><code class="name flex">
<span>def <span class="ident">dilate</span></span>(<span>self, s)</span>
</code></dt>
<dd>
<div class="desc"><p>Dilate track boxes by scale factor s</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L719-L722" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dilate(self, s):
    &#34;&#34;&#34;Dilate track boxes by scale factor s&#34;&#34;&#34;
    self._keyboxes = [bb.dilate(s) for bb in self._keyboxes]
    return self</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.duration"><code class="name flex">
<span>def <span class="ident">duration</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>The length of the track in seconds.</p>
<h2 id="returns">Returns</h2>
<p>The duration in seconds of this track object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L530-L537" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def duration(self):
    &#34;&#34;&#34;The length of the track in seconds.

    Returns:
        The duration in seconds of this track object
    &#34;&#34;&#34;
    assert self.framerate() is not None, &#34;Framerate must be set in constructor&#34;
    return len(self) / float(self.framerate())</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.during"><code class="name flex">
<span>def <span class="ident">during</span></span>(<span>self, k_start, k_end=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Does the track contain a keyframe during the time interval (startframe, endframe) inclusive?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L611-L615" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def during(self, k_start, k_end=None):
    &#34;&#34;&#34;Does the track contain a keyframe during the time interval (startframe, endframe) inclusive?&#34;&#34;&#34;        
    k_end = k_start+1 if k_end is None else k_end
    (startframe, endframe) = (self.startframe(), self.endframe())
    return len(self)&gt;0 and ((k_start &gt;= startframe and k_start &lt;= endframe) or (k_end &gt;= startframe and k_end &lt;= endframe) or (k_start &lt;= startframe and k_end &gt;= endframe))</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.during_interval"><code class="name flex">
<span>def <span class="ident">during_interval</span></span>(<span>self, k_start, k_end)</span>
</code></dt>
<dd>
<div class="desc"><p>Does the track contain a keyframe during the inclusive frame interval (startframe, endframe)?</p>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;The start and end frames are inclusive</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L617-L622" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def during_interval(self, k_start, k_end):
    &#34;&#34;&#34;Does the track contain a keyframe during the inclusive frame interval (startframe, endframe)?

    .. note:: The start and end frames are inclusive
    &#34;&#34;&#34;
    return self.during(k_start, k_end)</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.endbox"><code class="name flex">
<span>def <span class="ident">endbox</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>The endbox is the last box in the track</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L810-L812" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def endbox(self):
    &#34;&#34;&#34;The endbox is the last box in the track&#34;&#34;&#34;
    return self._keyboxes[-1] if len(self._keyboxes) &gt; 0 else None</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.endframe"><code class="name flex">
<span>def <span class="ident">endframe</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the endframe of the track or None if there are no keyframes.</p>
<p>The frame index is relative to the framerate set in the constructor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L523-L528" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def endframe(self):
    &#34;&#34;&#34;Return the endframe of the track or None if there are no keyframes.

    The frame index is relative to the framerate set in the constructor.
    &#34;&#34;&#34;
    return int(self._keyframes[-1]) if len(self._keyframes)&gt;0 else None  # assumes sorted order</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.endpointiou"><code class="name flex">
<span>def <span class="ident">endpointiou</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the mean spatial IoU between two tracks at the two overlapping endpoints.
useful for track continuation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L872-L877" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def endpointiou(self, other):
    &#34;&#34;&#34;Compute the mean spatial IoU between two tracks at the two overlapping endpoints.  useful for track continuation&#34;&#34;&#34;        
    assert isinstance(other, Track), &#34;invalid input - Must be vipy.object.Track()&#34;
    startframe = max(self.startframe(), other.startframe())
    endframe = min(self.endframe(), other.endframe())
    return float(np.mean([self[startframe].iou(other[startframe]), self[endframe].iou(other[endframe])]) if endframe &gt; startframe else 0.0)</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.fliplr"><code class="name flex">
<span>def <span class="ident">fliplr</span></span>(<span>self, H, W)</span>
</code></dt>
<dd>
<div class="desc"><p>Flip an image left and right (mirror about vertical axis)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L739-L742" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def fliplr(self, H, W):
    &#34;&#34;&#34;Flip an image left and right (mirror about vertical axis)&#34;&#34;&#34;
    self._keyboxes = [bb.fliplr(width=W) for bb in self._keyboxes]
    return self</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.flipud"><code class="name flex">
<span>def <span class="ident">flipud</span></span>(<span>self, H, W)</span>
</code></dt>
<dd>
<div class="desc"><p>Flip an image left and right (mirror about vertical axis)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L744-L747" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def flipud(self, H, W):
    &#34;&#34;&#34;Flip an image left and right (mirror about vertical axis)&#34;&#34;&#34;
    self._keyboxes = [bb.flipud(height=H) for bb in self._keyboxes]
    return self</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.fragmentiou"><code class="name flex">
<span>def <span class="ident">fragmentiou</span></span>(<span>self, other, dt=5)</span>
</code></dt>
<dd>
<div class="desc"><p>A fragment is a track that is fully contained within self</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L865-L870" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def fragmentiou(self, other, dt=5):
    &#34;&#34;&#34;A fragment is a track that is fully contained within self&#34;&#34;&#34;
    assert isinstance(other, Track), &#34;invalid input - Must be vipy.object.Track()&#34;        
    startframe = max(self.startframe(), other.startframe())
    endframe = min(self.endframe(), other.endframe())
    return float(np.min([self[min(k,endframe)].iou(other[min(k,endframe)]) for k in range(startframe, endframe, dt)])) if (other.startframe() &gt;= self.startframe() and other.endframe() &lt;= self.endframe() and endframe &gt; startframe) else 0</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.frameoffset"><code class="name flex">
<span>def <span class="ident">frameoffset</span></span>(<span>self, dx, dy)</span>
</code></dt>
<dd>
<div class="desc"><p>Offset boxes by (dx,dy) in each frame.</p>
<p>This is used to apply a different offset for each frame.
To apply one offset to all frames, use <code><a title="vipy.object.Track.offset" href="#vipy.object.Track.offset">Track.offset()</a></code>.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dx</code></strong></dt>
<dd>[list]
This should be a list of frame offsets at each keyframe the same length as the number of keyboxes</dd>
<dt><strong><code>dy</code></strong></dt>
<dd>[list]
This should be a list of frame offsets at each keyframe the same length as the number of keyboxes</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>This track updated in place</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L659-L674" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def frameoffset(self, dx, dy):
    &#34;&#34;&#34;Offset boxes by (dx,dy) in each frame.
    
    This is used to apply a different offset for each frame.  To apply one offset to all frames, use `vipy.object.Track.offset`.
    Args:
        dx: [list]  This should be a list of frame offsets at each keyframe the same length as the number of keyboxes
        dy: [list]  This should be a list of frame offsets at each keyframe the same length as the number of keyboxes

    Returns:
        This track updated in place
    &#34;&#34;&#34;
    assert isinstance(dx, list) or isinstance(dx, tuple)
    assert isinstance(dy, list) or isinstance(dy, tuple)
    assert len(self.keyboxes()) == len(dx) and len(self.keyboxes()) == len(dy)
    self._keyboxes = [bb.offset(dx=x, dy=y) for (bb, (x, y)) in zip(self._keyboxes, zip(dx, dy))]
    return self</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.framerate"><code class="name flex">
<span>def <span class="ident">framerate</span></span>(<span>self, fps=None, speed=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Resample keyframes from known original framerate set by constructor to be new framerate fps.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>fps</code></strong></dt>
<dd>[float]
The new frame rate in frames per second</dd>
<dt><strong><code>speed</code></strong></dt>
<dd>[float]
An optional speed factor which will multiply the current framerate by this factor (e.g. speed=2 &ndash;&gt; fps=self.framerate()*2)</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>This track object with the keyframes resampled to the new framerate</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L491-L513" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def framerate(self, fps=None, speed=None):
    &#34;&#34;&#34;Resample keyframes from known original framerate set by constructor to be new framerate fps.

    Args:
        fps: [float]  The new frame rate in frames per second
        speed: [float]  An optional speed factor which will multiply the current framerate by this factor (e.g. speed=2 --&gt; fps=self.framerate()*2)

    Returns:
        This track object with the keyframes resampled to the new framerate

    &#34;&#34;&#34;
    if fps is None and speed is None:
        return self._framerate
    
    assert self._framerate is not None, &#34;Framerate conversion requires that the framerate is known for current keyframes.  This must be provided to the vipy.object.Track() constructor.&#34;
    assert fps is not None or speed is not None, &#34;Invalid input&#34;
    assert not (fps is not None and speed is not None), &#34;Invalid input&#34;
    assert speed is None or speed &gt; 0, &#34;Invalid speed, must specify speed multiplier s=1, s=2 for 2x faster, s=0.5 for half slower&#34;
    
    fps = float(fps) if fps is not None else (1.0/speed)*self._framerate
    self._keyframes = [int(np.round(f*(fps/float(self._framerate)))) for f in self._keyframes]
    self._framerate = fps
    return self</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.has_normalized_coordinates"><code class="name flex">
<span>def <span class="ident">has_normalized_coordinates</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L379-L380" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def has_normalized_coordinates(self):
    return all(isinstance(bb, Detection) and bb.has_normalized_coordinates() for bb in self.keyboxes())</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.id"><code class="name flex">
<span>def <span class="ident">id</span></span>(<span>self, newid=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L749-L754" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def id(self, newid=None):
    if newid is None:
        return self._id
    else:
        self._id = newid
        return self</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.imclip"><code class="name flex">
<span>def <span class="ident">imclip</span></span>(<span>self, width, height)</span>
</code></dt>
<dd>
<div class="desc"><p>Clip the track to the image rectangle (width, height).
If a keybox is outside the image rectangle, remove it otherwise clip to the image rectangle.
This operation can change the length of the track and the size of the keyboxes.
The result may be an empty track if the track is completely outside
the image rectangle, which results in an exception.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L1058-L1069" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def imclip(self, width, height):
    &#34;&#34;&#34;Clip the track to the image rectangle (width, height).  If a keybox is outside the image rectangle, remove it otherwise clip to the image rectangle. 
       This operation can change the length of the track and the size of the keyboxes.  The result may be an empty track if the track is completely outside
       the image rectangle, which results in an exception.
    &#34;&#34;&#34;
    clipped = [(f, bb.imclip(width=width, height=height)) for (f,bb) in zip(self._keyframes, self._keyboxes) if bb.hasoverlap(width=width, height=height)]
    if len(clipped) &gt; 0:
        (self._keyframes, self._keyboxes) = zip(*clipped)
        (self._keyframes, self._keyboxes) = (list(self._keyframes), list(self._keyboxes))
        return self
    else:
        raise ValueError(&#39;All key boxes for track outside image rectangle&#39;)</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.iou"><code class="name flex">
<span>def <span class="ident">iou</span></span>(<span>self, other, dt=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the spatial IoU between two tracks as the mean IoU per frame in the range (self.startframe(), self.endframe())</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L851-L853" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def iou(self, other, dt=1):
    &#34;&#34;&#34;Compute the spatial IoU between two tracks as the mean IoU per frame in the range (self.startframe(), self.endframe())&#34;&#34;&#34;
    return self.rankiou(other, rank=len(self), dt=dt)</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.isdegenerate"><code class="name flex">
<span>def <span class="ident">isdegenerate</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Is the track degenerate?
</p>
<p>A degenerate track has:
- Unequal length keyboxes and keyframes
- length zero track
- Non increasing keyframes
- Invalid keyboxes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L394-L405" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isdegenerate(self):
    &#34;&#34;&#34;Is the track degenerate?  
    
    A degenerate track has:
        - Unequal length keyboxes and keyframes
        - length zero track
        - Non increasing keyframes
        - Invalid keyboxes
    &#34;&#34;&#34;
    return not (len(self.keyboxes()) == len(self.keyframes()) and
                (len(self) == 0 or all([bb.isvalid() for bb in self.keyboxes()])) and
                sorted(self.keyframes()) == list(self.keyframes()))</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.isempty"><code class="name flex">
<span>def <span class="ident">isempty</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L376-L377" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isempty(self):
    return self.__len__() == 0</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.ismoving"><code class="name flex">
<span>def <span class="ident">ismoving</span></span>(<span>self, startframe=None, endframe=None, mincover=0.9)</span>
</code></dt>
<dd>
<div class="desc"><p>Is the track moving in the frame range (startframe,endframe)?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L1177-L1180" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def ismoving(self, startframe=None, endframe=None, mincover=0.9):
    &#34;&#34;&#34;Is the track moving in the frame range (startframe,endframe)?&#34;&#34;&#34;
    (bbs, bbe) = (self[max(self.startframe(), startframe)] if startframe is not None else self.startbox(), self[min(self.endframe(), endframe)] if endframe is not None else self.endbox())
    return (bbs.maxcover(bbe) &lt; mincover) if (bbs is not None and bbe is not None) else False</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.json"><code class="name flex">
<span>def <span class="ident">json</span></span>(<span>self, encode=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L348-L352" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def json(self, encode=True):
    d = {k:getattr(self, k) if k != &#39;_keyboxes&#39; else tuple([bb.json(encode=False) for bb in getattr(self, k)]) for k in Track.__slots__}        
    d = {k.lstrip(&#39;_&#39;):v for (k,v) in d.items() if v is not None}  # prettyjson (remove &#34;_&#34; prefix to attributes)                
    d[&#39;keyframes&#39;] = tuple([int(f) for f in self._keyframes])
    return json.dumps(d) if encode else d</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.keyboxes"><code class="name flex">
<span>def <span class="ident">keyboxes</span></span>(<span>self, boxes=None, keyframes=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return keyboxes where there are track observations</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L458-L467" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def keyboxes(self, boxes=None, keyframes=None):
    &#34;&#34;&#34;Return keyboxes where there are track observations&#34;&#34;&#34;
    if boxes is None and keyframes is None:
        return self._keyboxes
    else:
        assert all([isinstance(bb, BoundingBox) for bb in boxes])
        self._keyboxes = boxes
        self._keyframes = keyframes if keyframes is not None else self._keyframes
        assert not self.isdegenerate()
        return self</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.keyframes"><code class="name flex">
<span>def <span class="ident">keyframes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return keyframe frame indexes where there are track observations</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L451-L453" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def keyframes(self):
    &#34;&#34;&#34;Return keyframe frame indexes where there are track observations&#34;&#34;&#34;
    return self._keyframes</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.label"><code class="name flex">
<span>def <span class="ident">label</span></span>(<span>self, label)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for category</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L607-L609" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def label(self, label):
    &#34;&#34;&#34;Alias for category&#34;&#34;&#34;
    return self.category(label)</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.linear_extrapolation"><code class="name flex">
<span>def <span class="ident">linear_extrapolation</span></span>(<span>self, k, shape=False, dt=30)</span>
</code></dt>
<dd>
<div class="desc"><p>Track extrapolation by linear fit.</p>
<ul>
<li>Requires at least 2 keyboxes.</li>
<li>Returned boxes may be degenerate.</li>
<li>shape=True then both the position and shape (width, height) of the box is extrapolated</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L1039-L1056" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def linear_extrapolation(self, k, shape=False, dt=30):
    &#34;&#34;&#34;Track extrapolation by linear fit.
    
       * Requires at least 2 keyboxes.
       * Returned boxes may be degenerate.
       * shape=True then both the position and shape (width, height) of the box is extrapolated
    &#34;&#34;&#34;
    if self.during(k):
        return self[k]
    elif len(self._keyboxes) == 1:
        return self.nearest_keybox(k)
    else:
        n = self.endframe() if k &gt; self.endframe() else self.startframe()+1
        d = self.endbox().clone() if k &gt; self.endframe() else self.startbox().clone()
        (vx, vy) = self.shape_invariant_velocity(n, dt=dt) if not shape else self.velocity(n, dt=dt)
        (vw, vh) = (self.velocity_w(n, dt=dt), self.velocity_h(n, dt=dt)) if shape else (0,0)
        d = d.translate((k-n)*vx, (k-n)*vy)
        return d if not shape else d.top( ((k-n)*vh)/2.0).bottom( ((k-n)*vh)/2.0).left( ((k-n)*vw)/2.0).right( ((k-n)*vw)/2.0)</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.linear_interpolation"><code class="name flex">
<span>def <span class="ident">linear_interpolation</span></span>(<span>self, f)</span>
</code></dt>
<dd>
<div class="desc"><p>Linear bounding box interpolation at frame=f given observed boxes (x,y,w,h) at keyframes.
</p>
<p>This returns a <code><a title="vipy.object.Detection" href="#vipy.object.Detection">Detection</a></code> which is the interpolation of the <code><a title="vipy.object.Track" href="#vipy.object.Track">Track</a></code> at frame k</p>
<ul>
<li>If self._boundary='extend', then boxes are repeated if the interpolation is outside the keyframes</li>
<li>If self._boundary='strict', then interpolation returns None if the interpolation is outside the keyframes</li>
</ul>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul>
<li>The returned BoundingBox object is not cloned when possible for speed purposes, be careful when modifying this object.
clone() the returned object if necessary</li>
<li>This means that we return a reference to the underlying keybox upgraded with track properties and cast as <code><a title="vipy.object.Detection" href="#vipy.object.Detection">Detection</a></code>.
If you modify this object, then the track keybox will be modfied.</li>
</ul>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L539-L573" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def linear_interpolation(self, f):
    &#34;&#34;&#34;Linear bounding box interpolation at frame=f given observed boxes (x,y,w,h) at keyframes.  

    This returns a `vipy.object.Detection` which is the interpolation of the `vipy.object.Track` at frame k

    - If self._boundary=&#39;extend&#39;, then boxes are repeated if the interpolation is outside the keyframes
    - If self._boundary=&#39;strict&#39;, then interpolation returns None if the interpolation is outside the keyframes
    
    .. note::  
        - The returned BoundingBox object is not cloned when possible for speed purposes, be careful when modifying this object.  clone() the returned object if necessary
        - This means that we return a reference to the underlying keybox upgraded with track properties and cast as `vipy.object.Detection`.  If you modify this object, then the track keybox will be modfied.
    &#34;&#34;&#34;
    assert len(self._keyboxes) &gt; 0, &#34;Degenerate object for interpolation&#34;   # not self.isempty()
    if len(self._keyboxes) == 1:
        return Detection.cast(self._keyboxes[0].clone()).new_category(self.category()).set_attribute(&#39;__trackid&#39;, self.id()) if (self._boundary == &#39;extend&#39; or self.during(f)) else None
    if f in self._keyframes:            
        return Detection.cast(self._keyboxes[self._keyframes.index(f)].clone()).new_category(self.category()).set_attribute(&#39;__trackid&#39;, self.id())  # clone requuired to not pollute attributes

    kf = self._keyframes
    ft = min(max(f, kf[0]), kf[-1])  # truncated frame index
    for i in reversed(range(0, len(kf)-1)):
        if kf[i] &lt;= ft and kf[i+1] &gt;= ft:
            break  # floor keyframe index
    c = (ft - kf[i]) / max(1, float(kf[i+1] - kf[i]))  # interpolation coefficient
    (bi, bj) = (self._keyboxes[i], self._keyboxes[i+1])
    d = Detection(xmin=bi._xmin + c*(bj._xmin - bi._xmin),   # float(np.interp(k, self._keyframes, [bb._xmin for bb in self._keyboxes])),
                  ymin=bi._ymin + c*(bj._ymin - bi._ymin),   # float(np.interp(k, self._keyframes, [bb._ymin for bb in self._keyboxes])),
                  xmax=bi._xmax + c*(bj._xmax - bi._xmax),   # float(np.interp(k, self._keyframes, [bb._xmax for bb in self._keyboxes])),
                  ymax=bi._ymax + c*(bj._ymax - bi._ymax),   # float(np.interp(k, self._keyframes, [bb._ymax for bb in self._keyboxes])),
                  confidence=bi.confidence() if isinstance(bi, Detection) else None,
                  attributes=bi.attributes.copy() if isinstance(bi, Detection) else None,  # unshared attributes (to allow for __trackid)
                  category=self.category())

    d.attributes[&#39;__trackid&#39;] = self.id()  # for correspondence of detections to tracks
    return d if self._boundary == &#39;extend&#39; or self.during(f) else None</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.loop_closure_distance"><code class="name flex">
<span>def <span class="ident">loop_closure_distance</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>The loop closure track distance is the Euclidean distance in pixels between the start frame bounding box and end frame bounding box</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L814-L816" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def loop_closure_distance(self):
    &#34;&#34;&#34;The loop closure track distance is the Euclidean distance in pixels between the start frame bounding box and end frame bounding box&#34;&#34;&#34;
    return self.startbox().dist(self.endbox()) if not self.isdegenerate() else None</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.maxiou"><code class="name flex">
<span>def <span class="ident">maxiou</span></span>(<span>self, other, dt=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the maximum spatial IoU between two tracks per frame in the range (self.startframe(), self.endframe())</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L861-L863" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def maxiou(self, other, dt=1):
    &#34;&#34;&#34;Compute the maximum spatial IoU between two tracks per frame in the range (self.startframe(), self.endframe())&#34;&#34;&#34;        
    return self.rankiou(other, rank=1, dt=dt)</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.maxsquare"><code class="name flex">
<span>def <span class="ident">maxsquare</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set all of the track boxes to maxsquare</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L724-L727" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def maxsquare(self):
    &#34;&#34;&#34;Set all of the track boxes to maxsquare&#34;&#34;&#34;
    self._keyboxes = [bb.maxsquare() for bb in self._keyboxes]
    return self</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.meanbox"><code class="name flex">
<span>def <span class="ident">meanbox</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the mean bounding box during the track, or None if the track is degenerate</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L474-L476" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def meanbox(self):
    &#34;&#34;&#34;Return the mean bounding box during the track, or None if the track is degenerate&#34;&#34;&#34;
    return BoundingBox(ulbr=np.mean([bb.ulbr() for bb in self.keyboxes()], axis=0)) if len(self.keyboxes()) &gt; 0 else None </code></pre>
</details>
</dd>
<dt id="vipy.object.Track.meanshape"><code class="name flex">
<span>def <span class="ident">meanshape</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the mean (width,height) of the box during the track, or None if the track is degenerate</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L469-L472" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def meanshape(self):
    &#34;&#34;&#34;Return the mean (width,height) of the box during the track, or None if the track is degenerate&#34;&#34;&#34;
    s = np.mean([bb.shape() for bb in self.keyboxes()], axis=0) if len(self.keyboxes()) &gt; 0 else None
    return (float(s[0]), float(s[1])) if s is not None else None</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.medianshape"><code class="name flex">
<span>def <span class="ident">medianshape</span></span>(<span>self, width)</span>
</code></dt>
<dd>
<div class="desc"><p>Track smoothing by median width and height of neighboring keyboxes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L1006-L1011" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def medianshape(self, width):
    &#34;&#34;&#34;Track smoothing by median width and height of neighboring keyboxes&#34;&#34;&#34;
    assert isinstance(width, int) and width &gt; 0
    if len(self._keyboxes) &gt; width:
        self._keyboxes = [bb.clone().medianshape(bbnbrs) for (bb, bbnbrs) in zip(self._keyboxes, chunklistwithoverlap(self._keyboxes, width, width-1))]
    return self</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.nearest_keybox"><code class="name flex">
<span>def <span class="ident">nearest_keybox</span></span>(<span>self, f)</span>
</code></dt>
<dd>
<div class="desc"><p>Nearest keybox to frame f</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L1172-L1175" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def nearest_keybox(self, f):
    &#34;&#34;&#34;Nearest keybox to frame f&#34;&#34;&#34;
    assert len(self._keyframes) &gt; 0
    return self._keyboxes[int(np.abs(np.array(self._keyframes) - f).argmin())]  # by-reference</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.nearest_keyframe"><code class="name flex">
<span>def <span class="ident">nearest_keyframe</span></span>(<span>self, f)</span>
</code></dt>
<dd>
<div class="desc"><p>Nearest keyframe to frame f</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L1167-L1170" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def nearest_keyframe(self, f):
    &#34;&#34;&#34;Nearest keyframe to frame f&#34;&#34;&#34;
    assert len(self._keyframes) &gt; 0
    return self._keyframes[int(np.abs(np.array(self._keyframes) - f).argmin())]</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.num_keyframes"><code class="name flex">
<span>def <span class="ident">num_keyframes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L455-L456" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def num_keyframes(self):
    return len(self._keyframes)</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.offset"><code class="name flex">
<span>def <span class="ident">offset</span></span>(<span>self, dt=0, dx=0, dy=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply a temporal shift of dt frames, and a spatial shift of (dx, dy) pixels.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>dt</code></strong></dt>
<dd>[int] frame offset</dd>
<dt><strong><code>dx</code></strong></dt>
<dd>[float] horizontal spatial offset </dd>
<dt><strong><code>dy</code></strong></dt>
<dd>[float] vertical spatial offset </dd>
</dl>
<h2 id="returns">Returns</h2>
<p>This box updated in place</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L628-L642" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def offset(self, dt=0, dx=0, dy=0):
    &#34;&#34;&#34;Apply a temporal shift of dt frames, and a spatial shift of (dx, dy) pixels.
    
    Args:
        dt: [int] frame offset
        dx: [float] horizontal spatial offset 
        dy: [float] vertical spatial offset 

    Returns:
        This box updated in place
    &#34;&#34;&#34;
    dt = int(np.round(dt*self.framerate())) if isinstance(dt, float) else dt
    self._keyboxes = [bb.offset(dx, dy) for bb in self._keyboxes]
    self._keyframes = [(f+dt) for f in self._keyframes]
    return self</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.pathlength"><code class="name flex">
<span>def <span class="ident">pathlength</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>The path length of a track is the cumulative Euclidean distance in pixels that the box travels</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L802-L804" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def pathlength(self):
    &#34;&#34;&#34;The path length of a track is the cumulative Euclidean distance in pixels that the box travels&#34;&#34;&#34;
    return float(np.sum([bb_next.dist(bb_prev) for (bb_next, bb_prev) in zip(self._keyboxes[1:], self._keyboxes[0:-1])])) if len(self._keyboxes)&gt;1 else 0.0</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.percentileiou"><code class="name flex">
<span>def <span class="ident">percentileiou</span></span>(<span>self, other, percentile, samples=100)</span>
</code></dt>
<dd>
<div class="desc"><p>Percentile iou returns rankiou for rank=percentile*len(overlap(self, other))</p>
<p>-other [Track]
-percentile [0,1]:
The top-k best overlaps to average when computing rankiou
-samples:
The number of uniformly spaced samples to take along the track for computing the rankiou</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L909-L924" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def percentileiou(self, other, percentile, samples=100):
    &#34;&#34;&#34;Percentile iou returns rankiou for rank=percentile*len(overlap(self, other))
    
       -other [Track]
       -percentile [0,1]:  The top-k best overlaps to average when computing rankiou
       -samples:  The number of uniformly spaced samples to take along the track for computing the rankiou
    &#34;&#34;&#34;
    assert percentile &gt; 0 and percentile &lt;= 1
    assert isinstance(other, Track), &#34;invalid input - Must be vipy.object.Track()&#34;
    assert self.framerate() == other.framerate()
    
    startframe = max(self.startframe(), other.startframe())
    endframe = min(self.endframe(), other.endframe())
    segmentlen = endframe - startframe
    dt = max(1, int(np.floor(segmentlen/samples)))
    return self.rankiou(other, max(1, int(segmentlen*percentile)), dt=dt) if segmentlen &gt; 0 else 0</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.rankiou"><code class="name flex">
<span>def <span class="ident">rankiou</span></span>(<span>self, other, rank, dt=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the mean spatial IoU between two tracks per frame in the range (self.startframe(), self.endframe()) using only the top-k (rank) frame overlaps
Sample tracks at endpoints and n uniformly spaced frames or a stride of dt frames.
</p>
<ul>
<li>rank [&gt;1]:
The top-k best IOU overlaps to average when computing the rank IOU</li>
<li>This is useful for track continuation where the box deforms in the overlapping segment at the end due to occlusion. </li>
<li>This is useful for track correspondence where a ground truth box does not match an estimated box precisely (e.g. loose box, non-visually grounded box)</li>
<li>This is the robust version of segmentiou.</li>
<li>Use percentileiou to determine the rank based a fraction of the length of the overlap, which will be more efficient for long tracks</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L893-L907" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rankiou(self, other, rank, dt=1):
    &#34;&#34;&#34;Compute the mean spatial IoU between two tracks per frame in the range (self.startframe(), self.endframe()) using only the top-k (rank) frame overlaps
       Sample tracks at endpoints and n uniformly spaced frames or a stride of dt frames.  
    
       - rank [&gt;1]:  The top-k best IOU overlaps to average when computing the rank IOU
       - This is useful for track continuation where the box deforms in the overlapping segment at the end due to occlusion. 
       - This is useful for track correspondence where a ground truth box does not match an estimated box precisely (e.g. loose box, non-visually grounded box)
       - This is the robust version of segmentiou.
       - Use percentileiou to determine the rank based a fraction of the length of the overlap, which will be more efficient for long tracks
    &#34;&#34;&#34;
    assert rank &gt;= 1 and rank &lt;= len(self)
    assert isinstance(other, Track), &#34;Invalid input - must be vipy.object.Track()&#34;
    assert dt &gt;= 1
    frames = [self.startframe()] + list(range(self.startframe()+dt, self.endframe(), dt)) + [self.endframe()]
    return float(np.mean(sorted([self[k].iou(other[k]) if (self.during(k) and other.during(k)) else 0.0 for k in frames])[-rank:]))</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.replace"><code class="name flex">
<span>def <span class="ident">replace</span></span>(<span>self, keyframe, box)</span>
</code></dt>
<dd>
<div class="desc"><p>Replace the keyframe and associated box(es), preserve sorted order of keyframes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L439-L441" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def replace(self, keyframe, box):
    &#34;&#34;&#34;Replace the keyframe and associated box(es), preserve sorted order of keyframes&#34;&#34;&#34;
    return self.delete(keyframe).add(keyframe, box)</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.resample"><code class="name flex">
<span>def <span class="ident">resample</span></span>(<span>self, dt)</span>
</code></dt>
<dd>
<div class="desc"><p>Resample the track using a stride of dt frames.
This reduces the density of keyframes by interpolating new keyframes as a uniform stride of dt.
This is useful for track compression</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L1071-L1077" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def resample(self, dt):
    &#34;&#34;&#34;Resample the track using a stride of dt frames.  This reduces the density of keyframes by interpolating new keyframes as a uniform stride of dt.  This is useful for track compression&#34;&#34;&#34;
    assert dt &gt;= 1 and dt &lt; len(self)
    frames =  list(range(self.startframe(), self.endframe(), dt)) + [self.endframe()]
    (self._keyboxes, self._keyframes) = zip(*[(self[k], k) for k in frames])
    (self._keyboxes, self._keyframes) = (list(self._keyboxes), list(self._keyframes))
    return self</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.rescale"><code class="name flex">
<span>def <span class="ident">rescale</span></span>(<span>self, s)</span>
</code></dt>
<dd>
<div class="desc"><p>Rescale track boxes by scale factor s</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L699-L703" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rescale(self, s):
    &#34;&#34;&#34;Rescale track boxes by scale factor s&#34;&#34;&#34;
    if s != 1.0:
        self._keyboxes = [bb.rescale(s) for bb in self._keyboxes]
    return self</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.rot90ccw"><code class="name flex">
<span>def <span class="ident">rot90ccw</span></span>(<span>self, H, W)</span>
</code></dt>
<dd>
<div class="desc"><p>Rotate an image with (H,W)=shape 90 degrees clockwise and update all boxes to be consistent</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L734-L737" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rot90ccw(self, H, W):
    &#34;&#34;&#34;Rotate an image with (H,W)=shape 90 degrees clockwise and update all boxes to be consistent&#34;&#34;&#34;
    self._keyboxes = [bb.rot90ccw(H, W) for bb in self._keyboxes]
    return self</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.rot90cw"><code class="name flex">
<span>def <span class="ident">rot90cw</span></span>(<span>self, H, W)</span>
</code></dt>
<dd>
<div class="desc"><p>Rotate an image with (H,W)=shape 90 degrees clockwise and update all boxes to be consistent</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L729-L732" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rot90cw(self, H, W):
    &#34;&#34;&#34;Rotate an image with (H,W)=shape 90 degrees clockwise and update all boxes to be consistent&#34;&#34;&#34;
    self._keyboxes = [bb.rot90cw(H, W) for bb in self._keyboxes]
    return self</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.scale"><code class="name flex">
<span>def <span class="ident">scale</span></span>(<span>self, s)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for rescale</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L705-L707" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def scale(self, s):
    &#34;&#34;&#34;Alias for rescale&#34;&#34;&#34;
    return self.rescale(s)</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.scale_x"><code class="name flex">
<span>def <span class="ident">scale_x</span></span>(<span>self, sx)</span>
</code></dt>
<dd>
<div class="desc"><p>Rescale track boxes by scale factor sx</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L709-L712" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def scale_x(self, sx):
    &#34;&#34;&#34;Rescale track boxes by scale factor sx&#34;&#34;&#34;
    self._keyboxes = [bb.scale_x(sx) for bb in self._keyboxes]
    return self</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.scale_y"><code class="name flex">
<span>def <span class="ident">scale_y</span></span>(<span>self, sy)</span>
</code></dt>
<dd>
<div class="desc"><p>Rescale track boxes by scale factor sx</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L714-L717" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def scale_y(self, sy):
    &#34;&#34;&#34;Rescale track boxes by scale factor sx&#34;&#34;&#34;
    self._keyboxes = [bb.scale_y(sy) for bb in self._keyboxes]
    return self</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.segment_maxiou"><code class="name flex">
<span>def <span class="ident">segment_maxiou</span></span>(<span>self, other, startframe, endframe)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the maximum framewise bounding box IOU between self and other in the range (startframe, endframe)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L855-L859" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def segment_maxiou(self, other, startframe, endframe):
    &#34;&#34;&#34;Return the maximum framewise bounding box IOU between self and other in the range (startframe, endframe)&#34;&#34;&#34;
    assert isinstance(other, Track), &#34;invalid input - Must be vipy.object.Track()&#34;
    assert startframe &lt; endframe
    return max([self[k].iou(other[k]) if (self[k] is not None) else 0 for k in range(startframe, endframe)])</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.segment_percentilecover"><code class="name flex">
<span>def <span class="ident">segment_percentilecover</span></span>(<span>self, other, percentile, samples=100)</span>
</code></dt>
<dd>
<div class="desc"><p>percentile cover on the overlapping segment with other</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L941-L954" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def segment_percentilecover(self, other, percentile, samples=100):
    &#34;&#34;&#34;percentile cover on the overlapping segment with other&#34;&#34;&#34;
    assert percentile &gt; 0 and percentile &lt;= 1
    assert isinstance(other, Track), &#34;invalid input - Must be vipy.object.Track()&#34;
    assert self.framerate() == other.framerate()
    
    startframe = max(self.startframe(), other.startframe())
    endframe = min(self.endframe(), other.endframe())
    segmentlen = endframe - startframe
    rank = int(segmentlen*percentile)
    dt = max(1, int(np.floor(segmentlen/samples)))
    bblist = [(self[min(k,endframe)], other[min(k,endframe)]) for k in range(startframe, endframe, dt)] if endframe &gt; startframe else []
    cover = [max(bbself.cover(bbother), bbother.cover(bbself)) for (bbself, bbother) in bblist]
    return float(np.mean(cover[-rank:]) if endframe &gt; startframe else 0.0)</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.segment_percentileiou"><code class="name flex">
<span>def <span class="ident">segment_percentileiou</span></span>(<span>self, other, percentile, samples=100)</span>
</code></dt>
<dd>
<div class="desc"><p>percentiliou on the overlapping segment with other</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L926-L938" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def segment_percentileiou(self, other, percentile, samples=100):
    &#34;&#34;&#34;percentiliou on the overlapping segment with other&#34;&#34;&#34;
    assert percentile &gt; 0 and percentile &lt;= 1
    assert isinstance(other, Track), &#34;invalid input - Must be vipy.object.Track()&#34;
    assert self.framerate() == other.framerate()
    
    startframe = max(self.startframe(), other.startframe())
    endframe = min(self.endframe(), other.endframe())
    segmentlen = endframe - startframe
    rank = int(segmentlen*percentile)
    dt = max(1, int(np.floor(segmentlen/samples)))
    iou = sorted([self[min(k,endframe)].iou(other[min(k,endframe)]) for k in range(startframe, endframe, dt)]) if endframe &gt; startframe else []
    return float(np.mean(iou[-rank:]) if endframe &gt; startframe else 0.0)</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.segmentcover"><code class="name flex">
<span>def <span class="ident">segmentcover</span></span>(<span>self, other, dt=5)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the mean spatial cover between two tracks at the overlapping segment, sampling by dt.
Useful for track continuation for densely overlapping tracks</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L886-L891" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def segmentcover(self, other, dt=5):
    &#34;&#34;&#34;Compute the mean spatial cover between two tracks at the overlapping segment, sampling by dt.  Useful for track continuation for densely overlapping tracks&#34;&#34;&#34;
    assert isinstance(other, Track), &#34;invalid input - Must be vipy.object.Track()&#34;
    startframe = max(self.startframe(), other.startframe())
    endframe = min(self.endframe(), other.endframe())   # inclusive
    return float(np.mean([self[min(k,endframe)].maxcover(other[min(k,endframe)]) for k in range(startframe, endframe, dt)]) if endframe &gt; startframe else 0.0)</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.segmentiou"><code class="name flex">
<span>def <span class="ident">segmentiou</span></span>(<span>self, other, dt=5)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the mean spatial IoU between two tracks at the overlapping segment, sampling by dt.
Useful for track continuation for densely overlapping tracks</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L879-L884" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def segmentiou(self, other, dt=5):
    &#34;&#34;&#34;Compute the mean spatial IoU between two tracks at the overlapping segment, sampling by dt.  Useful for track continuation for densely overlapping tracks&#34;&#34;&#34;
    assert isinstance(other, Track), &#34;invalid input - Must be vipy.object.Track()&#34;
    startframe = max(self.startframe(), other.startframe())
    endframe = min(self.endframe(), other.endframe())   # inclusive
    return float(np.mean([self[min(k,endframe)].iou(other[min(k,endframe)]) for k in range(startframe, endframe, dt)]) if endframe &gt; startframe else 0.0)</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.shape_invariant_velocity"><code class="name flex">
<span>def <span class="ident">shape_invariant_velocity</span></span>(<span>self, f, dt=30)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the (x,y) track velocity at frame f in units of pixels per frame computed by minimum mean finite differences of any box corner independent of changes in shape, over a finite time window of [f-dt, f]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L1135-L1145" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def shape_invariant_velocity(self, f, dt=30):
    &#34;&#34;&#34;Return the (x,y) track velocity at frame f in units of pixels per frame computed by minimum mean finite differences of any box corner independent of changes in shape, over a finite time window of [f-dt, f]&#34;&#34;&#34;
    assert f &gt;= 0 and dt &gt; 0
    if len(self) &lt; 2 or not (self.during(f) and self.during(f-dt)) :
        return (0,0)
    
    kb = [((f-dt), self.linear_interpolation(f-dt))] + [(kf, bb) for (kf,bb) in zip(self._keyframes, self._keyboxes) if (kf &gt; f-dt) and (kf &lt; f)]
    (kfe, bbe) = (f, self.linear_interpolation(f))
    vx = float((1.0/len(kb))*sum([min([(bbe._xmin - bb._xmin), (bbe._xmax - bb._xmax)], key=abs)/float(kfe-kf) for (kf,bb) in kb]))
    vy = float((1.0/len(kb))*sum([min([(bbe._ymin - bb._ymin), (bbe._ymax - bb._ymax)], key=abs)/float(kfe-kf) for (kf,bb) in kb]))
    return (vx, vy)</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.shapevariance"><code class="name flex">
<span>def <span class="ident">shapevariance</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the variance (width, height) of the box shape relative to <code><a title="vipy.object.Track.meanbox" href="#vipy.object.Track.meanbox">Track.meanbox()</a></code> during the track or None if the track is degenerate.
</p>
<p>This is useful for filtering spurious tracks where the aspect ratio changes rapidly and randomly</p>
<h2 id="returns">Returns</h2>
<p>(width_variance, height_variance) of the box shape during the track (or None)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L478-L488" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def shapevariance(self):
    &#34;&#34;&#34;Return the variance (width, height) of the box shape relative to `vipy.object.Track.meanbox` during the track or None if the track is degenerate.  

    This is useful for filtering spurious tracks where the aspect ratio changes rapidly and randomly

    Returns:
        (width_variance, height_variance) of the box shape during the track (or None)
    &#34;&#34;&#34;
    m = self.meanshape()
    return (float(np.mean([(bb.width() - m[0])**2 for bb in self.keyboxes()])), 
            float(np.mean([(bb.height() - m[1])**2 for bb in self.keyboxes()]))) if m is not None else None</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.significant_digits"><code class="name flex">
<span>def <span class="ident">significant_digits</span></span>(<span>self, n)</span>
</code></dt>
<dd>
<div class="desc"><p>Round the coordinates of all boxes so that they have n significant digits for efficient serialization</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L1079-L1082" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def significant_digits(self, n):
    &#34;&#34;&#34;Round the coordinates of all boxes so that they have n significant digits for efficient serialization&#34;&#34;&#34;
    self._keyboxes = [bb.significant_digits(n) for bb in self._keyboxes]
    return self</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.smallestbox"><code class="name flex">
<span>def <span class="ident">smallestbox</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>The smallest box of a track is the smallest spatial box in area along the track</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L792-L795" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def smallestbox(self):
    &#34;&#34;&#34;The smallest box of a track is the smallest spatial box in area along the track&#34;&#34;&#34;
    k = np.argmin([bb.area() for bb in self._keyboxes]) if len(self._keyboxes) &gt; 0 else None
    return self._keyboxes[k] if k is not None else None</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.smooth"><code class="name flex">
<span>def <span class="ident">smooth</span></span>(<span>self, width)</span>
</code></dt>
<dd>
<div class="desc"><p>Track smoothing by averaging neighboring keyboxes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L992-L997" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def smooth(self, width):
    &#34;&#34;&#34;Track smoothing by averaging neighboring keyboxes&#34;&#34;&#34;
    assert isinstance(width, int) and width &gt; 0
    if len(self._keyboxes) &gt; width:
        self._keyboxes = [bb.clone().average(bbnbrs) for (bb, bbnbrs) in zip(self._keyboxes, chunklistwithoverlap(self._keyboxes, width, width-1))] 
    return self</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.smoothshape"><code class="name flex">
<span>def <span class="ident">smoothshape</span></span>(<span>self, width)</span>
</code></dt>
<dd>
<div class="desc"><p>Track smoothing by averaging width and height of neighboring keyboxes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L999-L1004" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def smoothshape(self, width):
    &#34;&#34;&#34;Track smoothing by averaging width and height of neighboring keyboxes&#34;&#34;&#34;
    assert isinstance(width, int) and width &gt; 0
    if len(self._keyboxes) &gt; width:
        self._keyboxes = [bb.clone().averageshape(bbnbrs) for (bb, bbnbrs) in zip(self._keyboxes, chunklistwithoverlap(self._keyboxes, width, width-1))]
    return self</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.speed"><code class="name flex">
<span>def <span class="ident">speed</span></span>(<span>self, f, dt=30)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L1125-L1127" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def speed(self, f, dt=30):
    (u,v) = self.shape_invariant_velocity(f, dt)
    return float(np.sqrt(u**2 + v**2))</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.spline"><code class="name flex">
<span>def <span class="ident">spline</span></span>(<span>self, smoothingfactor=None, strict=True, startframe=None, endframe=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Track smoothing by cubic spline fit, will return resampled dt=1 track.
Smoothing factor will increase with smoothing &gt; 1 and decrease with 0 &lt; smoothing &lt; 1</p>
<p>This function requires optional package scipy</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L1013-L1037" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def spline(self, smoothingfactor=None, strict=True, startframe=None, endframe=None):
    &#34;&#34;&#34;Track smoothing by cubic spline fit, will return resampled dt=1 track.  Smoothing factor will increase with smoothing &gt; 1 and decrease with 0 &lt; smoothing &lt; 1
    
       This function requires optional package scipy
    &#34;&#34;&#34;
    try_import(&#39;scipy&#39;, &#39;scipy&#39;);  import scipy.interpolate;
    assert smoothingfactor is None or smoothingfactor &gt; 0
    t = self.clone().resample(dt=1)
    (startframe, endframe) = (self.startframe() if startframe is None else startframe, self.endframe() if endframe is None else endframe)
    try:
        assert len(t._keyframes) &gt; 4, &#34;Invalid length for spline interpolation&#34;        
        s = smoothingfactor * len(self._keyframes) if smoothingfactor is not None else None
        (xmin, ymin, xmax, ymax) = zip(*[bb.to_ulbr() for bb in t._keyboxes])
        f_xmin = scipy.interpolate.UnivariateSpline(t._keyframes, xmin, check_finite=False, s=s)
        f_ymin = scipy.interpolate.UnivariateSpline(t._keyframes, ymin, check_finite=False, s=s)
        f_xmax = scipy.interpolate.UnivariateSpline(t._keyframes, xmax, check_finite=False, s=s)
        f_ymax = scipy.interpolate.UnivariateSpline(t._keyframes, ymax, check_finite=False, s=s)
        (self._keyframes, self._keyboxes) = zip(*[(k, BoundingBox(xmin=float(f_xmin(k)), ymin=float(f_ymin(k)), xmax=float(f_xmax(k)), ymax=float(f_ymax(k)))) for k in range(startframe, endframe)])
    except Exception as e:
        if not strict:
            log.warning(&#39;[vipy.object.track]: spline smoothing failed with error &#34;%s&#34; - Returning unsmoothed track&#39; % (str(e)))
            return self
        else:
            raise
    return self</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.startbox"><code class="name flex">
<span>def <span class="ident">startbox</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>The startbox is the first bounding box in the track</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L806-L808" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def startbox(self):
    &#34;&#34;&#34;The startbox is the first bounding box in the track&#34;&#34;&#34;
    return self._keyboxes[0] if len(self._keyboxes) &gt; 0 else None</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.startframe"><code class="name flex">
<span>def <span class="ident">startframe</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the startframe of the track or None if there are no keyframes.
</p>
<p>The frame index is relative to the framerate set in the constructor.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L515-L521" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def startframe(self):
    &#34;&#34;&#34;Return the startframe of the track or None if there are no keyframes.  
    
    The frame index is relative to the framerate set in the constructor.

    &#34;&#34;&#34;        
    return int(self._keyframes[0]) if len(self._keyframes)&gt;0 else None  # assumes sorted order</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.temporal_distance"><code class="name flex">
<span>def <span class="ident">temporal_distance</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>The temporal distance between two tracks is the minimum number of frames separating them</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L987-L990" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def temporal_distance(self, other):
    &#34;&#34;&#34;The temporal distance between two tracks is the minimum number of frames separating them&#34;&#34;&#34;
    assert isinstance(other, Track), &#34;Invalid input - must be vipy.object.Track()&#34;
    return max(max(self.startframe() - other.endframe(), other.startframe() - self.endframe()), 0)</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.truncate"><code class="name flex">
<span>def <span class="ident">truncate</span></span>(<span>self, start=None, end=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Truncate a track so that any keyframes less than startframe or greater than endframe (inclusive) are removed.
Interpolate keyboxes at (startframe, endframe) endpoints.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>start</code></strong></dt>
<dd>[int|float] The start of the truncation relative to the track framerate.
All keyframes less than or equal to startframe are included.
If the keyframe does not exist at startframe, one is interpolated and added.</dd>
<dt><strong><code>end</code></strong></dt>
<dd>[int|float] The end of the truncation relative to the track framerate.
All keyframes greater than or equal to the endframe are included.
If the keyfrmae does not exist at endframe, one is interpolated and added.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>This track such that all keyboxes &lt;= startframe or &gt;= endframe are removed.</p>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;The startframe and endframe for truncation are inclusive.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L676-L697" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def truncate(self, start=None, end=None):
    &#34;&#34;&#34;Truncate a track so that any keyframes less than startframe or greater than endframe (inclusive) are removed.  Interpolate keyboxes at (startframe, endframe) endpoints.

    Args:
        start: [int|float] The start of the truncation relative to the track framerate.  All keyframes less than or equal to startframe are included.  If the keyframe does not exist at startframe, one is interpolated and added.
        end: [int|float] The end of the truncation relative to the track framerate.  All keyframes greater than or equal to the endframe are included.  If the keyfrmae does not exist at endframe, one is interpolated and added.

    Returns:
        This track such that all keyboxes &lt;= startframe or &gt;= endframe are removed.

    .. note::  The startframe and endframe for truncation are inclusive.  
    &#34;&#34;&#34;
    startframe = int(np.round(start*self.framerate())) if isinstance(start, float) else start
    endframe = int(np.round(end*self.framerate())) if isinstance(end, float) else end        
    
    if startframe is not None and startframe not in self._keyframes and self[startframe] is not None:
        self.add(startframe, self[startframe].clone())  # interpolated boundary condition
    if endframe is not None and endframe not in self._keyframes and self[endframe] is not None:
        self.add(endframe, self[endframe].clone())  # intepolated boundary condition
    kfkb = [(kf,kb) for (kf,kb) in zip(self._keyframes, self._keyboxes) if ((startframe is None or kf &gt;= startframe) and (endframe is None or kf &lt;= endframe))]
    (self._keyframes, self._keyboxes) = zip(*kfkb) if len(kfkb) &gt; 0 else ([], [])
    return self</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.uncrop"><code class="name flex">
<span>def <span class="ident">uncrop</span></span>(<span>self, bb, s=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply a transformation to the track that will undo a crop of a bounding box with an optional scale factor.</p>
<p>A typical operation is as follows.
A video is cropped and zommed in order to run a detector on a region of interest.
However, we want to align the resulting tracks on the original video before the crop and zoom.
</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>bb</code></strong></dt>
<dd>[<code>vipy.geometry.BoundingBox</code>].
A bounding box which was used to crop this track</dd>
<dt><strong><code>s</code></strong></dt>
<dd>[float]
A scale factor applied after the bounding box crop</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>This track after undoing the scale and crop</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L644-L657" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def uncrop(self, bb, s=1):
    &#34;&#34;&#34;Apply a transformation to the track that will undo a crop of a bounding box with an optional scale factor.

    A typical operation is as follows.  A video is cropped and zommed in order to run a detector on a region of interest.  However, we want to align the resulting tracks on the original video before the crop and zoom.  

    Args:
        bb: [`vipy.geometry.BoundingBox`].  A bounding box which was used to crop this track
        s: [float]  A scale factor applied after the bounding box crop

    Returns:
        This track after undoing the scale and crop 
    &#34;&#34;&#34;
    assert isinstance(bb, BoundingBox)
    return self.rescale(1/s).offset(dt=0, dx=bb.xmin(), dy=bb.ymin())</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.union"><code class="name flex">
<span>def <span class="ident">union</span></span>(<span>self, other, overlap='average')</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the union of two tracks.
Overlapping boxes between self and other:</p>
<p>Inputs
- average [bool]:
average framewise interpolated boxes at overlapping keyframes
- replace [bool]:
replace the box with other if other and self overlap at a keyframe
- keep [bool]:
keep the box from self (discard other) at a keyframe</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L956-L974" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def union(self, other, overlap=&#39;average&#39;):
    &#34;&#34;&#34;Compute the union of two tracks.  Overlapping boxes between self and other:
    
       Inputs
         - average [bool]:  average framewise interpolated boxes at overlapping keyframes
         - replace [bool]:  replace the box with other if other and self overlap at a keyframe
         - keep [bool]:  keep the box from self (discard other) at a keyframe
    &#34;&#34;&#34;
    assert isinstance(other, Track), &#34;Invalid input - must be vipy.object.Track()&#34;
    assert other.category() == self.category(), &#34;Category mismatch&#34;
    assert overlap in [&#39;average&#39;, &#39;replace&#39;, &#39;keep&#39;], &#34;Invalid input - &#39;overlap&#39; must be in [average, replace, keep]&#34;
    T = self.clone()
    keyframes = sorted(set(T._keyframes+other._keyframes))
    T._keyboxes = [((self[k].average(other[k]) if (overlap == &#39;average&#39;) else (self[k] if (overlap == &#39;keep&#39;) else other[k]))
                    if (self.during(k) and other.during(k)) else 
                    (self[k] if (self.during(k) and not other.during(k)) else (other[k])))
                   for k in keyframes] 
    T._keyframes = keyframes
    return T  </code></pre>
</details>
</dd>
<dt id="vipy.object.Track.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, keyframe, bbox)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L433-L437" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def update(self, keyframe, bbox):
    if keyframe in self._keyframes:
        self.delete(keyframe)
    self.add(keyframe, bbox)
    return self</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.velocity"><code class="name flex">
<span>def <span class="ident">velocity</span></span>(<span>self, f, dt=30)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the (x,y) track velocity at frame f in units of pixels per frame computed by mean finite difference of the box centroid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L1121-L1123" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def velocity(self, f, dt=30):
    &#34;&#34;&#34;Return the (x,y) track velocity at frame f in units of pixels per frame computed by mean finite difference of the box centroid&#34;&#34;&#34;
    return (self.velocity_x(f, dt), self.velocity_y(f, dt))</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.velocity_h"><code class="name flex">
<span>def <span class="ident">velocity_h</span></span>(<span>self, f, dt=30)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the height velocity at frame f in units of pixels per frame computed by finite difference</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L1162-L1165" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def velocity_h(self, f, dt=30):
    &#34;&#34;&#34;Return the height velocity at frame f in units of pixels per frame computed by finite difference&#34;&#34;&#34;
    assert f &gt;= 0 and dt &gt; 0 and self.during(f)
    return float(np.mean([(self[f].height() - self[f-k].height())/float(k) for k in range(1,dt) if self.during(f-k)])) if self.during(f-1) else 0</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.velocity_w"><code class="name flex">
<span>def <span class="ident">velocity_w</span></span>(<span>self, f, dt=30)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the width velocity at frame f in units of pixels per frame computed by finite difference</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L1157-L1160" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def velocity_w(self, f, dt=30):
    &#34;&#34;&#34;Return the width velocity at frame f in units of pixels per frame computed by finite difference&#34;&#34;&#34;
    assert f &gt;= 0 and dt &gt; 0 and self.during(f)
    return float(np.mean([(self[f].width() - self[f-k].width())/float(k) for k in range(1,dt) if self.during(f-k)])) if self.during(f-1) else 0</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.velocity_x"><code class="name flex">
<span>def <span class="ident">velocity_x</span></span>(<span>self, f, dt=30)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the left/right velocity at frame f in units of pixels per frame computed by mean finite difference over a fixed time window (dt, frames) of the box centroid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L1147-L1150" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def velocity_x(self, f, dt=30):
    &#34;&#34;&#34;Return the left/right velocity at frame f in units of pixels per frame computed by mean finite difference over a fixed time window (dt, frames) of the box centroid&#34;&#34;&#34;
    assert f &gt;= 0 and dt &gt; 0
    return float(np.mean([(self[f].centroid_x() - self[f-k].centroid_x())/float(k) for k in range(1,dt) if self.during(f-k)])) if (self.during(f-1) and self.during(f)) else 0</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.velocity_y"><code class="name flex">
<span>def <span class="ident">velocity_y</span></span>(<span>self, f, dt=30)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the up/down velocity at frame f in units of pixels per frame computed by mean finite difference over a fixed time window (dt, frames) of the box centroid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L1152-L1155" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def velocity_y(self, f, dt=30):
    &#34;&#34;&#34;Return the up/down velocity at frame f in units of pixels per frame computed by mean finite difference over a fixed time window (dt, frames) of the box centroid&#34;&#34;&#34;
    assert f &gt;= 0 and dt &gt; 0
    return float(np.mean([(self[f].centroid_y() - self[f-k].centroid_y())/float(k) for k in range(1,dt) if self.during(f-k)])) if (self.during(f-1) and self.during(f)) else 0</code></pre>
</details>
</dd>
<dt id="vipy.object.Track.within"><code class="name flex">
<span>def <span class="ident">within</span></span>(<span>self, starframe, endframe)</span>
</code></dt>
<dd>
<div class="desc"><p>Is the track within the frame range (startframe, endframe)?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/object.py#L624-L626" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def within(self, starframe, endframe):
    &#34;&#34;&#34;Is the track within the frame range (startframe, endframe)?&#34;&#34;&#34;
    return self.startframe() &gt;= startframe and self.endframe() &lt;= endframe</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="VIPY" href="https://github.com/visym/vipy/">
<img src="https://www.visym.com/labs/images/visym_logo_black_notext.png" alt="" width="60">
</a>
<h1 style="font-size:200%;"><b>VIPY:</b> Visual Dataset Transformation</h1>
</header>
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = './doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="vipy" href="index.html">vipy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="vipy.object.RandomDetection" href="#vipy.object.RandomDetection">RandomDetection</a></code></li>
<li><code><a title="vipy.object.greedy_assignment" href="#vipy.object.greedy_assignment">greedy_assignment</a></code></li>
<li><code><a title="vipy.object.greedy_track_assignment" href="#vipy.object.greedy_track_assignment">greedy_track_assignment</a></code></li>
<li><code><a title="vipy.object.non_maximum_suppression" href="#vipy.object.non_maximum_suppression">non_maximum_suppression</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="vipy.object.Detection" href="#vipy.object.Detection">Detection</a></code></h4>
<ul class="two-column">
<li><code><a title="vipy.object.Detection.attributes" href="#vipy.object.Detection.attributes">attributes</a></code></li>
<li><code><a title="vipy.object.Detection.cast" href="#vipy.object.Detection.cast">cast</a></code></li>
<li><code><a title="vipy.object.Detection.clone" href="#vipy.object.Detection.clone">clone</a></code></li>
<li><code><a title="vipy.object.Detection.downcast" href="#vipy.object.Detection.downcast">downcast</a></code></li>
<li><code><a title="vipy.object.Detection.from_json" href="#vipy.object.Detection.from_json">from_json</a></code></li>
<li><code><a title="vipy.object.Detection.id" href="#vipy.object.Detection.id">id</a></code></li>
<li><code><a title="vipy.object.Detection.json" href="#vipy.object.Detection.json">json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vipy.object.Keypoint2d" href="#vipy.object.Keypoint2d">Keypoint2d</a></code></h4>
<ul class="two-column">
<li><code><a title="vipy.object.Keypoint2d.attributes" href="#vipy.object.Keypoint2d.attributes">attributes</a></code></li>
<li><code><a title="vipy.object.Keypoint2d.cast" href="#vipy.object.Keypoint2d.cast">cast</a></code></li>
<li><code><a title="vipy.object.Keypoint2d.clone" href="#vipy.object.Keypoint2d.clone">clone</a></code></li>
<li><code><a title="vipy.object.Keypoint2d.from_json" href="#vipy.object.Keypoint2d.from_json">from_json</a></code></li>
<li><code><a title="vipy.object.Keypoint2d.guid" href="#vipy.object.Keypoint2d.guid">guid</a></code></li>
<li><code><a title="vipy.object.Keypoint2d.id" href="#vipy.object.Keypoint2d.id">id</a></code></li>
<li><code><a title="vipy.object.Keypoint2d.json" href="#vipy.object.Keypoint2d.json">json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vipy.object.Object" href="#vipy.object.Object">Object</a></code></h4>
<ul class="">
<li><code><a title="vipy.object.Object.add_tag" href="#vipy.object.Object.add_tag">add_tag</a></code></li>
<li><code><a title="vipy.object.Object.add_tags" href="#vipy.object.Object.add_tags">add_tags</a></code></li>
<li><code><a title="vipy.object.Object.append_attribute" href="#vipy.object.Object.append_attribute">append_attribute</a></code></li>
<li><code><a title="vipy.object.Object.category" href="#vipy.object.Object.category">category</a></code></li>
<li><code><a title="vipy.object.Object.clear_attributes" href="#vipy.object.Object.clear_attributes">clear_attributes</a></code></li>
<li><code><a title="vipy.object.Object.confidence" href="#vipy.object.Object.confidence">confidence</a></code></li>
<li><code><a title="vipy.object.Object.confidences" href="#vipy.object.Object.confidences">confidences</a></code></li>
<li><code><a title="vipy.object.Object.del_attribute" href="#vipy.object.Object.del_attribute">del_attribute</a></code></li>
<li><code><a title="vipy.object.Object.get_attribute" href="#vipy.object.Object.get_attribute">get_attribute</a></code></li>
<li><code><a title="vipy.object.Object.has_attribute" href="#vipy.object.Object.has_attribute">has_attribute</a></code></li>
<li><code><a title="vipy.object.Object.has_normalized_coordinates" href="#vipy.object.Object.has_normalized_coordinates">has_normalized_coordinates</a></code></li>
<li><code><a title="vipy.object.Object.new_category" href="#vipy.object.Object.new_category">new_category</a></code></li>
<li><code><a title="vipy.object.Object.set_attribute" href="#vipy.object.Object.set_attribute">set_attribute</a></code></li>
<li><code><a title="vipy.object.Object.tags" href="#vipy.object.Object.tags">tags</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vipy.object.Track" href="#vipy.object.Track">Track</a></code></h4>
<ul class="">
<li><code><a title="vipy.object.Track.acceleration" href="#vipy.object.Track.acceleration">acceleration</a></code></li>
<li><code><a title="vipy.object.Track.add" href="#vipy.object.Track.add">add</a></code></li>
<li><code><a title="vipy.object.Track.attributes" href="#vipy.object.Track.attributes">attributes</a></code></li>
<li><code><a title="vipy.object.Track.average" href="#vipy.object.Track.average">average</a></code></li>
<li><code><a title="vipy.object.Track.bearing" href="#vipy.object.Track.bearing">bearing</a></code></li>
<li><code><a title="vipy.object.Track.bearing_change" href="#vipy.object.Track.bearing_change">bearing_change</a></code></li>
<li><code><a title="vipy.object.Track.biggestbox" href="#vipy.object.Track.biggestbox">biggestbox</a></code></li>
<li><code><a title="vipy.object.Track.boundary" href="#vipy.object.Track.boundary">boundary</a></code></li>
<li><code><a title="vipy.object.Track.boundingbox" href="#vipy.object.Track.boundingbox">boundingbox</a></code></li>
<li><code><a title="vipy.object.Track.boxmap" href="#vipy.object.Track.boxmap">boxmap</a></code></li>
<li><code><a title="vipy.object.Track.category" href="#vipy.object.Track.category">category</a></code></li>
<li><code><a title="vipy.object.Track.categoryif" href="#vipy.object.Track.categoryif">categoryif</a></code></li>
<li><code><a title="vipy.object.Track.clip" href="#vipy.object.Track.clip">clip</a></code></li>
<li><code><a title="vipy.object.Track.clone" href="#vipy.object.Track.clone">clone</a></code></li>
<li><code><a title="vipy.object.Track.clone_during" href="#vipy.object.Track.clone_during">clone_during</a></code></li>
<li><code><a title="vipy.object.Track.confidence" href="#vipy.object.Track.confidence">confidence</a></code></li>
<li><code><a title="vipy.object.Track.delete" href="#vipy.object.Track.delete">delete</a></code></li>
<li><code><a title="vipy.object.Track.dict" href="#vipy.object.Track.dict">dict</a></code></li>
<li><code><a title="vipy.object.Track.dilate" href="#vipy.object.Track.dilate">dilate</a></code></li>
<li><code><a title="vipy.object.Track.duration" href="#vipy.object.Track.duration">duration</a></code></li>
<li><code><a title="vipy.object.Track.during" href="#vipy.object.Track.during">during</a></code></li>
<li><code><a title="vipy.object.Track.during_interval" href="#vipy.object.Track.during_interval">during_interval</a></code></li>
<li><code><a title="vipy.object.Track.endbox" href="#vipy.object.Track.endbox">endbox</a></code></li>
<li><code><a title="vipy.object.Track.endframe" href="#vipy.object.Track.endframe">endframe</a></code></li>
<li><code><a title="vipy.object.Track.endpointiou" href="#vipy.object.Track.endpointiou">endpointiou</a></code></li>
<li><code><a title="vipy.object.Track.fliplr" href="#vipy.object.Track.fliplr">fliplr</a></code></li>
<li><code><a title="vipy.object.Track.flipud" href="#vipy.object.Track.flipud">flipud</a></code></li>
<li><code><a title="vipy.object.Track.fragmentiou" href="#vipy.object.Track.fragmentiou">fragmentiou</a></code></li>
<li><code><a title="vipy.object.Track.frameoffset" href="#vipy.object.Track.frameoffset">frameoffset</a></code></li>
<li><code><a title="vipy.object.Track.framerate" href="#vipy.object.Track.framerate">framerate</a></code></li>
<li><code><a title="vipy.object.Track.from_json" href="#vipy.object.Track.from_json">from_json</a></code></li>
<li><code><a title="vipy.object.Track.has_normalized_coordinates" href="#vipy.object.Track.has_normalized_coordinates">has_normalized_coordinates</a></code></li>
<li><code><a title="vipy.object.Track.id" href="#vipy.object.Track.id">id</a></code></li>
<li><code><a title="vipy.object.Track.imclip" href="#vipy.object.Track.imclip">imclip</a></code></li>
<li><code><a title="vipy.object.Track.iou" href="#vipy.object.Track.iou">iou</a></code></li>
<li><code><a title="vipy.object.Track.isdegenerate" href="#vipy.object.Track.isdegenerate">isdegenerate</a></code></li>
<li><code><a title="vipy.object.Track.isempty" href="#vipy.object.Track.isempty">isempty</a></code></li>
<li><code><a title="vipy.object.Track.ismoving" href="#vipy.object.Track.ismoving">ismoving</a></code></li>
<li><code><a title="vipy.object.Track.json" href="#vipy.object.Track.json">json</a></code></li>
<li><code><a title="vipy.object.Track.keyboxes" href="#vipy.object.Track.keyboxes">keyboxes</a></code></li>
<li><code><a title="vipy.object.Track.keyframes" href="#vipy.object.Track.keyframes">keyframes</a></code></li>
<li><code><a title="vipy.object.Track.label" href="#vipy.object.Track.label">label</a></code></li>
<li><code><a title="vipy.object.Track.linear_extrapolation" href="#vipy.object.Track.linear_extrapolation">linear_extrapolation</a></code></li>
<li><code><a title="vipy.object.Track.linear_interpolation" href="#vipy.object.Track.linear_interpolation">linear_interpolation</a></code></li>
<li><code><a title="vipy.object.Track.loop_closure_distance" href="#vipy.object.Track.loop_closure_distance">loop_closure_distance</a></code></li>
<li><code><a title="vipy.object.Track.maxiou" href="#vipy.object.Track.maxiou">maxiou</a></code></li>
<li><code><a title="vipy.object.Track.maxsquare" href="#vipy.object.Track.maxsquare">maxsquare</a></code></li>
<li><code><a title="vipy.object.Track.meanbox" href="#vipy.object.Track.meanbox">meanbox</a></code></li>
<li><code><a title="vipy.object.Track.meanshape" href="#vipy.object.Track.meanshape">meanshape</a></code></li>
<li><code><a title="vipy.object.Track.medianshape" href="#vipy.object.Track.medianshape">medianshape</a></code></li>
<li><code><a title="vipy.object.Track.nearest_keybox" href="#vipy.object.Track.nearest_keybox">nearest_keybox</a></code></li>
<li><code><a title="vipy.object.Track.nearest_keyframe" href="#vipy.object.Track.nearest_keyframe">nearest_keyframe</a></code></li>
<li><code><a title="vipy.object.Track.num_keyframes" href="#vipy.object.Track.num_keyframes">num_keyframes</a></code></li>
<li><code><a title="vipy.object.Track.offset" href="#vipy.object.Track.offset">offset</a></code></li>
<li><code><a title="vipy.object.Track.pathlength" href="#vipy.object.Track.pathlength">pathlength</a></code></li>
<li><code><a title="vipy.object.Track.percentileiou" href="#vipy.object.Track.percentileiou">percentileiou</a></code></li>
<li><code><a title="vipy.object.Track.rankiou" href="#vipy.object.Track.rankiou">rankiou</a></code></li>
<li><code><a title="vipy.object.Track.replace" href="#vipy.object.Track.replace">replace</a></code></li>
<li><code><a title="vipy.object.Track.resample" href="#vipy.object.Track.resample">resample</a></code></li>
<li><code><a title="vipy.object.Track.rescale" href="#vipy.object.Track.rescale">rescale</a></code></li>
<li><code><a title="vipy.object.Track.rot90ccw" href="#vipy.object.Track.rot90ccw">rot90ccw</a></code></li>
<li><code><a title="vipy.object.Track.rot90cw" href="#vipy.object.Track.rot90cw">rot90cw</a></code></li>
<li><code><a title="vipy.object.Track.scale" href="#vipy.object.Track.scale">scale</a></code></li>
<li><code><a title="vipy.object.Track.scale_x" href="#vipy.object.Track.scale_x">scale_x</a></code></li>
<li><code><a title="vipy.object.Track.scale_y" href="#vipy.object.Track.scale_y">scale_y</a></code></li>
<li><code><a title="vipy.object.Track.segment_maxiou" href="#vipy.object.Track.segment_maxiou">segment_maxiou</a></code></li>
<li><code><a title="vipy.object.Track.segment_percentilecover" href="#vipy.object.Track.segment_percentilecover">segment_percentilecover</a></code></li>
<li><code><a title="vipy.object.Track.segment_percentileiou" href="#vipy.object.Track.segment_percentileiou">segment_percentileiou</a></code></li>
<li><code><a title="vipy.object.Track.segmentcover" href="#vipy.object.Track.segmentcover">segmentcover</a></code></li>
<li><code><a title="vipy.object.Track.segmentiou" href="#vipy.object.Track.segmentiou">segmentiou</a></code></li>
<li><code><a title="vipy.object.Track.shape_invariant_velocity" href="#vipy.object.Track.shape_invariant_velocity">shape_invariant_velocity</a></code></li>
<li><code><a title="vipy.object.Track.shapevariance" href="#vipy.object.Track.shapevariance">shapevariance</a></code></li>
<li><code><a title="vipy.object.Track.significant_digits" href="#vipy.object.Track.significant_digits">significant_digits</a></code></li>
<li><code><a title="vipy.object.Track.smallestbox" href="#vipy.object.Track.smallestbox">smallestbox</a></code></li>
<li><code><a title="vipy.object.Track.smooth" href="#vipy.object.Track.smooth">smooth</a></code></li>
<li><code><a title="vipy.object.Track.smoothshape" href="#vipy.object.Track.smoothshape">smoothshape</a></code></li>
<li><code><a title="vipy.object.Track.speed" href="#vipy.object.Track.speed">speed</a></code></li>
<li><code><a title="vipy.object.Track.spline" href="#vipy.object.Track.spline">spline</a></code></li>
<li><code><a title="vipy.object.Track.startbox" href="#vipy.object.Track.startbox">startbox</a></code></li>
<li><code><a title="vipy.object.Track.startframe" href="#vipy.object.Track.startframe">startframe</a></code></li>
<li><code><a title="vipy.object.Track.temporal_distance" href="#vipy.object.Track.temporal_distance">temporal_distance</a></code></li>
<li><code><a title="vipy.object.Track.truncate" href="#vipy.object.Track.truncate">truncate</a></code></li>
<li><code><a title="vipy.object.Track.uncrop" href="#vipy.object.Track.uncrop">uncrop</a></code></li>
<li><code><a title="vipy.object.Track.union" href="#vipy.object.Track.union">union</a></code></li>
<li><code><a title="vipy.object.Track.update" href="#vipy.object.Track.update">update</a></code></li>
<li><code><a title="vipy.object.Track.velocity" href="#vipy.object.Track.velocity">velocity</a></code></li>
<li><code><a title="vipy.object.Track.velocity_h" href="#vipy.object.Track.velocity_h">velocity_h</a></code></li>
<li><code><a title="vipy.object.Track.velocity_w" href="#vipy.object.Track.velocity_w">velocity_w</a></code></li>
<li><code><a title="vipy.object.Track.velocity_x" href="#vipy.object.Track.velocity_x">velocity_x</a></code></li>
<li><code><a title="vipy.object.Track.velocity_y" href="#vipy.object.Track.velocity_y">velocity_y</a></code></li>
<li><code><a title="vipy.object.Track.within" href="#vipy.object.Track.within">within</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
