<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.3.dev21+g251d61a.d20210524" />
<title>vipy.geometry API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vipy.geometry</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L1-L1013" class="git-link">Browse git</a>
</summary>
<pre><code class="python">import math
import numpy as np
from itertools import product
from vipy.util import try_import, istuple, isnumpy, isnumber, tolist
from vipy.linalg import columnvector
import warnings

try:
    import ujson as json  # faster
except ImportError:
    import json


def covariance_to_ellipse(cov):
    &#34;&#34;&#34;2x2 covariance matrix to ellipse (major_axis_length, minor_axis_length, angle_in_radians)&#34;&#34;&#34;
    assert isnumpy(cov) and cov.shape == (2,2), &#34;Invalid input&#34;
    (d,V) = np.linalg.eig(cov)
    return np.array((d[0], d[1], math.atan2(V[1,0], V[0,0])))  # (major_axis_len, minor_axis_len, angle_in_radians)


def dehomogenize(p):
    &#34;&#34;&#34;Convert 3x1 homogenous point (x,y,h) to 2x1 non-homogenous point (x/h, y/h)&#34;&#34;&#34;
    assert isnumpy(p)    
    if p.ndim == 1:
        assert len(p) == 3
        return p[0:2] / p[2]
    elif p.ndim == 2:
        assert isnumpy(p) and p.shape[0] == 3, &#34;Invalid input&#34;
        p = columnvector(p) if p.ndim == 1 else p
        return p[0:-1, :] / p[-1,:]
    else:
        return ValueError(&#39;p must be 1d or 2d&#39;)
    

def homogenize(p):
    &#34;&#34;&#34;Convert 2xN non-homogenous points (x,y) to 3xN non-homogenous point (x, y, 1)&#34;&#34;&#34;
    assert isnumpy(p)
    if p.ndim == 1:
        return np.hstack( (p, 1) )
    elif p.ndim == 2:
        assert p.shape[0] == 2, &#34;Invalid input&#34;
        p = columnvector(p) if p.ndim == 1 else p
        return np.vstack((p, np.ones_like(p[-1])))
    else:
        return ValueError(&#39;p must be 1d or 2d&#39;)


def apply_homography(H,p):
    &#34;&#34;&#34;Apply a 3x3 homography H to non-homogenous point p and return a transformed point &#34;&#34;&#34;
    assert isnumpy(H) and isnumpy(p) and H.shape == (3,3) and p.shape[0] == 2, &#34;Invalid input&#34;
    return dehomogenize(np.dot(H, homogenize(p)))


def similarity_transform_2x3(c=(0,0), r=0, s=1):
    &#34;&#34;&#34;Return a 2x3 similarity transform with rotation r (radians), scale s and origin c=(x,y)&#34;&#34;&#34;
    assert istuple(c) and len(c) == 2 and isnumber(r) and isnumber(s), &#34;Invalid input&#34;
    deg = r * 180. / math.pi
    a = s * np.cos(r)
    b = s * np.sin(r)
    (x,y) = (c[0], c[1])
    return np.array([[a, b, (1 - a) * x - b * y], [-b, a, b * x + (1 - a) * y]])


def similarity_transform(txy=(0,0), r=0, s=1):
    &#34;&#34;&#34;Return a 3x3 similarity transformation with translation tuple txy=(x,y), rotation r (radians, scale=s&#34;&#34;&#34;
    assert istuple(txy) and len(txy) == 2 and isnumber(r) and isnumber(s), &#34;Invalid input&#34;
    R = np.mat([[np.cos(r), -np.sin(r), 0], [np.sin(r), np.cos(r), 0], [0,0,1]])
    S = np.mat([[s,0,0], [0, s, 0], [0,0,1]])
    T = np.mat([[0,0,txy[0]], [0,0,txy[1]], [0,0,0]])
    return S * R + T  # composition


def affine_transform(txy=(0,0), r=0, sx=1, sy=1, kx=0, ky=0):
    &#34;&#34;&#34;Compose and return a 3x3 affine transformation for translation txy=(0,0), rotation r (radians), scalex=sx, scaley=sy, shearx=kx, sheary=ky&#34;&#34;&#34;
    assert istuple(txy) and len(txy) == 2 and isnumber(r) and isnumber(sx) and isnumber(sy) and isnumber(kx) and isnumber(ky), &#34;Invalid input&#34;
    R = np.mat([[np.cos(r), -np.sin(r), 0], [np.sin(r), np.cos(r), 0], [0,0,1]])
    S = np.mat([[sx,0,0], [0, sy, 0], [0,0,1]])
    K = np.mat([[1,ky,0], [kx,1,0], [0,0,1]])
    T = np.mat([[0,0,txy[0]], [0,0,txy[1]], [0,0,0]])
    return K * S * R + T  # composition


def random_affine_transform(txy=((0,1),(0,1)), r=(0,1), sx=(0.1,1), sy=(0.1,1), kx=(0.1,1), ky=(0.1,1)):
    &#34;&#34;&#34;Return a random 3x3 affine transformation matrix for the provided ranges, inputs must be tuples&#34;&#34;&#34;
    assert istuple(txy) and istuple(txy[0]) and istuple(txy[1]) and istuple(r) and istuple(sx) and istuple(sy) and istuple(kx) and istuple(ky), &#34;Invalid input&#34;
    uniform_random_in_range = lambda t: np.random.uniform(t[0], t[1])
    return affine_transform(txy=(uniform_random_in_range(txy[0]), uniform_random_in_range(txy[1])),
                            r=uniform_random_in_range(r),
                            sx=uniform_random_in_range(sx),
                            sy=uniform_random_in_range(sy),
                            kx=uniform_random_in_range(kx),
                            ky=uniform_random_in_range(ky))


def imtransform(img, A):
    &#34;&#34;&#34;Transform an numpy array image (MxNx3) following the affine or similiarity transformation A&#34;&#34;&#34;
    assert isnumpy(img) and isnumpy(A), &#34;invalid input&#34;
    try_import(cv2, &#39;opencv-python&#39;); import cv2
    if A.shape == (2,3):
        return cv2.warpAffine(img, A, (img.shape[1], img.shape[0]))
    else:
        return cv2.warpPerspective(img, A, (img.shape[1], img.shape[0]))


def normalize(x, eps=1E-16):
    &#34;&#34;&#34;Given a vector x, return the vector unit normalized as float64&#34;&#34;&#34;
    assert isnumpy(x), &#34;Invalid input&#34;
    return x / (np.linalg.norm(x.astype(np.float64)) + eps)

def imagebox(shape):
    return BoundingBox(xmin=0, ymin=0, width=shape[1], height=shape[0])



class BoundingBox(object):
    &#34;&#34;&#34;Core bounding box class with flexible constructors in this priority order:
          (xmin,ymin,xmax,ymax)
          (xmin,ymin,width,height)
          (centroid[0],centroid[1],width,height)
          (xcentroid,ycentroid,width,height)
          xywh=(xmin,ymin,width,height)
          ulbr=(xmin,ymin,xmax,ymax)
          bounding rectangle of binary mask image&#34;&#34;&#34;

    #__slots__ = [&#39;_xmin&#39;, &#39;_ymin&#39;, &#39;_xmax&#39;, &#39;_ymax&#39;]  # This is not backwards compatible
    def __init__(self, xmin=None, ymin=None, xmax=None, ymax=None, centroid=None, xcentroid=None, ycentroid=None, width=None, height=None, mask=None, xywh=None, ulbr=None, ulbrdict=None):

        if ulbrdict is not None:
            self.__dict__ = ulbrdict  # equivalent to (but faster)
            #self._xmin = ulbrdict[&#39;_xmin&#39;]
            #self._ymin = ulbrdict[&#39;_ymin&#39;]
            #self._xmax = ulbrdict[&#39;_xmax&#39;]
            #self._ymax = ulbrdict[&#39;_ymax&#39;]                                  
        elif xmin is not None and ymin is not None and xmax is not None and ymax is not None:
            if not (isnumber(xmin) and isnumber(ymin) and isnumber(xmax) and isnumber(ymax)):
                raise ValueError(&#39;Box coordinates must be integers or floats not &#34;%s&#34;&#39; % str(type(xmin)))
            self._xmin = float(xmin)
            self._ymin = float(ymin)
            self._xmax = float(xmax)
            self._ymax = float(ymax)
        elif xmin is not None and ymin is not None and width is not None and height is not None:
            if not (isnumber(xmin) and isnumber(ymin) and isnumber(width) and isnumber(height)):
                raise ValueError(&#39;Box coordinates must be integers or floats not &#34;%s&#34;&#39; % str(type(width)))
            self._xmin = float(xmin)
            self._ymin = float(ymin)
            self._xmax = self._xmin + float(width)
            self._ymax = self._ymin + float(height)
        elif centroid is not None and width is not None and height is not None:
            if not (len(centroid) == 2 and isnumber(centroid[0]) and isnumber(centroid[1]) and isnumber(width) and isnumber(height)):
                raise ValueError(&#39;Invalid box coordinates&#39;)
            self._xmin = float(centroid[0]) - float(width) / 2.0
            self._ymin = float(centroid[1]) - float(height) / 2.0
            self._xmax = float(centroid[0]) + float(width) / 2.0
            self._ymax = float(centroid[1]) + float(height) / 2.0
        elif xcentroid is not None and ycentroid is not None and width is not None and height is not None:
            #if not (isnumber(xcentroid) and isnumber(ycentroid) and isnumber(width) and isnumber(height)):
            #    raise ValueError(&#39;Box coordinates must be integers or floats&#39;)
            self._xmin = float(xcentroid) - (float(width) / 2.0)
            self._ymin = float(ycentroid) - (float(height) / 2.0)
            self._xmax = float(xcentroid) + (float(width) / 2.0)
            self._ymax = float(ycentroid) + (float(height) / 2.0)
        elif xywh is not None:
            self.xywh(xywh)
        elif ulbr is not None:
            self.ulbr(ulbr)
        elif mask is not None:
            # Bounding rectangle of non-zero pixels in a binary mask image
            if not isnumpy(mask) or np.sum(mask) == 0:
                raise ValueError(&#39;Mask input must be numpy array with at least one non-zero entry&#39;)
            imx = np.sum(mask, axis=0)
            imy = np.sum(mask, axis=1)
            self._xmin = np.argwhere(imx &gt; 0)[0]
            self._ymin = np.argwhere(imy &gt; 0)[0]
            self._xmax = np.argwhere(imx &gt; 0)[-1]
            self._ymax = np.argwhere(imy &gt; 0)[-1]
        else:
            raise ValueError(&#39;invalid constructor input&#39;)

    @classmethod
    def cast(cls, bb, flush=False):
        assert isinstance(bb, BoundingBox)
        bb.__class__ = BoundingBox
        if flush:
            bb.__dict__ = {k:v for (k,v) in bb.__dict__.items() if k in [&#39;_xmin&#39;, &#39;_ymin&#39;, &#39;_xmax&#39;, &#39;_ymax&#39;]}        
        return bb
    
    @classmethod
    def from_json(cls, s):
        d = json.loads(s) if not isinstance(s, dict) else s
        return cls(ulbrdict=d)

    def dict(self):
        &#34;&#34;&#34;Return a python dictionary containing the relevant serialized attributes suitable for JSON encoding&#34;&#34;&#34;
        return self.json(encode=False)
    
    def json(self, encode=True):
        return json.dumps(self.__dict__) if encode else self.__dict__
        
    def clone(self):
        return BoundingBox(xmin=self._xmin, xmax=self._xmax, ymin=self._ymin, ymax=self._ymax)
    def bbclone(self):
        return BoundingBox(xmin=self._xmin, xmax=self._xmax, ymin=self._ymin, ymax=self._ymax)

    def __eq__(self, other):
        &#34;&#34;&#34;Bounding box equality&#34;&#34;&#34;
        return isinstance(other, BoundingBox) and self.xywh() == other.xywh()

    def __neq__(self, other):
        &#34;&#34;&#34;Bounding box non-equality&#34;&#34;&#34;
        return not self.__eq__(other)

    def __repr__(self):
        return str(&#39;&lt;vipy.geometry.boundingbox: xmin=%s, ymin=%s, width=%s, height=%s&gt;&#39; % (self.xmin(), self.ymin(), self.bbwidth(), self.bbheight()))

    def __str__(self):
        return self.__repr__()
    
    def xmin(self):
        &#34;&#34;&#34;x coordinate of upper left corner of box, x-axis is image column&#34;&#34;&#34;
        return self._xmin

    def ul(self):
        &#34;&#34;&#34;Upper left coordinate (x,y)&#34;&#34;&#34;
        return (self._xmin, self._ymin)

    def ulx(self):
        &#34;&#34;&#34;Upper left coordinate (x)&#34;&#34;&#34;
        return self.ul()[0]

    def uly(self):
        &#34;&#34;&#34;Upper left coordinate (y)&#34;&#34;&#34;
        return self.ul()[1]

    def ur(self):
        &#34;&#34;&#34;Upper right coordinate (x,y)&#34;&#34;&#34;
        return (self._xmax, self._ymin)

    def urx(self):
        &#34;&#34;&#34;Upper right coordinate (x)&#34;&#34;&#34;
        return self.ur()[0]

    def ury(self):
        &#34;&#34;&#34;Upper right coordinate (y)&#34;&#34;&#34;
        return self.ur()[1]

    def ll(self):
        &#34;&#34;&#34;Lower left coordinate (x,y), synonym for bl()&#34;&#34;&#34;
        return (self._xmin, self._ymax)

    def bl(self):
        &#34;&#34;&#34;Bottom left coordinate (x,y), synonym for ll()&#34;&#34;&#34;
        return (self._xmin, self._ymax)

    def blx(self):
        &#34;&#34;&#34;Bottom left coordinate (x)&#34;&#34;&#34;
        return self.bl()[0]

    def bly(self):
        &#34;&#34;&#34;Bottom left coordinate (y)&#34;&#34;&#34;
        return self.bl()[1]

    def lr(self):
        &#34;&#34;&#34;Lower right coordinate (x,y), synonym for br()&#34;&#34;&#34;
        return (self._xmax, self._ymax)

    def br(self):
        &#34;&#34;&#34;Bottom right coordinate (x,y), synonym for lr()&#34;&#34;&#34;
        return (self._xmax, self._ymax)

    def brx(self):
        &#34;&#34;&#34;Bottom right coordinate (x)&#34;&#34;&#34;
        return self.br()[0]

    def bry(self):
        &#34;&#34;&#34;Bottom right coordinate (y)&#34;&#34;&#34;
        return self.br()[1]


    def ymin(self):
        &#34;&#34;&#34;y coordinate of upper left corner of box, y-axis is image row&#34;&#34;&#34;
        return self._ymin

    def xmax(self):
        &#34;&#34;&#34;x coordinate of lower right corner of box, x-axis is image column&#34;&#34;&#34;
        return self._xmax

    def ymax(self):
        &#34;&#34;&#34;y coordinate of lower right corner of box, y-axis is image row&#34;&#34;&#34;
        return self._ymax

    def upperleft(self):
        &#34;&#34;&#34;Return the (x,y) upper left corner coordinate of the box&#34;&#34;&#34;
        return (self.xmin(), self.ymin())

    def bottomleft(self):
        &#34;&#34;&#34;Return the (x,y) lower left corner coordinate of the box&#34;&#34;&#34;
        return (self.xmin(), self.ymax())

    def upperright(self):
        &#34;&#34;&#34;Return the (x,y) upper right corner coordinate of the box&#34;&#34;&#34;
        return (self.xmax(), self.ymin())

    def bottomright(self):
        &#34;&#34;&#34;Return the (x,y) lower right corner coordinate of the box&#34;&#34;&#34;
        return (self.xmax(), self.ymax())

    def isinteger(self):
        return (isinstance(self._xmin, int) and
                isinstance(self._ymin, int) and
                isinstance(self._xmax, int) and
                isinstance(self._ymax, int))
                
    def int(self):
        &#34;&#34;&#34;Convert corners to integer with rounding, in-place update&#34;&#34;&#34;
        (w,h) = (int(np.round(self.bbwidth())), int(np.round(self.bbheight())))
        self._xmin = int(np.round(self._xmin))
        self._ymin = int(np.round(self._ymin))
        self._xmax = int(np.round(self._xmax))
        self._ymax = int(np.round(self._ymax))
        if w != self.bbwidth():
            self.right(w - self.bbwidth())  # preserve aspect ratio due to rounding by +/- right side of box 
        if h != self.bbheight():
            self.bottom(h-self.bbheight())  # preserve aspect ratio due to rounding by +/- bottom of box
        return self

    def float(self):
        &#34;&#34;&#34;Convert corners to float&#34;&#34;&#34;
        self._xmin = float(self._xmin)
        self._ymin = float(self._ymin)
        self._xmax = float(self._xmax)
        self._ymax = float(self._ymax)
        return self

    def significant_digits(self, n):
        &#34;&#34;&#34;Convert corners to have at most n significant digits for efficient JSON storage&#34;&#34;&#34;
        assert isinstance(n, int) and n&gt;=0
        self._xmin = round(self._xmin, n)
        self._ymin = round(self._ymin, n)
        self._xmax = round(self._xmax, n)
        self._ymax = round(self._ymax, n)
        return self
        
    def translate(self, dx=0, dy=0):
        &#34;&#34;&#34;Translate the bounding box by dx in x and dy in y&#34;&#34;&#34;
        self._xmin = self._xmin + dx
        self._ymin = self._ymin + dy
        self._xmax = self._xmax + dx
        self._ymax = self._ymax + dy
        return self

    def to_origin(self):
        return self.translate(-self.xmin(), -self.ymin())
    
    def set_origin(self, other):
        &#34;&#34;&#34;Set the origin of the coordinates of this bounding box to be relative to the upper left of the other bounding box&#34;&#34;&#34;
        assert isinstance(other, BoundingBox), &#34;Invalid BoundingBox() input of type &#39;%s&#39;&#34; % str(type(other))
        return self.translate(other.xmin(), other.ymin())                
    
    def offset(self, dx=0, dy=0):
        &#34;&#34;&#34;Alias for translate&#34;&#34;&#34;
        return self.translate(dx, dy)

    def invalid(self):
        &#34;&#34;&#34;Is the box a valid bounding box?&#34;&#34;&#34;
        #is_undefined = np.isnan(self._xmin) or np.isnan(self._ymin) or np.isnan(self._xmax) or np.isnan(self._ymax)
        is_valid = ((self._xmax - self._xmin) &gt;= 0) and ((self._ymax - self._ymin) &gt;= 0)  # if nan, will return False
        return not is_valid

    def valid(self):
        return not self.invalid()

    def isvalid(self):
        return not self.invalid()

    def isdegenerate(self):
        return self.invalid()
        
    def isnonnegative(self):
        return (self.xmin() &gt;= 0 and
                self.ymin() &gt;= 0 and
                self.xmax() &gt;= 0 and
                self.ymax() &gt;= 0)

    def width(self):
        return self._xmax - self._xmin
    def bbwidth(self):
        return self._xmax - self._xmin
    
    def setwidth(self, w):
        &#34;&#34;&#34;Set new width keeping centroid constant&#34;&#34;&#34;
        if w &lt;= 0:
            raise ValueError(&#39;invalid width&#39;)
        worig = (self._xmax - self._xmin)
        self._xmax += float((w - worig) / 2.0)
        self._xmin -= float((w - worig) / 2.0)
        return self

    def setheight(self, h):
        &#34;&#34;&#34;Set new height keeping centroid constant&#34;&#34;&#34;
        if h &lt;= 0:
            raise ValueError(&#39;invalid height&#39;)
        horig = self._ymax - self._ymin
        self._ymax += float((h - horig) / 2.0)
        self._ymin -= float((h - horig) / 2.0)
        return self

    def height(self):
        return self._ymax - self._ymin
    def bbheight(self):
        return self._ymax - self._ymin

    def centroid(self, c=None):
        &#34;&#34;&#34;(x,y) tuple of centroid position of bounding box&#34;&#34;&#34;
        if c is None:
            (height, width) = (self._ymax-self._ymin, self._xmax-self._xmin)            
            return (self._xmin + (float(width) / 2.0), self._ymin + (float(height) / 2.0))
        else:
            assert len(c) == 2
            (height, width) = (self._ymax-self._ymin, self._xmax-self._xmin)
            self._xmin = float(c[0]) - (width / 2.0)
            self._ymin = float(c[1]) - (height / 2.0)
            self._xmax = float(c[0]) + (width / 2.0)
            self._ymax = float(c[1]) + (height / 2.0)
            return self
            
    def x_centroid(self):
        return self.centroid()[0]

    def xcentroid(self):
        &#34;&#34;&#34;Alias for x_centroid()&#34;&#34;&#34;
        return self.centroid()[0]
    def centroid_x(self):
        &#34;&#34;&#34;Alias for x_centroid()&#34;&#34;&#34;
        return self.centroid()[0]
            
    def y_centroid(self):
        return self.centroid()[1]

    def ycentroid(self):
        &#34;&#34;&#34;Alias for y_centroid()&#34;&#34;&#34;
        return self.centroid()[1]
    def centroid_y(self):
        &#34;&#34;&#34;Alias for y_centroid()&#34;&#34;&#34;
        return self.centroid()[1]
    
    def area(self):
        &#34;&#34;&#34;Return the area=width*height of the bounding box&#34;&#34;&#34;
        (height, width) = (self._ymax-self._ymin, self._xmax-self._xmin)        
        return width * height if (height&gt;0 and width&gt;0) else 0

    def to_xywh(self, xywh=None):
        &#34;&#34;&#34;Return bounding box corners as (x,y,width,height) tuple&#34;&#34;&#34;
        if xywh is None:
            (height, width) = (self._ymax-self._ymin, self._xmax-self._xmin)                    
            return tuple([self._xmin, self._ymin, width, height])
        else:
            assert len(xywh) == 4, &#34;Invalid (xmin,ymin,width,height) input&#34;
            self._xmin = float(xywh[0])
            self._ymin = float(xywh[1])
            self._xmax = float(self._xmin + xywh[2])
            self._ymax = float(self._ymin + xywh[3])
            return self

    def xywh(self, xywh_=None):
        &#34;&#34;&#34;Alias for to_xywh&#34;&#34;&#34;
        return self.to_xywh(xywh_)

    def cxywh(self, cxywh=None):
        &#34;&#34;&#34;Return or set bounding box corners as (centroidx,centroidy,width,height) tuple&#34;&#34;&#34;
        if cxywh is None:
            (height, width) = (self._ymax-self._ymin, self._xmax-self._xmin)                    
            return tuple([self.x_centroid(), self.y_centroid(), width, height])
        else:
            assert len(cxywh) == 4, &#34;Invalid (xcentroid, ycentroid, width, height) input&#34;
            return self.centroid( (cxywh[0], cxywh[1]) ).setwidth(cxywh[2]).setheight(cxywh[3])            
    
    def ulbr(self, ulbr=None):
        &#34;&#34;&#34;Return bounding box corners as upper left, bottom right (xmin, ymin, xmax, ymax)&#34;&#34;&#34;
        if ulbr is None:
            return (self._xmin, self._ymin, self._xmax, self._ymax)            
        else:
            assert len(ulbr) == 4, &#34;Invalid (xmin,ymin,xmax,ymax) input&#34;
            self._xmin = float(ulbr[0])
            self._ymin = float(ulbr[1])
            self._xmax = float(ulbr[2])
            self._ymax = float(ulbr[3])
            return self

    def to_ulbr(self, ulbr=None):
        &#34;&#34;&#34;Alias for ulbr()&#34;&#34;&#34;
        return self.ulbr(ulbr)
    
    def dx(self, bb):
        &#34;&#34;&#34;Offset bounding box by same xmin as provided box&#34;&#34;&#34;
        return bb._xmin - self._xmin

    def dy(self, bb):
        &#34;&#34;&#34;Offset bounding box by ymin of provided box&#34;&#34;&#34;
        return bb._ymin - self._ymin

    def sqdist(self, bb):
        &#34;&#34;&#34;Squared Euclidean distance between upper left corners of two bounding boxes&#34;&#34;&#34;
        assert isinstance(bb, BoundingBox), &#34;Invalid BoundingBox() input of type &#39;%s&#39;&#34; % str(type(bb))                
        return np.power(self.dx(bb), 2.0) + np.power(self.dy(bb), 2.0)

    def dist(self, bb):
        &#34;&#34;&#34;Distance between centroids of two bounding boxes&#34;&#34;&#34;
        assert isinstance(bb, BoundingBox), &#34;Invalid BoundingBox() input of type &#39;%s&#39;&#34; % str(type(bb))                
        return np.sqrt(np.sum(np.square(np.array(bb.centroid()) - np.array(self.centroid()))))

    def pdist(self, bb, sigma=None):
        &#34;&#34;&#34;Normalized Gaussian distance in [0,1] between centroids of two bounding boxes, where 0 is far and 1 is same with sigma=maxdim() of this box&#34;&#34;&#34;
        assert isinstance(bb, BoundingBox), &#34;Invalid BoundingBox() input of type &#39;%s&#39;&#34; % str(type(bb))
        return np.exp(-self.sqdist(bb)/(float(2*self.maxdim()*self.maxdim()) if sigma is None else float(2.0*sigma*sigma)))

    def iou(self, bb, area=None, otherarea=None):
        &#34;&#34;&#34;area of intersection / area of union&#34;&#34;&#34;
        assert bb is None or isinstance(bb, BoundingBox), &#34;Invalid BoundingBox() input of type &#39;%s&#39;&#34; % str(type(bb))        
        if bb is None:
            return 0
        w = min(self._xmax, bb._xmax) - max(self._xmin, bb._xmin)
        if w &lt;= 0:
            return 0  # invalid (no overlap), early exit
        h = min(self._ymax, bb._ymax) - max(self._ymin, bb._ymin)
        if h &lt;= 0:
            return 0  # invalid (no overlap), early exit

        area_intersection = w * h
        area_union = ((self.area() if area is None else area) +
                      (bb.area() if otherarea is None else otherarea) -
                      area_intersection)
        return (area_intersection / float(area_union)) if area_union &gt; 0 else 0

    def intersection_over_union(self, bb):
        &#34;&#34;&#34;Alias for iou&#34;&#34;&#34;
        return self.iou(bb)

    def area_of_intersection(self, bb, strict=True):
        &#34;&#34;&#34;area of intersection&#34;&#34;&#34;
        if strict:
            assert isinstance(bb, BoundingBox), &#34;Invalid BoundingBox() input of type &#39;%s&#39;&#34; % str(type(bb))                
        w = min(self._xmax, bb._xmax) - max(self._xmin, bb._xmin)
        if w &lt;= 0:
            return 0  # invalid (no overlap), early exit 
        h = min(self._ymax, bb._ymax) - max(self._ymin, bb._ymin)
        if h &lt;= 0:
            return 0  # invalid (no overlap), early exit 
        return w*h

    def area_of_union(self, bb):
        return self.area() + bb.area() - self.area_of_intersection(bb)
        
    def cover(self, bb):
        &#34;&#34;&#34;Fraction of this bounding box intersected by other bbox (bb)&#34;&#34;&#34;
        a = float(self.area())
        return (self.area_of_intersection(bb) / a) if a&gt;0 else 0

    def maxcover(self, bb, area=None, otherarea=None):
        &#34;&#34;&#34;The maximum cover of self to bb and bb to self&#34;&#34;&#34;
        aoi = self.area_of_intersection(bb, strict=False)
        (area, otherarea) = (self.area() if area is None else area, bb.area() if otherarea is None else otherarea)
        return float(max((aoi/area) if area&gt;0 else 0, (aoi/otherarea) if otherarea&gt;0 else 0))
    
    def shapeiou(self, bb, area=None, otherarea=None):
        &#34;&#34;&#34;Shape IoU is the IoU with the upper left corners aligned. This measures the deformation of the two boxes by removing the effect of translation&#34;&#34;&#34;
        #return self.iou(bb.clone().translate(dx=self._xmin-bb._xmin, dy=self._ymin-bb._ymin))  # equivalent to
        assert isinstance(bb, BoundingBox), &#34;Invalid input - must be BoundingBox()&#34;
        w = min(self._xmax, bb._xmax + (self._xmin-bb._xmin)) - max(self._xmin, bb._xmin + (self._xmin-bb._xmin))
        h = min(self._ymax, bb._ymax + (self._ymin-bb._ymin)) - max(self._ymin, bb._ymin + (self._ymin-bb._ymin))
        area_intersection = w * h
        area_union = ((self.area() if area is None else area) +
                      (bb.area() if otherarea is None else otherarea)
                      - area_intersection)
        return (area_intersection / float(area_union)) if area_union&gt;0 else 0
        
    def intersection(self, bb, strict=True):
        &#34;&#34;&#34;Intersection of two bounding boxes, throw an error on degeneracy of intersection result (if strict=True)&#34;&#34;&#34;
        assert isinstance(bb, BoundingBox), &#34;Invalid BoundingBox() input of type &#39;%s&#39;&#34; % str(type(bb))                        
        self._xmin = max(bb._xmin, self._xmin)
        self._ymin = max(bb._ymin, self._ymin)
        self._xmax = min(bb._xmax, self._xmax)
        self._ymax = min(bb._ymax, self._ymax)
        if strict and self.isdegenerate():
            raise ValueError(&#39;Degenerate intersection for bounding boxes &#34;%s&#34; and &#34;%s&#34;&#39; % (str(bb), str(self)))
        return self

    def hasintersection(self, bb, iou=None, cover=None, maxcover=None, bbcover=None, area=None, otherarea=None, gate=0):
        &#34;&#34;&#34;Return true if self and bb overlap by any amount, or by the cover threshold (if provided) or the iou threshold (if provided).  This is a convenience function that allows for shared computation for fast non-maximum suppression.&#34;&#34;&#34;

        if not (((self._xmax if self._xmax &lt; bb._xmax else bb._xmax) - (self._xmin if self._xmin &gt; bb._xmin else bb._xmin)) &gt; (-gate) and
                ((self._ymax if self._ymax &lt; bb._ymax else bb._ymax) - (self._ymin if self._ymin &gt; bb._ymin else bb._ymin)) &gt; (-gate)):  # faster than min(x,y)-max(x,y)
            return False  # does not intersect
        
        elif maxcover is not None or iou is not None or cover is not None or bbcover is not None:
            aoi = self.area_of_intersection(bb, strict=False)            
            otherarea = otherarea if otherarea is not None else (bb.area() if (maxcover is not None or bbcover is not None or iou is not None) else 0)
            area = area if area is not None else (self.area() if (maxcover is not None or cover is not None or iou is not None) else 0)
            return (((maxcover is not None) and (max(aoi/area, aoi/otherarea) &gt; maxcover)) or
                    ((iou is not None) and ((aoi / (area+otherarea-aoi)) &gt;= iou)) or
                    ((cover is not None) and ((aoi / area) &gt;= cover)) or
                    ((bbcover is not None) and ((aoi / otherarea) &gt;= bbcover)))
        else:
            return True

    def union(self, bb):
        &#34;&#34;&#34;Union of one or more bounding boxes with this box&#34;&#34;&#34;        
        bblist = tolist(bb)        
        assert all([isinstance(bb, BoundingBox) for bb in bblist]), &#34;Invalid BoundingBox() input&#34;
        self._xmin = min([bb._xmin for bb in bblist] + [self._xmin])
        self._ymin = min([bb._ymin for bb in bblist] + [self._ymin])
        self._xmax = max([bb._xmax for bb in bblist] + [self._xmax])
        self._ymax = max([bb._ymax for bb in bblist] + [self._ymax])
        return self

    def isinside(self, bb):
        &#34;&#34;&#34;Is this boundingbox fully within the provided bounding box?&#34;&#34;&#34;
        assert isinstance(bb, BoundingBox)
        return self.hasintersection(bb) and self.cover(bb) == 1.0
        
    def ispointinside(self, p):
        &#34;&#34;&#34;Is the 2D point p=(x,y) inside this boundingbox, or is the p=boundingbox() inside this bounding box?&#34;&#34;&#34;
        assert len(p) == 2, &#34;Invalid 2D point=(x,y) input&#34;
        return (p[0] &gt;= self._xmin) and (p[1] &gt;= self._ymin) and (p[0] &lt;= self._xmax) and (p[1] &lt;= self._ymax)

    def dilate(self, scale=1):
        &#34;&#34;&#34;Change scale of bounding box keeping centroid constant&#34;&#34;&#34;
        assert isnumber(scale), &#34;Invalid input&#34;
        w = (self._xmax - self._xmin)
        h = (self._ymax - self._ymin)
        c = self.centroid()
        old_x = self._xmin
        old_y = self._ymin
        new_x = (float(w) / 2.0) * scale
        new_y = (float(h) / 2.0) * scale
        self._xmin = c[0] - new_x
        self._ymin = c[1] - new_y
        self._xmax = c[0] + new_x
        self._ymax = c[1] + new_y
        return self

    def dilatepx(self, px):
        &#34;&#34;&#34;Dilate by a given pixel amount on all sides, keeping centroid constant&#34;&#34;&#34;
        self._xmin = self._xmin - px
        self._ymin = self._ymin - px
        self._xmax = self._xmax + px
        self._ymax = self._ymax + px
        return self

    def dilate_height(self, scale=1):
        &#34;&#34;&#34;Change scale of bounding box in y direction keeping centroid constant&#34;&#34;&#34;
        h = self.height()
        c = self.centroid()
        self._ymin = c[1] - (float(h) / 2.0) * scale
        self._ymax = c[1] + (float(h) / 2.0) * scale
        return self

    def dilate_width(self, scale=1):
        &#34;&#34;&#34;Change scale of bounding box in x direction keeping centroid constant&#34;&#34;&#34;
        w = self._xmax - self._xmin
        c = self.centroid()
        self._xmin = c[0] - (float(w) / 2.0) * scale
        self._xmax = c[0] + (float(w) / 2.0) * scale
        return self

    def top(self, dy):
        &#34;&#34;&#34;Make top of box taller (closer to top of image) by an offset dy&#34;&#34;&#34;
        self._ymin = self._ymin - dy
        return self

    def bottom(self, dy):
        &#34;&#34;&#34;Make bottom of box taller (closer to bottom of image) by an offset dy&#34;&#34;&#34;
        self._ymax = self._ymax + dy
        return self

    def left(self, dx):
        &#34;&#34;&#34;Make left of box wider (closer to left side of image) by an offset dx&#34;&#34;&#34;
        self._xmin = self._xmin - dx
        return self

    def right(self, dx):
        &#34;&#34;&#34;Make right of box wider (closer to right side of image) by an offset dx&#34;&#34;&#34;
        self._xmax = self._xmax + dx
        return self

    def rescale(self, scale=1):
        &#34;&#34;&#34;Multiply the box corners by a scale factor&#34;&#34;&#34;
        self._xmin = scale * self._xmin
        self._ymin = scale * self._ymin
        self._xmax = scale * self._xmax
        self._ymax = scale * self._ymax
        return self

    def scalex(self, scale=1):
        &#34;&#34;&#34;Multiply the box corners in the x dimension by a scale factor&#34;&#34;&#34;
        self._xmin = scale * self._xmin
        self._xmax = scale * self._xmax
        return self

    def scaley(self, scale=1):
        &#34;&#34;&#34;Multiply the box corners in the y dimension by a scale factor&#34;&#34;&#34;
        self._ymin = scale * self._ymin
        self._ymax = scale * self._ymax
        return self

    def resize(self, width, height):
        &#34;&#34;&#34;Change the aspect ratio width and height of the box&#34;&#34;&#34;
        self.setwidth(width)
        self.setheight(height)
        return self

    def rot90cw(self, H, W):
        &#34;&#34;&#34;Rotate a bounding box such that if an image of size (H,W) is rotated 90 deg clockwise, the boxes align&#34;&#34;&#34;
        (x,y,w,h) = self.xywh()
        (blx, bly) = self.bottomleft()
        return self.xywh((H - bly, blx, h, w))

    def rot90ccw(self, H, W):
        &#34;&#34;&#34;Rotate a bounding box such that if an image of size (H,W) is rotated 90 deg clockwise, the boxes align&#34;&#34;&#34;
        (x,y,w,h) = self.xywh()
        (urx, ury) = self.upperright()
        return self.xywh((ury, W - urx, h, w))

    def fliplr(self, img=None, width=None):
        &#34;&#34;&#34;Flip the box left/right consistent with fliplr of the provided img (or consistent with the image width)&#34;&#34;&#34;
        if img is not None:
            assert isnumpy(img), &#34;Invalid numpy image input&#34;
            width = img.shape[1]
        else:
            assert isnumber(width), &#34;Invalid width&#34;
        (x,y,w,h) = self.xywh()
        self._xmin = width - self._xmax
        self._xmax = self._xmin + w
        return self

    def flipud(self, img=None, height=None):
        &#34;&#34;&#34;Flip the box up/down consistent with flipud of the provided img (or consistent with the image height)&#34;&#34;&#34;
        if img is not None:
            assert isnumpy(img), &#34;Invalid numpy image input&#34;
            height = img.shape[0]
        else:
            assert height is not None and isnumber(height), &#34;Invalid height&#34;
        (x,y,w,h) = self.xywh()
        self._ymin = height - self._ymax
        self._ymax = self._ymin + h
        return self

    def imscale(self, im):
        &#34;&#34;&#34;Given a vipy.image object im, scale the box to be within [0,1], relative to height and width of image&#34;&#34;&#34;
        w = (1.0 / float(im.width()))
        h = (1.0 / float(im.height()))
        self._xmin = w * self._xmin
        self._ymin = h * self._ymin
        self._xmax = w * self._xmax
        self._ymax = h * self._ymax
        return self

    def maxsquare(self):
        &#34;&#34;&#34;Set the bounding box to be square by setting width and height to the maximum dimension of the box, keeping centroid constant&#34;&#34;&#34;
        (height, width) = (self._ymax-self._ymin, self._xmax-self._xmin)                            
        if width != height:
            dim = float(max(width, height))
            c = self.centroid()
            self._xmin = c[0] - (dim / 2.0)
            self._ymin = c[1] - (dim / 2.0)
            self._xmax = c[0] + (dim / 2.0)
            self._ymax = c[1] + (dim / 2.0)
        return self

    def maxsquareif(self, do):
        return self.maxsquare() if do else self

    def issquare(self):
        return np.allclose(self.bbheight(), self.bbwidth())

    def iseven(self):
        &#34;&#34;&#34;Are all corners even number integers?&#34;&#34;&#34;
        return (isinstance(self.xmin(), int) and self.xmin() % 2 == 0 and
                isinstance(self.ymin(), int) and self.ymin() % 2 == 0 and
                isinstance(self.xmax(), int) and self.xmax() % 2 == 0 and
                isinstance(self.ymax(), int) and self.ymax() % 2 == 0)

    def even(self):
        &#34;&#34;&#34;Force all corners to be even number integers.  This is helpful for FFMPEG crop filters.&#34;&#34;&#34;
        self.int()
        self._xmin = (self._xmin // 2) * 2
        self._ymin = (self._ymin // 2) * 2
        self._xmax = (self._xmax // 2) * 2
        self._ymax = (self._ymax // 2) * 2
        return self

    def minsquare(self):
        &#34;&#34;&#34;Set the bounding box to be square by setting width and height to the minimum dimension of the box, keeping centroid constant&#34;&#34;&#34;
        (height, width) = (self._ymax-self._ymin, self._xmax-self._xmin)                            
        if width != height:
            dim = float(min(width, height))
            c = self.centroid()
            self._xmin = c[0] - (dim / 2.0)
            self._ymin = c[1] - (dim / 2.0)
            self._xmax = c[0] + (dim / 2.0)
            self._ymax = c[1] + (dim / 2.0)
        return self

    def hasoverlap(self, img=None, width=None, height=None):
        &#34;&#34;&#34;Does the bounding box intersect with the provided image rectangle?&#34;&#34;&#34;
        if img is not None:
            assert isnumpy(img), &#34;Invalid image input&#34;
            (width, height) = (img.shape[1], img.shape[0])
        else:
            assert width is not None and height is not None, &#34;Invalid width and height - both must be provided&#34;
            assert isnumber(width) and isnumber(height), &#34;Invalid width and height - both must be numbers&#34;
        return self.area_of_intersection(BoundingBox(xmin=0, ymin=0, width=width, height=height)) &gt; 0

    def isinterior(self, width=None, height=None, border=1.0):
        &#34;&#34;&#34;Is this boundingbox fully within the provided image rectangle?  
        
           * If border in [0,1], then the image is dilated by a border percentage prior to computing interior, useful to check if self is near the image edge
           * If border=0.8, then the image rectangle is dilated by 80% (smaller) keeping the centroid constant. 
        &#34;&#34;&#34;
        assert border &gt; 0 and border &lt;= 1, &#34;Border must be a dilation fraction of the image, such that the image centroid is constant and the sides are dilated by a scale [0,1]&#34;
        return self.isinside(imagebox((height, width)).dilate(border))

    def iminterior(self, W, H):
        &#34;&#34;&#34;Transform bounding box to be interior to the image rectangle with shape (W,H).  
           Transform is applyed by computing smallest (dx,dy) translation that it is interior to the image rectangle, then clip to the image rectangle if it is too big to fit
        &#34;&#34;&#34;        
        assert self.intersection(BoundingBox(xmin=0, ymin=0, width=W, height=H)).area() &gt; 0, &#34;Bounding box must intersect image rectangle&#34;
        self.translate(dx=0 if self.xmin()&gt;0 else -self.xmin(),
                       dy=0 if self.ymin()&gt;0 else -self.ymin())
        self.translate(dx=0 if self.xmax()&lt;W else -(W-self.xmax()),
                       dy=0 if self.ymax()&lt;H else -(H-self.ymax()))
        return self.imclip(width=W, height=H)
        
    def imclip(self, img=None, width=None, height=None):
        &#34;&#34;&#34;Clip bounding box to image rectangle [0,0,width,height] or img.shape=(width, height) and, throw an exception on an invalid box&#34;&#34;&#34;
        if img is not None:
            assert isnumpy(img), &#34;Invalid numpy image input&#34;
            (height, width) = (img.shape[0], img.shape[1])
        else:
            assert width is not None and height is not None, &#34;Invalid width and height - both must be provided&#34;
            assert isnumber(width) and isnumber(height), &#34;Invalid width and height - both must be numbers&#34;
        return self.intersection(BoundingBox(xmin=0, ymin=0, width=width, height=height), strict=True)

    def imclipshape(self, W, H):
        &#34;&#34;&#34;Clip bounding box to image rectangle [0,0,W-1,H-1], throw an exception on an invalid box&#34;&#34;&#34;
        return self.imclip(width=W, height=H)

    def convexhull(self, fr):
        &#34;&#34;&#34;Given a set of points [[x1,y1],[x2,xy],...], return the bounding rectangle, typecast to float&#34;&#34;&#34;
        self._xmin = float(np.min(fr[:,0]))
        self._ymin = float(np.min(fr[:,1]))
        self._xmax = float(np.max(fr[:,0]))
        self._ymax = float(np.max(fr[:,1]))
        return self

    def aspectratio(self):
        &#34;&#34;&#34;Return the aspect ratio (width/height) of the box&#34;&#34;&#34;
        (height, width) = (self._ymax-self._ymin, self._xmax-self._xmin)                            
        assert height &gt; 0
        return float(width) / float(height)

    def shape(self):
        &#34;&#34;&#34;Return the (height, width) tuple for the box shape&#34;&#34;&#34;
        return (self._ymax-self._ymin, self._xmax-self._xmin)                            

    def mindimension(self):
        &#34;&#34;&#34;Return min(width, height) typecast to float&#34;&#34;&#34;
        return float(np.min(self.shape()))

    def mindim(self):
        &#34;&#34;&#34;Return min(width, height) typecast to float&#34;&#34;&#34;
        return float(np.min(self.shape()))

    def maxdim(self):
        &#34;&#34;&#34;Return max(width, height) typecast to float&#34;&#34;&#34;
        return float(np.max(self.shape())) 
    
    def ellipse(self):
        &#34;&#34;&#34;Convert the boundingbox to a vipy.geometry.Ellipse object&#34;&#34;&#34;
        (xcenter,ycenter) = self.centroid()
        return Ellipse(self.bbwidth() / 2.0, self.bbheight() / 2.0, xcenter, ycenter, 0)

    def average(self, other):
        &#34;&#34;&#34;Compute the average bounding box between self and other, and set self to the average.  Other may be a singleton bounding box or a list of bounding boxes&#34;&#34;&#34;
        assert all([isinstance(bb, BoundingBox) for bb in tolist(other)]), &#34;Invalid input - must be BoundingBox&#34;        
        return self.ulbr(np.mean( [self.ulbr()] + [bb.ulbr() for bb in tolist(other)], axis=0))

    def averageshape(self, other):
        &#34;&#34;&#34;Compute the average bounding box width and height between self and other.  Other may be a singleton bounding box or a list of bounding boxes&#34;&#34;&#34;
        assert all([isinstance(bb, BoundingBox) for bb in tolist(other)]), &#34;Invalid input - must be BoundingBox&#34;        
        (xmin, ymin, xmax, ymax) = np.mean( [self.ulbr()] + [bb.ulbr() for bb in tolist(other)], axis=0)
        self.setwidth(xmax-xmin)
        self.setheight(ymax-ymin)        
        return self

    def medianshape(self, other):
        &#34;&#34;&#34;Compute the median bounding box width and height between self and other.  Other may be a singleton bounding box or a list of bounding boxes&#34;&#34;&#34;
        assert all([isinstance(bb, BoundingBox) for bb in tolist(other)]), &#34;Invalid input - must be BoundingBox&#34;        
        (height, width) = np.median( [self.shape()] + [bb.shape() for bb in tolist(other)], axis=0)
        self.setwidth(width)
        self.setheight(height)
        return self

    def shapedist(self, other):
        &#34;&#34;&#34;L1 distance between (width,height) of two boxes&#34;&#34;&#34;
        assert isinstance(other, BoundingBox), &#34;Invalid input - must be BoundingBox()&#34;                
        return np.abs(self.bbwidth()-other.bbwidth())  + np.abs(self.bbheight()-other.bbheight())

    def affine(self, A):
        &#34;&#34;&#34;Apply an 2x3 affine transformation to the box centroid.  This operation preserves an axis aligned bounding box for an arbitrary affine transform.&#34;&#34;&#34;
        assert isnumpy(A) and A.shape == (2,3), &#34;A must be a 2x3 affine transformation matrix&#34;
        return self.centroid(np.dot(A, homogenize(np.array(self.centroid()))))

    def projective(self, A):
        &#34;&#34;&#34;Apply an 3x3 affine transformation to the box centroid.  This operation preserves an axis aligned bounding box for an arbitrary affine transform.&#34;&#34;&#34;
        assert isnumpy(A) and A.shape == (3,3), &#34;A must be a 3x3 affine transformation matrix&#34;
        return self.centroid(dehomogenize(np.dot(A, homogenize(np.array(self.centroid())))))
    
    def crop(self, img):
        &#34;&#34;&#34;Crop an HxW 2D numpy image, HxWxC 3D numpy image, or NxHxWxC 4D numpy image array using this bounding box applied to HxW dimensions.  Crop is performed in-place. &#34;&#34;&#34;
        assert isnumpy(img) and img.ndim in [2,3,4]
        assert self.isinteger(), &#34;Box corners must be integer - try calling self.int()&#34;

        if img.ndim == 2:
            return img[self.ymin():self.ymax(), self.xmin():self.xmax()]  # HxW
        elif img.ndim == 3:
            return img[self.ymin():self.ymax(), self.xmin():self.xmax(), :]  # HxWxC
        else: 
            return img[:, self.ymin():self.ymax(), self.xmin():self.xmax(), :]  # NxHxWxC

    def confidence(self):
        &#34;&#34;&#34;Bounding boxes do not have confidences, use vipy.object.Detection()&#34;&#34;&#34;
        return None

    def grid(self, rows, cols):
        &#34;&#34;&#34;Split a bounding box into the smallest grid of non-overlapping bounding boxes such that the union is the original box&#34;&#34;&#34;
        (w,h) = (self.width()/cols, self.height()/rows)
        return [BoundingBox(xmin=x, ymin=y, width=w, height=h) for x in np.arange(self._xmin, self._xmax, w) for y in np.arange(self._ymin, self._ymax, h)]

class Ellipse():
    __slots__ = [&#39;_major&#39;, &#39;_minor&#39;, &#39;_xcenter&#39;, &#39;_ycenter&#39;, &#39;_phi&#39;]
    def __init__(self, semi_major, semi_minor, xcenter, ycenter, phi):
        &#34;&#34;&#34;Ellipse parameterization, for length of semimajor (half width of ellipse) and semiminor axis (half height), center point and angle phi in radians&#34;&#34;&#34;
        self._major = semi_major
        self._minor = semi_minor
        self._xcenter = xcenter
        self._ycenter = ycenter
        self._phi = phi

    def __repr__(self):
        return str(&#39;&lt;vipy.geometry.ellipse: semimajor=%s, semiminor=%s, xcenter=%s, ycenter=%s, phi=%s (rad)&gt;&#39; % (self._major, self._minor, self._xcenter, self._ycenter, self._phi))

    def dict(self):
        return {&#39;semimajor&#39;:self._major, &#39;semiminor&#39;:self._minor, &#39;xcenter&#39;:self._xcenter, &#39;ycenter&#39;:self._ycenter, &#39;phi&#39;:self._phi}
    
    def area(self):
        &#34;&#34;&#34;Area of ellipse&#34;&#34;&#34;
        return math.pi * self._major * self._minor

    def center(self):
        &#34;&#34;&#34;Return centroid&#34;&#34;&#34;
        return (self._xcenter, self._ycenter)

    def centroid(self):
        &#34;&#34;&#34;Alias for center&#34;&#34;&#34;
        return self.center()

    def axes(self):
        &#34;&#34;&#34;Return the (major,minor) axis lengths&#34;&#34;&#34;
        return (self._major, self._minor)

    def angle(self):
        &#34;&#34;&#34;Return the angle phi (in degrees)&#34;&#34;&#34;
        return (self._phi * 180 / math.pi)

    def rescale(self, scale):
        &#34;&#34;&#34;Scale ellipse by scale factor&#34;&#34;&#34;
        assert isnumber(scale), &#34;Invalid input&#34;
        self._major *= scale
        self._minor *= scale
        self._xcenter *= scale
        self._ycenter *= scale
        return self

    def boundingbox(self):
        &#34;&#34;&#34; Estimate an equivalent bounding box based on scaling to a common area.
        Note, this does not factor in rotation.
        (c*l)*(c*w) = a_e  --&gt; c = sqrt(a_e / a_r) &#34;&#34;&#34;
        assert self._phi == 0, &#34;This function does not currently factor in rotation&#34;

        bbox = BoundingBox(width=2 * self._major, height=2 * self._minor, xcentroid=self._xcenter, ycentroid=self._ycenter)
        a_r = bbox.area()
        c = (self.area() / a_r) ** 0.5
        bbox2 = bbox.clone().dilate(c)
        return bbox2

    def inside(self, x, y=None):
        &#34;&#34;&#34;Return true if a point p=(x,y) is inside the ellipse&#34;&#34;&#34;
        p = (x,y) if y is not None else x
        assert len(p) == 2, &#34;Invalid input&#34;
        assert self._phi == 0, &#34;inside only currently supported for phi=0&#34;
        return ((np.square(p[0] - self._xcenter) / np.square(self._major)) + (np.square(p[1] - self._ycenter) / np.square(self._minor))) &lt;= 1

    def mask(self):
        &#34;&#34;&#34;Return a binary mask of size equal to the bounding box such that the pixels correspond to the interior of the ellipse&#34;&#34;&#34;
        (H,W) = (int(np.round(2 * self._minor)), int(np.round(2 * self._major)))
        img = np.zeros((H,W), dtype=bool)
        for (y,x) in product(range(0,H), range(0,W)):
            img[y,x] = self.inside(x,y)
        return img

def union(bblist):
    &#34;&#34;&#34;Return the union of a list of vipy.geometry.BoundingBox&#34;&#34;&#34;
    return bblist[0].clone().union(bblist)    </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="vipy.geometry.affine_transform"><code class="name flex">
<span>def <span class="ident">affine_transform</span></span>(<span>txy=(0, 0), r=0, sx=1, sy=1, kx=0, ky=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Compose and return a 3x3 affine transformation for translation txy=(0,0), rotation r (radians), scalex=sx, scaley=sy, shearx=kx, sheary=ky</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L73-L80" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def affine_transform(txy=(0,0), r=0, sx=1, sy=1, kx=0, ky=0):
    &#34;&#34;&#34;Compose and return a 3x3 affine transformation for translation txy=(0,0), rotation r (radians), scalex=sx, scaley=sy, shearx=kx, sheary=ky&#34;&#34;&#34;
    assert istuple(txy) and len(txy) == 2 and isnumber(r) and isnumber(sx) and isnumber(sy) and isnumber(kx) and isnumber(ky), &#34;Invalid input&#34;
    R = np.mat([[np.cos(r), -np.sin(r), 0], [np.sin(r), np.cos(r), 0], [0,0,1]])
    S = np.mat([[sx,0,0], [0, sy, 0], [0,0,1]])
    K = np.mat([[1,ky,0], [kx,1,0], [0,0,1]])
    T = np.mat([[0,0,txy[0]], [0,0,txy[1]], [0,0,0]])
    return K * S * R + T  # composition</code></pre>
</details>
</dd>
<dt id="vipy.geometry.apply_homography"><code class="name flex">
<span>def <span class="ident">apply_homography</span></span>(<span>H, p)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply a 3x3 homography H to non-homogenous point p and return a transformed point</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L48-L51" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def apply_homography(H,p):
    &#34;&#34;&#34;Apply a 3x3 homography H to non-homogenous point p and return a transformed point &#34;&#34;&#34;
    assert isnumpy(H) and isnumpy(p) and H.shape == (3,3) and p.shape[0] == 2, &#34;Invalid input&#34;
    return dehomogenize(np.dot(H, homogenize(p)))</code></pre>
</details>
</dd>
<dt id="vipy.geometry.covariance_to_ellipse"><code class="name flex">
<span>def <span class="ident">covariance_to_ellipse</span></span>(<span>cov)</span>
</code></dt>
<dd>
<div class="desc"><p>2x2 covariance matrix to ellipse (major_axis_length, minor_axis_length, angle_in_radians)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L14-L18" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def covariance_to_ellipse(cov):
    &#34;&#34;&#34;2x2 covariance matrix to ellipse (major_axis_length, minor_axis_length, angle_in_radians)&#34;&#34;&#34;
    assert isnumpy(cov) and cov.shape == (2,2), &#34;Invalid input&#34;
    (d,V) = np.linalg.eig(cov)
    return np.array((d[0], d[1], math.atan2(V[1,0], V[0,0])))  # (major_axis_len, minor_axis_len, angle_in_radians)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.dehomogenize"><code class="name flex">
<span>def <span class="ident">dehomogenize</span></span>(<span>p)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert 3x1 homogenous point (x,y,h) to 2x1 non-homogenous point (x/h, y/h)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L21-L32" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dehomogenize(p):
    &#34;&#34;&#34;Convert 3x1 homogenous point (x,y,h) to 2x1 non-homogenous point (x/h, y/h)&#34;&#34;&#34;
    assert isnumpy(p)    
    if p.ndim == 1:
        assert len(p) == 3
        return p[0:2] / p[2]
    elif p.ndim == 2:
        assert isnumpy(p) and p.shape[0] == 3, &#34;Invalid input&#34;
        p = columnvector(p) if p.ndim == 1 else p
        return p[0:-1, :] / p[-1,:]
    else:
        return ValueError(&#39;p must be 1d or 2d&#39;)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.homogenize"><code class="name flex">
<span>def <span class="ident">homogenize</span></span>(<span>p)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert 2xN non-homogenous points (x,y) to 3xN non-homogenous point (x, y, 1)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L35-L45" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def homogenize(p):
    &#34;&#34;&#34;Convert 2xN non-homogenous points (x,y) to 3xN non-homogenous point (x, y, 1)&#34;&#34;&#34;
    assert isnumpy(p)
    if p.ndim == 1:
        return np.hstack( (p, 1) )
    elif p.ndim == 2:
        assert p.shape[0] == 2, &#34;Invalid input&#34;
        p = columnvector(p) if p.ndim == 1 else p
        return np.vstack((p, np.ones_like(p[-1])))
    else:
        return ValueError(&#39;p must be 1d or 2d&#39;)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.imagebox"><code class="name flex">
<span>def <span class="ident">imagebox</span></span>(<span>shape)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L110-L111" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def imagebox(shape):
    return BoundingBox(xmin=0, ymin=0, width=shape[1], height=shape[0])</code></pre>
</details>
</dd>
<dt id="vipy.geometry.imtransform"><code class="name flex">
<span>def <span class="ident">imtransform</span></span>(<span>img, A)</span>
</code></dt>
<dd>
<div class="desc"><p>Transform an numpy array image (MxNx3) following the affine or similiarity transformation A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L95-L102" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def imtransform(img, A):
    &#34;&#34;&#34;Transform an numpy array image (MxNx3) following the affine or similiarity transformation A&#34;&#34;&#34;
    assert isnumpy(img) and isnumpy(A), &#34;invalid input&#34;
    try_import(cv2, &#39;opencv-python&#39;); import cv2
    if A.shape == (2,3):
        return cv2.warpAffine(img, A, (img.shape[1], img.shape[0]))
    else:
        return cv2.warpPerspective(img, A, (img.shape[1], img.shape[0]))</code></pre>
</details>
</dd>
<dt id="vipy.geometry.normalize"><code class="name flex">
<span>def <span class="ident">normalize</span></span>(<span>x, eps=1e-16)</span>
</code></dt>
<dd>
<div class="desc"><p>Given a vector x, return the vector unit normalized as float64</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L105-L108" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def normalize(x, eps=1E-16):
    &#34;&#34;&#34;Given a vector x, return the vector unit normalized as float64&#34;&#34;&#34;
    assert isnumpy(x), &#34;Invalid input&#34;
    return x / (np.linalg.norm(x.astype(np.float64)) + eps)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.random_affine_transform"><code class="name flex">
<span>def <span class="ident">random_affine_transform</span></span>(<span>txy=((0, 1), (0, 1)), r=(0, 1), sx=(0.1, 1), sy=(0.1, 1), kx=(0.1, 1), ky=(0.1, 1))</span>
</code></dt>
<dd>
<div class="desc"><p>Return a random 3x3 affine transformation matrix for the provided ranges, inputs must be tuples</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L83-L92" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def random_affine_transform(txy=((0,1),(0,1)), r=(0,1), sx=(0.1,1), sy=(0.1,1), kx=(0.1,1), ky=(0.1,1)):
    &#34;&#34;&#34;Return a random 3x3 affine transformation matrix for the provided ranges, inputs must be tuples&#34;&#34;&#34;
    assert istuple(txy) and istuple(txy[0]) and istuple(txy[1]) and istuple(r) and istuple(sx) and istuple(sy) and istuple(kx) and istuple(ky), &#34;Invalid input&#34;
    uniform_random_in_range = lambda t: np.random.uniform(t[0], t[1])
    return affine_transform(txy=(uniform_random_in_range(txy[0]), uniform_random_in_range(txy[1])),
                            r=uniform_random_in_range(r),
                            sx=uniform_random_in_range(sx),
                            sy=uniform_random_in_range(sy),
                            kx=uniform_random_in_range(kx),
                            ky=uniform_random_in_range(ky))</code></pre>
</details>
</dd>
<dt id="vipy.geometry.similarity_transform"><code class="name flex">
<span>def <span class="ident">similarity_transform</span></span>(<span>txy=(0, 0), r=0, s=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a 3x3 similarity transformation with translation tuple txy=(x,y), rotation r (radians, scale=s</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L64-L70" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def similarity_transform(txy=(0,0), r=0, s=1):
    &#34;&#34;&#34;Return a 3x3 similarity transformation with translation tuple txy=(x,y), rotation r (radians, scale=s&#34;&#34;&#34;
    assert istuple(txy) and len(txy) == 2 and isnumber(r) and isnumber(s), &#34;Invalid input&#34;
    R = np.mat([[np.cos(r), -np.sin(r), 0], [np.sin(r), np.cos(r), 0], [0,0,1]])
    S = np.mat([[s,0,0], [0, s, 0], [0,0,1]])
    T = np.mat([[0,0,txy[0]], [0,0,txy[1]], [0,0,0]])
    return S * R + T  # composition</code></pre>
</details>
</dd>
<dt id="vipy.geometry.similarity_transform_2x3"><code class="name flex">
<span>def <span class="ident">similarity_transform_2x3</span></span>(<span>c=(0, 0), r=0, s=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a 2x3 similarity transform with rotation r (radians), scale s and origin c=(x,y)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L54-L61" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def similarity_transform_2x3(c=(0,0), r=0, s=1):
    &#34;&#34;&#34;Return a 2x3 similarity transform with rotation r (radians), scale s and origin c=(x,y)&#34;&#34;&#34;
    assert istuple(c) and len(c) == 2 and isnumber(r) and isnumber(s), &#34;Invalid input&#34;
    deg = r * 180. / math.pi
    a = s * np.cos(r)
    b = s * np.sin(r)
    (x,y) = (c[0], c[1])
    return np.array([[a, b, (1 - a) * x - b * y], [-b, a, b * x + (1 - a) * y]])</code></pre>
</details>
</dd>
<dt id="vipy.geometry.union"><code class="name flex">
<span>def <span class="ident">union</span></span>(<span>bblist)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the union of a list of vipy.geometry.BoundingBox</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L1011-L1013" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def union(bblist):
    &#34;&#34;&#34;Return the union of a list of vipy.geometry.BoundingBox&#34;&#34;&#34;
    return bblist[0].clone().union(bblist)    </code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="vipy.geometry.BoundingBox"><code class="flex name class">
<span>class <span class="ident">BoundingBox</span></span>
<span>(</span><span>xmin=None, ymin=None, xmax=None, ymax=None, centroid=None, xcentroid=None, ycentroid=None, width=None, height=None, mask=None, xywh=None, ulbr=None, ulbrdict=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Core bounding box class with flexible constructors in this priority order:
(xmin,ymin,xmax,ymax)
(xmin,ymin,width,height)
(centroid[0],centroid[1],width,height)
(xcentroid,ycentroid,width,height)
xywh=(xmin,ymin,width,height)
ulbr=(xmin,ymin,xmax,ymax)
bounding rectangle of binary mask image</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L115-L937" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class BoundingBox(object):
    &#34;&#34;&#34;Core bounding box class with flexible constructors in this priority order:
          (xmin,ymin,xmax,ymax)
          (xmin,ymin,width,height)
          (centroid[0],centroid[1],width,height)
          (xcentroid,ycentroid,width,height)
          xywh=(xmin,ymin,width,height)
          ulbr=(xmin,ymin,xmax,ymax)
          bounding rectangle of binary mask image&#34;&#34;&#34;

    #__slots__ = [&#39;_xmin&#39;, &#39;_ymin&#39;, &#39;_xmax&#39;, &#39;_ymax&#39;]  # This is not backwards compatible
    def __init__(self, xmin=None, ymin=None, xmax=None, ymax=None, centroid=None, xcentroid=None, ycentroid=None, width=None, height=None, mask=None, xywh=None, ulbr=None, ulbrdict=None):

        if ulbrdict is not None:
            self.__dict__ = ulbrdict  # equivalent to (but faster)
            #self._xmin = ulbrdict[&#39;_xmin&#39;]
            #self._ymin = ulbrdict[&#39;_ymin&#39;]
            #self._xmax = ulbrdict[&#39;_xmax&#39;]
            #self._ymax = ulbrdict[&#39;_ymax&#39;]                                  
        elif xmin is not None and ymin is not None and xmax is not None and ymax is not None:
            if not (isnumber(xmin) and isnumber(ymin) and isnumber(xmax) and isnumber(ymax)):
                raise ValueError(&#39;Box coordinates must be integers or floats not &#34;%s&#34;&#39; % str(type(xmin)))
            self._xmin = float(xmin)
            self._ymin = float(ymin)
            self._xmax = float(xmax)
            self._ymax = float(ymax)
        elif xmin is not None and ymin is not None and width is not None and height is not None:
            if not (isnumber(xmin) and isnumber(ymin) and isnumber(width) and isnumber(height)):
                raise ValueError(&#39;Box coordinates must be integers or floats not &#34;%s&#34;&#39; % str(type(width)))
            self._xmin = float(xmin)
            self._ymin = float(ymin)
            self._xmax = self._xmin + float(width)
            self._ymax = self._ymin + float(height)
        elif centroid is not None and width is not None and height is not None:
            if not (len(centroid) == 2 and isnumber(centroid[0]) and isnumber(centroid[1]) and isnumber(width) and isnumber(height)):
                raise ValueError(&#39;Invalid box coordinates&#39;)
            self._xmin = float(centroid[0]) - float(width) / 2.0
            self._ymin = float(centroid[1]) - float(height) / 2.0
            self._xmax = float(centroid[0]) + float(width) / 2.0
            self._ymax = float(centroid[1]) + float(height) / 2.0
        elif xcentroid is not None and ycentroid is not None and width is not None and height is not None:
            #if not (isnumber(xcentroid) and isnumber(ycentroid) and isnumber(width) and isnumber(height)):
            #    raise ValueError(&#39;Box coordinates must be integers or floats&#39;)
            self._xmin = float(xcentroid) - (float(width) / 2.0)
            self._ymin = float(ycentroid) - (float(height) / 2.0)
            self._xmax = float(xcentroid) + (float(width) / 2.0)
            self._ymax = float(ycentroid) + (float(height) / 2.0)
        elif xywh is not None:
            self.xywh(xywh)
        elif ulbr is not None:
            self.ulbr(ulbr)
        elif mask is not None:
            # Bounding rectangle of non-zero pixels in a binary mask image
            if not isnumpy(mask) or np.sum(mask) == 0:
                raise ValueError(&#39;Mask input must be numpy array with at least one non-zero entry&#39;)
            imx = np.sum(mask, axis=0)
            imy = np.sum(mask, axis=1)
            self._xmin = np.argwhere(imx &gt; 0)[0]
            self._ymin = np.argwhere(imy &gt; 0)[0]
            self._xmax = np.argwhere(imx &gt; 0)[-1]
            self._ymax = np.argwhere(imy &gt; 0)[-1]
        else:
            raise ValueError(&#39;invalid constructor input&#39;)

    @classmethod
    def cast(cls, bb, flush=False):
        assert isinstance(bb, BoundingBox)
        bb.__class__ = BoundingBox
        if flush:
            bb.__dict__ = {k:v for (k,v) in bb.__dict__.items() if k in [&#39;_xmin&#39;, &#39;_ymin&#39;, &#39;_xmax&#39;, &#39;_ymax&#39;]}        
        return bb
    
    @classmethod
    def from_json(cls, s):
        d = json.loads(s) if not isinstance(s, dict) else s
        return cls(ulbrdict=d)

    def dict(self):
        &#34;&#34;&#34;Return a python dictionary containing the relevant serialized attributes suitable for JSON encoding&#34;&#34;&#34;
        return self.json(encode=False)
    
    def json(self, encode=True):
        return json.dumps(self.__dict__) if encode else self.__dict__
        
    def clone(self):
        return BoundingBox(xmin=self._xmin, xmax=self._xmax, ymin=self._ymin, ymax=self._ymax)
    def bbclone(self):
        return BoundingBox(xmin=self._xmin, xmax=self._xmax, ymin=self._ymin, ymax=self._ymax)

    def __eq__(self, other):
        &#34;&#34;&#34;Bounding box equality&#34;&#34;&#34;
        return isinstance(other, BoundingBox) and self.xywh() == other.xywh()

    def __neq__(self, other):
        &#34;&#34;&#34;Bounding box non-equality&#34;&#34;&#34;
        return not self.__eq__(other)

    def __repr__(self):
        return str(&#39;&lt;vipy.geometry.boundingbox: xmin=%s, ymin=%s, width=%s, height=%s&gt;&#39; % (self.xmin(), self.ymin(), self.bbwidth(), self.bbheight()))

    def __str__(self):
        return self.__repr__()
    
    def xmin(self):
        &#34;&#34;&#34;x coordinate of upper left corner of box, x-axis is image column&#34;&#34;&#34;
        return self._xmin

    def ul(self):
        &#34;&#34;&#34;Upper left coordinate (x,y)&#34;&#34;&#34;
        return (self._xmin, self._ymin)

    def ulx(self):
        &#34;&#34;&#34;Upper left coordinate (x)&#34;&#34;&#34;
        return self.ul()[0]

    def uly(self):
        &#34;&#34;&#34;Upper left coordinate (y)&#34;&#34;&#34;
        return self.ul()[1]

    def ur(self):
        &#34;&#34;&#34;Upper right coordinate (x,y)&#34;&#34;&#34;
        return (self._xmax, self._ymin)

    def urx(self):
        &#34;&#34;&#34;Upper right coordinate (x)&#34;&#34;&#34;
        return self.ur()[0]

    def ury(self):
        &#34;&#34;&#34;Upper right coordinate (y)&#34;&#34;&#34;
        return self.ur()[1]

    def ll(self):
        &#34;&#34;&#34;Lower left coordinate (x,y), synonym for bl()&#34;&#34;&#34;
        return (self._xmin, self._ymax)

    def bl(self):
        &#34;&#34;&#34;Bottom left coordinate (x,y), synonym for ll()&#34;&#34;&#34;
        return (self._xmin, self._ymax)

    def blx(self):
        &#34;&#34;&#34;Bottom left coordinate (x)&#34;&#34;&#34;
        return self.bl()[0]

    def bly(self):
        &#34;&#34;&#34;Bottom left coordinate (y)&#34;&#34;&#34;
        return self.bl()[1]

    def lr(self):
        &#34;&#34;&#34;Lower right coordinate (x,y), synonym for br()&#34;&#34;&#34;
        return (self._xmax, self._ymax)

    def br(self):
        &#34;&#34;&#34;Bottom right coordinate (x,y), synonym for lr()&#34;&#34;&#34;
        return (self._xmax, self._ymax)

    def brx(self):
        &#34;&#34;&#34;Bottom right coordinate (x)&#34;&#34;&#34;
        return self.br()[0]

    def bry(self):
        &#34;&#34;&#34;Bottom right coordinate (y)&#34;&#34;&#34;
        return self.br()[1]


    def ymin(self):
        &#34;&#34;&#34;y coordinate of upper left corner of box, y-axis is image row&#34;&#34;&#34;
        return self._ymin

    def xmax(self):
        &#34;&#34;&#34;x coordinate of lower right corner of box, x-axis is image column&#34;&#34;&#34;
        return self._xmax

    def ymax(self):
        &#34;&#34;&#34;y coordinate of lower right corner of box, y-axis is image row&#34;&#34;&#34;
        return self._ymax

    def upperleft(self):
        &#34;&#34;&#34;Return the (x,y) upper left corner coordinate of the box&#34;&#34;&#34;
        return (self.xmin(), self.ymin())

    def bottomleft(self):
        &#34;&#34;&#34;Return the (x,y) lower left corner coordinate of the box&#34;&#34;&#34;
        return (self.xmin(), self.ymax())

    def upperright(self):
        &#34;&#34;&#34;Return the (x,y) upper right corner coordinate of the box&#34;&#34;&#34;
        return (self.xmax(), self.ymin())

    def bottomright(self):
        &#34;&#34;&#34;Return the (x,y) lower right corner coordinate of the box&#34;&#34;&#34;
        return (self.xmax(), self.ymax())

    def isinteger(self):
        return (isinstance(self._xmin, int) and
                isinstance(self._ymin, int) and
                isinstance(self._xmax, int) and
                isinstance(self._ymax, int))
                
    def int(self):
        &#34;&#34;&#34;Convert corners to integer with rounding, in-place update&#34;&#34;&#34;
        (w,h) = (int(np.round(self.bbwidth())), int(np.round(self.bbheight())))
        self._xmin = int(np.round(self._xmin))
        self._ymin = int(np.round(self._ymin))
        self._xmax = int(np.round(self._xmax))
        self._ymax = int(np.round(self._ymax))
        if w != self.bbwidth():
            self.right(w - self.bbwidth())  # preserve aspect ratio due to rounding by +/- right side of box 
        if h != self.bbheight():
            self.bottom(h-self.bbheight())  # preserve aspect ratio due to rounding by +/- bottom of box
        return self

    def float(self):
        &#34;&#34;&#34;Convert corners to float&#34;&#34;&#34;
        self._xmin = float(self._xmin)
        self._ymin = float(self._ymin)
        self._xmax = float(self._xmax)
        self._ymax = float(self._ymax)
        return self

    def significant_digits(self, n):
        &#34;&#34;&#34;Convert corners to have at most n significant digits for efficient JSON storage&#34;&#34;&#34;
        assert isinstance(n, int) and n&gt;=0
        self._xmin = round(self._xmin, n)
        self._ymin = round(self._ymin, n)
        self._xmax = round(self._xmax, n)
        self._ymax = round(self._ymax, n)
        return self
        
    def translate(self, dx=0, dy=0):
        &#34;&#34;&#34;Translate the bounding box by dx in x and dy in y&#34;&#34;&#34;
        self._xmin = self._xmin + dx
        self._ymin = self._ymin + dy
        self._xmax = self._xmax + dx
        self._ymax = self._ymax + dy
        return self

    def to_origin(self):
        return self.translate(-self.xmin(), -self.ymin())
    
    def set_origin(self, other):
        &#34;&#34;&#34;Set the origin of the coordinates of this bounding box to be relative to the upper left of the other bounding box&#34;&#34;&#34;
        assert isinstance(other, BoundingBox), &#34;Invalid BoundingBox() input of type &#39;%s&#39;&#34; % str(type(other))
        return self.translate(other.xmin(), other.ymin())                
    
    def offset(self, dx=0, dy=0):
        &#34;&#34;&#34;Alias for translate&#34;&#34;&#34;
        return self.translate(dx, dy)

    def invalid(self):
        &#34;&#34;&#34;Is the box a valid bounding box?&#34;&#34;&#34;
        #is_undefined = np.isnan(self._xmin) or np.isnan(self._ymin) or np.isnan(self._xmax) or np.isnan(self._ymax)
        is_valid = ((self._xmax - self._xmin) &gt;= 0) and ((self._ymax - self._ymin) &gt;= 0)  # if nan, will return False
        return not is_valid

    def valid(self):
        return not self.invalid()

    def isvalid(self):
        return not self.invalid()

    def isdegenerate(self):
        return self.invalid()
        
    def isnonnegative(self):
        return (self.xmin() &gt;= 0 and
                self.ymin() &gt;= 0 and
                self.xmax() &gt;= 0 and
                self.ymax() &gt;= 0)

    def width(self):
        return self._xmax - self._xmin
    def bbwidth(self):
        return self._xmax - self._xmin
    
    def setwidth(self, w):
        &#34;&#34;&#34;Set new width keeping centroid constant&#34;&#34;&#34;
        if w &lt;= 0:
            raise ValueError(&#39;invalid width&#39;)
        worig = (self._xmax - self._xmin)
        self._xmax += float((w - worig) / 2.0)
        self._xmin -= float((w - worig) / 2.0)
        return self

    def setheight(self, h):
        &#34;&#34;&#34;Set new height keeping centroid constant&#34;&#34;&#34;
        if h &lt;= 0:
            raise ValueError(&#39;invalid height&#39;)
        horig = self._ymax - self._ymin
        self._ymax += float((h - horig) / 2.0)
        self._ymin -= float((h - horig) / 2.0)
        return self

    def height(self):
        return self._ymax - self._ymin
    def bbheight(self):
        return self._ymax - self._ymin

    def centroid(self, c=None):
        &#34;&#34;&#34;(x,y) tuple of centroid position of bounding box&#34;&#34;&#34;
        if c is None:
            (height, width) = (self._ymax-self._ymin, self._xmax-self._xmin)            
            return (self._xmin + (float(width) / 2.0), self._ymin + (float(height) / 2.0))
        else:
            assert len(c) == 2
            (height, width) = (self._ymax-self._ymin, self._xmax-self._xmin)
            self._xmin = float(c[0]) - (width / 2.0)
            self._ymin = float(c[1]) - (height / 2.0)
            self._xmax = float(c[0]) + (width / 2.0)
            self._ymax = float(c[1]) + (height / 2.0)
            return self
            
    def x_centroid(self):
        return self.centroid()[0]

    def xcentroid(self):
        &#34;&#34;&#34;Alias for x_centroid()&#34;&#34;&#34;
        return self.centroid()[0]
    def centroid_x(self):
        &#34;&#34;&#34;Alias for x_centroid()&#34;&#34;&#34;
        return self.centroid()[0]
            
    def y_centroid(self):
        return self.centroid()[1]

    def ycentroid(self):
        &#34;&#34;&#34;Alias for y_centroid()&#34;&#34;&#34;
        return self.centroid()[1]
    def centroid_y(self):
        &#34;&#34;&#34;Alias for y_centroid()&#34;&#34;&#34;
        return self.centroid()[1]
    
    def area(self):
        &#34;&#34;&#34;Return the area=width*height of the bounding box&#34;&#34;&#34;
        (height, width) = (self._ymax-self._ymin, self._xmax-self._xmin)        
        return width * height if (height&gt;0 and width&gt;0) else 0

    def to_xywh(self, xywh=None):
        &#34;&#34;&#34;Return bounding box corners as (x,y,width,height) tuple&#34;&#34;&#34;
        if xywh is None:
            (height, width) = (self._ymax-self._ymin, self._xmax-self._xmin)                    
            return tuple([self._xmin, self._ymin, width, height])
        else:
            assert len(xywh) == 4, &#34;Invalid (xmin,ymin,width,height) input&#34;
            self._xmin = float(xywh[0])
            self._ymin = float(xywh[1])
            self._xmax = float(self._xmin + xywh[2])
            self._ymax = float(self._ymin + xywh[3])
            return self

    def xywh(self, xywh_=None):
        &#34;&#34;&#34;Alias for to_xywh&#34;&#34;&#34;
        return self.to_xywh(xywh_)

    def cxywh(self, cxywh=None):
        &#34;&#34;&#34;Return or set bounding box corners as (centroidx,centroidy,width,height) tuple&#34;&#34;&#34;
        if cxywh is None:
            (height, width) = (self._ymax-self._ymin, self._xmax-self._xmin)                    
            return tuple([self.x_centroid(), self.y_centroid(), width, height])
        else:
            assert len(cxywh) == 4, &#34;Invalid (xcentroid, ycentroid, width, height) input&#34;
            return self.centroid( (cxywh[0], cxywh[1]) ).setwidth(cxywh[2]).setheight(cxywh[3])            
    
    def ulbr(self, ulbr=None):
        &#34;&#34;&#34;Return bounding box corners as upper left, bottom right (xmin, ymin, xmax, ymax)&#34;&#34;&#34;
        if ulbr is None:
            return (self._xmin, self._ymin, self._xmax, self._ymax)            
        else:
            assert len(ulbr) == 4, &#34;Invalid (xmin,ymin,xmax,ymax) input&#34;
            self._xmin = float(ulbr[0])
            self._ymin = float(ulbr[1])
            self._xmax = float(ulbr[2])
            self._ymax = float(ulbr[3])
            return self

    def to_ulbr(self, ulbr=None):
        &#34;&#34;&#34;Alias for ulbr()&#34;&#34;&#34;
        return self.ulbr(ulbr)
    
    def dx(self, bb):
        &#34;&#34;&#34;Offset bounding box by same xmin as provided box&#34;&#34;&#34;
        return bb._xmin - self._xmin

    def dy(self, bb):
        &#34;&#34;&#34;Offset bounding box by ymin of provided box&#34;&#34;&#34;
        return bb._ymin - self._ymin

    def sqdist(self, bb):
        &#34;&#34;&#34;Squared Euclidean distance between upper left corners of two bounding boxes&#34;&#34;&#34;
        assert isinstance(bb, BoundingBox), &#34;Invalid BoundingBox() input of type &#39;%s&#39;&#34; % str(type(bb))                
        return np.power(self.dx(bb), 2.0) + np.power(self.dy(bb), 2.0)

    def dist(self, bb):
        &#34;&#34;&#34;Distance between centroids of two bounding boxes&#34;&#34;&#34;
        assert isinstance(bb, BoundingBox), &#34;Invalid BoundingBox() input of type &#39;%s&#39;&#34; % str(type(bb))                
        return np.sqrt(np.sum(np.square(np.array(bb.centroid()) - np.array(self.centroid()))))

    def pdist(self, bb, sigma=None):
        &#34;&#34;&#34;Normalized Gaussian distance in [0,1] between centroids of two bounding boxes, where 0 is far and 1 is same with sigma=maxdim() of this box&#34;&#34;&#34;
        assert isinstance(bb, BoundingBox), &#34;Invalid BoundingBox() input of type &#39;%s&#39;&#34; % str(type(bb))
        return np.exp(-self.sqdist(bb)/(float(2*self.maxdim()*self.maxdim()) if sigma is None else float(2.0*sigma*sigma)))

    def iou(self, bb, area=None, otherarea=None):
        &#34;&#34;&#34;area of intersection / area of union&#34;&#34;&#34;
        assert bb is None or isinstance(bb, BoundingBox), &#34;Invalid BoundingBox() input of type &#39;%s&#39;&#34; % str(type(bb))        
        if bb is None:
            return 0
        w = min(self._xmax, bb._xmax) - max(self._xmin, bb._xmin)
        if w &lt;= 0:
            return 0  # invalid (no overlap), early exit
        h = min(self._ymax, bb._ymax) - max(self._ymin, bb._ymin)
        if h &lt;= 0:
            return 0  # invalid (no overlap), early exit

        area_intersection = w * h
        area_union = ((self.area() if area is None else area) +
                      (bb.area() if otherarea is None else otherarea) -
                      area_intersection)
        return (area_intersection / float(area_union)) if area_union &gt; 0 else 0

    def intersection_over_union(self, bb):
        &#34;&#34;&#34;Alias for iou&#34;&#34;&#34;
        return self.iou(bb)

    def area_of_intersection(self, bb, strict=True):
        &#34;&#34;&#34;area of intersection&#34;&#34;&#34;
        if strict:
            assert isinstance(bb, BoundingBox), &#34;Invalid BoundingBox() input of type &#39;%s&#39;&#34; % str(type(bb))                
        w = min(self._xmax, bb._xmax) - max(self._xmin, bb._xmin)
        if w &lt;= 0:
            return 0  # invalid (no overlap), early exit 
        h = min(self._ymax, bb._ymax) - max(self._ymin, bb._ymin)
        if h &lt;= 0:
            return 0  # invalid (no overlap), early exit 
        return w*h

    def area_of_union(self, bb):
        return self.area() + bb.area() - self.area_of_intersection(bb)
        
    def cover(self, bb):
        &#34;&#34;&#34;Fraction of this bounding box intersected by other bbox (bb)&#34;&#34;&#34;
        a = float(self.area())
        return (self.area_of_intersection(bb) / a) if a&gt;0 else 0

    def maxcover(self, bb, area=None, otherarea=None):
        &#34;&#34;&#34;The maximum cover of self to bb and bb to self&#34;&#34;&#34;
        aoi = self.area_of_intersection(bb, strict=False)
        (area, otherarea) = (self.area() if area is None else area, bb.area() if otherarea is None else otherarea)
        return float(max((aoi/area) if area&gt;0 else 0, (aoi/otherarea) if otherarea&gt;0 else 0))
    
    def shapeiou(self, bb, area=None, otherarea=None):
        &#34;&#34;&#34;Shape IoU is the IoU with the upper left corners aligned. This measures the deformation of the two boxes by removing the effect of translation&#34;&#34;&#34;
        #return self.iou(bb.clone().translate(dx=self._xmin-bb._xmin, dy=self._ymin-bb._ymin))  # equivalent to
        assert isinstance(bb, BoundingBox), &#34;Invalid input - must be BoundingBox()&#34;
        w = min(self._xmax, bb._xmax + (self._xmin-bb._xmin)) - max(self._xmin, bb._xmin + (self._xmin-bb._xmin))
        h = min(self._ymax, bb._ymax + (self._ymin-bb._ymin)) - max(self._ymin, bb._ymin + (self._ymin-bb._ymin))
        area_intersection = w * h
        area_union = ((self.area() if area is None else area) +
                      (bb.area() if otherarea is None else otherarea)
                      - area_intersection)
        return (area_intersection / float(area_union)) if area_union&gt;0 else 0
        
    def intersection(self, bb, strict=True):
        &#34;&#34;&#34;Intersection of two bounding boxes, throw an error on degeneracy of intersection result (if strict=True)&#34;&#34;&#34;
        assert isinstance(bb, BoundingBox), &#34;Invalid BoundingBox() input of type &#39;%s&#39;&#34; % str(type(bb))                        
        self._xmin = max(bb._xmin, self._xmin)
        self._ymin = max(bb._ymin, self._ymin)
        self._xmax = min(bb._xmax, self._xmax)
        self._ymax = min(bb._ymax, self._ymax)
        if strict and self.isdegenerate():
            raise ValueError(&#39;Degenerate intersection for bounding boxes &#34;%s&#34; and &#34;%s&#34;&#39; % (str(bb), str(self)))
        return self

    def hasintersection(self, bb, iou=None, cover=None, maxcover=None, bbcover=None, area=None, otherarea=None, gate=0):
        &#34;&#34;&#34;Return true if self and bb overlap by any amount, or by the cover threshold (if provided) or the iou threshold (if provided).  This is a convenience function that allows for shared computation for fast non-maximum suppression.&#34;&#34;&#34;

        if not (((self._xmax if self._xmax &lt; bb._xmax else bb._xmax) - (self._xmin if self._xmin &gt; bb._xmin else bb._xmin)) &gt; (-gate) and
                ((self._ymax if self._ymax &lt; bb._ymax else bb._ymax) - (self._ymin if self._ymin &gt; bb._ymin else bb._ymin)) &gt; (-gate)):  # faster than min(x,y)-max(x,y)
            return False  # does not intersect
        
        elif maxcover is not None or iou is not None or cover is not None or bbcover is not None:
            aoi = self.area_of_intersection(bb, strict=False)            
            otherarea = otherarea if otherarea is not None else (bb.area() if (maxcover is not None or bbcover is not None or iou is not None) else 0)
            area = area if area is not None else (self.area() if (maxcover is not None or cover is not None or iou is not None) else 0)
            return (((maxcover is not None) and (max(aoi/area, aoi/otherarea) &gt; maxcover)) or
                    ((iou is not None) and ((aoi / (area+otherarea-aoi)) &gt;= iou)) or
                    ((cover is not None) and ((aoi / area) &gt;= cover)) or
                    ((bbcover is not None) and ((aoi / otherarea) &gt;= bbcover)))
        else:
            return True

    def union(self, bb):
        &#34;&#34;&#34;Union of one or more bounding boxes with this box&#34;&#34;&#34;        
        bblist = tolist(bb)        
        assert all([isinstance(bb, BoundingBox) for bb in bblist]), &#34;Invalid BoundingBox() input&#34;
        self._xmin = min([bb._xmin for bb in bblist] + [self._xmin])
        self._ymin = min([bb._ymin for bb in bblist] + [self._ymin])
        self._xmax = max([bb._xmax for bb in bblist] + [self._xmax])
        self._ymax = max([bb._ymax for bb in bblist] + [self._ymax])
        return self

    def isinside(self, bb):
        &#34;&#34;&#34;Is this boundingbox fully within the provided bounding box?&#34;&#34;&#34;
        assert isinstance(bb, BoundingBox)
        return self.hasintersection(bb) and self.cover(bb) == 1.0
        
    def ispointinside(self, p):
        &#34;&#34;&#34;Is the 2D point p=(x,y) inside this boundingbox, or is the p=boundingbox() inside this bounding box?&#34;&#34;&#34;
        assert len(p) == 2, &#34;Invalid 2D point=(x,y) input&#34;
        return (p[0] &gt;= self._xmin) and (p[1] &gt;= self._ymin) and (p[0] &lt;= self._xmax) and (p[1] &lt;= self._ymax)

    def dilate(self, scale=1):
        &#34;&#34;&#34;Change scale of bounding box keeping centroid constant&#34;&#34;&#34;
        assert isnumber(scale), &#34;Invalid input&#34;
        w = (self._xmax - self._xmin)
        h = (self._ymax - self._ymin)
        c = self.centroid()
        old_x = self._xmin
        old_y = self._ymin
        new_x = (float(w) / 2.0) * scale
        new_y = (float(h) / 2.0) * scale
        self._xmin = c[0] - new_x
        self._ymin = c[1] - new_y
        self._xmax = c[0] + new_x
        self._ymax = c[1] + new_y
        return self

    def dilatepx(self, px):
        &#34;&#34;&#34;Dilate by a given pixel amount on all sides, keeping centroid constant&#34;&#34;&#34;
        self._xmin = self._xmin - px
        self._ymin = self._ymin - px
        self._xmax = self._xmax + px
        self._ymax = self._ymax + px
        return self

    def dilate_height(self, scale=1):
        &#34;&#34;&#34;Change scale of bounding box in y direction keeping centroid constant&#34;&#34;&#34;
        h = self.height()
        c = self.centroid()
        self._ymin = c[1] - (float(h) / 2.0) * scale
        self._ymax = c[1] + (float(h) / 2.0) * scale
        return self

    def dilate_width(self, scale=1):
        &#34;&#34;&#34;Change scale of bounding box in x direction keeping centroid constant&#34;&#34;&#34;
        w = self._xmax - self._xmin
        c = self.centroid()
        self._xmin = c[0] - (float(w) / 2.0) * scale
        self._xmax = c[0] + (float(w) / 2.0) * scale
        return self

    def top(self, dy):
        &#34;&#34;&#34;Make top of box taller (closer to top of image) by an offset dy&#34;&#34;&#34;
        self._ymin = self._ymin - dy
        return self

    def bottom(self, dy):
        &#34;&#34;&#34;Make bottom of box taller (closer to bottom of image) by an offset dy&#34;&#34;&#34;
        self._ymax = self._ymax + dy
        return self

    def left(self, dx):
        &#34;&#34;&#34;Make left of box wider (closer to left side of image) by an offset dx&#34;&#34;&#34;
        self._xmin = self._xmin - dx
        return self

    def right(self, dx):
        &#34;&#34;&#34;Make right of box wider (closer to right side of image) by an offset dx&#34;&#34;&#34;
        self._xmax = self._xmax + dx
        return self

    def rescale(self, scale=1):
        &#34;&#34;&#34;Multiply the box corners by a scale factor&#34;&#34;&#34;
        self._xmin = scale * self._xmin
        self._ymin = scale * self._ymin
        self._xmax = scale * self._xmax
        self._ymax = scale * self._ymax
        return self

    def scalex(self, scale=1):
        &#34;&#34;&#34;Multiply the box corners in the x dimension by a scale factor&#34;&#34;&#34;
        self._xmin = scale * self._xmin
        self._xmax = scale * self._xmax
        return self

    def scaley(self, scale=1):
        &#34;&#34;&#34;Multiply the box corners in the y dimension by a scale factor&#34;&#34;&#34;
        self._ymin = scale * self._ymin
        self._ymax = scale * self._ymax
        return self

    def resize(self, width, height):
        &#34;&#34;&#34;Change the aspect ratio width and height of the box&#34;&#34;&#34;
        self.setwidth(width)
        self.setheight(height)
        return self

    def rot90cw(self, H, W):
        &#34;&#34;&#34;Rotate a bounding box such that if an image of size (H,W) is rotated 90 deg clockwise, the boxes align&#34;&#34;&#34;
        (x,y,w,h) = self.xywh()
        (blx, bly) = self.bottomleft()
        return self.xywh((H - bly, blx, h, w))

    def rot90ccw(self, H, W):
        &#34;&#34;&#34;Rotate a bounding box such that if an image of size (H,W) is rotated 90 deg clockwise, the boxes align&#34;&#34;&#34;
        (x,y,w,h) = self.xywh()
        (urx, ury) = self.upperright()
        return self.xywh((ury, W - urx, h, w))

    def fliplr(self, img=None, width=None):
        &#34;&#34;&#34;Flip the box left/right consistent with fliplr of the provided img (or consistent with the image width)&#34;&#34;&#34;
        if img is not None:
            assert isnumpy(img), &#34;Invalid numpy image input&#34;
            width = img.shape[1]
        else:
            assert isnumber(width), &#34;Invalid width&#34;
        (x,y,w,h) = self.xywh()
        self._xmin = width - self._xmax
        self._xmax = self._xmin + w
        return self

    def flipud(self, img=None, height=None):
        &#34;&#34;&#34;Flip the box up/down consistent with flipud of the provided img (or consistent with the image height)&#34;&#34;&#34;
        if img is not None:
            assert isnumpy(img), &#34;Invalid numpy image input&#34;
            height = img.shape[0]
        else:
            assert height is not None and isnumber(height), &#34;Invalid height&#34;
        (x,y,w,h) = self.xywh()
        self._ymin = height - self._ymax
        self._ymax = self._ymin + h
        return self

    def imscale(self, im):
        &#34;&#34;&#34;Given a vipy.image object im, scale the box to be within [0,1], relative to height and width of image&#34;&#34;&#34;
        w = (1.0 / float(im.width()))
        h = (1.0 / float(im.height()))
        self._xmin = w * self._xmin
        self._ymin = h * self._ymin
        self._xmax = w * self._xmax
        self._ymax = h * self._ymax
        return self

    def maxsquare(self):
        &#34;&#34;&#34;Set the bounding box to be square by setting width and height to the maximum dimension of the box, keeping centroid constant&#34;&#34;&#34;
        (height, width) = (self._ymax-self._ymin, self._xmax-self._xmin)                            
        if width != height:
            dim = float(max(width, height))
            c = self.centroid()
            self._xmin = c[0] - (dim / 2.0)
            self._ymin = c[1] - (dim / 2.0)
            self._xmax = c[0] + (dim / 2.0)
            self._ymax = c[1] + (dim / 2.0)
        return self

    def maxsquareif(self, do):
        return self.maxsquare() if do else self

    def issquare(self):
        return np.allclose(self.bbheight(), self.bbwidth())

    def iseven(self):
        &#34;&#34;&#34;Are all corners even number integers?&#34;&#34;&#34;
        return (isinstance(self.xmin(), int) and self.xmin() % 2 == 0 and
                isinstance(self.ymin(), int) and self.ymin() % 2 == 0 and
                isinstance(self.xmax(), int) and self.xmax() % 2 == 0 and
                isinstance(self.ymax(), int) and self.ymax() % 2 == 0)

    def even(self):
        &#34;&#34;&#34;Force all corners to be even number integers.  This is helpful for FFMPEG crop filters.&#34;&#34;&#34;
        self.int()
        self._xmin = (self._xmin // 2) * 2
        self._ymin = (self._ymin // 2) * 2
        self._xmax = (self._xmax // 2) * 2
        self._ymax = (self._ymax // 2) * 2
        return self

    def minsquare(self):
        &#34;&#34;&#34;Set the bounding box to be square by setting width and height to the minimum dimension of the box, keeping centroid constant&#34;&#34;&#34;
        (height, width) = (self._ymax-self._ymin, self._xmax-self._xmin)                            
        if width != height:
            dim = float(min(width, height))
            c = self.centroid()
            self._xmin = c[0] - (dim / 2.0)
            self._ymin = c[1] - (dim / 2.0)
            self._xmax = c[0] + (dim / 2.0)
            self._ymax = c[1] + (dim / 2.0)
        return self

    def hasoverlap(self, img=None, width=None, height=None):
        &#34;&#34;&#34;Does the bounding box intersect with the provided image rectangle?&#34;&#34;&#34;
        if img is not None:
            assert isnumpy(img), &#34;Invalid image input&#34;
            (width, height) = (img.shape[1], img.shape[0])
        else:
            assert width is not None and height is not None, &#34;Invalid width and height - both must be provided&#34;
            assert isnumber(width) and isnumber(height), &#34;Invalid width and height - both must be numbers&#34;
        return self.area_of_intersection(BoundingBox(xmin=0, ymin=0, width=width, height=height)) &gt; 0

    def isinterior(self, width=None, height=None, border=1.0):
        &#34;&#34;&#34;Is this boundingbox fully within the provided image rectangle?  
        
           * If border in [0,1], then the image is dilated by a border percentage prior to computing interior, useful to check if self is near the image edge
           * If border=0.8, then the image rectangle is dilated by 80% (smaller) keeping the centroid constant. 
        &#34;&#34;&#34;
        assert border &gt; 0 and border &lt;= 1, &#34;Border must be a dilation fraction of the image, such that the image centroid is constant and the sides are dilated by a scale [0,1]&#34;
        return self.isinside(imagebox((height, width)).dilate(border))

    def iminterior(self, W, H):
        &#34;&#34;&#34;Transform bounding box to be interior to the image rectangle with shape (W,H).  
           Transform is applyed by computing smallest (dx,dy) translation that it is interior to the image rectangle, then clip to the image rectangle if it is too big to fit
        &#34;&#34;&#34;        
        assert self.intersection(BoundingBox(xmin=0, ymin=0, width=W, height=H)).area() &gt; 0, &#34;Bounding box must intersect image rectangle&#34;
        self.translate(dx=0 if self.xmin()&gt;0 else -self.xmin(),
                       dy=0 if self.ymin()&gt;0 else -self.ymin())
        self.translate(dx=0 if self.xmax()&lt;W else -(W-self.xmax()),
                       dy=0 if self.ymax()&lt;H else -(H-self.ymax()))
        return self.imclip(width=W, height=H)
        
    def imclip(self, img=None, width=None, height=None):
        &#34;&#34;&#34;Clip bounding box to image rectangle [0,0,width,height] or img.shape=(width, height) and, throw an exception on an invalid box&#34;&#34;&#34;
        if img is not None:
            assert isnumpy(img), &#34;Invalid numpy image input&#34;
            (height, width) = (img.shape[0], img.shape[1])
        else:
            assert width is not None and height is not None, &#34;Invalid width and height - both must be provided&#34;
            assert isnumber(width) and isnumber(height), &#34;Invalid width and height - both must be numbers&#34;
        return self.intersection(BoundingBox(xmin=0, ymin=0, width=width, height=height), strict=True)

    def imclipshape(self, W, H):
        &#34;&#34;&#34;Clip bounding box to image rectangle [0,0,W-1,H-1], throw an exception on an invalid box&#34;&#34;&#34;
        return self.imclip(width=W, height=H)

    def convexhull(self, fr):
        &#34;&#34;&#34;Given a set of points [[x1,y1],[x2,xy],...], return the bounding rectangle, typecast to float&#34;&#34;&#34;
        self._xmin = float(np.min(fr[:,0]))
        self._ymin = float(np.min(fr[:,1]))
        self._xmax = float(np.max(fr[:,0]))
        self._ymax = float(np.max(fr[:,1]))
        return self

    def aspectratio(self):
        &#34;&#34;&#34;Return the aspect ratio (width/height) of the box&#34;&#34;&#34;
        (height, width) = (self._ymax-self._ymin, self._xmax-self._xmin)                            
        assert height &gt; 0
        return float(width) / float(height)

    def shape(self):
        &#34;&#34;&#34;Return the (height, width) tuple for the box shape&#34;&#34;&#34;
        return (self._ymax-self._ymin, self._xmax-self._xmin)                            

    def mindimension(self):
        &#34;&#34;&#34;Return min(width, height) typecast to float&#34;&#34;&#34;
        return float(np.min(self.shape()))

    def mindim(self):
        &#34;&#34;&#34;Return min(width, height) typecast to float&#34;&#34;&#34;
        return float(np.min(self.shape()))

    def maxdim(self):
        &#34;&#34;&#34;Return max(width, height) typecast to float&#34;&#34;&#34;
        return float(np.max(self.shape())) 
    
    def ellipse(self):
        &#34;&#34;&#34;Convert the boundingbox to a vipy.geometry.Ellipse object&#34;&#34;&#34;
        (xcenter,ycenter) = self.centroid()
        return Ellipse(self.bbwidth() / 2.0, self.bbheight() / 2.0, xcenter, ycenter, 0)

    def average(self, other):
        &#34;&#34;&#34;Compute the average bounding box between self and other, and set self to the average.  Other may be a singleton bounding box or a list of bounding boxes&#34;&#34;&#34;
        assert all([isinstance(bb, BoundingBox) for bb in tolist(other)]), &#34;Invalid input - must be BoundingBox&#34;        
        return self.ulbr(np.mean( [self.ulbr()] + [bb.ulbr() for bb in tolist(other)], axis=0))

    def averageshape(self, other):
        &#34;&#34;&#34;Compute the average bounding box width and height between self and other.  Other may be a singleton bounding box or a list of bounding boxes&#34;&#34;&#34;
        assert all([isinstance(bb, BoundingBox) for bb in tolist(other)]), &#34;Invalid input - must be BoundingBox&#34;        
        (xmin, ymin, xmax, ymax) = np.mean( [self.ulbr()] + [bb.ulbr() for bb in tolist(other)], axis=0)
        self.setwidth(xmax-xmin)
        self.setheight(ymax-ymin)        
        return self

    def medianshape(self, other):
        &#34;&#34;&#34;Compute the median bounding box width and height between self and other.  Other may be a singleton bounding box or a list of bounding boxes&#34;&#34;&#34;
        assert all([isinstance(bb, BoundingBox) for bb in tolist(other)]), &#34;Invalid input - must be BoundingBox&#34;        
        (height, width) = np.median( [self.shape()] + [bb.shape() for bb in tolist(other)], axis=0)
        self.setwidth(width)
        self.setheight(height)
        return self

    def shapedist(self, other):
        &#34;&#34;&#34;L1 distance between (width,height) of two boxes&#34;&#34;&#34;
        assert isinstance(other, BoundingBox), &#34;Invalid input - must be BoundingBox()&#34;                
        return np.abs(self.bbwidth()-other.bbwidth())  + np.abs(self.bbheight()-other.bbheight())

    def affine(self, A):
        &#34;&#34;&#34;Apply an 2x3 affine transformation to the box centroid.  This operation preserves an axis aligned bounding box for an arbitrary affine transform.&#34;&#34;&#34;
        assert isnumpy(A) and A.shape == (2,3), &#34;A must be a 2x3 affine transformation matrix&#34;
        return self.centroid(np.dot(A, homogenize(np.array(self.centroid()))))

    def projective(self, A):
        &#34;&#34;&#34;Apply an 3x3 affine transformation to the box centroid.  This operation preserves an axis aligned bounding box for an arbitrary affine transform.&#34;&#34;&#34;
        assert isnumpy(A) and A.shape == (3,3), &#34;A must be a 3x3 affine transformation matrix&#34;
        return self.centroid(dehomogenize(np.dot(A, homogenize(np.array(self.centroid())))))
    
    def crop(self, img):
        &#34;&#34;&#34;Crop an HxW 2D numpy image, HxWxC 3D numpy image, or NxHxWxC 4D numpy image array using this bounding box applied to HxW dimensions.  Crop is performed in-place. &#34;&#34;&#34;
        assert isnumpy(img) and img.ndim in [2,3,4]
        assert self.isinteger(), &#34;Box corners must be integer - try calling self.int()&#34;

        if img.ndim == 2:
            return img[self.ymin():self.ymax(), self.xmin():self.xmax()]  # HxW
        elif img.ndim == 3:
            return img[self.ymin():self.ymax(), self.xmin():self.xmax(), :]  # HxWxC
        else: 
            return img[:, self.ymin():self.ymax(), self.xmin():self.xmax(), :]  # NxHxWxC

    def confidence(self):
        &#34;&#34;&#34;Bounding boxes do not have confidences, use vipy.object.Detection()&#34;&#34;&#34;
        return None

    def grid(self, rows, cols):
        &#34;&#34;&#34;Split a bounding box into the smallest grid of non-overlapping bounding boxes such that the union is the original box&#34;&#34;&#34;
        (w,h) = (self.width()/cols, self.height()/rows)
        return [BoundingBox(xmin=x, ymin=y, width=w, height=h) for x in np.arange(self._xmin, self._xmax, w) for y in np.arange(self._ymin, self._ymax, h)]</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="vipy.image.ImageDetection" href="image.html#vipy.image.ImageDetection">ImageDetection</a></li>
<li><a title="vipy.object.Detection" href="object.html#vipy.object.Detection">Detection</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="vipy.geometry.BoundingBox.cast"><code class="name flex">
<span>def <span class="ident">cast</span></span>(<span>bb, flush=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L179-L185" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@classmethod
def cast(cls, bb, flush=False):
    assert isinstance(bb, BoundingBox)
    bb.__class__ = BoundingBox
    if flush:
        bb.__dict__ = {k:v for (k,v) in bb.__dict__.items() if k in [&#39;_xmin&#39;, &#39;_ymin&#39;, &#39;_xmax&#39;, &#39;_ymax&#39;]}        
    return bb</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>s)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L187-L190" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@classmethod
def from_json(cls, s):
    d = json.loads(s) if not isinstance(s, dict) else s
    return cls(ulbrdict=d)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="vipy.geometry.BoundingBox.affine"><code class="name flex">
<span>def <span class="ident">affine</span></span>(<span>self, A)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply an 2x3 affine transformation to the box centroid.
This operation preserves an axis aligned bounding box for an arbitrary affine transform.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L908-L911" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def affine(self, A):
    &#34;&#34;&#34;Apply an 2x3 affine transformation to the box centroid.  This operation preserves an axis aligned bounding box for an arbitrary affine transform.&#34;&#34;&#34;
    assert isnumpy(A) and A.shape == (2,3), &#34;A must be a 2x3 affine transformation matrix&#34;
    return self.centroid(np.dot(A, homogenize(np.array(self.centroid()))))</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.area"><code class="name flex">
<span>def <span class="ident">area</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the area=width*height of the bounding box</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L446-L449" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def area(self):
    &#34;&#34;&#34;Return the area=width*height of the bounding box&#34;&#34;&#34;
    (height, width) = (self._ymax-self._ymin, self._xmax-self._xmin)        
    return width * height if (height&gt;0 and width&gt;0) else 0</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.area_of_intersection"><code class="name flex">
<span>def <span class="ident">area_of_intersection</span></span>(<span>self, bb, strict=True)</span>
</code></dt>
<dd>
<div class="desc"><p>area of intersection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L538-L548" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def area_of_intersection(self, bb, strict=True):
    &#34;&#34;&#34;area of intersection&#34;&#34;&#34;
    if strict:
        assert isinstance(bb, BoundingBox), &#34;Invalid BoundingBox() input of type &#39;%s&#39;&#34; % str(type(bb))                
    w = min(self._xmax, bb._xmax) - max(self._xmin, bb._xmin)
    if w &lt;= 0:
        return 0  # invalid (no overlap), early exit 
    h = min(self._ymax, bb._ymax) - max(self._ymin, bb._ymin)
    if h &lt;= 0:
        return 0  # invalid (no overlap), early exit 
    return w*h</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.area_of_union"><code class="name flex">
<span>def <span class="ident">area_of_union</span></span>(<span>self, bb)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L550-L551" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def area_of_union(self, bb):
    return self.area() + bb.area() - self.area_of_intersection(bb)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.aspectratio"><code class="name flex">
<span>def <span class="ident">aspectratio</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the aspect ratio (width/height) of the box</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L855-L859" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def aspectratio(self):
    &#34;&#34;&#34;Return the aspect ratio (width/height) of the box&#34;&#34;&#34;
    (height, width) = (self._ymax-self._ymin, self._xmax-self._xmin)                            
    assert height &gt; 0
    return float(width) / float(height)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.average"><code class="name flex">
<span>def <span class="ident">average</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the average bounding box between self and other, and set self to the average.
Other may be a singleton bounding box or a list of bounding boxes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L882-L885" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def average(self, other):
    &#34;&#34;&#34;Compute the average bounding box between self and other, and set self to the average.  Other may be a singleton bounding box or a list of bounding boxes&#34;&#34;&#34;
    assert all([isinstance(bb, BoundingBox) for bb in tolist(other)]), &#34;Invalid input - must be BoundingBox&#34;        
    return self.ulbr(np.mean( [self.ulbr()] + [bb.ulbr() for bb in tolist(other)], axis=0))</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.averageshape"><code class="name flex">
<span>def <span class="ident">averageshape</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the average bounding box width and height between self and other.
Other may be a singleton bounding box or a list of bounding boxes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L887-L893" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def averageshape(self, other):
    &#34;&#34;&#34;Compute the average bounding box width and height between self and other.  Other may be a singleton bounding box or a list of bounding boxes&#34;&#34;&#34;
    assert all([isinstance(bb, BoundingBox) for bb in tolist(other)]), &#34;Invalid input - must be BoundingBox&#34;        
    (xmin, ymin, xmax, ymax) = np.mean( [self.ulbr()] + [bb.ulbr() for bb in tolist(other)], axis=0)
    self.setwidth(xmax-xmin)
    self.setheight(ymax-ymin)        
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.bbclone"><code class="name flex">
<span>def <span class="ident">bbclone</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L201-L202" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def bbclone(self):
    return BoundingBox(xmin=self._xmin, xmax=self._xmax, ymin=self._ymin, ymax=self._ymax)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.bbheight"><code class="name flex">
<span>def <span class="ident">bbheight</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L409-L410" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def bbheight(self):
    return self._ymax - self._ymin</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.bbwidth"><code class="name flex">
<span>def <span class="ident">bbwidth</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L386-L387" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def bbwidth(self):
    return self._xmax - self._xmin</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.bl"><code class="name flex">
<span>def <span class="ident">bl</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Bottom left coordinate (x,y), synonym for ll()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L250-L252" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def bl(self):
    &#34;&#34;&#34;Bottom left coordinate (x,y), synonym for ll()&#34;&#34;&#34;
    return (self._xmin, self._ymax)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.blx"><code class="name flex">
<span>def <span class="ident">blx</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Bottom left coordinate (x)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L254-L256" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def blx(self):
    &#34;&#34;&#34;Bottom left coordinate (x)&#34;&#34;&#34;
    return self.bl()[0]</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.bly"><code class="name flex">
<span>def <span class="ident">bly</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Bottom left coordinate (y)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L258-L260" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def bly(self):
    &#34;&#34;&#34;Bottom left coordinate (y)&#34;&#34;&#34;
    return self.bl()[1]</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.bottom"><code class="name flex">
<span>def <span class="ident">bottom</span></span>(<span>self, dy)</span>
</code></dt>
<dd>
<div class="desc"><p>Make bottom of box taller (closer to bottom of image) by an offset dy</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L670-L673" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def bottom(self, dy):
    &#34;&#34;&#34;Make bottom of box taller (closer to bottom of image) by an offset dy&#34;&#34;&#34;
    self._ymax = self._ymax + dy
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.bottomleft"><code class="name flex">
<span>def <span class="ident">bottomleft</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the (x,y) lower left corner coordinate of the box</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L295-L297" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def bottomleft(self):
    &#34;&#34;&#34;Return the (x,y) lower left corner coordinate of the box&#34;&#34;&#34;
    return (self.xmin(), self.ymax())</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.bottomright"><code class="name flex">
<span>def <span class="ident">bottomright</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the (x,y) lower right corner coordinate of the box</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L303-L305" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def bottomright(self):
    &#34;&#34;&#34;Return the (x,y) lower right corner coordinate of the box&#34;&#34;&#34;
    return (self.xmax(), self.ymax())</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.br"><code class="name flex">
<span>def <span class="ident">br</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Bottom right coordinate (x,y), synonym for lr()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L266-L268" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def br(self):
    &#34;&#34;&#34;Bottom right coordinate (x,y), synonym for lr()&#34;&#34;&#34;
    return (self._xmax, self._ymax)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.brx"><code class="name flex">
<span>def <span class="ident">brx</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Bottom right coordinate (x)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L270-L272" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def brx(self):
    &#34;&#34;&#34;Bottom right coordinate (x)&#34;&#34;&#34;
    return self.br()[0]</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.bry"><code class="name flex">
<span>def <span class="ident">bry</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Bottom right coordinate (y)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L274-L276" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def bry(self):
    &#34;&#34;&#34;Bottom right coordinate (y)&#34;&#34;&#34;
    return self.br()[1]</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.centroid"><code class="name flex">
<span>def <span class="ident">centroid</span></span>(<span>self, c=None)</span>
</code></dt>
<dd>
<div class="desc"><p>(x,y) tuple of centroid position of bounding box</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L412-L424" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def centroid(self, c=None):
    &#34;&#34;&#34;(x,y) tuple of centroid position of bounding box&#34;&#34;&#34;
    if c is None:
        (height, width) = (self._ymax-self._ymin, self._xmax-self._xmin)            
        return (self._xmin + (float(width) / 2.0), self._ymin + (float(height) / 2.0))
    else:
        assert len(c) == 2
        (height, width) = (self._ymax-self._ymin, self._xmax-self._xmin)
        self._xmin = float(c[0]) - (width / 2.0)
        self._ymin = float(c[1]) - (height / 2.0)
        self._xmax = float(c[0]) + (width / 2.0)
        self._ymax = float(c[1]) + (height / 2.0)
        return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.centroid_x"><code class="name flex">
<span>def <span class="ident">centroid_x</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for x_centroid()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L432-L434" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def centroid_x(self):
    &#34;&#34;&#34;Alias for x_centroid()&#34;&#34;&#34;
    return self.centroid()[0]</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.centroid_y"><code class="name flex">
<span>def <span class="ident">centroid_y</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for y_centroid()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L442-L444" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def centroid_y(self):
    &#34;&#34;&#34;Alias for y_centroid()&#34;&#34;&#34;
    return self.centroid()[1]</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.clone"><code class="name flex">
<span>def <span class="ident">clone</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L199-L200" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def clone(self):
    return BoundingBox(xmin=self._xmin, xmax=self._xmax, ymin=self._ymin, ymax=self._ymax)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.confidence"><code class="name flex">
<span>def <span class="ident">confidence</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Bounding boxes do not have confidences, use vipy.object.Detection()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L930-L932" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def confidence(self):
    &#34;&#34;&#34;Bounding boxes do not have confidences, use vipy.object.Detection()&#34;&#34;&#34;
    return None</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.convexhull"><code class="name flex">
<span>def <span class="ident">convexhull</span></span>(<span>self, fr)</span>
</code></dt>
<dd>
<div class="desc"><p>Given a set of points [[x1,y1],[x2,xy],&hellip;], return the bounding rectangle, typecast to float</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L847-L853" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def convexhull(self, fr):
    &#34;&#34;&#34;Given a set of points [[x1,y1],[x2,xy],...], return the bounding rectangle, typecast to float&#34;&#34;&#34;
    self._xmin = float(np.min(fr[:,0]))
    self._ymin = float(np.min(fr[:,1]))
    self._xmax = float(np.max(fr[:,0]))
    self._ymax = float(np.max(fr[:,1]))
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.cover"><code class="name flex">
<span>def <span class="ident">cover</span></span>(<span>self, bb)</span>
</code></dt>
<dd>
<div class="desc"><p>Fraction of this bounding box intersected by other bbox (bb)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L553-L556" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def cover(self, bb):
    &#34;&#34;&#34;Fraction of this bounding box intersected by other bbox (bb)&#34;&#34;&#34;
    a = float(self.area())
    return (self.area_of_intersection(bb) / a) if a&gt;0 else 0</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.crop"><code class="name flex">
<span>def <span class="ident">crop</span></span>(<span>self, img)</span>
</code></dt>
<dd>
<div class="desc"><p>Crop an HxW 2D numpy image, HxWxC 3D numpy image, or NxHxWxC 4D numpy image array using this bounding box applied to HxW dimensions.
Crop is performed in-place.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L918-L928" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def crop(self, img):
    &#34;&#34;&#34;Crop an HxW 2D numpy image, HxWxC 3D numpy image, or NxHxWxC 4D numpy image array using this bounding box applied to HxW dimensions.  Crop is performed in-place. &#34;&#34;&#34;
    assert isnumpy(img) and img.ndim in [2,3,4]
    assert self.isinteger(), &#34;Box corners must be integer - try calling self.int()&#34;

    if img.ndim == 2:
        return img[self.ymin():self.ymax(), self.xmin():self.xmax()]  # HxW
    elif img.ndim == 3:
        return img[self.ymin():self.ymax(), self.xmin():self.xmax(), :]  # HxWxC
    else: 
        return img[:, self.ymin():self.ymax(), self.xmin():self.xmax(), :]  # NxHxWxC</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.cxywh"><code class="name flex">
<span>def <span class="ident">cxywh</span></span>(<span>self, cxywh=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return or set bounding box corners as (centroidx,centroidy,width,height) tuple</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L468-L475" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def cxywh(self, cxywh=None):
    &#34;&#34;&#34;Return or set bounding box corners as (centroidx,centroidy,width,height) tuple&#34;&#34;&#34;
    if cxywh is None:
        (height, width) = (self._ymax-self._ymin, self._xmax-self._xmin)                    
        return tuple([self.x_centroid(), self.y_centroid(), width, height])
    else:
        assert len(cxywh) == 4, &#34;Invalid (xcentroid, ycentroid, width, height) input&#34;
        return self.centroid( (cxywh[0], cxywh[1]) ).setwidth(cxywh[2]).setheight(cxywh[3])            </code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.dict"><code class="name flex">
<span>def <span class="ident">dict</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a python dictionary containing the relevant serialized attributes suitable for JSON encoding</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L192-L194" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dict(self):
    &#34;&#34;&#34;Return a python dictionary containing the relevant serialized attributes suitable for JSON encoding&#34;&#34;&#34;
    return self.json(encode=False)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.dilate"><code class="name flex">
<span>def <span class="ident">dilate</span></span>(<span>self, scale=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Change scale of bounding box keeping centroid constant</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L625-L639" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dilate(self, scale=1):
    &#34;&#34;&#34;Change scale of bounding box keeping centroid constant&#34;&#34;&#34;
    assert isnumber(scale), &#34;Invalid input&#34;
    w = (self._xmax - self._xmin)
    h = (self._ymax - self._ymin)
    c = self.centroid()
    old_x = self._xmin
    old_y = self._ymin
    new_x = (float(w) / 2.0) * scale
    new_y = (float(h) / 2.0) * scale
    self._xmin = c[0] - new_x
    self._ymin = c[1] - new_y
    self._xmax = c[0] + new_x
    self._ymax = c[1] + new_y
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.dilate_height"><code class="name flex">
<span>def <span class="ident">dilate_height</span></span>(<span>self, scale=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Change scale of bounding box in y direction keeping centroid constant</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L649-L655" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dilate_height(self, scale=1):
    &#34;&#34;&#34;Change scale of bounding box in y direction keeping centroid constant&#34;&#34;&#34;
    h = self.height()
    c = self.centroid()
    self._ymin = c[1] - (float(h) / 2.0) * scale
    self._ymax = c[1] + (float(h) / 2.0) * scale
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.dilate_width"><code class="name flex">
<span>def <span class="ident">dilate_width</span></span>(<span>self, scale=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Change scale of bounding box in x direction keeping centroid constant</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L657-L663" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dilate_width(self, scale=1):
    &#34;&#34;&#34;Change scale of bounding box in x direction keeping centroid constant&#34;&#34;&#34;
    w = self._xmax - self._xmin
    c = self.centroid()
    self._xmin = c[0] - (float(w) / 2.0) * scale
    self._xmax = c[0] + (float(w) / 2.0) * scale
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.dilatepx"><code class="name flex">
<span>def <span class="ident">dilatepx</span></span>(<span>self, px)</span>
</code></dt>
<dd>
<div class="desc"><p>Dilate by a given pixel amount on all sides, keeping centroid constant</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L641-L647" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dilatepx(self, px):
    &#34;&#34;&#34;Dilate by a given pixel amount on all sides, keeping centroid constant&#34;&#34;&#34;
    self._xmin = self._xmin - px
    self._ymin = self._ymin - px
    self._xmax = self._xmax + px
    self._ymax = self._ymax + px
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.dist"><code class="name flex">
<span>def <span class="ident">dist</span></span>(<span>self, bb)</span>
</code></dt>
<dd>
<div class="desc"><p>Distance between centroids of two bounding boxes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L506-L509" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dist(self, bb):
    &#34;&#34;&#34;Distance between centroids of two bounding boxes&#34;&#34;&#34;
    assert isinstance(bb, BoundingBox), &#34;Invalid BoundingBox() input of type &#39;%s&#39;&#34; % str(type(bb))                
    return np.sqrt(np.sum(np.square(np.array(bb.centroid()) - np.array(self.centroid()))))</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.dx"><code class="name flex">
<span>def <span class="ident">dx</span></span>(<span>self, bb)</span>
</code></dt>
<dd>
<div class="desc"><p>Offset bounding box by same xmin as provided box</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L493-L495" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dx(self, bb):
    &#34;&#34;&#34;Offset bounding box by same xmin as provided box&#34;&#34;&#34;
    return bb._xmin - self._xmin</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.dy"><code class="name flex">
<span>def <span class="ident">dy</span></span>(<span>self, bb)</span>
</code></dt>
<dd>
<div class="desc"><p>Offset bounding box by ymin of provided box</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L497-L499" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dy(self, bb):
    &#34;&#34;&#34;Offset bounding box by ymin of provided box&#34;&#34;&#34;
    return bb._ymin - self._ymin</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.ellipse"><code class="name flex">
<span>def <span class="ident">ellipse</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert the boundingbox to a vipy.geometry.Ellipse object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L877-L880" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def ellipse(self):
    &#34;&#34;&#34;Convert the boundingbox to a vipy.geometry.Ellipse object&#34;&#34;&#34;
    (xcenter,ycenter) = self.centroid()
    return Ellipse(self.bbwidth() / 2.0, self.bbheight() / 2.0, xcenter, ycenter, 0)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.even"><code class="name flex">
<span>def <span class="ident">even</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Force all corners to be even number integers.
This is helpful for FFMPEG crop filters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L782-L789" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def even(self):
    &#34;&#34;&#34;Force all corners to be even number integers.  This is helpful for FFMPEG crop filters.&#34;&#34;&#34;
    self.int()
    self._xmin = (self._xmin // 2) * 2
    self._ymin = (self._ymin // 2) * 2
    self._xmax = (self._xmax // 2) * 2
    self._ymax = (self._ymax // 2) * 2
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.fliplr"><code class="name flex">
<span>def <span class="ident">fliplr</span></span>(<span>self, img=None, width=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Flip the box left/right consistent with fliplr of the provided img (or consistent with the image width)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L723-L733" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def fliplr(self, img=None, width=None):
    &#34;&#34;&#34;Flip the box left/right consistent with fliplr of the provided img (or consistent with the image width)&#34;&#34;&#34;
    if img is not None:
        assert isnumpy(img), &#34;Invalid numpy image input&#34;
        width = img.shape[1]
    else:
        assert isnumber(width), &#34;Invalid width&#34;
    (x,y,w,h) = self.xywh()
    self._xmin = width - self._xmax
    self._xmax = self._xmin + w
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.flipud"><code class="name flex">
<span>def <span class="ident">flipud</span></span>(<span>self, img=None, height=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Flip the box up/down consistent with flipud of the provided img (or consistent with the image height)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L735-L745" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def flipud(self, img=None, height=None):
    &#34;&#34;&#34;Flip the box up/down consistent with flipud of the provided img (or consistent with the image height)&#34;&#34;&#34;
    if img is not None:
        assert isnumpy(img), &#34;Invalid numpy image input&#34;
        height = img.shape[0]
    else:
        assert height is not None and isnumber(height), &#34;Invalid height&#34;
    (x,y,w,h) = self.xywh()
    self._ymin = height - self._ymax
    self._ymax = self._ymin + h
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.float"><code class="name flex">
<span>def <span class="ident">float</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert corners to float</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L326-L332" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def float(self):
    &#34;&#34;&#34;Convert corners to float&#34;&#34;&#34;
    self._xmin = float(self._xmin)
    self._ymin = float(self._ymin)
    self._xmax = float(self._xmax)
    self._ymax = float(self._ymax)
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.grid"><code class="name flex">
<span>def <span class="ident">grid</span></span>(<span>self, rows, cols)</span>
</code></dt>
<dd>
<div class="desc"><p>Split a bounding box into the smallest grid of non-overlapping bounding boxes such that the union is the original box</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L934-L937" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def grid(self, rows, cols):
    &#34;&#34;&#34;Split a bounding box into the smallest grid of non-overlapping bounding boxes such that the union is the original box&#34;&#34;&#34;
    (w,h) = (self.width()/cols, self.height()/rows)
    return [BoundingBox(xmin=x, ymin=y, width=w, height=h) for x in np.arange(self._xmin, self._xmax, w) for y in np.arange(self._ymin, self._ymax, h)]</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.hasintersection"><code class="name flex">
<span>def <span class="ident">hasintersection</span></span>(<span>self, bb, iou=None, cover=None, maxcover=None, bbcover=None, area=None, otherarea=None, gate=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Return true if self and bb overlap by any amount, or by the cover threshold (if provided) or the iou threshold (if provided).
This is a convenience function that allows for shared computation for fast non-maximum suppression.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L587-L603" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def hasintersection(self, bb, iou=None, cover=None, maxcover=None, bbcover=None, area=None, otherarea=None, gate=0):
    &#34;&#34;&#34;Return true if self and bb overlap by any amount, or by the cover threshold (if provided) or the iou threshold (if provided).  This is a convenience function that allows for shared computation for fast non-maximum suppression.&#34;&#34;&#34;

    if not (((self._xmax if self._xmax &lt; bb._xmax else bb._xmax) - (self._xmin if self._xmin &gt; bb._xmin else bb._xmin)) &gt; (-gate) and
            ((self._ymax if self._ymax &lt; bb._ymax else bb._ymax) - (self._ymin if self._ymin &gt; bb._ymin else bb._ymin)) &gt; (-gate)):  # faster than min(x,y)-max(x,y)
        return False  # does not intersect
    
    elif maxcover is not None or iou is not None or cover is not None or bbcover is not None:
        aoi = self.area_of_intersection(bb, strict=False)            
        otherarea = otherarea if otherarea is not None else (bb.area() if (maxcover is not None or bbcover is not None or iou is not None) else 0)
        area = area if area is not None else (self.area() if (maxcover is not None or cover is not None or iou is not None) else 0)
        return (((maxcover is not None) and (max(aoi/area, aoi/otherarea) &gt; maxcover)) or
                ((iou is not None) and ((aoi / (area+otherarea-aoi)) &gt;= iou)) or
                ((cover is not None) and ((aoi / area) &gt;= cover)) or
                ((bbcover is not None) and ((aoi / otherarea) &gt;= bbcover)))
    else:
        return True</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.hasoverlap"><code class="name flex">
<span>def <span class="ident">hasoverlap</span></span>(<span>self, img=None, width=None, height=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Does the bounding box intersect with the provided image rectangle?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L803-L811" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def hasoverlap(self, img=None, width=None, height=None):
    &#34;&#34;&#34;Does the bounding box intersect with the provided image rectangle?&#34;&#34;&#34;
    if img is not None:
        assert isnumpy(img), &#34;Invalid image input&#34;
        (width, height) = (img.shape[1], img.shape[0])
    else:
        assert width is not None and height is not None, &#34;Invalid width and height - both must be provided&#34;
        assert isnumber(width) and isnumber(height), &#34;Invalid width and height - both must be numbers&#34;
    return self.area_of_intersection(BoundingBox(xmin=0, ymin=0, width=width, height=height)) &gt; 0</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.height"><code class="name flex">
<span>def <span class="ident">height</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L407-L408" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def height(self):
    return self._ymax - self._ymin</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.imclip"><code class="name flex">
<span>def <span class="ident">imclip</span></span>(<span>self, img=None, width=None, height=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Clip bounding box to image rectangle [0,0,width,height] or img.shape=(width, height) and, throw an exception on an invalid box</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L833-L841" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def imclip(self, img=None, width=None, height=None):
    &#34;&#34;&#34;Clip bounding box to image rectangle [0,0,width,height] or img.shape=(width, height) and, throw an exception on an invalid box&#34;&#34;&#34;
    if img is not None:
        assert isnumpy(img), &#34;Invalid numpy image input&#34;
        (height, width) = (img.shape[0], img.shape[1])
    else:
        assert width is not None and height is not None, &#34;Invalid width and height - both must be provided&#34;
        assert isnumber(width) and isnumber(height), &#34;Invalid width and height - both must be numbers&#34;
    return self.intersection(BoundingBox(xmin=0, ymin=0, width=width, height=height), strict=True)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.imclipshape"><code class="name flex">
<span>def <span class="ident">imclipshape</span></span>(<span>self, W, H)</span>
</code></dt>
<dd>
<div class="desc"><p>Clip bounding box to image rectangle [0,0,W-1,H-1], throw an exception on an invalid box</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L843-L845" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def imclipshape(self, W, H):
    &#34;&#34;&#34;Clip bounding box to image rectangle [0,0,W-1,H-1], throw an exception on an invalid box&#34;&#34;&#34;
    return self.imclip(width=W, height=H)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.iminterior"><code class="name flex">
<span>def <span class="ident">iminterior</span></span>(<span>self, W, H)</span>
</code></dt>
<dd>
<div class="desc"><p>Transform bounding box to be interior to the image rectangle with shape (W,H).<br>
Transform is applyed by computing smallest (dx,dy) translation that it is interior to the image rectangle, then clip to the image rectangle if it is too big to fit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L822-L831" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def iminterior(self, W, H):
    &#34;&#34;&#34;Transform bounding box to be interior to the image rectangle with shape (W,H).  
       Transform is applyed by computing smallest (dx,dy) translation that it is interior to the image rectangle, then clip to the image rectangle if it is too big to fit
    &#34;&#34;&#34;        
    assert self.intersection(BoundingBox(xmin=0, ymin=0, width=W, height=H)).area() &gt; 0, &#34;Bounding box must intersect image rectangle&#34;
    self.translate(dx=0 if self.xmin()&gt;0 else -self.xmin(),
                   dy=0 if self.ymin()&gt;0 else -self.ymin())
    self.translate(dx=0 if self.xmax()&lt;W else -(W-self.xmax()),
                   dy=0 if self.ymax()&lt;H else -(H-self.ymax()))
    return self.imclip(width=W, height=H)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.imscale"><code class="name flex">
<span>def <span class="ident">imscale</span></span>(<span>self, im)</span>
</code></dt>
<dd>
<div class="desc"><p>Given a vipy.image object im, scale the box to be within [0,1], relative to height and width of image</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L747-L755" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def imscale(self, im):
    &#34;&#34;&#34;Given a vipy.image object im, scale the box to be within [0,1], relative to height and width of image&#34;&#34;&#34;
    w = (1.0 / float(im.width()))
    h = (1.0 / float(im.height()))
    self._xmin = w * self._xmin
    self._ymin = h * self._ymin
    self._xmax = w * self._xmax
    self._ymax = h * self._ymax
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.int"><code class="name flex">
<span>def <span class="ident">int</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert corners to integer with rounding, in-place update</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L313-L324" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def int(self):
    &#34;&#34;&#34;Convert corners to integer with rounding, in-place update&#34;&#34;&#34;
    (w,h) = (int(np.round(self.bbwidth())), int(np.round(self.bbheight())))
    self._xmin = int(np.round(self._xmin))
    self._ymin = int(np.round(self._ymin))
    self._xmax = int(np.round(self._xmax))
    self._ymax = int(np.round(self._ymax))
    if w != self.bbwidth():
        self.right(w - self.bbwidth())  # preserve aspect ratio due to rounding by +/- right side of box 
    if h != self.bbheight():
        self.bottom(h-self.bbheight())  # preserve aspect ratio due to rounding by +/- bottom of box
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.intersection"><code class="name flex">
<span>def <span class="ident">intersection</span></span>(<span>self, bb, strict=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Intersection of two bounding boxes, throw an error on degeneracy of intersection result (if strict=True)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L576-L585" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def intersection(self, bb, strict=True):
    &#34;&#34;&#34;Intersection of two bounding boxes, throw an error on degeneracy of intersection result (if strict=True)&#34;&#34;&#34;
    assert isinstance(bb, BoundingBox), &#34;Invalid BoundingBox() input of type &#39;%s&#39;&#34; % str(type(bb))                        
    self._xmin = max(bb._xmin, self._xmin)
    self._ymin = max(bb._ymin, self._ymin)
    self._xmax = min(bb._xmax, self._xmax)
    self._ymax = min(bb._ymax, self._ymax)
    if strict and self.isdegenerate():
        raise ValueError(&#39;Degenerate intersection for bounding boxes &#34;%s&#34; and &#34;%s&#34;&#39; % (str(bb), str(self)))
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.intersection_over_union"><code class="name flex">
<span>def <span class="ident">intersection_over_union</span></span>(<span>self, bb)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for iou</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L534-L536" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def intersection_over_union(self, bb):
    &#34;&#34;&#34;Alias for iou&#34;&#34;&#34;
    return self.iou(bb)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.invalid"><code class="name flex">
<span>def <span class="ident">invalid</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Is the box a valid bounding box?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L363-L367" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def invalid(self):
    &#34;&#34;&#34;Is the box a valid bounding box?&#34;&#34;&#34;
    #is_undefined = np.isnan(self._xmin) or np.isnan(self._ymin) or np.isnan(self._xmax) or np.isnan(self._ymax)
    is_valid = ((self._xmax - self._xmin) &gt;= 0) and ((self._ymax - self._ymin) &gt;= 0)  # if nan, will return False
    return not is_valid</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.iou"><code class="name flex">
<span>def <span class="ident">iou</span></span>(<span>self, bb, area=None, otherarea=None)</span>
</code></dt>
<dd>
<div class="desc"><p>area of intersection / area of union</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L516-L532" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def iou(self, bb, area=None, otherarea=None):
    &#34;&#34;&#34;area of intersection / area of union&#34;&#34;&#34;
    assert bb is None or isinstance(bb, BoundingBox), &#34;Invalid BoundingBox() input of type &#39;%s&#39;&#34; % str(type(bb))        
    if bb is None:
        return 0
    w = min(self._xmax, bb._xmax) - max(self._xmin, bb._xmin)
    if w &lt;= 0:
        return 0  # invalid (no overlap), early exit
    h = min(self._ymax, bb._ymax) - max(self._ymin, bb._ymin)
    if h &lt;= 0:
        return 0  # invalid (no overlap), early exit

    area_intersection = w * h
    area_union = ((self.area() if area is None else area) +
                  (bb.area() if otherarea is None else otherarea) -
                  area_intersection)
    return (area_intersection / float(area_union)) if area_union &gt; 0 else 0</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.isdegenerate"><code class="name flex">
<span>def <span class="ident">isdegenerate</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L375-L376" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isdegenerate(self):
    return self.invalid()</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.iseven"><code class="name flex">
<span>def <span class="ident">iseven</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Are all corners even number integers?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L775-L780" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def iseven(self):
    &#34;&#34;&#34;Are all corners even number integers?&#34;&#34;&#34;
    return (isinstance(self.xmin(), int) and self.xmin() % 2 == 0 and
            isinstance(self.ymin(), int) and self.ymin() % 2 == 0 and
            isinstance(self.xmax(), int) and self.xmax() % 2 == 0 and
            isinstance(self.ymax(), int) and self.ymax() % 2 == 0)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.isinside"><code class="name flex">
<span>def <span class="ident">isinside</span></span>(<span>self, bb)</span>
</code></dt>
<dd>
<div class="desc"><p>Is this boundingbox fully within the provided bounding box?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L615-L618" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isinside(self, bb):
    &#34;&#34;&#34;Is this boundingbox fully within the provided bounding box?&#34;&#34;&#34;
    assert isinstance(bb, BoundingBox)
    return self.hasintersection(bb) and self.cover(bb) == 1.0</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.isinteger"><code class="name flex">
<span>def <span class="ident">isinteger</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L307-L311" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isinteger(self):
    return (isinstance(self._xmin, int) and
            isinstance(self._ymin, int) and
            isinstance(self._xmax, int) and
            isinstance(self._ymax, int))</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.isinterior"><code class="name flex">
<span>def <span class="ident">isinterior</span></span>(<span>self, width=None, height=None, border=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Is this boundingbox fully within the provided image rectangle?
</p>
<ul>
<li>If border in [0,1], then the image is dilated by a border percentage prior to computing interior, useful to check if self is near the image edge</li>
<li>If border=0.8, then the image rectangle is dilated by 80% (smaller) keeping the centroid constant.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L813-L820" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isinterior(self, width=None, height=None, border=1.0):
    &#34;&#34;&#34;Is this boundingbox fully within the provided image rectangle?  
    
       * If border in [0,1], then the image is dilated by a border percentage prior to computing interior, useful to check if self is near the image edge
       * If border=0.8, then the image rectangle is dilated by 80% (smaller) keeping the centroid constant. 
    &#34;&#34;&#34;
    assert border &gt; 0 and border &lt;= 1, &#34;Border must be a dilation fraction of the image, such that the image centroid is constant and the sides are dilated by a scale [0,1]&#34;
    return self.isinside(imagebox((height, width)).dilate(border))</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.isnonnegative"><code class="name flex">
<span>def <span class="ident">isnonnegative</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L378-L382" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isnonnegative(self):
    return (self.xmin() &gt;= 0 and
            self.ymin() &gt;= 0 and
            self.xmax() &gt;= 0 and
            self.ymax() &gt;= 0)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.ispointinside"><code class="name flex">
<span>def <span class="ident">ispointinside</span></span>(<span>self, p)</span>
</code></dt>
<dd>
<div class="desc"><p>Is the 2D point p=(x,y) inside this boundingbox, or is the p=boundingbox() inside this bounding box?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L620-L623" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def ispointinside(self, p):
    &#34;&#34;&#34;Is the 2D point p=(x,y) inside this boundingbox, or is the p=boundingbox() inside this bounding box?&#34;&#34;&#34;
    assert len(p) == 2, &#34;Invalid 2D point=(x,y) input&#34;
    return (p[0] &gt;= self._xmin) and (p[1] &gt;= self._ymin) and (p[0] &lt;= self._xmax) and (p[1] &lt;= self._ymax)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.issquare"><code class="name flex">
<span>def <span class="ident">issquare</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L772-L773" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def issquare(self):
    return np.allclose(self.bbheight(), self.bbwidth())</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.isvalid"><code class="name flex">
<span>def <span class="ident">isvalid</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L372-L373" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isvalid(self):
    return not self.invalid()</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.json"><code class="name flex">
<span>def <span class="ident">json</span></span>(<span>self, encode=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L196-L197" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def json(self, encode=True):
    return json.dumps(self.__dict__) if encode else self.__dict__</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.left"><code class="name flex">
<span>def <span class="ident">left</span></span>(<span>self, dx)</span>
</code></dt>
<dd>
<div class="desc"><p>Make left of box wider (closer to left side of image) by an offset dx</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L675-L678" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def left(self, dx):
    &#34;&#34;&#34;Make left of box wider (closer to left side of image) by an offset dx&#34;&#34;&#34;
    self._xmin = self._xmin - dx
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.ll"><code class="name flex">
<span>def <span class="ident">ll</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Lower left coordinate (x,y), synonym for bl()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L246-L248" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def ll(self):
    &#34;&#34;&#34;Lower left coordinate (x,y), synonym for bl()&#34;&#34;&#34;
    return (self._xmin, self._ymax)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.lr"><code class="name flex">
<span>def <span class="ident">lr</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Lower right coordinate (x,y), synonym for br()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L262-L264" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def lr(self):
    &#34;&#34;&#34;Lower right coordinate (x,y), synonym for br()&#34;&#34;&#34;
    return (self._xmax, self._ymax)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.maxcover"><code class="name flex">
<span>def <span class="ident">maxcover</span></span>(<span>self, bb, area=None, otherarea=None)</span>
</code></dt>
<dd>
<div class="desc"><p>The maximum cover of self to bb and bb to self</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L558-L562" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def maxcover(self, bb, area=None, otherarea=None):
    &#34;&#34;&#34;The maximum cover of self to bb and bb to self&#34;&#34;&#34;
    aoi = self.area_of_intersection(bb, strict=False)
    (area, otherarea) = (self.area() if area is None else area, bb.area() if otherarea is None else otherarea)
    return float(max((aoi/area) if area&gt;0 else 0, (aoi/otherarea) if otherarea&gt;0 else 0))</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.maxdim"><code class="name flex">
<span>def <span class="ident">maxdim</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return max(width, height) typecast to float</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L873-L875" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def maxdim(self):
    &#34;&#34;&#34;Return max(width, height) typecast to float&#34;&#34;&#34;
    return float(np.max(self.shape())) </code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.maxsquare"><code class="name flex">
<span>def <span class="ident">maxsquare</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the bounding box to be square by setting width and height to the maximum dimension of the box, keeping centroid constant</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L757-L767" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def maxsquare(self):
    &#34;&#34;&#34;Set the bounding box to be square by setting width and height to the maximum dimension of the box, keeping centroid constant&#34;&#34;&#34;
    (height, width) = (self._ymax-self._ymin, self._xmax-self._xmin)                            
    if width != height:
        dim = float(max(width, height))
        c = self.centroid()
        self._xmin = c[0] - (dim / 2.0)
        self._ymin = c[1] - (dim / 2.0)
        self._xmax = c[0] + (dim / 2.0)
        self._ymax = c[1] + (dim / 2.0)
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.maxsquareif"><code class="name flex">
<span>def <span class="ident">maxsquareif</span></span>(<span>self, do)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L769-L770" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def maxsquareif(self, do):
    return self.maxsquare() if do else self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.medianshape"><code class="name flex">
<span>def <span class="ident">medianshape</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the median bounding box width and height between self and other.
Other may be a singleton bounding box or a list of bounding boxes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L895-L901" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def medianshape(self, other):
    &#34;&#34;&#34;Compute the median bounding box width and height between self and other.  Other may be a singleton bounding box or a list of bounding boxes&#34;&#34;&#34;
    assert all([isinstance(bb, BoundingBox) for bb in tolist(other)]), &#34;Invalid input - must be BoundingBox&#34;        
    (height, width) = np.median( [self.shape()] + [bb.shape() for bb in tolist(other)], axis=0)
    self.setwidth(width)
    self.setheight(height)
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.mindim"><code class="name flex">
<span>def <span class="ident">mindim</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return min(width, height) typecast to float</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L869-L871" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def mindim(self):
    &#34;&#34;&#34;Return min(width, height) typecast to float&#34;&#34;&#34;
    return float(np.min(self.shape()))</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.mindimension"><code class="name flex">
<span>def <span class="ident">mindimension</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return min(width, height) typecast to float</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L865-L867" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def mindimension(self):
    &#34;&#34;&#34;Return min(width, height) typecast to float&#34;&#34;&#34;
    return float(np.min(self.shape()))</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.minsquare"><code class="name flex">
<span>def <span class="ident">minsquare</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the bounding box to be square by setting width and height to the minimum dimension of the box, keeping centroid constant</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L791-L801" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def minsquare(self):
    &#34;&#34;&#34;Set the bounding box to be square by setting width and height to the minimum dimension of the box, keeping centroid constant&#34;&#34;&#34;
    (height, width) = (self._ymax-self._ymin, self._xmax-self._xmin)                            
    if width != height:
        dim = float(min(width, height))
        c = self.centroid()
        self._xmin = c[0] - (dim / 2.0)
        self._ymin = c[1] - (dim / 2.0)
        self._xmax = c[0] + (dim / 2.0)
        self._ymax = c[1] + (dim / 2.0)
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.offset"><code class="name flex">
<span>def <span class="ident">offset</span></span>(<span>self, dx=0, dy=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for translate</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L359-L361" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def offset(self, dx=0, dy=0):
    &#34;&#34;&#34;Alias for translate&#34;&#34;&#34;
    return self.translate(dx, dy)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.pdist"><code class="name flex">
<span>def <span class="ident">pdist</span></span>(<span>self, bb, sigma=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Normalized Gaussian distance in [0,1] between centroids of two bounding boxes, where 0 is far and 1 is same with sigma=maxdim() of this box</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L511-L514" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def pdist(self, bb, sigma=None):
    &#34;&#34;&#34;Normalized Gaussian distance in [0,1] between centroids of two bounding boxes, where 0 is far and 1 is same with sigma=maxdim() of this box&#34;&#34;&#34;
    assert isinstance(bb, BoundingBox), &#34;Invalid BoundingBox() input of type &#39;%s&#39;&#34; % str(type(bb))
    return np.exp(-self.sqdist(bb)/(float(2*self.maxdim()*self.maxdim()) if sigma is None else float(2.0*sigma*sigma)))</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.projective"><code class="name flex">
<span>def <span class="ident">projective</span></span>(<span>self, A)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply an 3x3 affine transformation to the box centroid.
This operation preserves an axis aligned bounding box for an arbitrary affine transform.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L913-L916" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def projective(self, A):
    &#34;&#34;&#34;Apply an 3x3 affine transformation to the box centroid.  This operation preserves an axis aligned bounding box for an arbitrary affine transform.&#34;&#34;&#34;
    assert isnumpy(A) and A.shape == (3,3), &#34;A must be a 3x3 affine transformation matrix&#34;
    return self.centroid(dehomogenize(np.dot(A, homogenize(np.array(self.centroid())))))</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.rescale"><code class="name flex">
<span>def <span class="ident">rescale</span></span>(<span>self, scale=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Multiply the box corners by a scale factor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L685-L691" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rescale(self, scale=1):
    &#34;&#34;&#34;Multiply the box corners by a scale factor&#34;&#34;&#34;
    self._xmin = scale * self._xmin
    self._ymin = scale * self._ymin
    self._xmax = scale * self._xmax
    self._ymax = scale * self._ymax
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.resize"><code class="name flex">
<span>def <span class="ident">resize</span></span>(<span>self, width, height)</span>
</code></dt>
<dd>
<div class="desc"><p>Change the aspect ratio width and height of the box</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L705-L709" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def resize(self, width, height):
    &#34;&#34;&#34;Change the aspect ratio width and height of the box&#34;&#34;&#34;
    self.setwidth(width)
    self.setheight(height)
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.right"><code class="name flex">
<span>def <span class="ident">right</span></span>(<span>self, dx)</span>
</code></dt>
<dd>
<div class="desc"><p>Make right of box wider (closer to right side of image) by an offset dx</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L680-L683" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def right(self, dx):
    &#34;&#34;&#34;Make right of box wider (closer to right side of image) by an offset dx&#34;&#34;&#34;
    self._xmax = self._xmax + dx
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.rot90ccw"><code class="name flex">
<span>def <span class="ident">rot90ccw</span></span>(<span>self, H, W)</span>
</code></dt>
<dd>
<div class="desc"><p>Rotate a bounding box such that if an image of size (H,W) is rotated 90 deg clockwise, the boxes align</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L717-L721" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rot90ccw(self, H, W):
    &#34;&#34;&#34;Rotate a bounding box such that if an image of size (H,W) is rotated 90 deg clockwise, the boxes align&#34;&#34;&#34;
    (x,y,w,h) = self.xywh()
    (urx, ury) = self.upperright()
    return self.xywh((ury, W - urx, h, w))</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.rot90cw"><code class="name flex">
<span>def <span class="ident">rot90cw</span></span>(<span>self, H, W)</span>
</code></dt>
<dd>
<div class="desc"><p>Rotate a bounding box such that if an image of size (H,W) is rotated 90 deg clockwise, the boxes align</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L711-L715" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rot90cw(self, H, W):
    &#34;&#34;&#34;Rotate a bounding box such that if an image of size (H,W) is rotated 90 deg clockwise, the boxes align&#34;&#34;&#34;
    (x,y,w,h) = self.xywh()
    (blx, bly) = self.bottomleft()
    return self.xywh((H - bly, blx, h, w))</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.scalex"><code class="name flex">
<span>def <span class="ident">scalex</span></span>(<span>self, scale=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Multiply the box corners in the x dimension by a scale factor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L693-L697" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def scalex(self, scale=1):
    &#34;&#34;&#34;Multiply the box corners in the x dimension by a scale factor&#34;&#34;&#34;
    self._xmin = scale * self._xmin
    self._xmax = scale * self._xmax
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.scaley"><code class="name flex">
<span>def <span class="ident">scaley</span></span>(<span>self, scale=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Multiply the box corners in the y dimension by a scale factor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L699-L703" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def scaley(self, scale=1):
    &#34;&#34;&#34;Multiply the box corners in the y dimension by a scale factor&#34;&#34;&#34;
    self._ymin = scale * self._ymin
    self._ymax = scale * self._ymax
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.set_origin"><code class="name flex">
<span>def <span class="ident">set_origin</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the origin of the coordinates of this bounding box to be relative to the upper left of the other bounding box</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L354-L357" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def set_origin(self, other):
    &#34;&#34;&#34;Set the origin of the coordinates of this bounding box to be relative to the upper left of the other bounding box&#34;&#34;&#34;
    assert isinstance(other, BoundingBox), &#34;Invalid BoundingBox() input of type &#39;%s&#39;&#34; % str(type(other))
    return self.translate(other.xmin(), other.ymin())                </code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.setheight"><code class="name flex">
<span>def <span class="ident">setheight</span></span>(<span>self, h)</span>
</code></dt>
<dd>
<div class="desc"><p>Set new height keeping centroid constant</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L398-L405" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def setheight(self, h):
    &#34;&#34;&#34;Set new height keeping centroid constant&#34;&#34;&#34;
    if h &lt;= 0:
        raise ValueError(&#39;invalid height&#39;)
    horig = self._ymax - self._ymin
    self._ymax += float((h - horig) / 2.0)
    self._ymin -= float((h - horig) / 2.0)
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.setwidth"><code class="name flex">
<span>def <span class="ident">setwidth</span></span>(<span>self, w)</span>
</code></dt>
<dd>
<div class="desc"><p>Set new width keeping centroid constant</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L389-L396" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def setwidth(self, w):
    &#34;&#34;&#34;Set new width keeping centroid constant&#34;&#34;&#34;
    if w &lt;= 0:
        raise ValueError(&#39;invalid width&#39;)
    worig = (self._xmax - self._xmin)
    self._xmax += float((w - worig) / 2.0)
    self._xmin -= float((w - worig) / 2.0)
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.shape"><code class="name flex">
<span>def <span class="ident">shape</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the (height, width) tuple for the box shape</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L861-L863" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def shape(self):
    &#34;&#34;&#34;Return the (height, width) tuple for the box shape&#34;&#34;&#34;
    return (self._ymax-self._ymin, self._xmax-self._xmin)                            </code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.shapedist"><code class="name flex">
<span>def <span class="ident">shapedist</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>L1 distance between (width,height) of two boxes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L903-L906" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def shapedist(self, other):
    &#34;&#34;&#34;L1 distance between (width,height) of two boxes&#34;&#34;&#34;
    assert isinstance(other, BoundingBox), &#34;Invalid input - must be BoundingBox()&#34;                
    return np.abs(self.bbwidth()-other.bbwidth())  + np.abs(self.bbheight()-other.bbheight())</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.shapeiou"><code class="name flex">
<span>def <span class="ident">shapeiou</span></span>(<span>self, bb, area=None, otherarea=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Shape IoU is the IoU with the upper left corners aligned. This measures the deformation of the two boxes by removing the effect of translation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L564-L574" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def shapeiou(self, bb, area=None, otherarea=None):
    &#34;&#34;&#34;Shape IoU is the IoU with the upper left corners aligned. This measures the deformation of the two boxes by removing the effect of translation&#34;&#34;&#34;
    #return self.iou(bb.clone().translate(dx=self._xmin-bb._xmin, dy=self._ymin-bb._ymin))  # equivalent to
    assert isinstance(bb, BoundingBox), &#34;Invalid input - must be BoundingBox()&#34;
    w = min(self._xmax, bb._xmax + (self._xmin-bb._xmin)) - max(self._xmin, bb._xmin + (self._xmin-bb._xmin))
    h = min(self._ymax, bb._ymax + (self._ymin-bb._ymin)) - max(self._ymin, bb._ymin + (self._ymin-bb._ymin))
    area_intersection = w * h
    area_union = ((self.area() if area is None else area) +
                  (bb.area() if otherarea is None else otherarea)
                  - area_intersection)
    return (area_intersection / float(area_union)) if area_union&gt;0 else 0</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.significant_digits"><code class="name flex">
<span>def <span class="ident">significant_digits</span></span>(<span>self, n)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert corners to have at most n significant digits for efficient JSON storage</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L334-L341" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def significant_digits(self, n):
    &#34;&#34;&#34;Convert corners to have at most n significant digits for efficient JSON storage&#34;&#34;&#34;
    assert isinstance(n, int) and n&gt;=0
    self._xmin = round(self._xmin, n)
    self._ymin = round(self._ymin, n)
    self._xmax = round(self._xmax, n)
    self._ymax = round(self._ymax, n)
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.sqdist"><code class="name flex">
<span>def <span class="ident">sqdist</span></span>(<span>self, bb)</span>
</code></dt>
<dd>
<div class="desc"><p>Squared Euclidean distance between upper left corners of two bounding boxes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L501-L504" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def sqdist(self, bb):
    &#34;&#34;&#34;Squared Euclidean distance between upper left corners of two bounding boxes&#34;&#34;&#34;
    assert isinstance(bb, BoundingBox), &#34;Invalid BoundingBox() input of type &#39;%s&#39;&#34; % str(type(bb))                
    return np.power(self.dx(bb), 2.0) + np.power(self.dy(bb), 2.0)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.to_origin"><code class="name flex">
<span>def <span class="ident">to_origin</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L351-L352" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def to_origin(self):
    return self.translate(-self.xmin(), -self.ymin())</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.to_ulbr"><code class="name flex">
<span>def <span class="ident">to_ulbr</span></span>(<span>self, ulbr=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for ulbr()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L489-L491" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def to_ulbr(self, ulbr=None):
    &#34;&#34;&#34;Alias for ulbr()&#34;&#34;&#34;
    return self.ulbr(ulbr)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.to_xywh"><code class="name flex">
<span>def <span class="ident">to_xywh</span></span>(<span>self, xywh=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return bounding box corners as (x,y,width,height) tuple</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L451-L462" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def to_xywh(self, xywh=None):
    &#34;&#34;&#34;Return bounding box corners as (x,y,width,height) tuple&#34;&#34;&#34;
    if xywh is None:
        (height, width) = (self._ymax-self._ymin, self._xmax-self._xmin)                    
        return tuple([self._xmin, self._ymin, width, height])
    else:
        assert len(xywh) == 4, &#34;Invalid (xmin,ymin,width,height) input&#34;
        self._xmin = float(xywh[0])
        self._ymin = float(xywh[1])
        self._xmax = float(self._xmin + xywh[2])
        self._ymax = float(self._ymin + xywh[3])
        return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.top"><code class="name flex">
<span>def <span class="ident">top</span></span>(<span>self, dy)</span>
</code></dt>
<dd>
<div class="desc"><p>Make top of box taller (closer to top of image) by an offset dy</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L665-L668" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def top(self, dy):
    &#34;&#34;&#34;Make top of box taller (closer to top of image) by an offset dy&#34;&#34;&#34;
    self._ymin = self._ymin - dy
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.translate"><code class="name flex">
<span>def <span class="ident">translate</span></span>(<span>self, dx=0, dy=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Translate the bounding box by dx in x and dy in y</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L343-L349" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def translate(self, dx=0, dy=0):
    &#34;&#34;&#34;Translate the bounding box by dx in x and dy in y&#34;&#34;&#34;
    self._xmin = self._xmin + dx
    self._ymin = self._ymin + dy
    self._xmax = self._xmax + dx
    self._ymax = self._ymax + dy
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.ul"><code class="name flex">
<span>def <span class="ident">ul</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Upper left coordinate (x,y)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L222-L224" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def ul(self):
    &#34;&#34;&#34;Upper left coordinate (x,y)&#34;&#34;&#34;
    return (self._xmin, self._ymin)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.ulbr"><code class="name flex">
<span>def <span class="ident">ulbr</span></span>(<span>self, ulbr=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return bounding box corners as upper left, bottom right (xmin, ymin, xmax, ymax)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L477-L487" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def ulbr(self, ulbr=None):
    &#34;&#34;&#34;Return bounding box corners as upper left, bottom right (xmin, ymin, xmax, ymax)&#34;&#34;&#34;
    if ulbr is None:
        return (self._xmin, self._ymin, self._xmax, self._ymax)            
    else:
        assert len(ulbr) == 4, &#34;Invalid (xmin,ymin,xmax,ymax) input&#34;
        self._xmin = float(ulbr[0])
        self._ymin = float(ulbr[1])
        self._xmax = float(ulbr[2])
        self._ymax = float(ulbr[3])
        return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.ulx"><code class="name flex">
<span>def <span class="ident">ulx</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Upper left coordinate (x)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L226-L228" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def ulx(self):
    &#34;&#34;&#34;Upper left coordinate (x)&#34;&#34;&#34;
    return self.ul()[0]</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.uly"><code class="name flex">
<span>def <span class="ident">uly</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Upper left coordinate (y)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L230-L232" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def uly(self):
    &#34;&#34;&#34;Upper left coordinate (y)&#34;&#34;&#34;
    return self.ul()[1]</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.union"><code class="name flex">
<span>def <span class="ident">union</span></span>(<span>self, bb)</span>
</code></dt>
<dd>
<div class="desc"><p>Union of one or more bounding boxes with this box</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L605-L613" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def union(self, bb):
    &#34;&#34;&#34;Union of one or more bounding boxes with this box&#34;&#34;&#34;        
    bblist = tolist(bb)        
    assert all([isinstance(bb, BoundingBox) for bb in bblist]), &#34;Invalid BoundingBox() input&#34;
    self._xmin = min([bb._xmin for bb in bblist] + [self._xmin])
    self._ymin = min([bb._ymin for bb in bblist] + [self._ymin])
    self._xmax = max([bb._xmax for bb in bblist] + [self._xmax])
    self._ymax = max([bb._ymax for bb in bblist] + [self._ymax])
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.upperleft"><code class="name flex">
<span>def <span class="ident">upperleft</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the (x,y) upper left corner coordinate of the box</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L291-L293" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def upperleft(self):
    &#34;&#34;&#34;Return the (x,y) upper left corner coordinate of the box&#34;&#34;&#34;
    return (self.xmin(), self.ymin())</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.upperright"><code class="name flex">
<span>def <span class="ident">upperright</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the (x,y) upper right corner coordinate of the box</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L299-L301" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def upperright(self):
    &#34;&#34;&#34;Return the (x,y) upper right corner coordinate of the box&#34;&#34;&#34;
    return (self.xmax(), self.ymin())</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.ur"><code class="name flex">
<span>def <span class="ident">ur</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Upper right coordinate (x,y)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L234-L236" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def ur(self):
    &#34;&#34;&#34;Upper right coordinate (x,y)&#34;&#34;&#34;
    return (self._xmax, self._ymin)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.urx"><code class="name flex">
<span>def <span class="ident">urx</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Upper right coordinate (x)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L238-L240" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def urx(self):
    &#34;&#34;&#34;Upper right coordinate (x)&#34;&#34;&#34;
    return self.ur()[0]</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.ury"><code class="name flex">
<span>def <span class="ident">ury</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Upper right coordinate (y)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L242-L244" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def ury(self):
    &#34;&#34;&#34;Upper right coordinate (y)&#34;&#34;&#34;
    return self.ur()[1]</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.valid"><code class="name flex">
<span>def <span class="ident">valid</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L369-L370" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def valid(self):
    return not self.invalid()</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.width"><code class="name flex">
<span>def <span class="ident">width</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L384-L385" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def width(self):
    return self._xmax - self._xmin</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.x_centroid"><code class="name flex">
<span>def <span class="ident">x_centroid</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L426-L427" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def x_centroid(self):
    return self.centroid()[0]</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.xcentroid"><code class="name flex">
<span>def <span class="ident">xcentroid</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for x_centroid()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L429-L431" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def xcentroid(self):
    &#34;&#34;&#34;Alias for x_centroid()&#34;&#34;&#34;
    return self.centroid()[0]</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.xmax"><code class="name flex">
<span>def <span class="ident">xmax</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>x coordinate of lower right corner of box, x-axis is image column</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L283-L285" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def xmax(self):
    &#34;&#34;&#34;x coordinate of lower right corner of box, x-axis is image column&#34;&#34;&#34;
    return self._xmax</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.xmin"><code class="name flex">
<span>def <span class="ident">xmin</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>x coordinate of upper left corner of box, x-axis is image column</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L218-L220" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def xmin(self):
    &#34;&#34;&#34;x coordinate of upper left corner of box, x-axis is image column&#34;&#34;&#34;
    return self._xmin</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.xywh"><code class="name flex">
<span>def <span class="ident">xywh</span></span>(<span>self, xywh_=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for to_xywh</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L464-L466" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def xywh(self, xywh_=None):
    &#34;&#34;&#34;Alias for to_xywh&#34;&#34;&#34;
    return self.to_xywh(xywh_)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.y_centroid"><code class="name flex">
<span>def <span class="ident">y_centroid</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L436-L437" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def y_centroid(self):
    return self.centroid()[1]</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.ycentroid"><code class="name flex">
<span>def <span class="ident">ycentroid</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for y_centroid()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L439-L441" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def ycentroid(self):
    &#34;&#34;&#34;Alias for y_centroid()&#34;&#34;&#34;
    return self.centroid()[1]</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.ymax"><code class="name flex">
<span>def <span class="ident">ymax</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>y coordinate of lower right corner of box, y-axis is image row</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L287-L289" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def ymax(self):
    &#34;&#34;&#34;y coordinate of lower right corner of box, y-axis is image row&#34;&#34;&#34;
    return self._ymax</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.ymin"><code class="name flex">
<span>def <span class="ident">ymin</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>y coordinate of upper left corner of box, y-axis is image row</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L279-L281" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def ymin(self):
    &#34;&#34;&#34;y coordinate of upper left corner of box, y-axis is image row&#34;&#34;&#34;
    return self._ymin</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="vipy.geometry.Ellipse"><code class="flex name class">
<span>class <span class="ident">Ellipse</span></span>
<span>(</span><span>semi_major, semi_minor, xcenter, ycenter, phi)</span>
</code></dt>
<dd>
<div class="desc"><p>Ellipse parameterization, for length of semimajor (half width of ellipse) and semiminor axis (half height), center point and angle phi in radians</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L939-L1009" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Ellipse():
    __slots__ = [&#39;_major&#39;, &#39;_minor&#39;, &#39;_xcenter&#39;, &#39;_ycenter&#39;, &#39;_phi&#39;]
    def __init__(self, semi_major, semi_minor, xcenter, ycenter, phi):
        &#34;&#34;&#34;Ellipse parameterization, for length of semimajor (half width of ellipse) and semiminor axis (half height), center point and angle phi in radians&#34;&#34;&#34;
        self._major = semi_major
        self._minor = semi_minor
        self._xcenter = xcenter
        self._ycenter = ycenter
        self._phi = phi

    def __repr__(self):
        return str(&#39;&lt;vipy.geometry.ellipse: semimajor=%s, semiminor=%s, xcenter=%s, ycenter=%s, phi=%s (rad)&gt;&#39; % (self._major, self._minor, self._xcenter, self._ycenter, self._phi))

    def dict(self):
        return {&#39;semimajor&#39;:self._major, &#39;semiminor&#39;:self._minor, &#39;xcenter&#39;:self._xcenter, &#39;ycenter&#39;:self._ycenter, &#39;phi&#39;:self._phi}
    
    def area(self):
        &#34;&#34;&#34;Area of ellipse&#34;&#34;&#34;
        return math.pi * self._major * self._minor

    def center(self):
        &#34;&#34;&#34;Return centroid&#34;&#34;&#34;
        return (self._xcenter, self._ycenter)

    def centroid(self):
        &#34;&#34;&#34;Alias for center&#34;&#34;&#34;
        return self.center()

    def axes(self):
        &#34;&#34;&#34;Return the (major,minor) axis lengths&#34;&#34;&#34;
        return (self._major, self._minor)

    def angle(self):
        &#34;&#34;&#34;Return the angle phi (in degrees)&#34;&#34;&#34;
        return (self._phi * 180 / math.pi)

    def rescale(self, scale):
        &#34;&#34;&#34;Scale ellipse by scale factor&#34;&#34;&#34;
        assert isnumber(scale), &#34;Invalid input&#34;
        self._major *= scale
        self._minor *= scale
        self._xcenter *= scale
        self._ycenter *= scale
        return self

    def boundingbox(self):
        &#34;&#34;&#34; Estimate an equivalent bounding box based on scaling to a common area.
        Note, this does not factor in rotation.
        (c*l)*(c*w) = a_e  --&gt; c = sqrt(a_e / a_r) &#34;&#34;&#34;
        assert self._phi == 0, &#34;This function does not currently factor in rotation&#34;

        bbox = BoundingBox(width=2 * self._major, height=2 * self._minor, xcentroid=self._xcenter, ycentroid=self._ycenter)
        a_r = bbox.area()
        c = (self.area() / a_r) ** 0.5
        bbox2 = bbox.clone().dilate(c)
        return bbox2

    def inside(self, x, y=None):
        &#34;&#34;&#34;Return true if a point p=(x,y) is inside the ellipse&#34;&#34;&#34;
        p = (x,y) if y is not None else x
        assert len(p) == 2, &#34;Invalid input&#34;
        assert self._phi == 0, &#34;inside only currently supported for phi=0&#34;
        return ((np.square(p[0] - self._xcenter) / np.square(self._major)) + (np.square(p[1] - self._ycenter) / np.square(self._minor))) &lt;= 1

    def mask(self):
        &#34;&#34;&#34;Return a binary mask of size equal to the bounding box such that the pixels correspond to the interior of the ellipse&#34;&#34;&#34;
        (H,W) = (int(np.round(2 * self._minor)), int(np.round(2 * self._major)))
        img = np.zeros((H,W), dtype=bool)
        for (y,x) in product(range(0,H), range(0,W)):
            img[y,x] = self.inside(x,y)
        return img</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="vipy.geometry.Ellipse.angle"><code class="name flex">
<span>def <span class="ident">angle</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the angle phi (in degrees)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L971-L973" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def angle(self):
    &#34;&#34;&#34;Return the angle phi (in degrees)&#34;&#34;&#34;
    return (self._phi * 180 / math.pi)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Ellipse.area"><code class="name flex">
<span>def <span class="ident">area</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Area of ellipse</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L955-L957" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def area(self):
    &#34;&#34;&#34;Area of ellipse&#34;&#34;&#34;
    return math.pi * self._major * self._minor</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Ellipse.axes"><code class="name flex">
<span>def <span class="ident">axes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the (major,minor) axis lengths</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L967-L969" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def axes(self):
    &#34;&#34;&#34;Return the (major,minor) axis lengths&#34;&#34;&#34;
    return (self._major, self._minor)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Ellipse.boundingbox"><code class="name flex">
<span>def <span class="ident">boundingbox</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Estimate an equivalent bounding box based on scaling to a common area.
Note, this does not factor in rotation.
(c<em>l)</em>(c*w) = a_e
&ndash;&gt; c = sqrt(a_e / a_r)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L984-L994" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def boundingbox(self):
    &#34;&#34;&#34; Estimate an equivalent bounding box based on scaling to a common area.
    Note, this does not factor in rotation.
    (c*l)*(c*w) = a_e  --&gt; c = sqrt(a_e / a_r) &#34;&#34;&#34;
    assert self._phi == 0, &#34;This function does not currently factor in rotation&#34;

    bbox = BoundingBox(width=2 * self._major, height=2 * self._minor, xcentroid=self._xcenter, ycentroid=self._ycenter)
    a_r = bbox.area()
    c = (self.area() / a_r) ** 0.5
    bbox2 = bbox.clone().dilate(c)
    return bbox2</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Ellipse.center"><code class="name flex">
<span>def <span class="ident">center</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return centroid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L959-L961" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def center(self):
    &#34;&#34;&#34;Return centroid&#34;&#34;&#34;
    return (self._xcenter, self._ycenter)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Ellipse.centroid"><code class="name flex">
<span>def <span class="ident">centroid</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for center</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L963-L965" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def centroid(self):
    &#34;&#34;&#34;Alias for center&#34;&#34;&#34;
    return self.center()</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Ellipse.dict"><code class="name flex">
<span>def <span class="ident">dict</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L952-L953" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dict(self):
    return {&#39;semimajor&#39;:self._major, &#39;semiminor&#39;:self._minor, &#39;xcenter&#39;:self._xcenter, &#39;ycenter&#39;:self._ycenter, &#39;phi&#39;:self._phi}</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Ellipse.inside"><code class="name flex">
<span>def <span class="ident">inside</span></span>(<span>self, x, y=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return true if a point p=(x,y) is inside the ellipse</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L996-L1001" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def inside(self, x, y=None):
    &#34;&#34;&#34;Return true if a point p=(x,y) is inside the ellipse&#34;&#34;&#34;
    p = (x,y) if y is not None else x
    assert len(p) == 2, &#34;Invalid input&#34;
    assert self._phi == 0, &#34;inside only currently supported for phi=0&#34;
    return ((np.square(p[0] - self._xcenter) / np.square(self._major)) + (np.square(p[1] - self._ycenter) / np.square(self._minor))) &lt;= 1</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Ellipse.mask"><code class="name flex">
<span>def <span class="ident">mask</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a binary mask of size equal to the bounding box such that the pixels correspond to the interior of the ellipse</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L1003-L1009" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def mask(self):
    &#34;&#34;&#34;Return a binary mask of size equal to the bounding box such that the pixels correspond to the interior of the ellipse&#34;&#34;&#34;
    (H,W) = (int(np.round(2 * self._minor)), int(np.round(2 * self._major)))
    img = np.zeros((H,W), dtype=bool)
    for (y,x) in product(range(0,H), range(0,W)):
        img[y,x] = self.inside(x,y)
    return img</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Ellipse.rescale"><code class="name flex">
<span>def <span class="ident">rescale</span></span>(<span>self, scale)</span>
</code></dt>
<dd>
<div class="desc"><p>Scale ellipse by scale factor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/518200996e33d153578a4c3a3b4db5e850d6f54c/vipy/geometry.py#L975-L982" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rescale(self, scale):
    &#34;&#34;&#34;Scale ellipse by scale factor&#34;&#34;&#34;
    assert isnumber(scale), &#34;Invalid input&#34;
    self._major *= scale
    self._minor *= scale
    self._xcenter *= scale
    self._ycenter *= scale
    return self</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="Vipy" href="https://github.com/visym/vipy/">
<img src="https://www.visym.com/labs/images/visym_logo_black_notext.png" alt="" width="150"> <p> </p>
</a>
</header>
<form>
<input id="lunr-search" name="q" placeholder=" Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '../doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="vipy" href="index.html">vipy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="vipy.geometry.affine_transform" href="#vipy.geometry.affine_transform">affine_transform</a></code></li>
<li><code><a title="vipy.geometry.apply_homography" href="#vipy.geometry.apply_homography">apply_homography</a></code></li>
<li><code><a title="vipy.geometry.covariance_to_ellipse" href="#vipy.geometry.covariance_to_ellipse">covariance_to_ellipse</a></code></li>
<li><code><a title="vipy.geometry.dehomogenize" href="#vipy.geometry.dehomogenize">dehomogenize</a></code></li>
<li><code><a title="vipy.geometry.homogenize" href="#vipy.geometry.homogenize">homogenize</a></code></li>
<li><code><a title="vipy.geometry.imagebox" href="#vipy.geometry.imagebox">imagebox</a></code></li>
<li><code><a title="vipy.geometry.imtransform" href="#vipy.geometry.imtransform">imtransform</a></code></li>
<li><code><a title="vipy.geometry.normalize" href="#vipy.geometry.normalize">normalize</a></code></li>
<li><code><a title="vipy.geometry.random_affine_transform" href="#vipy.geometry.random_affine_transform">random_affine_transform</a></code></li>
<li><code><a title="vipy.geometry.similarity_transform" href="#vipy.geometry.similarity_transform">similarity_transform</a></code></li>
<li><code><a title="vipy.geometry.similarity_transform_2x3" href="#vipy.geometry.similarity_transform_2x3">similarity_transform_2x3</a></code></li>
<li><code><a title="vipy.geometry.union" href="#vipy.geometry.union">union</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="vipy.geometry.BoundingBox" href="#vipy.geometry.BoundingBox">BoundingBox</a></code></h4>
<ul class="">
<li><code><a title="vipy.geometry.BoundingBox.affine" href="#vipy.geometry.BoundingBox.affine">affine</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.area" href="#vipy.geometry.BoundingBox.area">area</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.area_of_intersection" href="#vipy.geometry.BoundingBox.area_of_intersection">area_of_intersection</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.area_of_union" href="#vipy.geometry.BoundingBox.area_of_union">area_of_union</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.aspectratio" href="#vipy.geometry.BoundingBox.aspectratio">aspectratio</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.average" href="#vipy.geometry.BoundingBox.average">average</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.averageshape" href="#vipy.geometry.BoundingBox.averageshape">averageshape</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.bbclone" href="#vipy.geometry.BoundingBox.bbclone">bbclone</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.bbheight" href="#vipy.geometry.BoundingBox.bbheight">bbheight</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.bbwidth" href="#vipy.geometry.BoundingBox.bbwidth">bbwidth</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.bl" href="#vipy.geometry.BoundingBox.bl">bl</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.blx" href="#vipy.geometry.BoundingBox.blx">blx</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.bly" href="#vipy.geometry.BoundingBox.bly">bly</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.bottom" href="#vipy.geometry.BoundingBox.bottom">bottom</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.bottomleft" href="#vipy.geometry.BoundingBox.bottomleft">bottomleft</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.bottomright" href="#vipy.geometry.BoundingBox.bottomright">bottomright</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.br" href="#vipy.geometry.BoundingBox.br">br</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.brx" href="#vipy.geometry.BoundingBox.brx">brx</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.bry" href="#vipy.geometry.BoundingBox.bry">bry</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.cast" href="#vipy.geometry.BoundingBox.cast">cast</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.centroid" href="#vipy.geometry.BoundingBox.centroid">centroid</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.centroid_x" href="#vipy.geometry.BoundingBox.centroid_x">centroid_x</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.centroid_y" href="#vipy.geometry.BoundingBox.centroid_y">centroid_y</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.clone" href="#vipy.geometry.BoundingBox.clone">clone</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.confidence" href="#vipy.geometry.BoundingBox.confidence">confidence</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.convexhull" href="#vipy.geometry.BoundingBox.convexhull">convexhull</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.cover" href="#vipy.geometry.BoundingBox.cover">cover</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.crop" href="#vipy.geometry.BoundingBox.crop">crop</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.cxywh" href="#vipy.geometry.BoundingBox.cxywh">cxywh</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.dict" href="#vipy.geometry.BoundingBox.dict">dict</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.dilate" href="#vipy.geometry.BoundingBox.dilate">dilate</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.dilate_height" href="#vipy.geometry.BoundingBox.dilate_height">dilate_height</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.dilate_width" href="#vipy.geometry.BoundingBox.dilate_width">dilate_width</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.dilatepx" href="#vipy.geometry.BoundingBox.dilatepx">dilatepx</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.dist" href="#vipy.geometry.BoundingBox.dist">dist</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.dx" href="#vipy.geometry.BoundingBox.dx">dx</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.dy" href="#vipy.geometry.BoundingBox.dy">dy</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.ellipse" href="#vipy.geometry.BoundingBox.ellipse">ellipse</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.even" href="#vipy.geometry.BoundingBox.even">even</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.fliplr" href="#vipy.geometry.BoundingBox.fliplr">fliplr</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.flipud" href="#vipy.geometry.BoundingBox.flipud">flipud</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.float" href="#vipy.geometry.BoundingBox.float">float</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.from_json" href="#vipy.geometry.BoundingBox.from_json">from_json</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.grid" href="#vipy.geometry.BoundingBox.grid">grid</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.hasintersection" href="#vipy.geometry.BoundingBox.hasintersection">hasintersection</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.hasoverlap" href="#vipy.geometry.BoundingBox.hasoverlap">hasoverlap</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.height" href="#vipy.geometry.BoundingBox.height">height</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.imclip" href="#vipy.geometry.BoundingBox.imclip">imclip</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.imclipshape" href="#vipy.geometry.BoundingBox.imclipshape">imclipshape</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.iminterior" href="#vipy.geometry.BoundingBox.iminterior">iminterior</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.imscale" href="#vipy.geometry.BoundingBox.imscale">imscale</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.int" href="#vipy.geometry.BoundingBox.int">int</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.intersection" href="#vipy.geometry.BoundingBox.intersection">intersection</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.intersection_over_union" href="#vipy.geometry.BoundingBox.intersection_over_union">intersection_over_union</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.invalid" href="#vipy.geometry.BoundingBox.invalid">invalid</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.iou" href="#vipy.geometry.BoundingBox.iou">iou</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.isdegenerate" href="#vipy.geometry.BoundingBox.isdegenerate">isdegenerate</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.iseven" href="#vipy.geometry.BoundingBox.iseven">iseven</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.isinside" href="#vipy.geometry.BoundingBox.isinside">isinside</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.isinteger" href="#vipy.geometry.BoundingBox.isinteger">isinteger</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.isinterior" href="#vipy.geometry.BoundingBox.isinterior">isinterior</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.isnonnegative" href="#vipy.geometry.BoundingBox.isnonnegative">isnonnegative</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.ispointinside" href="#vipy.geometry.BoundingBox.ispointinside">ispointinside</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.issquare" href="#vipy.geometry.BoundingBox.issquare">issquare</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.isvalid" href="#vipy.geometry.BoundingBox.isvalid">isvalid</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.json" href="#vipy.geometry.BoundingBox.json">json</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.left" href="#vipy.geometry.BoundingBox.left">left</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.ll" href="#vipy.geometry.BoundingBox.ll">ll</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.lr" href="#vipy.geometry.BoundingBox.lr">lr</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.maxcover" href="#vipy.geometry.BoundingBox.maxcover">maxcover</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.maxdim" href="#vipy.geometry.BoundingBox.maxdim">maxdim</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.maxsquare" href="#vipy.geometry.BoundingBox.maxsquare">maxsquare</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.maxsquareif" href="#vipy.geometry.BoundingBox.maxsquareif">maxsquareif</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.medianshape" href="#vipy.geometry.BoundingBox.medianshape">medianshape</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.mindim" href="#vipy.geometry.BoundingBox.mindim">mindim</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.mindimension" href="#vipy.geometry.BoundingBox.mindimension">mindimension</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.minsquare" href="#vipy.geometry.BoundingBox.minsquare">minsquare</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.offset" href="#vipy.geometry.BoundingBox.offset">offset</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.pdist" href="#vipy.geometry.BoundingBox.pdist">pdist</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.projective" href="#vipy.geometry.BoundingBox.projective">projective</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.rescale" href="#vipy.geometry.BoundingBox.rescale">rescale</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.resize" href="#vipy.geometry.BoundingBox.resize">resize</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.right" href="#vipy.geometry.BoundingBox.right">right</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.rot90ccw" href="#vipy.geometry.BoundingBox.rot90ccw">rot90ccw</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.rot90cw" href="#vipy.geometry.BoundingBox.rot90cw">rot90cw</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.scalex" href="#vipy.geometry.BoundingBox.scalex">scalex</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.scaley" href="#vipy.geometry.BoundingBox.scaley">scaley</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.set_origin" href="#vipy.geometry.BoundingBox.set_origin">set_origin</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.setheight" href="#vipy.geometry.BoundingBox.setheight">setheight</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.setwidth" href="#vipy.geometry.BoundingBox.setwidth">setwidth</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.shape" href="#vipy.geometry.BoundingBox.shape">shape</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.shapedist" href="#vipy.geometry.BoundingBox.shapedist">shapedist</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.shapeiou" href="#vipy.geometry.BoundingBox.shapeiou">shapeiou</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.significant_digits" href="#vipy.geometry.BoundingBox.significant_digits">significant_digits</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.sqdist" href="#vipy.geometry.BoundingBox.sqdist">sqdist</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.to_origin" href="#vipy.geometry.BoundingBox.to_origin">to_origin</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.to_ulbr" href="#vipy.geometry.BoundingBox.to_ulbr">to_ulbr</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.to_xywh" href="#vipy.geometry.BoundingBox.to_xywh">to_xywh</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.top" href="#vipy.geometry.BoundingBox.top">top</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.translate" href="#vipy.geometry.BoundingBox.translate">translate</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.ul" href="#vipy.geometry.BoundingBox.ul">ul</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.ulbr" href="#vipy.geometry.BoundingBox.ulbr">ulbr</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.ulx" href="#vipy.geometry.BoundingBox.ulx">ulx</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.uly" href="#vipy.geometry.BoundingBox.uly">uly</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.union" href="#vipy.geometry.BoundingBox.union">union</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.upperleft" href="#vipy.geometry.BoundingBox.upperleft">upperleft</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.upperright" href="#vipy.geometry.BoundingBox.upperright">upperright</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.ur" href="#vipy.geometry.BoundingBox.ur">ur</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.urx" href="#vipy.geometry.BoundingBox.urx">urx</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.ury" href="#vipy.geometry.BoundingBox.ury">ury</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.valid" href="#vipy.geometry.BoundingBox.valid">valid</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.width" href="#vipy.geometry.BoundingBox.width">width</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.x_centroid" href="#vipy.geometry.BoundingBox.x_centroid">x_centroid</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.xcentroid" href="#vipy.geometry.BoundingBox.xcentroid">xcentroid</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.xmax" href="#vipy.geometry.BoundingBox.xmax">xmax</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.xmin" href="#vipy.geometry.BoundingBox.xmin">xmin</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.xywh" href="#vipy.geometry.BoundingBox.xywh">xywh</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.y_centroid" href="#vipy.geometry.BoundingBox.y_centroid">y_centroid</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.ycentroid" href="#vipy.geometry.BoundingBox.ycentroid">ycentroid</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.ymax" href="#vipy.geometry.BoundingBox.ymax">ymax</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.ymin" href="#vipy.geometry.BoundingBox.ymin">ymin</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vipy.geometry.Ellipse" href="#vipy.geometry.Ellipse">Ellipse</a></code></h4>
<ul class="two-column">
<li><code><a title="vipy.geometry.Ellipse.angle" href="#vipy.geometry.Ellipse.angle">angle</a></code></li>
<li><code><a title="vipy.geometry.Ellipse.area" href="#vipy.geometry.Ellipse.area">area</a></code></li>
<li><code><a title="vipy.geometry.Ellipse.axes" href="#vipy.geometry.Ellipse.axes">axes</a></code></li>
<li><code><a title="vipy.geometry.Ellipse.boundingbox" href="#vipy.geometry.Ellipse.boundingbox">boundingbox</a></code></li>
<li><code><a title="vipy.geometry.Ellipse.center" href="#vipy.geometry.Ellipse.center">center</a></code></li>
<li><code><a title="vipy.geometry.Ellipse.centroid" href="#vipy.geometry.Ellipse.centroid">centroid</a></code></li>
<li><code><a title="vipy.geometry.Ellipse.dict" href="#vipy.geometry.Ellipse.dict">dict</a></code></li>
<li><code><a title="vipy.geometry.Ellipse.inside" href="#vipy.geometry.Ellipse.inside">inside</a></code></li>
<li><code><a title="vipy.geometry.Ellipse.mask" href="#vipy.geometry.Ellipse.mask">mask</a></code></li>
<li><code><a title="vipy.geometry.Ellipse.rescale" href="#vipy.geometry.Ellipse.rescale">rescale</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.9.3.dev21+g251d61a.d20210524</a>.</p>
</footer>
</body>
</html>