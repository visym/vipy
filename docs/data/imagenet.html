<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.6" />
<meta name="google-site-verification" content="aB8LkQegj94_TJPdrcJm2ldIRWyXY82Jp24Gtkdgyn0" />
<title>vipy.data.imagenet API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vipy.data.imagenet</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/data/imagenet.py#L1-L374" class="git-link">Browse git</a>
</summary>
<pre><code class="python">import os
import vipy
from vipy.util import readcsv, remkdir, filepath, islist, filetail, filebase, filefull, tocache, isinstalled
from vipy.image import ImageDetection, ImageCategory
import scipy.io
import numpy as np
from vipy.globals import log

try:
    import lxml.etree as ET  # faster (optional)
except:
    import xml.etree.ElementTree as ET  # slower (default)

    
URLS_2014 = [&#39;https://image-net.org/data/ILSVRC/2014/ILSVRC2014_DET_train.tar&#39;,
             &#39;https://image-net.org/data/ILSVRC/2013/ILSVRC2013_DET_val.tar&#39;,
             &#39;https://image-net.org/data/ILSVRC/2014/ILSVRC2014_DET_bbox_train.tgz&#39;,
             &#39;https://image-net.org/data/ILSVRC/2013/ILSVRC2013_DET_bbox_val.tgz&#39;,
             &#39;https://image-net.org/data/ILSVRC/2012/ILSVRC2012_bbox_train_v2.tar.gz&#39;,
             &#39;https://image-net.org/data/ILSVRC/2012/ILSVRC2012_bbox_val_v3.tgz&#39;,
             &#39;https://image-net.org/data/ILSVRC/2013/ILSVRC2013_DET_test.tar&#39;,
             &#39;https://image-net.org/data/bboxes_annotations.tar.gz&#39;]
             
URLS_2012 = [&#39;https://image-net.org/data/ILSVRC/2012/ILSVRC2012_img_train.tar&#39;,
             &#39;https://image-net.org/data/ILSVRC/2012/ILSVRC2012_img_val.tar&#39;,             
             &#39;https://image-net.org/data/ILSVRC/2012/ILSVRC2012_bbox_val_v3.tgz&#39;,
             &#39;https://image-net.org/data/ILSVRC/2012/ILSVRC2012_bbox_train_v2.tar.gz&#39;,
             &#39;https://image-net.org/data/ILSVRC/2012/ILSVRC2012_img_train_t3.tar&#39;,
             &#39;https://image-net.org/data/ILSVRC/2012/ILSVRC2012_bbox_train_dogs.tar.gz&#39;,
             &#39;https://image-net.org/data/ILSVRC/2012/ILSVRC2012_devkit_t12.tar.gz&#39;]

URL_SYNSET = &#39;https://raw.githubusercontent.com/torch/tutorials/master/7_imagenet_classification/synset_words.txt&#39;
IMAGENET21K_RESIZED_URL = &#39;https://image-net.org/data/imagenet21k_resized.tar.gz&#39;
IMAGENET21K_URL = &#39;https://image-net.org/data/winter21_whole.tar.gz&#39;
IMAGENET21K_WORDNET_ID = &#39;https://storage.googleapis.com/bit_models/imagenet21k_wordnet_ids.txt&#39;
IMAGENET21K_WORDNET_LEMMAS = &#39;https://storage.googleapis.com/bit_models/imagenet21k_wordnet_lemmas.txt&#39;
IMAGENET21K_MD5 = &#39;ab313ce03179fd803a401b02c651c0a2&#39;

IMAGENET_FACES = &#39;https://image-net.org/data/face_annotations_ILSVRC.json&#39;


class Imagenet2012():
    &#34;&#34;&#34;Imagenet2012 requires login at https://image-net.org from the same IP address as the download, and agreeing to the ImageNet terms: https://image-net.org/download-images.php#term&#34;&#34;&#34;
    def __init__(self, datadir=None, redownload=False):
        datadir = tocache(&#39;imagenet2012&#39;) if datadir is None else datadir
        
        self._datadir = remkdir(datadir)

        if redownload or not os.path.exists(os.path.join(self._datadir, &#39;.complete&#39;)):        
            for url in URLS_2012:
                vipy.downloader.download(url, os.path.join(self._datadir, filetail(url)))

            for url in URLS_2012:
                vipy.downloader.unpack(os.path.join(self._datadir, filetail(url)), remkdir(os.path.join(self._datadir, filebase(url))))

            for f in vipy.util.findtar(os.path.join(self._datadir, &#39;ILSVRC2012_img_train&#39;)):
                vipy.downloader.unpack(f, filefull(f))

            for f in vipy.util.findtar(os.path.join(self._datadir, &#39;ILSVRC2012_img_train_v3&#39;)):
                vipy.downloader.unpack(f, filefull(f))
               
            vipy.downloader.download(URL_SYNSET, os.path.join(self._datadir, &#39;synset_words.txt&#39;))
            open(os.path.join(self._datadir, &#39;.complete&#39;), &#39;a&#39;).close()        
            
        self._synset_to_categorylist = {x.split(&#39; &#39;,1)[0]:[y.lstrip().rstrip() for y in x.split(&#39; &#39;, 1)[1].split(&#39;,&#39;)] for x in vipy.util.readtxt(os.path.join(self._datadir, &#39;synset_words.txt&#39;))}            

        metadata = scipy.io.loadmat(os.path.join(self._datadir, &#39;ILSVRC2012_devkit_t12/ILSVRC2012_devkit_t12/data/meta.mat&#39;), struct_as_record=False)
        synsets = np.squeeze(metadata[&#39;synsets&#39;])
        ids = np.squeeze(np.array([s.ILSVRC2012_ID for s in synsets]))
        wnids = np.squeeze(np.array([s.WNID for s in synsets]))
        words = np.squeeze(np.array([s.words for s in synsets]))
            
        self._wnid_to_categorylist = {wnid:[c.strip() for c in category.split(&#39;,&#39;)] for (wnid,category) in zip(wnids, words)}
                                    
        
    def synset_to_category(self, s=None):
        return self._wnid_to_categorylist if s is None else self._wnid_to_categorylist[s]
    
    def classification_trainset(self):
        &#34;&#34;&#34;ImageNet2012 Classification, trainset&#34;&#34;&#34;
        imgfiles = vipy.util.findimages(os.path.join(self._datadir, &#39;ILSVRC2012_img_train&#39;))  # slow-ish, may be better to cache
        imlist = ([vipy.image.TaggedImage(filename=f, attributes={&#39;wordnet_id&#39;:f.rsplit(&#39;/&#39;,2)[-2]}, tags=self._wnid_to_categorylist[f.rsplit(&#39;/&#39;,2)[-2]]) for f in imgfiles] if os.name == &#39;posix&#39; else
                  [vipy.image.TaggedImage(filename=f, attributes={&#39;wordnet_id&#39;:os.path.basename(os.path.dirname(f))}, tags=self._wnid_to_categorylist[os.path.basename(os.path.dirname(f))]) for f in imgfiles])
        
        return vipy.dataset.Dataset(imlist, &#39;imagenet2012_classification:train&#39;)
        
    def classification_valset(self):
        &#34;&#34;&#34;ImageNet2012 Classification, valset&#34;&#34;&#34;        
        imlist = []
        imgfiles = vipy.util.findimages(os.path.join(self._datadir, &#39;ILSVRC2012_img_val&#39;))  # slow-ish, may be better to cache
                    
        # ground truth is imagenet synset index 1-1000
        gt = vipy.util.readtxt(os.path.join(self._datadir, &#39;ILSVRC2012_devkit_t12&#39;, &#39;ILSVRC2012_devkit_t12&#39;, &#39;data&#39;, &#39;ILSVRC2012_validation_ground_truth.txt&#39;))
        for (f,y) in zip(sorted(imgfiles), gt):
            imlist.append( (f, y) )

        # Index mapping is in mat file (yuck)
        synsets = self.synset_to_category()
        d_idx_to_category = {str(k):self.synset_to_category(r[0][1][0]) for (k,r) in enumerate(scipy.io.loadmat(os.path.join(self._datadir, &#39;ILSVRC2012_devkit_t12/ILSVRC2012_devkit_t12/data/meta.mat&#39;))[&#39;synsets&#39;], start=1) if r[0][1][0] in synsets}

        imlist = [vipy.image.TaggedImage(filename=f, attributes={&#39;synset_index&#39;:y}, tags=d_idx_to_category[y]) for (f,y) in imlist] 
        return vipy.dataset.Dataset(imlist, &#39;imagenet2012_classification:val&#39;)

    def faces(self):
        &#34;&#34;&#34;Return all annotated faces in 2012 train and val sets:
        https://image-net.org/face-obfuscation/
        &#34;&#34;&#34;

        cachefile = os.path.join(self._datadir, &#39;faces.json&#39;)
        if not os.path.exists(cachefile):        
            if not os.path.exists(os.path.join(self._datadir, &#39;face_annotations_ILSVRC.json&#39;)):
                vipy.downloader.download(IMAGENET_FACES, os.path.join(self._datadir, filetail(IMAGENET_FACES)))

            faces = {vipy.util.filetail(d[&#39;url&#39;]):d[&#39;bboxes&#39;] for d in vipy.util.readjson(os.path.join(self._datadir, &#39;face_annotations_ILSVRC.json&#39;))}
            imgfiles = vipy.util.findimages(os.path.join(self._datadir, &#39;ILSVRC2012_img_train&#39;))  # slow-ish, may be better to cache
            imgfiles += vipy.util.findimages(os.path.join(self._datadir, &#39;ILSVRC2012_img_val&#39;))  # slow-ish, may be better to cache
            
            imlist = [vipy.image.Scene(filename=f).objects([vipy.object.Detection(category=&#39;face&#39;, xmin=o[&#39;x0&#39;], ymin=o[&#39;y0&#39;], xmax=o[&#39;x1&#39;], ymax=o[&#39;y1&#39;]) for o in (faces[filetail(f)] if filetail(f) in faces else [])]) for f in imgfiles]
            vipy.save(imlist, cachefile)
        else:
            try:
                imlist = vipy.load(cachefile)
            except:
                if os.path.exists(cachefile):
                    os.remove(cachefile)  # force recache on failure
                return self.faces()
            
        return vipy.dataset.Dataset([im for im in imlist if im.num_objects()&gt;0], &#39;imagenet2012_faces:train&#39;)
        
    def localization_trainset(self):
        &#34;&#34;&#34;ImageNet2012 localization, imageset = {train, val}, this takes a long time to read the XML files, load and cache&#34;&#34;&#34;

        cachefile = os.path.join(self._datadir, &#39;localization_trainset.json&#39;)
        if not os.path.exists(cachefile):
            log.warning(&#39;Initial parsing of XML files for imagenet-localization takes a long time... Consider &#34;pip install lxml ujson&#34; to speed this up&#39;)
        
            imlist = []
            classification = self.classification_trainset()
            synsets = self.synset_to_category()
            for f in classification._ds:                
                xmlfile = &#39;%s.xml&#39; % filefull(f.replace(&#39;ILSVRC2012_img_train&#39;, &#39;ILSVRC2012_bbox_train_v2&#39;))
                im = vipy.image.Scene(filename=f)
                if os.path.exists(xmlfile):
                    root = ET.parse(xmlfile).getroot()  
                    for obj in root.findall(&#34;object&#34;):
                        name = obj.findtext(&#34;name&#34;)
                        b = obj.find(&#34;bndbox&#34;)
                        xmin = int(b.findtext(&#34;xmin&#34;))
                        ymin = int(b.findtext(&#34;ymin&#34;))
                        xmax = int(b.findtext(&#34;xmax&#34;))
                        ymax = int(b.findtext(&#34;ymax&#34;))
                        im.add_object(vipy.object.Detection(tags=synsets[name] if name in synsets else [name], xmin=xmin, ymin=ymin, xmax=xmax, ymax=ymax))
                if im.num_objects()&gt;0:
                    imlist.append(im)                
            vipy.save(imlist, cachefile)  # cached
            
        else:
            try:
                imlist = vipy.load(cachefile)
            except:
                if os.path.exists(cachefile):
                    os.remove(cachefile)  # force recache on failure
                return self.localization_trainset()  
                               
        return vipy.dataset.Dataset(imlist, &#39;imagenet2012_localization:train&#39;)
    
                
class Imagenet21K_Resized(vipy.dataset.Dataset):
    &#34;&#34;&#34;Imagenet21K_Resized requires login at https://image-net.org from the same IP address as the download, and agreeing to the ImageNet terms: https://image-net.org/download-images.php#term    
       https://image-net.org/download-images.php, imagenet-21K 2021 release (&#34;squish&#34; resized)&#34;&#34;&#34;
    def __init__(self, datadir=None, aslemma=True, redownload=False, recache=False):

        datadir = tocache(&#39;imagenet21k_resized&#39;) if datadir is None else datadir
        
        self._datadir = vipy.util.remkdir(datadir)
        
        if redownload or not os.path.exists(os.path.join(self._datadir, &#39;.complete&#39;)):
            vipy.globals.log.info(&#39;[vipy.data.imagenet]: downloading Imagenet-21K resized to &#34;%s&#34;&#39; % self._datadir)            
            vipy.downloader.download_and_unpack(IMAGENET21K_RESIZED_URL, self._datadir, sha1=None)
            vipy.downloader.download(IMAGENET21K_WORDNET_ID, os.path.join(self._datadir, &#39;imagenet21k_wordnet_ids.txt&#39;))
            vipy.downloader.download(IMAGENET21K_WORDNET_LEMMAS, os.path.join(self._datadir, &#39;imagenet21k_wordnet_lemmas.txt&#39;))

            open(os.path.join(self._datadir, &#39;.complete&#39;), &#39;a&#39;).close()
        
        # Class names: https://github.com/google-research/big_transfer/issues/7
        self._synset_to_categorylist = {x:[y.rstrip().lstrip() for y in lemma.split(&#39;,&#39;)] for (x,lemma) in zip(vipy.util.readtxt(os.path.join(self._datadir, &#39;imagenet21k_wordnet_ids.txt&#39;)), vipy.util.readtxt(os.path.join(self._datadir, &#39;imagenet21k_wordnet_lemmas.txt&#39;)))}

        cachefile = os.path.join(self._datadir, &#39;.imlist.txt&#39;)
        if recache and os.path.exists(cachefile):
            os.remove(cachefile)
            
        f_category = lambda c, synset_to_categorylist=self._synset_to_categorylist, aslemma=aslemma: synset_to_categorylist[c][0] if aslemma else c        
        imlist = vipy.util.findimages(os.path.join(datadir, &#39;imagenet21k_resized&#39;)) if not os.path.exists(cachefile) else [os.path.join(self._datadir, f) for f in vipy.util.readlist(cachefile)]
        loader = lambda f, f_category=f_category: vipy.image.TaggegdImage(filename=f,
                                                                          attributes={&#39;wordnet_id&#39;:vipy.util.filebase(vipy.util.filepath(f))},
                                                                          tags=f_category(vipy.util.filebase(vipy.util.filepath(f))))
        super().__init__(imlist, id=&#39;imagenet21k_resized&#39;, loader=loader)

        if not os.path.exists(cachefile):
            vipy.util.writelist([f.replace(self._datadir + &#39;/&#39;, &#39;&#39;) for f in imlist], cachefile)  # cache me for faster loading instead of walking the directory tree        

        
    def synset_to_category(self, s=None):
        return self._synset_to_categorylist if s is None else self._synset_to_categorylist[s]
        

class Imagenet21K(vipy.dataset.Dataset):
    &#34;&#34;&#34;Imagenet21K requires login at https://image-net.org from the same IP address as the download, and agreeing to the ImageNet terms: https://image-net.org/download-images.php#term    
       imagenet-21K 2021 winter release
    &#34;&#34;&#34;
    def __init__(self, datadir=None, aslemma=True, redownload=False, recache=False):

        datadir = tocache(&#39;imagenet21k&#39;) if datadir is None else datadir
        
        self._datadir = vipy.util.remkdir(datadir)
        
        if redownload or not os.path.exists(os.path.join(self._datadir, &#39;.complete&#39;)):
            if isinstalled(&#39;wget&#39;):
                vipy.globals.log.info(&#39;downloading &#34;%s&#34; to &#34;%s&#34;&#39; % (IMAGENET21K_URL , self._datadir))                
                os.system(&#39;wget --no-check-certificate --continue --tries=32 -O %s %s &#39; % (os.path.join(self._datadir, filetail(IMAGENET21K_URL)), IMAGENET21K_URL))  # server fails many times, need smart continue
            else:
                vipy.downloader.download(IMAGENET21K_URL, os.path.join(self._datadir, filetail(IMAGENET21K_URL)))  # fallback on dumb downloader
            vipy.downloader.unpack(os.path.join(self._datadir, filetail(IMAGENET21K_URL)), self._datadir)  # fallback on dumb downloader

            for f in vipy.util.findtar(os.path.join(datadir, &#39;winter21_whole&#39;)):
                if not os.path.exists(filefull(f)):
                    vipy.downloader.unpack(f, filefull(f), progress=False)
                    os.remove(f)  # cleanup
                
            vipy.downloader.download(IMAGENET21K_WORDNET_ID, os.path.join(self._datadir, &#39;imagenet21k_wordnet_ids.txt&#39;))
            vipy.downloader.download(IMAGENET21K_WORDNET_LEMMAS, os.path.join(self._datadir, &#39;imagenet21k_wordnet_lemmas.txt&#39;))

            open(os.path.join(self._datadir, &#39;.complete&#39;), &#39;a&#39;).close()
        
        cachefile = os.path.join(self._datadir, &#39;.imlist.txt&#39;)
        if recache and os.path.exists(cachefile):
            os.remove(cachefile)
            
        # Class names: https://github.com/google-research/big_transfer/issues/7
        self._synset_to_categorylist = {x:[y.rstrip().lstrip() for y in lemma.split(&#39;,&#39;)] for (x,lemma) in zip(vipy.util.readtxt(os.path.join(self._datadir, &#39;imagenet21k_wordnet_ids.txt&#39;)), vipy.util.readtxt(os.path.join(self._datadir, &#39;imagenet21k_wordnet_lemmas.txt&#39;)))}

        f_category = lambda c, synset_to_categorylist=self._synset_to_categorylist, aslemma=aslemma: synset_to_categorylist[c] if aslemma else c
        imglist = vipy.util.findimages(os.path.join(datadir, &#39;winter21_whole&#39;)) if not os.path.exists(cachefile) else vipy.util.readlist(cachefile)
        
        imlist = ([vipy.image.TaggedImage(filename=f, attributes={&#39;wordnet_id&#39;:f.rsplit(&#39;/&#39;,2)[-2]}, tags=f_category(f.rsplit(&#39;/&#39;,2)[-2])) for f in imglist] if os.name == &#39;posix&#39; else
                  [vipy.image.TaggedImage(filename=f, attributes={&#39;wordnet_id&#39;:os.path.basename(os.path.dirname(f))}, tags=f_category(os.path.basename(os.path.dirname(f)))) for f in imglist])
        super().__init__(imlist, id=&#39;imagenet21k&#39;)

        if not os.path.exists(cachefile):
            vipy.util.writelist(imlist, cachefile)  # cache me for faster loading instead of walking the directory tree, not relocatable

        
    def synset_to_category(self, s=None):
        return self._synset_to_categorylist if s is None else self._synset_to_categorylist[s]
         
   
class Imagenet2014_DET():
    &#34;&#34;&#34;Imagenet2014_DET requires login at https://image-net.org from the same IP address as the download, and agreeing to the ImageNet terms: https://image-net.org/download-images.php#term&#34;&#34;&#34;    
    def __init__(self, datadir=None, redownload=False, recache=False):    
        datadir = tocache(&#39;imagenet2014_det&#39;) if datadir is None else datadir
        
        self._datadir = remkdir(datadir)

        if recache:
            if os.path.exists(os.path.join(self._datadir, &#39;imagenet2014_det_trainset.json&#39;)):
                os.remove(os.path.join(self._datadir, &#39;imagenet2014_det_trainset.json&#39;))
            if os.path.exists(os.path.join(self._datadir, &#39;imagenet2014_det_valset.json&#39;)):
                os.remove(os.path.join(self._datadir, &#39;imagenet2014_det_valset.json&#39;))
                
        if redownload or not os.path.exists(os.path.join(self._datadir, &#39;.complete&#39;)):
            for url in URLS_2014:
                vipy.downloader.download(url, os.path.join(self._datadir, filetail(url)))

            vipy.downloader.download(IMAGENET21K_WORDNET_ID, os.path.join(self._datadir, &#39;imagenet21k_wordnet_ids.txt&#39;))
            vipy.downloader.download(IMAGENET21K_WORDNET_LEMMAS, os.path.join(self._datadir, &#39;imagenet21k_wordnet_lemmas.txt&#39;))
                
            for url in URLS_2014:
                vipy.downloader.unpack(os.path.join(self._datadir, filetail(url)), remkdir(os.path.join(self._datadir, filebase(url))))
        
            for f in vipy.util.findtar(os.path.join(self._datadir, &#39;ILSVRC2014_DET_train&#39;)):
                vipy.downloader.unpack(f, filefull(f))

            for f in vipy.util.findtar(os.path.join(self._datadir, &#39;ILSVRC2014_DET_val&#39;)):
                vipy.downloader.unpack(f, filefull(f))

            for f in vipy.util.findtargz(os.path.join(self._datadir, &#39;bboxes_annotation&#39;)):
                vipy.downloader.unpack(f, filefull(f))
                
            open(os.path.join(self._datadir, &#39;.complete&#39;), &#39;a&#39;).close()        

    def synset_to_category(self):
        return {x:[y.rstrip().lstrip() for y in lemma.split(&#39;,&#39;)] for (x,lemma) in zip(vipy.util.readtxt(os.path.join(self._datadir, &#39;imagenet21k_wordnet_ids.txt&#39;)), vipy.util.readtxt(os.path.join(self._datadir, &#39;imagenet21k_wordnet_lemmas.txt&#39;)))}        
            
    def trainset(self):
        cachefile = os.path.join(self._datadir, &#39;imagenet2014_det_trainset.json&#39;)

        if not os.path.exists(cachefile):
            log.warning(&#39;Initial parsing of XML files takes a long time... Consider &#34;pip install lxml ujson&#34; to speed this up&#39;)            
            imgfiles = {filebase(f):f for f in vipy.util.findimages(os.path.join(self._datadir, &#39;ILSVRC2014_DET_train&#39;))}  # slow-ish
            xmlfiles = {filebase(f):f for f in vipy.util.findxml(os.path.join(self._datadir, &#39;bboxes_annotation&#39;))}  # slow-ish
            xmlfiles |= {filebase(f):f for f in vipy.util.findxml(os.path.join(self._datadir, &#39;ILSVRC2014_DET_bbox_train&#39;))}  # slow-ish
            xmlfiles |= {filebase(f):f for f in vipy.util.findxml(os.path.join(self._datadir, &#39;ILSVRC2012_bbox_train_v2&#39;))}  # slow-ish
            d_synset_to_category = self.synset_to_category()
            
            imlist = []        
            for (k,f) in imgfiles.items():
                im = vipy.image.Scene(filename=f)
                if k in xmlfiles and os.path.exists(xmlfiles[k]):
                    root = ET.parse(xmlfiles[k]).getroot()  
                    for obj in root.findall(&#34;object&#34;):
                        name = obj.findtext(&#34;name&#34;)
                        subcategory = obj.findtext(&#34;name&#34;)                    
                        b = obj.find(&#34;bndbox&#34;)
                        xmin = int(b.findtext(&#34;xmin&#34;))
                        ymin = int(b.findtext(&#34;ymin&#34;))
                        xmax = int(b.findtext(&#34;xmax&#34;))
                        ymax = int(b.findtext(&#34;ymax&#34;))
                        tags = (d_synset_to_category[name] if name in d_synset_to_category else [name]) + (d_synset_to_category[subcategory] if subcategory in d_synset_to_category else [subcategory])
                        im.add_object(vipy.object.Detection(tags=tags, xmin=int(xmin), ymin=int(ymin), xmax=int(xmax), ymax=int(ymax), attributes={&#39;wordnet_id&#39;:name, &#39;subcategory&#39;:subcategory}))
                imlist.append(im)                
            vipy.save(imlist, cachefile)  # cached
        else:
            try:
                imlist = vipy.load(cachefile)
            except:
                if os.path.exists(cachefile):
                    os.remove(cachefile)  # force recache on failure
                return self.trainset()
            
        return vipy.dataset.Dataset(imlist, &#39;imagenet2014_det:trainset&#39;)


    def valset(self):
        cachefile = os.path.join(self._datadir, &#39;imagenet2014_det_valset.json&#39;)

        if not os.path.exists(cachefile):
            log.warning(&#39;Initial parsing of XML files takes a long time... Consider &#34;pip install lxml ujson&#34; to speed this up&#39;)            
            imgfiles = {filebase(f):f for f in vipy.util.findimages(os.path.join(self._datadir, &#39;ILSVRC2013_DET_val&#39;))}  # slow-ish
            xmlfiles = {filebase(f):f for f in vipy.util.findxml(os.path.join(self._datadir, &#39;bboxes_annotation&#39;))}  # slow-ish
            xmlfiles |= {filebase(f):f for f in vipy.util.findxml(os.path.join(self._datadir, &#39;ILSVRC2013_DET_bbox_val&#39;))}  # slow-ish
            xmlfiles |= {filebase(f):f for f in vipy.util.findxml(os.path.join(self._datadir, &#39;ILSVRC2012_bbox_val_v3&#39;))}  # slow-ish
            d_synset_to_category = self.synset_to_category()
            
            imlist = []        
            for (k,f) in imgfiles.items():
                im = vipy.image.Scene(filename=f)
                if k in xmlfiles and os.path.exists(xmlfiles[k]):
                    root = ET.parse(xmlfiles[k]).getroot()  
                    for obj in root.findall(&#34;object&#34;):
                        name = obj.findtext(&#34;name&#34;)
                        subcategory = obj.findtext(&#34;name&#34;)                    
                        b = obj.find(&#34;bndbox&#34;)
                        xmin = int(b.findtext(&#34;xmin&#34;))
                        ymin = int(b.findtext(&#34;ymin&#34;))
                        xmax = int(b.findtext(&#34;xmax&#34;))
                        ymax = int(b.findtext(&#34;ymax&#34;))
                        tags = (d_synset_to_category[name] if name in d_synset_to_category else [name]) + (d_synset_to_category[subcategory] if subcategory in d_synset_to_category else [subcategory])
                        im.add_object(vipy.object.Detection(tags=tags, xmin=int(xmin), ymin=int(ymin), xmax=int(xmax), ymax=int(ymax), attributes={&#39;wordnet_id&#39;:name, &#39;subcategory&#39;:subcategory}))
                imlist.append(im)                
            vipy.save(imlist, cachefile)  # cached
        else:
            try:
                imlist = vipy.load(cachefile)
            except:
                if os.path.exists(cachefile):
                    os.remove(cachefile)  # force recache on failure
                return self.trainset()
            
        return vipy.dataset.Dataset(imlist, &#39;imagenet2014_det:valset&#39;)


    def testset(self):
        return vipy.dataset.Dataset.from_directory(os.path.join(self._datadir, &#39;ILSVRC2013_DET_test&#39;), filetype=&#39;jpg&#39;).id(&#39;imagenet2014_det:testset&#39;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="vipy.data.imagenet.Imagenet2012"><code class="flex name class">
<span>class <span class="ident">Imagenet2012</span></span>
<span>(</span><span>datadir=None, redownload=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Imagenet2012 requires login at <a href="https://image-net.org">https://image-net.org</a> from the same IP address as the download, and agreeing to the ImageNet terms: <a href="https://image-net.org/download-images.php#term">https://image-net.org/download-images.php#term</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/data/imagenet.py#L42-L165" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Imagenet2012():
    &#34;&#34;&#34;Imagenet2012 requires login at https://image-net.org from the same IP address as the download, and agreeing to the ImageNet terms: https://image-net.org/download-images.php#term&#34;&#34;&#34;
    def __init__(self, datadir=None, redownload=False):
        datadir = tocache(&#39;imagenet2012&#39;) if datadir is None else datadir
        
        self._datadir = remkdir(datadir)

        if redownload or not os.path.exists(os.path.join(self._datadir, &#39;.complete&#39;)):        
            for url in URLS_2012:
                vipy.downloader.download(url, os.path.join(self._datadir, filetail(url)))

            for url in URLS_2012:
                vipy.downloader.unpack(os.path.join(self._datadir, filetail(url)), remkdir(os.path.join(self._datadir, filebase(url))))

            for f in vipy.util.findtar(os.path.join(self._datadir, &#39;ILSVRC2012_img_train&#39;)):
                vipy.downloader.unpack(f, filefull(f))

            for f in vipy.util.findtar(os.path.join(self._datadir, &#39;ILSVRC2012_img_train_v3&#39;)):
                vipy.downloader.unpack(f, filefull(f))
               
            vipy.downloader.download(URL_SYNSET, os.path.join(self._datadir, &#39;synset_words.txt&#39;))
            open(os.path.join(self._datadir, &#39;.complete&#39;), &#39;a&#39;).close()        
            
        self._synset_to_categorylist = {x.split(&#39; &#39;,1)[0]:[y.lstrip().rstrip() for y in x.split(&#39; &#39;, 1)[1].split(&#39;,&#39;)] for x in vipy.util.readtxt(os.path.join(self._datadir, &#39;synset_words.txt&#39;))}            

        metadata = scipy.io.loadmat(os.path.join(self._datadir, &#39;ILSVRC2012_devkit_t12/ILSVRC2012_devkit_t12/data/meta.mat&#39;), struct_as_record=False)
        synsets = np.squeeze(metadata[&#39;synsets&#39;])
        ids = np.squeeze(np.array([s.ILSVRC2012_ID for s in synsets]))
        wnids = np.squeeze(np.array([s.WNID for s in synsets]))
        words = np.squeeze(np.array([s.words for s in synsets]))
            
        self._wnid_to_categorylist = {wnid:[c.strip() for c in category.split(&#39;,&#39;)] for (wnid,category) in zip(wnids, words)}
                                    
        
    def synset_to_category(self, s=None):
        return self._wnid_to_categorylist if s is None else self._wnid_to_categorylist[s]
    
    def classification_trainset(self):
        &#34;&#34;&#34;ImageNet2012 Classification, trainset&#34;&#34;&#34;
        imgfiles = vipy.util.findimages(os.path.join(self._datadir, &#39;ILSVRC2012_img_train&#39;))  # slow-ish, may be better to cache
        imlist = ([vipy.image.TaggedImage(filename=f, attributes={&#39;wordnet_id&#39;:f.rsplit(&#39;/&#39;,2)[-2]}, tags=self._wnid_to_categorylist[f.rsplit(&#39;/&#39;,2)[-2]]) for f in imgfiles] if os.name == &#39;posix&#39; else
                  [vipy.image.TaggedImage(filename=f, attributes={&#39;wordnet_id&#39;:os.path.basename(os.path.dirname(f))}, tags=self._wnid_to_categorylist[os.path.basename(os.path.dirname(f))]) for f in imgfiles])
        
        return vipy.dataset.Dataset(imlist, &#39;imagenet2012_classification:train&#39;)
        
    def classification_valset(self):
        &#34;&#34;&#34;ImageNet2012 Classification, valset&#34;&#34;&#34;        
        imlist = []
        imgfiles = vipy.util.findimages(os.path.join(self._datadir, &#39;ILSVRC2012_img_val&#39;))  # slow-ish, may be better to cache
                    
        # ground truth is imagenet synset index 1-1000
        gt = vipy.util.readtxt(os.path.join(self._datadir, &#39;ILSVRC2012_devkit_t12&#39;, &#39;ILSVRC2012_devkit_t12&#39;, &#39;data&#39;, &#39;ILSVRC2012_validation_ground_truth.txt&#39;))
        for (f,y) in zip(sorted(imgfiles), gt):
            imlist.append( (f, y) )

        # Index mapping is in mat file (yuck)
        synsets = self.synset_to_category()
        d_idx_to_category = {str(k):self.synset_to_category(r[0][1][0]) for (k,r) in enumerate(scipy.io.loadmat(os.path.join(self._datadir, &#39;ILSVRC2012_devkit_t12/ILSVRC2012_devkit_t12/data/meta.mat&#39;))[&#39;synsets&#39;], start=1) if r[0][1][0] in synsets}

        imlist = [vipy.image.TaggedImage(filename=f, attributes={&#39;synset_index&#39;:y}, tags=d_idx_to_category[y]) for (f,y) in imlist] 
        return vipy.dataset.Dataset(imlist, &#39;imagenet2012_classification:val&#39;)

    def faces(self):
        &#34;&#34;&#34;Return all annotated faces in 2012 train and val sets:
        https://image-net.org/face-obfuscation/
        &#34;&#34;&#34;

        cachefile = os.path.join(self._datadir, &#39;faces.json&#39;)
        if not os.path.exists(cachefile):        
            if not os.path.exists(os.path.join(self._datadir, &#39;face_annotations_ILSVRC.json&#39;)):
                vipy.downloader.download(IMAGENET_FACES, os.path.join(self._datadir, filetail(IMAGENET_FACES)))

            faces = {vipy.util.filetail(d[&#39;url&#39;]):d[&#39;bboxes&#39;] for d in vipy.util.readjson(os.path.join(self._datadir, &#39;face_annotations_ILSVRC.json&#39;))}
            imgfiles = vipy.util.findimages(os.path.join(self._datadir, &#39;ILSVRC2012_img_train&#39;))  # slow-ish, may be better to cache
            imgfiles += vipy.util.findimages(os.path.join(self._datadir, &#39;ILSVRC2012_img_val&#39;))  # slow-ish, may be better to cache
            
            imlist = [vipy.image.Scene(filename=f).objects([vipy.object.Detection(category=&#39;face&#39;, xmin=o[&#39;x0&#39;], ymin=o[&#39;y0&#39;], xmax=o[&#39;x1&#39;], ymax=o[&#39;y1&#39;]) for o in (faces[filetail(f)] if filetail(f) in faces else [])]) for f in imgfiles]
            vipy.save(imlist, cachefile)
        else:
            try:
                imlist = vipy.load(cachefile)
            except:
                if os.path.exists(cachefile):
                    os.remove(cachefile)  # force recache on failure
                return self.faces()
            
        return vipy.dataset.Dataset([im for im in imlist if im.num_objects()&gt;0], &#39;imagenet2012_faces:train&#39;)
        
    def localization_trainset(self):
        &#34;&#34;&#34;ImageNet2012 localization, imageset = {train, val}, this takes a long time to read the XML files, load and cache&#34;&#34;&#34;

        cachefile = os.path.join(self._datadir, &#39;localization_trainset.json&#39;)
        if not os.path.exists(cachefile):
            log.warning(&#39;Initial parsing of XML files for imagenet-localization takes a long time... Consider &#34;pip install lxml ujson&#34; to speed this up&#39;)
        
            imlist = []
            classification = self.classification_trainset()
            synsets = self.synset_to_category()
            for f in classification._ds:                
                xmlfile = &#39;%s.xml&#39; % filefull(f.replace(&#39;ILSVRC2012_img_train&#39;, &#39;ILSVRC2012_bbox_train_v2&#39;))
                im = vipy.image.Scene(filename=f)
                if os.path.exists(xmlfile):
                    root = ET.parse(xmlfile).getroot()  
                    for obj in root.findall(&#34;object&#34;):
                        name = obj.findtext(&#34;name&#34;)
                        b = obj.find(&#34;bndbox&#34;)
                        xmin = int(b.findtext(&#34;xmin&#34;))
                        ymin = int(b.findtext(&#34;ymin&#34;))
                        xmax = int(b.findtext(&#34;xmax&#34;))
                        ymax = int(b.findtext(&#34;ymax&#34;))
                        im.add_object(vipy.object.Detection(tags=synsets[name] if name in synsets else [name], xmin=xmin, ymin=ymin, xmax=xmax, ymax=ymax))
                if im.num_objects()&gt;0:
                    imlist.append(im)                
            vipy.save(imlist, cachefile)  # cached
            
        else:
            try:
                imlist = vipy.load(cachefile)
            except:
                if os.path.exists(cachefile):
                    os.remove(cachefile)  # force recache on failure
                return self.localization_trainset()  
                               
        return vipy.dataset.Dataset(imlist, &#39;imagenet2012_localization:train&#39;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="vipy.data.imagenet.Imagenet2012.classification_trainset"><code class="name flex">
<span>def <span class="ident">classification_trainset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>ImageNet2012 Classification, trainset</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/data/imagenet.py#L79-L85" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def classification_trainset(self):
    &#34;&#34;&#34;ImageNet2012 Classification, trainset&#34;&#34;&#34;
    imgfiles = vipy.util.findimages(os.path.join(self._datadir, &#39;ILSVRC2012_img_train&#39;))  # slow-ish, may be better to cache
    imlist = ([vipy.image.TaggedImage(filename=f, attributes={&#39;wordnet_id&#39;:f.rsplit(&#39;/&#39;,2)[-2]}, tags=self._wnid_to_categorylist[f.rsplit(&#39;/&#39;,2)[-2]]) for f in imgfiles] if os.name == &#39;posix&#39; else
              [vipy.image.TaggedImage(filename=f, attributes={&#39;wordnet_id&#39;:os.path.basename(os.path.dirname(f))}, tags=self._wnid_to_categorylist[os.path.basename(os.path.dirname(f))]) for f in imgfiles])
    
    return vipy.dataset.Dataset(imlist, &#39;imagenet2012_classification:train&#39;)</code></pre>
</details>
</dd>
<dt id="vipy.data.imagenet.Imagenet2012.classification_valset"><code class="name flex">
<span>def <span class="ident">classification_valset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>ImageNet2012 Classification, valset</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/data/imagenet.py#L87-L102" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def classification_valset(self):
    &#34;&#34;&#34;ImageNet2012 Classification, valset&#34;&#34;&#34;        
    imlist = []
    imgfiles = vipy.util.findimages(os.path.join(self._datadir, &#39;ILSVRC2012_img_val&#39;))  # slow-ish, may be better to cache
                
    # ground truth is imagenet synset index 1-1000
    gt = vipy.util.readtxt(os.path.join(self._datadir, &#39;ILSVRC2012_devkit_t12&#39;, &#39;ILSVRC2012_devkit_t12&#39;, &#39;data&#39;, &#39;ILSVRC2012_validation_ground_truth.txt&#39;))
    for (f,y) in zip(sorted(imgfiles), gt):
        imlist.append( (f, y) )

    # Index mapping is in mat file (yuck)
    synsets = self.synset_to_category()
    d_idx_to_category = {str(k):self.synset_to_category(r[0][1][0]) for (k,r) in enumerate(scipy.io.loadmat(os.path.join(self._datadir, &#39;ILSVRC2012_devkit_t12/ILSVRC2012_devkit_t12/data/meta.mat&#39;))[&#39;synsets&#39;], start=1) if r[0][1][0] in synsets}

    imlist = [vipy.image.TaggedImage(filename=f, attributes={&#39;synset_index&#39;:y}, tags=d_idx_to_category[y]) for (f,y) in imlist] 
    return vipy.dataset.Dataset(imlist, &#39;imagenet2012_classification:val&#39;)</code></pre>
</details>
</dd>
<dt id="vipy.data.imagenet.Imagenet2012.faces"><code class="name flex">
<span>def <span class="ident">faces</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return all annotated faces in 2012 train and val sets:
<a href="https://image-net.org/face-obfuscation/">https://image-net.org/face-obfuscation/</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/data/imagenet.py#L104-L128" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def faces(self):
    &#34;&#34;&#34;Return all annotated faces in 2012 train and val sets:
    https://image-net.org/face-obfuscation/
    &#34;&#34;&#34;

    cachefile = os.path.join(self._datadir, &#39;faces.json&#39;)
    if not os.path.exists(cachefile):        
        if not os.path.exists(os.path.join(self._datadir, &#39;face_annotations_ILSVRC.json&#39;)):
            vipy.downloader.download(IMAGENET_FACES, os.path.join(self._datadir, filetail(IMAGENET_FACES)))

        faces = {vipy.util.filetail(d[&#39;url&#39;]):d[&#39;bboxes&#39;] for d in vipy.util.readjson(os.path.join(self._datadir, &#39;face_annotations_ILSVRC.json&#39;))}
        imgfiles = vipy.util.findimages(os.path.join(self._datadir, &#39;ILSVRC2012_img_train&#39;))  # slow-ish, may be better to cache
        imgfiles += vipy.util.findimages(os.path.join(self._datadir, &#39;ILSVRC2012_img_val&#39;))  # slow-ish, may be better to cache
        
        imlist = [vipy.image.Scene(filename=f).objects([vipy.object.Detection(category=&#39;face&#39;, xmin=o[&#39;x0&#39;], ymin=o[&#39;y0&#39;], xmax=o[&#39;x1&#39;], ymax=o[&#39;y1&#39;]) for o in (faces[filetail(f)] if filetail(f) in faces else [])]) for f in imgfiles]
        vipy.save(imlist, cachefile)
    else:
        try:
            imlist = vipy.load(cachefile)
        except:
            if os.path.exists(cachefile):
                os.remove(cachefile)  # force recache on failure
            return self.faces()
        
    return vipy.dataset.Dataset([im for im in imlist if im.num_objects()&gt;0], &#39;imagenet2012_faces:train&#39;)</code></pre>
</details>
</dd>
<dt id="vipy.data.imagenet.Imagenet2012.localization_trainset"><code class="name flex">
<span>def <span class="ident">localization_trainset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>ImageNet2012 localization, imageset = {train, val}, this takes a long time to read the XML files, load and cache</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/data/imagenet.py#L130-L165" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def localization_trainset(self):
    &#34;&#34;&#34;ImageNet2012 localization, imageset = {train, val}, this takes a long time to read the XML files, load and cache&#34;&#34;&#34;

    cachefile = os.path.join(self._datadir, &#39;localization_trainset.json&#39;)
    if not os.path.exists(cachefile):
        log.warning(&#39;Initial parsing of XML files for imagenet-localization takes a long time... Consider &#34;pip install lxml ujson&#34; to speed this up&#39;)
    
        imlist = []
        classification = self.classification_trainset()
        synsets = self.synset_to_category()
        for f in classification._ds:                
            xmlfile = &#39;%s.xml&#39; % filefull(f.replace(&#39;ILSVRC2012_img_train&#39;, &#39;ILSVRC2012_bbox_train_v2&#39;))
            im = vipy.image.Scene(filename=f)
            if os.path.exists(xmlfile):
                root = ET.parse(xmlfile).getroot()  
                for obj in root.findall(&#34;object&#34;):
                    name = obj.findtext(&#34;name&#34;)
                    b = obj.find(&#34;bndbox&#34;)
                    xmin = int(b.findtext(&#34;xmin&#34;))
                    ymin = int(b.findtext(&#34;ymin&#34;))
                    xmax = int(b.findtext(&#34;xmax&#34;))
                    ymax = int(b.findtext(&#34;ymax&#34;))
                    im.add_object(vipy.object.Detection(tags=synsets[name] if name in synsets else [name], xmin=xmin, ymin=ymin, xmax=xmax, ymax=ymax))
            if im.num_objects()&gt;0:
                imlist.append(im)                
        vipy.save(imlist, cachefile)  # cached
        
    else:
        try:
            imlist = vipy.load(cachefile)
        except:
            if os.path.exists(cachefile):
                os.remove(cachefile)  # force recache on failure
            return self.localization_trainset()  
                           
    return vipy.dataset.Dataset(imlist, &#39;imagenet2012_localization:train&#39;)</code></pre>
</details>
</dd>
<dt id="vipy.data.imagenet.Imagenet2012.synset_to_category"><code class="name flex">
<span>def <span class="ident">synset_to_category</span></span>(<span>self, s=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/data/imagenet.py#L76-L77" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def synset_to_category(self, s=None):
    return self._wnid_to_categorylist if s is None else self._wnid_to_categorylist[s]</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="vipy.data.imagenet.Imagenet2014_DET"><code class="flex name class">
<span>class <span class="ident">Imagenet2014_DET</span></span>
<span>(</span><span>datadir=None, redownload=False, recache=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Imagenet2014_DET requires login at <a href="https://image-net.org">https://image-net.org</a> from the same IP address as the download, and agreeing to the ImageNet terms: <a href="https://image-net.org/download-images.php#term">https://image-net.org/download-images.php#term</a></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/data/imagenet.py#L257-L373" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Imagenet2014_DET():
    &#34;&#34;&#34;Imagenet2014_DET requires login at https://image-net.org from the same IP address as the download, and agreeing to the ImageNet terms: https://image-net.org/download-images.php#term&#34;&#34;&#34;    
    def __init__(self, datadir=None, redownload=False, recache=False):    
        datadir = tocache(&#39;imagenet2014_det&#39;) if datadir is None else datadir
        
        self._datadir = remkdir(datadir)

        if recache:
            if os.path.exists(os.path.join(self._datadir, &#39;imagenet2014_det_trainset.json&#39;)):
                os.remove(os.path.join(self._datadir, &#39;imagenet2014_det_trainset.json&#39;))
            if os.path.exists(os.path.join(self._datadir, &#39;imagenet2014_det_valset.json&#39;)):
                os.remove(os.path.join(self._datadir, &#39;imagenet2014_det_valset.json&#39;))
                
        if redownload or not os.path.exists(os.path.join(self._datadir, &#39;.complete&#39;)):
            for url in URLS_2014:
                vipy.downloader.download(url, os.path.join(self._datadir, filetail(url)))

            vipy.downloader.download(IMAGENET21K_WORDNET_ID, os.path.join(self._datadir, &#39;imagenet21k_wordnet_ids.txt&#39;))
            vipy.downloader.download(IMAGENET21K_WORDNET_LEMMAS, os.path.join(self._datadir, &#39;imagenet21k_wordnet_lemmas.txt&#39;))
                
            for url in URLS_2014:
                vipy.downloader.unpack(os.path.join(self._datadir, filetail(url)), remkdir(os.path.join(self._datadir, filebase(url))))
        
            for f in vipy.util.findtar(os.path.join(self._datadir, &#39;ILSVRC2014_DET_train&#39;)):
                vipy.downloader.unpack(f, filefull(f))

            for f in vipy.util.findtar(os.path.join(self._datadir, &#39;ILSVRC2014_DET_val&#39;)):
                vipy.downloader.unpack(f, filefull(f))

            for f in vipy.util.findtargz(os.path.join(self._datadir, &#39;bboxes_annotation&#39;)):
                vipy.downloader.unpack(f, filefull(f))
                
            open(os.path.join(self._datadir, &#39;.complete&#39;), &#39;a&#39;).close()        

    def synset_to_category(self):
        return {x:[y.rstrip().lstrip() for y in lemma.split(&#39;,&#39;)] for (x,lemma) in zip(vipy.util.readtxt(os.path.join(self._datadir, &#39;imagenet21k_wordnet_ids.txt&#39;)), vipy.util.readtxt(os.path.join(self._datadir, &#39;imagenet21k_wordnet_lemmas.txt&#39;)))}        
            
    def trainset(self):
        cachefile = os.path.join(self._datadir, &#39;imagenet2014_det_trainset.json&#39;)

        if not os.path.exists(cachefile):
            log.warning(&#39;Initial parsing of XML files takes a long time... Consider &#34;pip install lxml ujson&#34; to speed this up&#39;)            
            imgfiles = {filebase(f):f for f in vipy.util.findimages(os.path.join(self._datadir, &#39;ILSVRC2014_DET_train&#39;))}  # slow-ish
            xmlfiles = {filebase(f):f for f in vipy.util.findxml(os.path.join(self._datadir, &#39;bboxes_annotation&#39;))}  # slow-ish
            xmlfiles |= {filebase(f):f for f in vipy.util.findxml(os.path.join(self._datadir, &#39;ILSVRC2014_DET_bbox_train&#39;))}  # slow-ish
            xmlfiles |= {filebase(f):f for f in vipy.util.findxml(os.path.join(self._datadir, &#39;ILSVRC2012_bbox_train_v2&#39;))}  # slow-ish
            d_synset_to_category = self.synset_to_category()
            
            imlist = []        
            for (k,f) in imgfiles.items():
                im = vipy.image.Scene(filename=f)
                if k in xmlfiles and os.path.exists(xmlfiles[k]):
                    root = ET.parse(xmlfiles[k]).getroot()  
                    for obj in root.findall(&#34;object&#34;):
                        name = obj.findtext(&#34;name&#34;)
                        subcategory = obj.findtext(&#34;name&#34;)                    
                        b = obj.find(&#34;bndbox&#34;)
                        xmin = int(b.findtext(&#34;xmin&#34;))
                        ymin = int(b.findtext(&#34;ymin&#34;))
                        xmax = int(b.findtext(&#34;xmax&#34;))
                        ymax = int(b.findtext(&#34;ymax&#34;))
                        tags = (d_synset_to_category[name] if name in d_synset_to_category else [name]) + (d_synset_to_category[subcategory] if subcategory in d_synset_to_category else [subcategory])
                        im.add_object(vipy.object.Detection(tags=tags, xmin=int(xmin), ymin=int(ymin), xmax=int(xmax), ymax=int(ymax), attributes={&#39;wordnet_id&#39;:name, &#39;subcategory&#39;:subcategory}))
                imlist.append(im)                
            vipy.save(imlist, cachefile)  # cached
        else:
            try:
                imlist = vipy.load(cachefile)
            except:
                if os.path.exists(cachefile):
                    os.remove(cachefile)  # force recache on failure
                return self.trainset()
            
        return vipy.dataset.Dataset(imlist, &#39;imagenet2014_det:trainset&#39;)


    def valset(self):
        cachefile = os.path.join(self._datadir, &#39;imagenet2014_det_valset.json&#39;)

        if not os.path.exists(cachefile):
            log.warning(&#39;Initial parsing of XML files takes a long time... Consider &#34;pip install lxml ujson&#34; to speed this up&#39;)            
            imgfiles = {filebase(f):f for f in vipy.util.findimages(os.path.join(self._datadir, &#39;ILSVRC2013_DET_val&#39;))}  # slow-ish
            xmlfiles = {filebase(f):f for f in vipy.util.findxml(os.path.join(self._datadir, &#39;bboxes_annotation&#39;))}  # slow-ish
            xmlfiles |= {filebase(f):f for f in vipy.util.findxml(os.path.join(self._datadir, &#39;ILSVRC2013_DET_bbox_val&#39;))}  # slow-ish
            xmlfiles |= {filebase(f):f for f in vipy.util.findxml(os.path.join(self._datadir, &#39;ILSVRC2012_bbox_val_v3&#39;))}  # slow-ish
            d_synset_to_category = self.synset_to_category()
            
            imlist = []        
            for (k,f) in imgfiles.items():
                im = vipy.image.Scene(filename=f)
                if k in xmlfiles and os.path.exists(xmlfiles[k]):
                    root = ET.parse(xmlfiles[k]).getroot()  
                    for obj in root.findall(&#34;object&#34;):
                        name = obj.findtext(&#34;name&#34;)
                        subcategory = obj.findtext(&#34;name&#34;)                    
                        b = obj.find(&#34;bndbox&#34;)
                        xmin = int(b.findtext(&#34;xmin&#34;))
                        ymin = int(b.findtext(&#34;ymin&#34;))
                        xmax = int(b.findtext(&#34;xmax&#34;))
                        ymax = int(b.findtext(&#34;ymax&#34;))
                        tags = (d_synset_to_category[name] if name in d_synset_to_category else [name]) + (d_synset_to_category[subcategory] if subcategory in d_synset_to_category else [subcategory])
                        im.add_object(vipy.object.Detection(tags=tags, xmin=int(xmin), ymin=int(ymin), xmax=int(xmax), ymax=int(ymax), attributes={&#39;wordnet_id&#39;:name, &#39;subcategory&#39;:subcategory}))
                imlist.append(im)                
            vipy.save(imlist, cachefile)  # cached
        else:
            try:
                imlist = vipy.load(cachefile)
            except:
                if os.path.exists(cachefile):
                    os.remove(cachefile)  # force recache on failure
                return self.trainset()
            
        return vipy.dataset.Dataset(imlist, &#39;imagenet2014_det:valset&#39;)


    def testset(self):
        return vipy.dataset.Dataset.from_directory(os.path.join(self._datadir, &#39;ILSVRC2013_DET_test&#39;), filetype=&#39;jpg&#39;).id(&#39;imagenet2014_det:testset&#39;)</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="vipy.data.imagenet.Imagenet2014_DET.synset_to_category"><code class="name flex">
<span>def <span class="ident">synset_to_category</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/data/imagenet.py#L291-L292" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def synset_to_category(self):
    return {x:[y.rstrip().lstrip() for y in lemma.split(&#39;,&#39;)] for (x,lemma) in zip(vipy.util.readtxt(os.path.join(self._datadir, &#39;imagenet21k_wordnet_ids.txt&#39;)), vipy.util.readtxt(os.path.join(self._datadir, &#39;imagenet21k_wordnet_lemmas.txt&#39;)))}        </code></pre>
</details>
</dd>
<dt id="vipy.data.imagenet.Imagenet2014_DET.testset"><code class="name flex">
<span>def <span class="ident">testset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/data/imagenet.py#L372-L373" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def testset(self):
    return vipy.dataset.Dataset.from_directory(os.path.join(self._datadir, &#39;ILSVRC2013_DET_test&#39;), filetype=&#39;jpg&#39;).id(&#39;imagenet2014_det:testset&#39;)</code></pre>
</details>
</dd>
<dt id="vipy.data.imagenet.Imagenet2014_DET.trainset"><code class="name flex">
<span>def <span class="ident">trainset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/data/imagenet.py#L294-L330" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def trainset(self):
    cachefile = os.path.join(self._datadir, &#39;imagenet2014_det_trainset.json&#39;)

    if not os.path.exists(cachefile):
        log.warning(&#39;Initial parsing of XML files takes a long time... Consider &#34;pip install lxml ujson&#34; to speed this up&#39;)            
        imgfiles = {filebase(f):f for f in vipy.util.findimages(os.path.join(self._datadir, &#39;ILSVRC2014_DET_train&#39;))}  # slow-ish
        xmlfiles = {filebase(f):f for f in vipy.util.findxml(os.path.join(self._datadir, &#39;bboxes_annotation&#39;))}  # slow-ish
        xmlfiles |= {filebase(f):f for f in vipy.util.findxml(os.path.join(self._datadir, &#39;ILSVRC2014_DET_bbox_train&#39;))}  # slow-ish
        xmlfiles |= {filebase(f):f for f in vipy.util.findxml(os.path.join(self._datadir, &#39;ILSVRC2012_bbox_train_v2&#39;))}  # slow-ish
        d_synset_to_category = self.synset_to_category()
        
        imlist = []        
        for (k,f) in imgfiles.items():
            im = vipy.image.Scene(filename=f)
            if k in xmlfiles and os.path.exists(xmlfiles[k]):
                root = ET.parse(xmlfiles[k]).getroot()  
                for obj in root.findall(&#34;object&#34;):
                    name = obj.findtext(&#34;name&#34;)
                    subcategory = obj.findtext(&#34;name&#34;)                    
                    b = obj.find(&#34;bndbox&#34;)
                    xmin = int(b.findtext(&#34;xmin&#34;))
                    ymin = int(b.findtext(&#34;ymin&#34;))
                    xmax = int(b.findtext(&#34;xmax&#34;))
                    ymax = int(b.findtext(&#34;ymax&#34;))
                    tags = (d_synset_to_category[name] if name in d_synset_to_category else [name]) + (d_synset_to_category[subcategory] if subcategory in d_synset_to_category else [subcategory])
                    im.add_object(vipy.object.Detection(tags=tags, xmin=int(xmin), ymin=int(ymin), xmax=int(xmax), ymax=int(ymax), attributes={&#39;wordnet_id&#39;:name, &#39;subcategory&#39;:subcategory}))
            imlist.append(im)                
        vipy.save(imlist, cachefile)  # cached
    else:
        try:
            imlist = vipy.load(cachefile)
        except:
            if os.path.exists(cachefile):
                os.remove(cachefile)  # force recache on failure
            return self.trainset()
        
    return vipy.dataset.Dataset(imlist, &#39;imagenet2014_det:trainset&#39;)</code></pre>
</details>
</dd>
<dt id="vipy.data.imagenet.Imagenet2014_DET.valset"><code class="name flex">
<span>def <span class="ident">valset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/data/imagenet.py#L333-L369" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def valset(self):
    cachefile = os.path.join(self._datadir, &#39;imagenet2014_det_valset.json&#39;)

    if not os.path.exists(cachefile):
        log.warning(&#39;Initial parsing of XML files takes a long time... Consider &#34;pip install lxml ujson&#34; to speed this up&#39;)            
        imgfiles = {filebase(f):f for f in vipy.util.findimages(os.path.join(self._datadir, &#39;ILSVRC2013_DET_val&#39;))}  # slow-ish
        xmlfiles = {filebase(f):f for f in vipy.util.findxml(os.path.join(self._datadir, &#39;bboxes_annotation&#39;))}  # slow-ish
        xmlfiles |= {filebase(f):f for f in vipy.util.findxml(os.path.join(self._datadir, &#39;ILSVRC2013_DET_bbox_val&#39;))}  # slow-ish
        xmlfiles |= {filebase(f):f for f in vipy.util.findxml(os.path.join(self._datadir, &#39;ILSVRC2012_bbox_val_v3&#39;))}  # slow-ish
        d_synset_to_category = self.synset_to_category()
        
        imlist = []        
        for (k,f) in imgfiles.items():
            im = vipy.image.Scene(filename=f)
            if k in xmlfiles and os.path.exists(xmlfiles[k]):
                root = ET.parse(xmlfiles[k]).getroot()  
                for obj in root.findall(&#34;object&#34;):
                    name = obj.findtext(&#34;name&#34;)
                    subcategory = obj.findtext(&#34;name&#34;)                    
                    b = obj.find(&#34;bndbox&#34;)
                    xmin = int(b.findtext(&#34;xmin&#34;))
                    ymin = int(b.findtext(&#34;ymin&#34;))
                    xmax = int(b.findtext(&#34;xmax&#34;))
                    ymax = int(b.findtext(&#34;ymax&#34;))
                    tags = (d_synset_to_category[name] if name in d_synset_to_category else [name]) + (d_synset_to_category[subcategory] if subcategory in d_synset_to_category else [subcategory])
                    im.add_object(vipy.object.Detection(tags=tags, xmin=int(xmin), ymin=int(ymin), xmax=int(xmax), ymax=int(ymax), attributes={&#39;wordnet_id&#39;:name, &#39;subcategory&#39;:subcategory}))
            imlist.append(im)                
        vipy.save(imlist, cachefile)  # cached
    else:
        try:
            imlist = vipy.load(cachefile)
        except:
            if os.path.exists(cachefile):
                os.remove(cachefile)  # force recache on failure
            return self.trainset()
        
    return vipy.dataset.Dataset(imlist, &#39;imagenet2014_det:valset&#39;)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="vipy.data.imagenet.Imagenet21K"><code class="flex name class">
<span>class <span class="ident">Imagenet21K</span></span>
<span>(</span><span>datadir=None, aslemma=True, redownload=False, recache=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Imagenet21K requires login at <a href="https://image-net.org">https://image-net.org</a> from the same IP address as the download, and agreeing to the ImageNet terms: <a href="https://image-net.org/download-images.php#term">https://image-net.org/download-images.php#term</a>
<br>
imagenet-21K 2021 winter release</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/data/imagenet.py#L207-L254" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Imagenet21K(vipy.dataset.Dataset):
    &#34;&#34;&#34;Imagenet21K requires login at https://image-net.org from the same IP address as the download, and agreeing to the ImageNet terms: https://image-net.org/download-images.php#term    
       imagenet-21K 2021 winter release
    &#34;&#34;&#34;
    def __init__(self, datadir=None, aslemma=True, redownload=False, recache=False):

        datadir = tocache(&#39;imagenet21k&#39;) if datadir is None else datadir
        
        self._datadir = vipy.util.remkdir(datadir)
        
        if redownload or not os.path.exists(os.path.join(self._datadir, &#39;.complete&#39;)):
            if isinstalled(&#39;wget&#39;):
                vipy.globals.log.info(&#39;downloading &#34;%s&#34; to &#34;%s&#34;&#39; % (IMAGENET21K_URL , self._datadir))                
                os.system(&#39;wget --no-check-certificate --continue --tries=32 -O %s %s &#39; % (os.path.join(self._datadir, filetail(IMAGENET21K_URL)), IMAGENET21K_URL))  # server fails many times, need smart continue
            else:
                vipy.downloader.download(IMAGENET21K_URL, os.path.join(self._datadir, filetail(IMAGENET21K_URL)))  # fallback on dumb downloader
            vipy.downloader.unpack(os.path.join(self._datadir, filetail(IMAGENET21K_URL)), self._datadir)  # fallback on dumb downloader

            for f in vipy.util.findtar(os.path.join(datadir, &#39;winter21_whole&#39;)):
                if not os.path.exists(filefull(f)):
                    vipy.downloader.unpack(f, filefull(f), progress=False)
                    os.remove(f)  # cleanup
                
            vipy.downloader.download(IMAGENET21K_WORDNET_ID, os.path.join(self._datadir, &#39;imagenet21k_wordnet_ids.txt&#39;))
            vipy.downloader.download(IMAGENET21K_WORDNET_LEMMAS, os.path.join(self._datadir, &#39;imagenet21k_wordnet_lemmas.txt&#39;))

            open(os.path.join(self._datadir, &#39;.complete&#39;), &#39;a&#39;).close()
        
        cachefile = os.path.join(self._datadir, &#39;.imlist.txt&#39;)
        if recache and os.path.exists(cachefile):
            os.remove(cachefile)
            
        # Class names: https://github.com/google-research/big_transfer/issues/7
        self._synset_to_categorylist = {x:[y.rstrip().lstrip() for y in lemma.split(&#39;,&#39;)] for (x,lemma) in zip(vipy.util.readtxt(os.path.join(self._datadir, &#39;imagenet21k_wordnet_ids.txt&#39;)), vipy.util.readtxt(os.path.join(self._datadir, &#39;imagenet21k_wordnet_lemmas.txt&#39;)))}

        f_category = lambda c, synset_to_categorylist=self._synset_to_categorylist, aslemma=aslemma: synset_to_categorylist[c] if aslemma else c
        imglist = vipy.util.findimages(os.path.join(datadir, &#39;winter21_whole&#39;)) if not os.path.exists(cachefile) else vipy.util.readlist(cachefile)
        
        imlist = ([vipy.image.TaggedImage(filename=f, attributes={&#39;wordnet_id&#39;:f.rsplit(&#39;/&#39;,2)[-2]}, tags=f_category(f.rsplit(&#39;/&#39;,2)[-2])) for f in imglist] if os.name == &#39;posix&#39; else
                  [vipy.image.TaggedImage(filename=f, attributes={&#39;wordnet_id&#39;:os.path.basename(os.path.dirname(f))}, tags=f_category(os.path.basename(os.path.dirname(f)))) for f in imglist])
        super().__init__(imlist, id=&#39;imagenet21k&#39;)

        if not os.path.exists(cachefile):
            vipy.util.writelist(imlist, cachefile)  # cache me for faster loading instead of walking the directory tree, not relocatable

        
    def synset_to_category(self, s=None):
        return self._synset_to_categorylist if s is None else self._synset_to_categorylist[s]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="vipy.dataset.Dataset" href="../dataset.html#vipy.dataset.Dataset">Dataset</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="vipy.data.imagenet.Imagenet21K.synset_to_category"><code class="name flex">
<span>def <span class="ident">synset_to_category</span></span>(<span>self, s=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/data/imagenet.py#L253-L254" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def synset_to_category(self, s=None):
    return self._synset_to_categorylist if s is None else self._synset_to_categorylist[s]</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vipy.dataset.Dataset" href="../dataset.html#vipy.dataset.Dataset">Dataset</a></b></code>:
<ul class="hlist">
<li><code><a title="vipy.dataset.Dataset.batch" href="../dataset.html#vipy.dataset.Dataset.batch">batch</a></code></li>
<li><code><a title="vipy.dataset.Dataset.chunk" href="../dataset.html#vipy.dataset.Dataset.chunk">chunk</a></code></li>
<li><code><a title="vipy.dataset.Dataset.chunks" href="../dataset.html#vipy.dataset.Dataset.chunks">chunks</a></code></li>
<li><code><a title="vipy.dataset.Dataset.clone" href="../dataset.html#vipy.dataset.Dataset.clone">clone</a></code></li>
<li><code><a title="vipy.dataset.Dataset.count" href="../dataset.html#vipy.dataset.Dataset.count">count</a></code></li>
<li><code><a title="vipy.dataset.Dataset.filter" href="../dataset.html#vipy.dataset.Dataset.filter">filter</a></code></li>
<li><code><a title="vipy.dataset.Dataset.frequency" href="../dataset.html#vipy.dataset.Dataset.frequency">frequency</a></code></li>
<li><code><a title="vipy.dataset.Dataset.from_directory" href="../dataset.html#vipy.dataset.Dataset.from_directory">from_directory</a></code></li>
<li><code><a title="vipy.dataset.Dataset.from_image_urls" href="../dataset.html#vipy.dataset.Dataset.from_image_urls">from_image_urls</a></code></li>
<li><code><a title="vipy.dataset.Dataset.groupby" href="../dataset.html#vipy.dataset.Dataset.groupby">groupby</a></code></li>
<li><code><a title="vipy.dataset.Dataset.id" href="../dataset.html#vipy.dataset.Dataset.id">id</a></code></li>
<li><code><a title="vipy.dataset.Dataset.identity_shuffler" href="../dataset.html#vipy.dataset.Dataset.identity_shuffler">identity_shuffler</a></code></li>
<li><code><a title="vipy.dataset.Dataset.index" href="../dataset.html#vipy.dataset.Dataset.index">index</a></code></li>
<li><code><a title="vipy.dataset.Dataset.inverse_frequency" href="../dataset.html#vipy.dataset.Dataset.inverse_frequency">inverse_frequency</a></code></li>
<li><code><a title="vipy.dataset.Dataset.list" href="../dataset.html#vipy.dataset.Dataset.list">list</a></code></li>
<li><code><a title="vipy.dataset.Dataset.load" href="../dataset.html#vipy.dataset.Dataset.load">load</a></code></li>
<li><code><a title="vipy.dataset.Dataset.localmap" href="../dataset.html#vipy.dataset.Dataset.localmap">localmap</a></code></li>
<li><code><a title="vipy.dataset.Dataset.map" href="../dataset.html#vipy.dataset.Dataset.map">map</a></code></li>
<li><code><a title="vipy.dataset.Dataset.minibatch" href="../dataset.html#vipy.dataset.Dataset.minibatch">minibatch</a></code></li>
<li><code><a title="vipy.dataset.Dataset.partition" href="../dataset.html#vipy.dataset.Dataset.partition">partition</a></code></li>
<li><code><a title="vipy.dataset.Dataset.pipeline" href="../dataset.html#vipy.dataset.Dataset.pipeline">pipeline</a></code></li>
<li><code><a title="vipy.dataset.Dataset.raw" href="../dataset.html#vipy.dataset.Dataset.raw">raw</a></code></li>
<li><code><a title="vipy.dataset.Dataset.repeat" href="../dataset.html#vipy.dataset.Dataset.repeat">repeat</a></code></li>
<li><code><a title="vipy.dataset.Dataset.sample" href="../dataset.html#vipy.dataset.Dataset.sample">sample</a></code></li>
<li><code><a title="vipy.dataset.Dataset.set" href="../dataset.html#vipy.dataset.Dataset.set">set</a></code></li>
<li><code><a title="vipy.dataset.Dataset.shift" href="../dataset.html#vipy.dataset.Dataset.shift">shift</a></code></li>
<li><code><a title="vipy.dataset.Dataset.shuffle" href="../dataset.html#vipy.dataset.Dataset.shuffle">shuffle</a></code></li>
<li><code><a title="vipy.dataset.Dataset.slice" href="../dataset.html#vipy.dataset.Dataset.slice">slice</a></code></li>
<li><code><a title="vipy.dataset.Dataset.sort" href="../dataset.html#vipy.dataset.Dataset.sort">sort</a></code></li>
<li><code><a title="vipy.dataset.Dataset.split" href="../dataset.html#vipy.dataset.Dataset.split">split</a></code></li>
<li><code><a title="vipy.dataset.Dataset.streaming_map" href="../dataset.html#vipy.dataset.Dataset.streaming_map">streaming_map</a></code></li>
<li><code><a title="vipy.dataset.Dataset.streaming_shuffler" href="../dataset.html#vipy.dataset.Dataset.streaming_shuffler">streaming_shuffler</a></code></li>
<li><code><a title="vipy.dataset.Dataset.take" href="../dataset.html#vipy.dataset.Dataset.take">take</a></code></li>
<li><code><a title="vipy.dataset.Dataset.take_fraction" href="../dataset.html#vipy.dataset.Dataset.take_fraction">take_fraction</a></code></li>
<li><code><a title="vipy.dataset.Dataset.takeby" href="../dataset.html#vipy.dataset.Dataset.takeby">takeby</a></code></li>
<li><code><a title="vipy.dataset.Dataset.takelist" href="../dataset.html#vipy.dataset.Dataset.takelist">takelist</a></code></li>
<li><code><a title="vipy.dataset.Dataset.takeone" href="../dataset.html#vipy.dataset.Dataset.takeone">takeone</a></code></li>
<li><code><a title="vipy.dataset.Dataset.truncate" href="../dataset.html#vipy.dataset.Dataset.truncate">truncate</a></code></li>
<li><code><a title="vipy.dataset.Dataset.tuple" href="../dataset.html#vipy.dataset.Dataset.tuple">tuple</a></code></li>
<li><code><a title="vipy.dataset.Dataset.uniform_shuffler" href="../dataset.html#vipy.dataset.Dataset.uniform_shuffler">uniform_shuffler</a></code></li>
<li><code><a title="vipy.dataset.Dataset.zip" href="../dataset.html#vipy.dataset.Dataset.zip">zip</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vipy.data.imagenet.Imagenet21K_Resized"><code class="flex name class">
<span>class <span class="ident">Imagenet21K_Resized</span></span>
<span>(</span><span>datadir=None, aslemma=True, redownload=False, recache=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Imagenet21K_Resized requires login at <a href="https://image-net.org">https://image-net.org</a> from the same IP address as the download, and agreeing to the ImageNet terms: <a href="https://image-net.org/download-images.php#term">https://image-net.org/download-images.php#term</a>
<br>
<a href="https://image-net.org/download-images.php,">https://image-net.org/download-images.php,</a> imagenet-21K 2021 release ("squish" resized)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/data/imagenet.py#L168-L204" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Imagenet21K_Resized(vipy.dataset.Dataset):
    &#34;&#34;&#34;Imagenet21K_Resized requires login at https://image-net.org from the same IP address as the download, and agreeing to the ImageNet terms: https://image-net.org/download-images.php#term    
       https://image-net.org/download-images.php, imagenet-21K 2021 release (&#34;squish&#34; resized)&#34;&#34;&#34;
    def __init__(self, datadir=None, aslemma=True, redownload=False, recache=False):

        datadir = tocache(&#39;imagenet21k_resized&#39;) if datadir is None else datadir
        
        self._datadir = vipy.util.remkdir(datadir)
        
        if redownload or not os.path.exists(os.path.join(self._datadir, &#39;.complete&#39;)):
            vipy.globals.log.info(&#39;[vipy.data.imagenet]: downloading Imagenet-21K resized to &#34;%s&#34;&#39; % self._datadir)            
            vipy.downloader.download_and_unpack(IMAGENET21K_RESIZED_URL, self._datadir, sha1=None)
            vipy.downloader.download(IMAGENET21K_WORDNET_ID, os.path.join(self._datadir, &#39;imagenet21k_wordnet_ids.txt&#39;))
            vipy.downloader.download(IMAGENET21K_WORDNET_LEMMAS, os.path.join(self._datadir, &#39;imagenet21k_wordnet_lemmas.txt&#39;))

            open(os.path.join(self._datadir, &#39;.complete&#39;), &#39;a&#39;).close()
        
        # Class names: https://github.com/google-research/big_transfer/issues/7
        self._synset_to_categorylist = {x:[y.rstrip().lstrip() for y in lemma.split(&#39;,&#39;)] for (x,lemma) in zip(vipy.util.readtxt(os.path.join(self._datadir, &#39;imagenet21k_wordnet_ids.txt&#39;)), vipy.util.readtxt(os.path.join(self._datadir, &#39;imagenet21k_wordnet_lemmas.txt&#39;)))}

        cachefile = os.path.join(self._datadir, &#39;.imlist.txt&#39;)
        if recache and os.path.exists(cachefile):
            os.remove(cachefile)
            
        f_category = lambda c, synset_to_categorylist=self._synset_to_categorylist, aslemma=aslemma: synset_to_categorylist[c][0] if aslemma else c        
        imlist = vipy.util.findimages(os.path.join(datadir, &#39;imagenet21k_resized&#39;)) if not os.path.exists(cachefile) else [os.path.join(self._datadir, f) for f in vipy.util.readlist(cachefile)]
        loader = lambda f, f_category=f_category: vipy.image.TaggegdImage(filename=f,
                                                                          attributes={&#39;wordnet_id&#39;:vipy.util.filebase(vipy.util.filepath(f))},
                                                                          tags=f_category(vipy.util.filebase(vipy.util.filepath(f))))
        super().__init__(imlist, id=&#39;imagenet21k_resized&#39;, loader=loader)

        if not os.path.exists(cachefile):
            vipy.util.writelist([f.replace(self._datadir + &#39;/&#39;, &#39;&#39;) for f in imlist], cachefile)  # cache me for faster loading instead of walking the directory tree        

        
    def synset_to_category(self, s=None):
        return self._synset_to_categorylist if s is None else self._synset_to_categorylist[s]</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="vipy.dataset.Dataset" href="../dataset.html#vipy.dataset.Dataset">Dataset</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="vipy.data.imagenet.Imagenet21K_Resized.synset_to_category"><code class="name flex">
<span>def <span class="ident">synset_to_category</span></span>(<span>self, s=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/data/imagenet.py#L203-L204" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def synset_to_category(self, s=None):
    return self._synset_to_categorylist if s is None else self._synset_to_categorylist[s]</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vipy.dataset.Dataset" href="../dataset.html#vipy.dataset.Dataset">Dataset</a></b></code>:
<ul class="hlist">
<li><code><a title="vipy.dataset.Dataset.batch" href="../dataset.html#vipy.dataset.Dataset.batch">batch</a></code></li>
<li><code><a title="vipy.dataset.Dataset.chunk" href="../dataset.html#vipy.dataset.Dataset.chunk">chunk</a></code></li>
<li><code><a title="vipy.dataset.Dataset.chunks" href="../dataset.html#vipy.dataset.Dataset.chunks">chunks</a></code></li>
<li><code><a title="vipy.dataset.Dataset.clone" href="../dataset.html#vipy.dataset.Dataset.clone">clone</a></code></li>
<li><code><a title="vipy.dataset.Dataset.count" href="../dataset.html#vipy.dataset.Dataset.count">count</a></code></li>
<li><code><a title="vipy.dataset.Dataset.filter" href="../dataset.html#vipy.dataset.Dataset.filter">filter</a></code></li>
<li><code><a title="vipy.dataset.Dataset.frequency" href="../dataset.html#vipy.dataset.Dataset.frequency">frequency</a></code></li>
<li><code><a title="vipy.dataset.Dataset.from_directory" href="../dataset.html#vipy.dataset.Dataset.from_directory">from_directory</a></code></li>
<li><code><a title="vipy.dataset.Dataset.from_image_urls" href="../dataset.html#vipy.dataset.Dataset.from_image_urls">from_image_urls</a></code></li>
<li><code><a title="vipy.dataset.Dataset.groupby" href="../dataset.html#vipy.dataset.Dataset.groupby">groupby</a></code></li>
<li><code><a title="vipy.dataset.Dataset.id" href="../dataset.html#vipy.dataset.Dataset.id">id</a></code></li>
<li><code><a title="vipy.dataset.Dataset.identity_shuffler" href="../dataset.html#vipy.dataset.Dataset.identity_shuffler">identity_shuffler</a></code></li>
<li><code><a title="vipy.dataset.Dataset.index" href="../dataset.html#vipy.dataset.Dataset.index">index</a></code></li>
<li><code><a title="vipy.dataset.Dataset.inverse_frequency" href="../dataset.html#vipy.dataset.Dataset.inverse_frequency">inverse_frequency</a></code></li>
<li><code><a title="vipy.dataset.Dataset.list" href="../dataset.html#vipy.dataset.Dataset.list">list</a></code></li>
<li><code><a title="vipy.dataset.Dataset.load" href="../dataset.html#vipy.dataset.Dataset.load">load</a></code></li>
<li><code><a title="vipy.dataset.Dataset.localmap" href="../dataset.html#vipy.dataset.Dataset.localmap">localmap</a></code></li>
<li><code><a title="vipy.dataset.Dataset.map" href="../dataset.html#vipy.dataset.Dataset.map">map</a></code></li>
<li><code><a title="vipy.dataset.Dataset.minibatch" href="../dataset.html#vipy.dataset.Dataset.minibatch">minibatch</a></code></li>
<li><code><a title="vipy.dataset.Dataset.partition" href="../dataset.html#vipy.dataset.Dataset.partition">partition</a></code></li>
<li><code><a title="vipy.dataset.Dataset.pipeline" href="../dataset.html#vipy.dataset.Dataset.pipeline">pipeline</a></code></li>
<li><code><a title="vipy.dataset.Dataset.raw" href="../dataset.html#vipy.dataset.Dataset.raw">raw</a></code></li>
<li><code><a title="vipy.dataset.Dataset.repeat" href="../dataset.html#vipy.dataset.Dataset.repeat">repeat</a></code></li>
<li><code><a title="vipy.dataset.Dataset.sample" href="../dataset.html#vipy.dataset.Dataset.sample">sample</a></code></li>
<li><code><a title="vipy.dataset.Dataset.set" href="../dataset.html#vipy.dataset.Dataset.set">set</a></code></li>
<li><code><a title="vipy.dataset.Dataset.shift" href="../dataset.html#vipy.dataset.Dataset.shift">shift</a></code></li>
<li><code><a title="vipy.dataset.Dataset.shuffle" href="../dataset.html#vipy.dataset.Dataset.shuffle">shuffle</a></code></li>
<li><code><a title="vipy.dataset.Dataset.slice" href="../dataset.html#vipy.dataset.Dataset.slice">slice</a></code></li>
<li><code><a title="vipy.dataset.Dataset.sort" href="../dataset.html#vipy.dataset.Dataset.sort">sort</a></code></li>
<li><code><a title="vipy.dataset.Dataset.split" href="../dataset.html#vipy.dataset.Dataset.split">split</a></code></li>
<li><code><a title="vipy.dataset.Dataset.streaming_map" href="../dataset.html#vipy.dataset.Dataset.streaming_map">streaming_map</a></code></li>
<li><code><a title="vipy.dataset.Dataset.streaming_shuffler" href="../dataset.html#vipy.dataset.Dataset.streaming_shuffler">streaming_shuffler</a></code></li>
<li><code><a title="vipy.dataset.Dataset.take" href="../dataset.html#vipy.dataset.Dataset.take">take</a></code></li>
<li><code><a title="vipy.dataset.Dataset.take_fraction" href="../dataset.html#vipy.dataset.Dataset.take_fraction">take_fraction</a></code></li>
<li><code><a title="vipy.dataset.Dataset.takeby" href="../dataset.html#vipy.dataset.Dataset.takeby">takeby</a></code></li>
<li><code><a title="vipy.dataset.Dataset.takelist" href="../dataset.html#vipy.dataset.Dataset.takelist">takelist</a></code></li>
<li><code><a title="vipy.dataset.Dataset.takeone" href="../dataset.html#vipy.dataset.Dataset.takeone">takeone</a></code></li>
<li><code><a title="vipy.dataset.Dataset.truncate" href="../dataset.html#vipy.dataset.Dataset.truncate">truncate</a></code></li>
<li><code><a title="vipy.dataset.Dataset.tuple" href="../dataset.html#vipy.dataset.Dataset.tuple">tuple</a></code></li>
<li><code><a title="vipy.dataset.Dataset.uniform_shuffler" href="../dataset.html#vipy.dataset.Dataset.uniform_shuffler">uniform_shuffler</a></code></li>
<li><code><a title="vipy.dataset.Dataset.zip" href="../dataset.html#vipy.dataset.Dataset.zip">zip</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="VIPY" href="https://github.com/visym/vipy/">
<img src="https://www.visym.com/labs/images/visym_logo_black_notext.png" alt="" width="60">
</a>
<h1 style="font-size:200%;"><b>VIPY:</b> Visual Dataset Transformation</h1>
</header>
<form>
<input id="lunr-search" name="q" placeholder=" Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = '././doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="vipy.data" href="index.html">vipy.data</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="vipy.data.imagenet.Imagenet2012" href="#vipy.data.imagenet.Imagenet2012">Imagenet2012</a></code></h4>
<ul class="">
<li><code><a title="vipy.data.imagenet.Imagenet2012.classification_trainset" href="#vipy.data.imagenet.Imagenet2012.classification_trainset">classification_trainset</a></code></li>
<li><code><a title="vipy.data.imagenet.Imagenet2012.classification_valset" href="#vipy.data.imagenet.Imagenet2012.classification_valset">classification_valset</a></code></li>
<li><code><a title="vipy.data.imagenet.Imagenet2012.faces" href="#vipy.data.imagenet.Imagenet2012.faces">faces</a></code></li>
<li><code><a title="vipy.data.imagenet.Imagenet2012.localization_trainset" href="#vipy.data.imagenet.Imagenet2012.localization_trainset">localization_trainset</a></code></li>
<li><code><a title="vipy.data.imagenet.Imagenet2012.synset_to_category" href="#vipy.data.imagenet.Imagenet2012.synset_to_category">synset_to_category</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vipy.data.imagenet.Imagenet2014_DET" href="#vipy.data.imagenet.Imagenet2014_DET">Imagenet2014_DET</a></code></h4>
<ul class="">
<li><code><a title="vipy.data.imagenet.Imagenet2014_DET.synset_to_category" href="#vipy.data.imagenet.Imagenet2014_DET.synset_to_category">synset_to_category</a></code></li>
<li><code><a title="vipy.data.imagenet.Imagenet2014_DET.testset" href="#vipy.data.imagenet.Imagenet2014_DET.testset">testset</a></code></li>
<li><code><a title="vipy.data.imagenet.Imagenet2014_DET.trainset" href="#vipy.data.imagenet.Imagenet2014_DET.trainset">trainset</a></code></li>
<li><code><a title="vipy.data.imagenet.Imagenet2014_DET.valset" href="#vipy.data.imagenet.Imagenet2014_DET.valset">valset</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vipy.data.imagenet.Imagenet21K" href="#vipy.data.imagenet.Imagenet21K">Imagenet21K</a></code></h4>
<ul class="">
<li><code><a title="vipy.data.imagenet.Imagenet21K.synset_to_category" href="#vipy.data.imagenet.Imagenet21K.synset_to_category">synset_to_category</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vipy.data.imagenet.Imagenet21K_Resized" href="#vipy.data.imagenet.Imagenet21K_Resized">Imagenet21K_Resized</a></code></h4>
<ul class="">
<li><code><a title="vipy.data.imagenet.Imagenet21K_Resized.synset_to_category" href="#vipy.data.imagenet.Imagenet21K_Resized.synset_to_category">synset_to_category</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
