<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.6" />
<meta name="google-site-verification" content="aB8LkQegj94_TJPdrcJm2ldIRWyXY82Jp24Gtkdgyn0" />
<title>vipy.util API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vipy.util</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1-L1942" class="git-link">Browse git</a>
</summary>
<pre><code class="python">import urllib.request
import urllib.parse
import urllib.error
from urllib.parse import urlparse
from os import chmod
import os.path
import numpy as np
import tempfile
import time
from time import gmtime, strftime, localtime
from datetime import datetime
import sys
import csv
import hashlib
import shutil
import re
import uuid
import builtins
import pickle as cPickle
import PIL
import matplotlib.pyplot as plt
from itertools import groupby as itertools_groupby
from itertools import tee, chain, batched
import importlib
import pathlib
import socket
import warnings
import copy
import bz2
import random
import gc

from vipy.globals import log

ALPHABET = &#34;0123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz&#34;

try:
    import ujson as json  # faster
except ImportError:
    import json

try:
    import dill as default_pickle
except:
    import pickle as default_pickle
    
def class_registry():
    &#34;&#34;&#34;Return a dictionary mapping str(type(obj)) to a JSON loader for all vipy objects.

    This function is useful for JSON loading of vipy objects to map to the correct deserialization method.
    &#34;&#34;&#34;

    import vipy.video
    import vipy.image
    import vipy.dataset

    registry = {&#34;&lt;class &#39;vipy.video.Scene&#39;&gt;&#34;:vipy.video.Scene.from_json,
                &#34;&lt;class &#39;vipy.video.Video&#39;&gt;&#34;:vipy.video.Video.from_json,
                &#34;&lt;class &#39;vipy.video.VideoCategory&#39;&gt;&#34;:vipy.video.VideoCategory.from_json,
                &#34;&lt;class &#39;vipy.image.Image&#39;&gt;&#34;:vipy.image.Image.from_json,
                &#34;&lt;class &#39;vipy.image.ImageCategory&#39;&gt;&#34;:vipy.image.ImageCategory.from_json,
                &#34;&lt;class &#39;vipy.image.ImageDetection&#39;&gt;&#34;:vipy.image.ImageDetection.from_json,            
                &#34;&lt;class &#39;vipy.image.Scene&#39;&gt;&#34;:vipy.image.Scene.from_json,
                &#34;&lt;class &#39;vipy.geometry.BoundingBox&#39;&gt;&#34;:vipy.geometry.BoundingBox.from_json,
                &#34;&lt;class &#39;vipy.object.Track&#39;&gt;&#34;:vipy.object.Track.from_json,
                &#34;&lt;class &#39;vipy.object.Detection&#39;&gt;&#34;:vipy.object.Detection.from_json,
                &#34;&lt;class &#39;vipy.activity.Activity&#39;&gt;&#34;:vipy.activity.Activity.from_json}
    try:
        import pycollector.video
        registry.update( {&#34;&lt;class &#39;pycollector.video.Video&#39;&gt;&#34;:pycollector.video.Video.from_json} )
    except:
        registry.update( {&#34;&lt;class &#39;pycollector.video.Video&#39;&gt;&#34;:lambda x: exec(&#34;raise ValueError(\&#34;&lt;class &#39;pycollector.video.Video&#39;&gt; not found - Run &#39;pip install pycollector&#39; \&#34;)&#34;)})        
    try:
        import pycollector.admin.video
        registry.update( {&#34;&lt;class &#39;pycollector.admin.video.Video&#39;&gt;&#34;:pycollector.admin.video.Video.from_json} )
    except:
        registry.update( {&#34;&lt;class &#39;pycollector.admin.video.Video&#39;&gt;&#34;:lambda x: exec(&#34;raise ValueError(\&#34;&lt;class &#39;pycollector.admin.video.Video&#39;&gt; not found - This is for admin use only \&#34;)&#34;)})        

    registry.update( {None: cPickle.loads} )  # fallback on generic pickle dumps
    return registry
            

def save(vars, outfile=None, backup=False):
    &#34;&#34;&#34;Save variables to an archive file.

    This function allows vipy objects to be serialized to disk for later loading.

    ```python
    im = vipy.image.owl()
    im = vipy.util.load(vipy.util.save(im))   # round trip
    ```

    Args:
        vars: A python object to save.  This can be any serializable python object
        outfile:  An output file to save.  Must have extension [.pkl, .json, .pkl.bz2].  If None, will save to a temporary JSON file.
        backup [bool]:  If true and the outfile already exists, make a copy and save as outfile.bak before overwriting
    Returns
        A path to the saved archive file.  Load using `vipy.util.load`. 

    .. note:: JSON is preferred as an archive format for vipy.  Be sure to install the excellent ultrajson library (pip install ujson) for fast serialization.
    &#34;&#34;&#34;
    allowable = set([&#39;.pkl&#39;, &#39;.json&#39;, &#39;.pkl.bz2&#39;])
    outfile = tempjson() if outfile is None else outfile

    if backup and os.path.exists(outfile):
        shutil.copyfile(outfile, outfile+&#39;.bak&#39;)
    remkdir(filepath(outfile))
    if ispkl(outfile):
        with open(outfile, &#39;wb&#39;) as f:
            default_pickle.dump(vars, f)

    elif isjsonfile(outfile):
        saveobj = vars
        registry = class_registry()
        if isinstance(saveobj, list) and all([str(type(d)) in registry for d in saveobj]):
            j = [{str(type(d)):d.json(encode=False)} for d in saveobj] if isinstance(saveobj, list) else ({str(type(d)):d.json(encode=False)} for d in saveobj)
        elif str(type(saveobj)) in registry:
            j = {str(type(saveobj)):saveobj.json(encode=False)}
        else:
            j = saveobj

        s = json.dumps(j, ensure_ascii=False)  # load to memory (faster than json.dump), will throw exception if it cannot serialize
        with open(outfile, &#39;w&#39;) as f:
            f.write(s)            

    elif ispklbz2(outfile):
        return pklbz2(outfile, vars)
    else:
        raise ValueError(&#39;Unknown file extension for save file &#34;%s&#34; - must be in %s&#39; % (fileext(outfile), str(allowable)))
    
    return os.path.abspath(outfile)


def load(infile, abspath=True, freeze=True, relocatable=True):
    &#34;&#34;&#34;Load variables from a relocatable archive file format, either dill pickle, JSON format or JSON directory format.
       
       Loading is performed by attemping the following:

       1. If the input file is a directory, return a `vipy.dataset.Dataset` with lazy loading of all pkl or json files recursively discovered in this directory.
       2. If the input file is a pickle or json file, load it
       3. if abspath=true, then convert relative paths to absolute paths for object when loaded
       4. If freeze=True, then disable the python reference cycle garbage collector for the object loaded by this file
    
    ```python
    im = vipy.image.owl()
    f = vipy.util.save(im)
    im = vipy.util.load(im)
    ```

       Args:
           infile: [str] file saved using `vipy.util.save` with extension [.pkl, .json].  This may also be a directory tree containing json or pkl files 
           abspath: [bool] If true, then convert all vipy objects with relative paths to absolute paths. If False, then preserve relative paths and warn user.
           freeze: [bool] If True, then disable python reference cycle garbage collector for this loaded object. 
           relocatable: [bool] If True, then perform relocatable relative and absolute paths for vipy objects containing filenames
       Returns:
           The object in the archive file
    &#34;&#34;&#34;
    if freeze:
        gc.disable()
        
    infile = os.path.abspath(os.path.expanduser(infile))

    if ispkl(infile):
        with open(infile, &#39;rb&#39;) as f:
            obj = default_pickle.load(f)
    elif isjsonfile(infile):
        with open(infile, &#39;r&#39;) as f:
            loadobj = json.load(f)
        registry = class_registry()
        assert isinstance(loadobj, list) or isinstance(loadobj, dict), &#34;invalid vipy JSON serialization format&#34;
        if isinstance(loadobj, list) and all([isinstance(d, dict) for d in loadobj]) and all([c in registry for d in loadobj for (c,v) in d.items()]):
            obj = [registry[c](v) for d in loadobj for (c,v) in d.items()]
        elif isinstance(loadobj, dict) and all([c in registry for (c,d) in loadobj.items()]):
            obj = [registry[c](v) for (c,v) in loadobj.items()]
            obj = obj[0] if len(obj) == 1 else obj
        else:
            obj = loadobj
    elif ispklbz2(infile):
        return pklbz2(infile)
    elif os.path.isdir(infile):        
        import vipy.dataset
        return vipy.dataset.Dataset.from_directory(infile)
    else:
        raise ValueError(&#39;unknown file type&#39;)
    
    # Relocatable vipy object?
    testobj = tolist(obj)[0] if len(tolist(obj)) &gt; 0 else None
    if relocatable and testobj is not None and hasattr(testobj, &#39;filename&#39;) and testobj.filename() is not None:
        if not os.path.isabs(testobj.filename()):
            if not abspath:
                warnings.warn(&#39;Loading archive &#34;%s&#34; with relative paths.  Changing directory to &#34;%s&#34;.  Disable this warning with vipy.util.load(..., abspath=True).&#39; % (infile, filepath(infile)))
                os.chdir(filepath(infile))
            else:
                # Absolute path?  The loaded archive will no longer be relocatable if you save this to a new archive, and the videos directory cannot be moved
                pwd = os.getcwd()  # save current directory
                os.chdir(filepath(infile))  # change to archive directory
                objout = [o.abspath() if o.filename() is not None else o for o in tolist(obj)]  # set absolute paths relative to archive directory
                obj = objout if isinstance(obj, list) else objout[0]
                os.chdir(pwd)  # restore current directory
        elif not testobj.hasfilename():
            warnings.warn(&#39;Loading &#34;%s&#34; that contains path (e.g. &#34;%s&#34;) which does not exist&#39; % (infile, testobj.filename()))

    # Large vipy object?  Disable garbage collection.
    #   - Python uses reference counting for the primary garbage collection mechanism, but also uses reference cycle checks to search for dependencies between objects.
    #   - All vipy objects are self contained, and do not have reference cycles.  However, there is no way to mark an individual object which does not participate in reference cycle counting.
    #   - This means that a large number of vipy objects, garbage collection can take minutes searching for cycles which are never there.  To fix this, globally disable the garbage collector.
    #   - Note that refernece counting is still performed, we are just disabling reference *cycle* counting using the generational garbage collector.
    #   - This can be re-enabled at any time by &#34;import gc; gc.enable()&#34;
    #   - If you use %autoreload iPython magic command, note that this will be very slow.  You should set %sutoreload 0
    #   - Alternatively, load as JSON and all attributes will be unpacked on demand and stored in a packed format that is not tracked (e.g. tuple of strings) by the reference cycle counter
    if freeze:
        gc.enable()
        gc.collect()
        gc.freeze() 
    return obj


def is_jsonable(obj):
    &#34;&#34;&#34;Return true if can be successfully converted to json (without actually doing it) by recursive type checking&#34;&#34;&#34;
    if isinstance(obj, (str, int, float, bool, type(None))):
        return True  # JSON types
    elif isinstance(obj, (list, tuple)):
        return all(is_jsonable(item) for item in obj)
    elif isinstance(obj, dict):
        # JSON object keys *must* be strings
        return all(isinstance(key, str) and is_jsonable(value) for key, value in obj.items())
    else:
        return False
    
def dirload(indir):
    &#34;&#34;&#34;Load a directory by recursively searching for loadable archives and loading them into a flat list&#34;&#34;&#34;
    return [x for f in findloadable(indir) for x in load(f)]

def dedupe(inlist, f):
    &#34;&#34;&#34;Deduplicate the list using the provided lambda function which transforms an element to a dedupe key, such that all elements with the same key are duplicates&#34;&#34;&#34;
    assert callable(f)
    assert isinstance(inlist, list)
    return list({f(x):x for x in inlist}.values())


def pklbz2(filename, obj=None):
    &#34;&#34;&#34;Read/Write a bz2 compressed pickle file&#34;&#34;&#34;
    assert filename[-8:] == &#39;.pkl.bz2&#39;, &#34;Invalid filename - must be &#39;*.pkl.bz2&#39;&#34;
    if obj is not None:
        f = bz2.BZ2File(filename, &#39;wb&#39;)
        default_pickle.dump(obj, f)
        f.close()
        return filename
    else:
        f = bz2.BZ2File(filename, &#39;rb&#39;)
        obj = default_pickle.load(f)
        f.close()
        return obj
        

def catcher(f, *args, **kwargs):
    &#34;&#34;&#34;Call the function f with the provided arguments, and return (True, result) on success and (False, exception) if there is any thrown exception.

    Useful for parallel processing
    Useful for wrapping a function where execptions are silent.

    For example, attempting to remove a file where the filename may be None or not present

    &gt;&gt;&gt; vipy.util.catcher(lambda f: os.remove(f), None)
    &gt;&gt;&gt; vipy.util.catcher(lambda f: os.remove(f), &#39;/path/to/missing.txt&#39;))

    &#34;&#34;&#34;
    assert callable(f)
    try:
        return (True, f(*args, **kwargs))
    except Exception as e:
        return (False, str(e))


def mergedict(*args):
    &#34;&#34;&#34;Combine keys of two or more dictionaries and return a dictionary deep copy.
    
    ```python
    d1 = {1:2}
    d2 = {3:4}
    d3 = mergedict(d1,d2)
    assert d3 == {1:2, 3:4}
    ```

    &#34;&#34;&#34;
    assert all(isinstance(d, dict) for d in args)
    assert len(args) &gt; 0
    d = copy.deepcopy(args[0])
    for o in args[1:]:
        d.update(o)
    return d


def env(var=None):
    &#34;&#34;&#34;Return the VIPY environment variable var, returning None if not present, or all environment variables if var=None.  Var is optionally prepended with &#39;VIPY_&#39;&#34;&#34;&#34;
    env = {k:v for (k,v) in os.environ.items() if k.startswith(&#39;VIPY_&#39;)}
    var = (&#39;VIPY_&#39;+var) if var is not None and not var.startswith(&#39;VIPY_&#39;) else var
    return env if var is None else (env[var] if var in env else None)

def hascache():
    &#34;&#34;&#34;Is the VIPY_CACHE environment variable set?&#34;&#34;&#34;
    return &#39;VIPY_CACHE&#39; in os.environ

def cache():
    &#34;&#34;&#34;If the VIPY_CACHE environment variable set, return it otherwise return tempdir()&#34;&#34;&#34;
    return remkdir(os.path.expanduser(os.environ[&#39;VIPY_CACHE&#39;])) if hascache() else tempdir()

def tocache(filename):
    &#34;&#34;&#34;If the VIPY_CACHE environment variable is set, then return the filename=subpath/to/file.ext in the cache as VIPY_CACHE/subpath/to/file.ext.  Otherwise, return the file in the system temp&#34;&#34;&#34;
    return os.path.join(cache(), filename)

def seconds_to_MMSS_colon_notation(sec):
    &#34;&#34;&#34;Convert integer seconds into MM:SS colon format.  If sec=121, then return &#39;02:01&#39;. &#34;&#34;&#34;
    assert isinstance(sec, int) and sec &lt;= 99*60 + 59 and sec &gt;= 0
    return &#39;%02d:%02d&#39; % (int(sec/60.0), sec % 60)

def try_import(package, pipname=None, message=None):
    &#34;&#34;&#34;Show a helpful error message for missing optional packages&#34;&#34;&#34;
    try:
        importlib.import_module(package)
    except:
        if message is not None:
            raise ImportError(message)
        else:
            raise ImportError(&#39;Optional package &#34;%s&#34; not installed -  Run &#34;pip install %s&#34; or &#34;pip install vipy[all]&#34; &#39; % (package, package if pipname is None else pipname))


def findyaml(basedir):
    &#34;&#34;&#34;Return a list of absolute paths to yaml files recursively discovered by walking the directory tree rooted at basedir&#34;&#34;&#34;
    return [str(path.resolve()) for path in pathlib.Path(basedir).rglob(&#39;*.yml&#39;)]


def findpkl(basedir):
    &#34;&#34;&#34;Return a list of absolute paths to pkl files recursively discovered by walking the directory tree rooted at basedir&#34;&#34;&#34;
    return [str(path.resolve()) for path in pathlib.Path(basedir).rglob(&#39;*.pkl&#39;)]

def findpickle(basedir):
    &#34;&#34;&#34;Return a list of absolute paths to pkl files recursively discovered by walking the directory tree rooted at basedir&#34;&#34;&#34;
    return [str(path.resolve()) for path in pathlib.Path(basedir).rglob(&#39;*.pickle&#39;)]

def findpklbz2(basedir):
    &#34;&#34;&#34;Return a list of absolute paths to .pkl.bz2 files recursively discovered by walking the directory tree rooted at basedir&#34;&#34;&#34;
    return [str(path.resolve()) for path in pathlib.Path(basedir).rglob(&#39;*.pkl.bz2&#39;)]

def findpdf(basedir):
    &#34;&#34;&#34;Return a list of absolute paths to pdf files recursively discovered by walking the directory tree rooted at basedir&#34;&#34;&#34;
    return [str(path.resolve()) for path in pathlib.Path(basedir).rglob(&#39;*.pdf&#39;)]

def findpng(basedir):
    &#34;&#34;&#34;Return a list of absolute paths to png files recursively discovered by walking the directory tree rooted at basedir&#34;&#34;&#34;
    return [str(path.resolve()) for path in pathlib.Path(basedir).rglob(&#39;*.png&#39;)]

def findjpg(basedir):
    &#34;&#34;&#34;Return a list of absolute paths to jpg files recursively discovered by walking the directory tree rooted at basedir&#34;&#34;&#34;
    return [str(path.resolve()) for path in pathlib.Path(basedir).rglob(&#39;*.jpg&#39;)]

def findjson(basedir):
    &#34;&#34;&#34;Return a list of absolute paths to json files recursively discovered by walking the directory tree rooted at basedir&#34;&#34;&#34;
    return [str(path.resolve()) for path in pathlib.Path(basedir).rglob(&#39;*.json&#39;)]

def findtxt(basedir):
    &#34;&#34;&#34;Return a list of absolute paths to txt files recursively discovered by walking the directory tree rooted at basedir&#34;&#34;&#34;
    return [str(path.resolve()) for path in pathlib.Path(basedir).rglob(&#39;*.txt&#39;)]

def findtar(basedir):
    &#34;&#34;&#34;Return a list of absolute paths to tar files recursively discovered by walking the directory tree rooted at basedir&#34;&#34;&#34;
    return [str(path.resolve()) for path in pathlib.Path(basedir).rglob(&#39;*.tar&#39;)]

def findtargz(basedir):
    &#34;&#34;&#34;Return a list of absolute paths to .pkl.bz2 files recursively discovered by walking the directory tree rooted at basedir&#34;&#34;&#34;
    return [str(path.resolve()) for path in pathlib.Path(basedir).rglob(&#39;*.tar.gz&#39;)]

def findimage(basedir):
    &#34;&#34;&#34;Return a list of absolute paths to image files recursively discovered by walking the directory tree rooted at basedir&#34;&#34;&#34;
    return [str(path.resolve()) for path in pathlib.Path(basedir).rglob(&#39;*&#39;) if isimage(str(path.resolve()))]

def findimages(basedir):
    &#34;&#34;&#34;Alias for `vipy.util.findimage`&#34;&#34;&#34;
    return findimage(basedir)

def findvideo(basedir):
    &#34;&#34;&#34;Return a list of absolute paths to video files recursively discovered by walking the directory tree rooted at basedir&#34;&#34;&#34;
    return [str(path.resolve()) for path in pathlib.Path(basedir).rglob(&#39;*&#39;) if isvideo(str(path.resolve()))]

def findwebp(basedir):
    &#34;&#34;&#34;Return a list of absolute paths to video files recursively discovered by walking the directory tree rooted at basedir&#34;&#34;&#34;
    return [str(path.resolve()) for path in pathlib.Path(basedir).rglob(&#39;*&#39;) if iswebp(str(path.resolve()))]

def findxml(basedir):
    &#34;&#34;&#34;Return a list of absolute paths to video files recursively discovered by walking the directory tree rooted at basedir&#34;&#34;&#34;
    return [str(path.resolve()) for path in pathlib.Path(basedir).rglob(&#39;*.xml&#39;)]

def findvideos(basedir):
    &#34;&#34;&#34;Alias for `vipy.util.findvideo`&#34;&#34;&#34;
    return findvideo(basedir)

def findloadable(basedir):
    &#34;&#34;&#34;Return a list of absolute paths to any archive file loadable by `vipy.load` (*.pkl, *.json, *.pkl.bz2).  Recursively search starting from basedir&#34;&#34;&#34;
    return findpkl(basedir) + findjson(basedir) + findpklbz2(basedir) + findpickle(basedir)

def readyaml(yamlfile):
    &#34;&#34;&#34;Read a yaml file and return a parsed dictionary, this is slow for large yaml files&#34;&#34;&#34;
    try_import(&#39;yaml&#39;, &#39;pyyaml&#39;)
    import yaml    
    try:
            from yaml import CLoader as Loader
    except ImportError:
            from yaml import Loader

    with open(yamlfile, &#39;r&#39;) as f:
        return yaml.load(f.read(), Loader=Loader)  # yaml.CLoader is faster, but not installed via pip


def count_images_in_subdirectories(indir):
    &#34;&#34;&#34;Count the total number of images in indir/subdir1, indir/subdir2, go down only one level and no further...&#34;&#34;&#34;
    num_files = 0
    for d in dirlist(outdir):
        num_files += len(imlist(d))
    return num_files


def keymax(d):
    &#34;&#34;&#34;Return key in dictionary containing maximum value&#34;&#34;&#34;
    vmax = max(d.values())
    for (k, v) in d.items():
        if v == vmax:
            return k

def keymin(d):
    &#34;&#34;&#34;Return key in dictionary containing minimum value&#34;&#34;&#34;
    vmin = min(d.values())
    for (k, v) in d.items():
        if v == vmin:
            return k


def isjsonfile(filename):
    return isinstance(filename, str) and len(filename) &gt; 5 and filename[-5:] == &#39;.json&#39;


def writejson(d, outfile):
    with open(outfile, &#39;w&#39;) as f:
        json.dump(d, f)
    return outfile


def readjson(jsonfile, strict=True):
    &#34;&#34;&#34;Read jsonfile=/path/to/file.json and return the json parsed object, issue warning if jsonfile does not have .json extension and strict=True&#34;&#34;&#34;
    if not isjsonfile(jsonfile) and strict:
        warnings.warn(&#39;Attempting to read JSON file &#34;%s&#34; without .json extension&#39; % jsonfile)
    with open(jsonfile) as f:
        data = json.loads(f.read())
    return data

def tryjson(jsonfile):
    &#34;&#34;&#34;Attempt to load the json file, return True if loadable, False if not&#34;&#34;&#34;
    try:
        readjson(jsonfile, strict=False)
        return True
    except Exception as e:
        return False

def groupby(initer, keyfunc):
    &#34;&#34;&#34;groupby on unsorted input iterable (initer)&#34;&#34;&#34;
    return itertools_groupby(sorted(initer, key=keyfunc), keyfunc)


def vipy_groupby(inset, keyfunc):
    &#34;&#34;&#34;groupby on unsorted inset&#34;&#34;&#34;
    return groupby(inset, keyfunc)


def groupbyasdict(togroup, keyfunc, valuefunc=lambda x: x):
    &#34;&#34;&#34;Return dictionary of keys and lists from groupby on unsorted inset, where keyfunc is a lambda function on elements in inset
    
    Args:
        togroup: an iteraable of elements to group
        keyfunc:  a lambda function to operate on elements of togroup such that the value returned from the lambda is the equality key for grouping
        valuefunc: a lambda function to operate on elements of to group such that the value returned from the lambda is a transform of the element to be grouped
    Returns:
        A dictionary with unique keys returned from keyfunc, and values are lists of elements in togroup with the same key

    &#34;&#34;&#34;
    return {k: [valuefunc(vi) for vi in v] for (k, v) in groupby(togroup, keyfunc)}

def countby(inlist, keyfunc=lambda x: x):
    &#34;&#34;&#34;Return dictionary of keys and group sizes for a grouping of the input list by keyfunc lambda function, sorted by increasing count&#34;&#34;&#34; 
    return {k:v for (k,v) in sorted({k:len(v) for (k,v) in groupbyasdict(inlist, keyfunc).items()}.items(), key=lambda x: x[1])}

def sumby(inlist, keyfunc=lambda x: x[0], valuefunc=lambda x: x[1]):
    &#34;&#34;&#34;Given an inlist of tuples [(&#39;a&#39;,1), (&#39;a&#39;,2), (&#39;b&#39;,4)], group by the keyfunc, then sum over the values in valuefunc.  Returns ductionary over keys, sum reduced over valuefunc.  Example returns {&#39;a&#39;:3,&#39;b&#39;:4}.&#34;&#34;&#34;
    return {k:sum([valuefunc(vi) for vi in v]) for (k,v) in groupbyasdict(inlist, keyfunc).items()}

def most_frequent(inlist, topk=1):
    &#34;&#34;&#34;Return the most frequent element as determined by element equality&#34;&#34;&#34;
    ranked = list(countby(inlist).keys())
    return ranked[-topk:] if topk is not None else ranked

def countbyasdict(inlist, keyfunc):
    &#34;&#34;&#34;Alias for `vipy.util.countby`&#34;&#34;&#34;
    return countby(inlist, keyfunc)

def softmax(x, temperature=1.0):
    &#34;&#34;&#34;Row-wise softmax&#34;&#34;&#34;
    assert x.ndim == 2
    z = np.exp((x - np.max(x, axis=1).reshape(x.shape[0], 1)) / temperature)
    return z / np.sum(z, axis=1).reshape(x.shape[0], 1)


def permutelist(inlist, seed=None):
    &#34;&#34;&#34;randomly permute list order.  Permutation is deterministic (same permutation on multiple calls) if specified.  Shuffle is not in place&#34;&#34;&#34;
    if seed is not None:
        np.random.seed(seed)  # deterministic        
    outlist = [inlist[k] for k in np.random.permutation(list(range(0, len(inlist))))]
    if seed is not None:
        np.random.seed()  # re-init randomness
    return outlist

def shufflelist(inlist):
    &#34;&#34;&#34;Randomly shuffle a list, returning the shuffled list. Shuffle is not in-place&#34;&#34;&#34;
    return random.sample(inlist, len(inlist))

def flatlist(inlist):
    &#34;&#34;&#34;Convert list of tuples into a list expanded by concatenating tuples.  If the input is already flat, return it unchanged.&#34;&#34;&#34;
    return [x for r in inlist for x in (r if isinstance(r, (list, tuple, set)) else (r,))]


def rmdir(indir):
    &#34;&#34;&#34;Recursively remove directory and all contents (if the directory exists)&#34;&#34;&#34;
    if os.path.exists(indir) and os.path.isdir(indir):
        shutil.rmtree(indir)
    return indir

def dividelist(inlist, fractions):
    &#34;&#34;&#34;Divide inlist into a list of lists such that the size of each sublist is the requseted fraction of the original list. 

       This operation is deterministic and generates the same division in multiple calls.
       
    Args:
        inlist: [list]
        fractions: [tuple] such as (0.1, 0.7, 0.2)   An iterable of fractions that must be non-negative and sum to one
    &#34;&#34;&#34;
    assert all([f &gt;= 0 and f &lt;=1 for f in fractions])
    assert np.sum(fractions) == 1
    assert len(inlist) &gt;= len(fractions)
    N = np.int32(np.maximum(0, np.ceil(len(inlist)*np.array(fractions))))
    outlist = []
    for n in N:
        outlist.append(inlist[0:n])
        inlist = inlist[n:]
    return outlist


def pairwise(iterable, prepad=False, postpad=False, padval=None):
    &#34;&#34;&#34;Equivalent to python-3.10 itertools.pairwise. 
    
    &gt;&gt;&gt; pairwise(&#39;ABCD&#39;) --&gt; (A,B), (B,C), (C,D)
    &gt;&gt;&gt; pairwise(&#39;ABCD&#39;, prepad=True, padval=0) --&gt; (0,A), (A,B), (B,C), (C,D)
    &gt;&gt;&gt; pairwise(&#39;ABCD&#39;, postpad=True) --&gt; (A,B), (B,C), (C,D), (D,None)
    &gt;&gt;&gt; pairwise([(1,1),(2,2)], prepad=True, postpad=True, padval=(None,None)) --&gt; [((None, None), (1, 1)), ((1, 1), (2, 2)), ((2, 2), (None, None))]
    &#34;&#34;&#34;
    
    a, b = tee(iterable, 2)
    if prepad:
        a = chain([padval], a)
    else:
        b0 = next(b, None)
    if postpad:
        b = chain(b, [padval])
    return zip(a, b)


def chunklist(inlist, num_chunks):
    &#34;&#34;&#34;Convert list into a list of lists of length num_chunks, such that each element is a list containing a sequential chunk of the original list.
    
    ```python
    (A,B,C) = vipy.util.chunklist(inlist, num_chunks=3)
    assert len(A) == len(inlist) // 3
    ```

    .. note::  The last chunk will be larger for ragged chunks
    &#34;&#34;&#34;
    (m, n) = (num_chunks, int(np.ceil(float(len(inlist)) / float(num_chunks))))
    return [inlist[i * n:min(i * n + n, len(inlist))] for i in range(0, m)]


def chunkgen(inlist, num_chunks):
    &#34;&#34;&#34;Yield a list of lists of length num_chunks, such that each element is a list containing a sequential chunk of the original list.
    
    ```python
    A = next(vipy.util.chunkgen(inlist, num_chunks=3))
    assert len(A) == len(inlist) // 3
    ```
    .. note::  The last chunk will be larger for ragged chunks
    &#34;&#34;&#34;
    (m, n) = (num_chunks, int(np.ceil(float(len(inlist)) / float(num_chunks))))
    for i in range(0,m):
        yield inlist[i * n:min(i * n + n, len(inlist))]


def chunklistbysize(inlist, size_per_chunk):
    &#34;&#34;&#34;Convert list into a list of lists such that each element is a list
    containing a sequential chunk of the original list of length
    size_per_chunk&#34;&#34;&#34;
    assert size_per_chunk &gt;= 1
    return [inlist[i:i+size_per_chunk] for i in range(0,len(inlist),size_per_chunk)]

def chunkgenbysize(ingen, size_per_chunk):
    &#34;&#34;&#34;Yield a list of lists such that each element is a list
    containing a sequential chunk of the original list of length
    size_per_chunk&#34;&#34;&#34;
    assert size_per_chunk &gt;= 1
    return batched(ingen, size_per_chunk)
    
def triplets(inlist):
    &#34;&#34;&#34;Yield triplets (1,2,3), (4,5,6), ...  from list inlist=[1,2,3,4,5,6,...]&#34;&#34;&#34;
    for k in range(0, len(inlist), 3):
        yield (inlist[k], inlist[k+1] if (k+1)&lt;len(inlist) else None, inlist[k+2] if (k+2)&lt;len(inlist) else None)
        
def chunklistWithOverlap(inlist, size_per_chunk, overlap_per_chunk):
    &#34;&#34;&#34;Convert list into a list of lists such that each element is a list
    containing a sequential chunk of the original list of length
    size_per_chunk&#34;&#34;&#34;
    assert size_per_chunk &gt;= 1 and overlap_per_chunk &gt;= 0 and size_per_chunk &gt; overlap_per_chunk
    return [inlist[i-size_per_chunk:i] for i in range(size_per_chunk, len(inlist)+(size_per_chunk-overlap_per_chunk), size_per_chunk - overlap_per_chunk)]


def chunklistwithoverlap(inlist, size_per_chunk, overlap_per_chunk):
    &#34;&#34;&#34;Alias for chunklistWithOverlap&#34;&#34;&#34;
    return chunklistWithOverlap(inlist, size_per_chunk, overlap_per_chunk)

def imwritejet(img, imfile=None):
    &#34;&#34;&#34;Write a grayscale numpy image as a jet colormapped image to the
    given file&#34;&#34;&#34;
    if imfile is None:
        imfile = temppng()

    if isnumpy(img):
        if img.ndim == 2:
            cm = plt.get_cmap(&#39;gist_rainbow&#39;)
            PIL.Image.fromarray(np.uint8(255 * cm(img)[:,:,:3])).save(os.path.expanduser(imfile))
        else:
            raise ValueError(&#39;Input must be a 2D numpy array&#39;)
    else:
        raise ValueError(&#39;Input must be numpy array&#39;)
    return imfile


def isuint8(img):
    return isnumpy(img) and img.dtype == np.dtype(&#39;uint8&#39;)

def isnumber(x):
    &#34;&#34;&#34;Is the input a python type of a number or a string containing a number?&#34;&#34;&#34;
    return isinstance(x, (int, float)) or (isnumpy(x) and np.isscalar(x)) or (isstring(x) and isfloat(x))


def isfloat(x):
    &#34;&#34;&#34;Is the input a float or a string that can be converted to float?&#34;&#34;&#34;
    try:
        float(x)
        return True
    except ValueError:
        return False


def imwritegray(img, imfile=None, quality=75):
    &#34;&#34;&#34;Write a floating point grayscale numpy image in [0,1] as [0,255] grayscale&#34;&#34;&#34;
    if imfile is None:
        imfile = temppng()
    if isnumpy(img):
        if img.dtype == np.dtype(&#39;uint8&#39;):
            # Assume that uint8 is in the range [0,255]
            PIL.Image.fromarray(img).save(os.path.expanduser(imfile), quality=quality)
        elif img.dtype == np.dtype(&#39;float32&#39;):
            # Convert [0, 1.0] to uint8 [0,255]
            PIL.Image.fromarray(np.uint8(img * 255.0)).save(os.path.expanduser(imfile), quality=quality)
        else:
            raise ValueError(&#39;Unsupported datatype - &#39;
                             &#39;Numpy array must be uint8 or float32&#39;)
    else:
        raise ValueError(&#39;Input must be numpy array&#39;)
    return imfile


def imwrite(img, imfile=None, writeas=None, quality=75):
    &#34;&#34;&#34;Write a floating point 2D numpy image as jet or gray, 3D numpy as
    rgb or bgr&#34;&#34;&#34;
    if imfile is None:
        imfile = temppng()
    if not isnumpy(img):
        raise ValueError(&#39;image must by numpy object&#39;)
    if writeas is None:
        if img.ndim == 2:
            writeas = &#39;gray&#39;
        else:
            writeas = &#39;bgr&#39;

    imfile = os.path.expanduser(imfile)
    if writeas in [&#39;jet&#39;]:
        imwritejet(img, imfile)
    elif writeas in [&#39;gray&#39;]:
        imwritegray(img, imfile)
    elif writeas in [&#39;rgb&#39;]:
        if img.ndim != 3:
            raise ValueError(&#39;numpy array must be 3D&#39;)
        if img.dtype == np.dtype(&#39;uint8&#39;):
            PIL.Image.fromarray(rgb2bgr(img)).save(imfile, quality=quality)  # convert to BGR
        elif img.dtype == np.dtype(&#39;float32&#39;):
            # convert to uint8 then BGR
            PIL.Image.fromarray(rgb2bgr(np.uint8(255.0 * img))).save(imfile)
    elif writeas in [&#39;bgr&#39;]:
        if img.ndim != 3:
            raise ValueError(&#39;numpy array must be 3D&#39;)
        if img.dtype == np.dtype(&#39;uint8&#39;):
            PIL.Image.fromarray(img).save(imfile, quality=quality)  # convert to BGR
        elif img.dtype == np.dtype(&#39;float32&#39;):
            # convert to uint8 then BGR
            PIL.Image.fromarray(np.uint8(255.0 * img)).save(imfile, quality=quality)
    else:
        raise ValueError(&#39;unsupported writeas&#39;)

    return imfile


def print_and_return(x):
    log.info(x)
    return x


def savetemp(img):
    f = &#39;/tmp/%s.png&#39; % uuid.uuid1().hex
    PIL.Image.fromarray(img.astype(np.uint8)).save(f)
    return f


def gray2jet(img):
    &#34;&#34;&#34;[0,1] grayscale to [0.255] RGB&#34;&#34;&#34;
    import matplotlib.pyplot as plt
    jet = plt.get_cmap(&#39;jet&#39;)
    return np.uint8(255.0 * jet(img)[:, :, 0:3])


def jet(n, bgr=False):
    &#34;&#34;&#34;jet colormap&#34;&#34;&#34;
    from matplotlib import cm
    cmap = cm.get_cmap(&#39;jet&#39;, n)
    rgb = np.uint8(255 * cmap(np.arange(n)))
    return rgb if bgr is False else np.fliplr(rgb)


def is_email_address(email):
    &#34;&#34;&#34;Is the provided string an email address?&#34;&#34;&#34;
    regex = r&#39;\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b&#39;
    return re.fullmatch(regex, email) is not None


def is_hiddenfile(filename):
    &#34;&#34;&#34;Does the filename start with a period?&#34;&#34;&#34;
    return filename[0] == &#39;.&#39;


def seq(start, stop, step=1):
    &#34;&#34;&#34;Equivalent to matlab [start:step:stop]&#34;&#34;&#34;
    n = int(round((stop - start) / float(step)))
    if n &gt; 1:
        return([start + step * i for i in range(n + 1)])
    else:
        return([])


def loadh5(filename):
    &#34;&#34;&#34;Load an HDF5 file&#34;&#34;&#34;
    if ishdf5(filename):
        try_import(&#39;h5py&#39;); import h5py
        f = h5py.File(filename, &#39;r&#39;)
        obj = f[filebase(filename)].value  # FIXME: lazy evaluation?
        return obj
    else:
        raise ValueError(&#39;Invalid HDF5 file &#34;%s&#34; &#39; % filename)



def loadmat73(matfile, keys=None):
    &#34;&#34;&#34;Matlab 7.3 format, keys should be a list of keys to access HDF5
    file as f[key1][key2]...  Returned as numpy array&#34;&#34;&#34;
    try_import(&#39;h5py&#39;); import h5py
    f = h5py.File(matfile, &#39;r&#39;)
    if keys is None:
        return f
    else:
        for k in keys:
            f = f[k]
        return np.array(f)


def take(inlist, k):
    &#34;&#34;&#34;Take k elements at random from inlist&#34;&#34;&#34;
    return [inlist[i] for i in np.random.permutation(range(len(inlist)))[0:k]] if len(inlist)&gt;k else inlist

def takeone(inlist):
    &#34;&#34;&#34;Take one element at random from inlist or return None if empty&#34;&#34;&#34;
    return take(list(inlist), k=1)[0] if len(inlist)&gt;=1 else None   # -&gt; random.sample()?

def takelast(inlist):
    &#34;&#34;&#34;Take last element from inlist or return None if empty&#34;&#34;&#34;
    return tolist(inlist)[-1] if len(tolist(inlist))&gt;=1 else None

def tryload(infile, abspath=False):
    &#34;&#34;&#34;Attempt to load a pkl file, and return the value if successful and None if not&#34;&#34;&#34;
    try:
        return load(infile, abspath=abspath)
    except:
        return None

def canload(infile):
    &#34;&#34;&#34;Attempt to load an archive file, and return true if it can be successfully loaded, otherwise False&#34;&#34;&#34;
    try:
        load(infile, abspath=True)
        return True
    except:
        return False




def repath(v, srcpath, dstpath):
    &#34;&#34;&#34;Change the filename with prefix srcpath to dstpath, for any element in v that supports the filename() api&#34;&#34;&#34;
    if not islist(v) and (hasattr(v, &#39;filename&#39;) and hasattr(v, &#39;clone&#39;)):
        vc = v.filename( v.filename().replace(os.path.normpath(srcpath), os.path.normpath(dstpath))) if v.filename() is not None else v
    elif islist(v) and all([(hasattr(vv, &#39;filename&#39;) and hasattr(vv, &#39;clone&#39;)) for vv in v]):
        vc = [vv.filename( vv.filename().replace(os.path.normpath(srcpath), os.path.normpath(dstpath))) if vv.filename() is not None else vv for vv in v ]
    elif isstring(v):
        vc = v.replace(os.path.normpath(srcpath), os.path.normpath(dstpath))
    else:
        raise ValueError(&#39;Input must be a singleton or list of vipy.image.Image() or vipy.video.Video() objects, not type &#34;%s&#34;&#39; % (str(type(v))))
    return vc
    

def scpsave(V, username=None):
    &#34;&#34;&#34;Save an archive file to load via SCP.

    Use case:

    - This archive format is useful to allow access to videos and images that are accessible behind a remote server for which you have access via SSH key-based authentication.
    - You create this archive on the remote server, and all vipy objects are replaced with references to remote media.
    - Every video or image is replaced with a URL of the format &#39;scp://USER@HOST:/path/to.mp4&#39;.  
    - Vipy will use your SSH keys to SCP these media files from USER@HOST on demand, so that the videos are cached for you on your local machine when you need them.
    - This is useful for transparently visualizing large datasets that are hidden behind an SSH-only accessible server

    Usage:
    
    ```python
    outfile = vipy.util.scpsave([vipy.video.Video(filename=&#39;/path/to.mp4)])  # run on remote machine that you have SSH key access
    V = vipy.util.scpload(outfile)  # run on local machine that has SSH key access to remote machine
    V[0].load()  # this will SCP the videos from &#39;scp:///path/to.mp4&#39; to $VIPY_CACHE/to.mp4 transparently and on demand
    ```

    Args:
        V: [vipy objects] A list of vipy objects or `vipy.dataset.Dataset`
        username: [str] Your username on the remote machine to select the proper SSH key

    Returns:
        A temp archive file stored on the remote machine that will be downloaded and loaded via SCP, such that each element in the list will be fetched via scp when pixels are loaded.

    &#34;&#34;&#34;
    
    import vipy.image
    import vipy.video

    if isinstance(V, vipy.dataset.Dataset) and V._isvipy():
        v = V.localmap(lambda v: v.clone().url(&#39;scp://%s%s:%s&#39; % ((&#39;%s@&#39; % username) if username is not None else &#39;&#39;, socket.gethostname(), v.filename())).nofilename())
    elif (isinstance(V, vipy.image.Image) or isinstance(V, vipy.video.Video)) and V.hasfilename():        
        v = V.clone().url(&#39;scp://%s%s:%s&#39; % ((&#39;%s@&#39; % username) if username is not None else &#39;&#39;, socket.gethostname(), V.filename())).nofilename()
    elif islist(V) and all([isinstance(v, vipy.image.Image) or isinstance(v, vipy.video.Video) for v in V]):
        v = [v.clone().url(&#39;scp://%s%s:%s&#39; % ((&#39;%s@&#39; % username) if username is not None else &#39;&#39;, socket.gethostname(), v.abspath().filename())).nofilename() for v in V]
    else:
        v = V # no vipy objects

    pklfile = &#39;scp://%s%s:%s&#39; % ((&#39;%s@&#39; % username) if username is not None else &#39;&#39;, socket.gethostname(), save(v, temppkl()))
    cmd = &#34;V = vipy.util.scpload(&#39;%s&#39;)&#34; % pklfile
    log.info(&#39;[vipy.util.scpsave]: On a local machine where you have public key ssh access to this remote machine run:\n&gt;&gt;&gt; %s\n&#39; % cmd)
    return pklfile


def scpload(url):
    &#34;&#34;&#34;Load an archive file saved using `vipy.util.scpsave`&#34;&#34;&#34;
    import vipy.downloader
    return load(vipy.downloader.scp(url, templike(url)))


def load_opencv_yaml(yamlfile):
    &#34;&#34;&#34;Load a numpy array from YAML file exported from OpenCV&#34;&#34;&#34;
    return np.squeeze(np.array(cv.Load(yamlfile)))


def matrix_to_opencv_yaml(yamlfile, mtxlist, mtxname=None):
    &#34;&#34;&#34;Write list of matrices to OpenCV yaml file format with given
    variable names&#34;&#34;&#34;
    def _write_matrix(f, M, mtxname):
        f.write(&#39;    %s: !!opencv-matrix\n&#39; % mtxname)
        f.write(&#39;       rows: %d\n&#39; % M.shape[0])
        f.write(&#39;       cols: %d\n&#39; % (M.shape[1] if M.ndim == 2 else 1))
        f.write(&#39;       dt: f\n&#39;)
        f.write(&#39;       data: [ &#39;)
        datastr = &#39;&#39;
        for (k, x) in enumerate(M.flatten()):
            datastr += &#39;%.6e&#39; % x
            if (k + 1 == M.size):
                f.write(datastr)
                break
            datastr += &#39;, &#39;
            if ((k + 1) % 4) == 0:
                f.write(datastr + &#39;\n           &#39;)
                datastr = &#39;&#39;
        f.write(&#39;]\n&#39;)

    # Write me!
    mtxlist = tolist(mtxlist)
    if mtxname is None:
        mtxname = [&#39;mtx_%02d&#39; % k for k in range(0, len(mtxlist))]
    with open(yamlfile, &#39;w&#39;) as f:
        f.write(&#39;%YAML:1.0\n&#39;)
        for (m, mname) in zip(mtxlist, mtxname):
            _write_matrix(f, m, mname)

    return yamlfile


def save_opencv_yaml(yamlfile, mat):
    &#34;&#34;&#34;Save a numpy array to YAML file importable by OpenCV&#34;&#34;&#34;

    def _write_matrix(f, M):
        f.write(&#39;    mtx_01: !!opencv-matrix\n&#39;)
        f.write(&#39;       rows: %d\n&#39; % M.shape[0])
        f.write(&#39;       cols: %d\n&#39; % (M.shape[1] if M.ndim == 2 else 1))
        f.write(&#39;       dt: f\n&#39;)
        f.write(&#39;       data: [ &#39;)
        datastr = &#39;&#39;
        for (k, x) in enumerate(M.flatten()):
            datastr += &#39;%.6e&#39; % x
            if (k + 1 == M.size):
                f.write(datastr)
                break
            datastr += &#39;, &#39;
            if ((k + 1) % 4) == 0:
                f.write(datastr + &#39;\n           &#39;)
                datastr = &#39;&#39;

        f.write(&#39;]\n&#39;)

    with open(yamlfile, &#39;w&#39;) as f:
        f.write(&#39;%YAML:1.0\n&#39;)
        _write_matrix(f, mat)

    return yamlfile


def tofilename(s, hyphen=True):
    &#34;&#34;&#34;Convert arbitrary string to valid filename with underscores
    replacing invalid chars&#34;&#34;&#34;
    valid_chars = &#34;-_.%s%s&#34; % (str.ascii_letters, str.digits)
    s = str.replace(s, &#39; &#39;, &#39;_&#39;)
    if hyphen:
        s = str.replace(s, &#39;-&#39;, &#39;_&#39;)
    return &#34;&#34;.join(x for x in s if x in valid_chars)


def isexe(filename):
    &#34;&#34;&#34;Is the file an executable binary?&#34;&#34;&#34;
    return os.path.isfile(filename) and os.access(filename, os.X_OK)


def isinstalled(cmd):
    &#34;&#34;&#34;Is the command is available on the path&#34;&#34;&#34;
    return shutil.which(cmd) is not None


def isextension(filename, ext):
    &#34;&#34;&#34;Does the filename end with the extension ext? 
    
    ```python
    isextension(&#39;/path/to/myfile.json&#39;, &#39;json&#39;) == True
    isextension(&#39;/path/to/myfile.json&#39;, &#39;.json&#39;) == True
    isextension(&#39;/path/to/myfile.json&#39;, &#39;.pkl&#39;) == False
    ```

    &#34;&#34;&#34;
    return filename is not None and filename.endswith(ext)

def ispkl(filename):
    &#34;&#34;&#34;Is the file a pickle archive file&#34;&#34;&#34;
    return filename[-4:] == &#39;.pkl&#39; if isstring(filename) and len(filename) &gt;= 4 else False

def ispklbz2(filename):
    &#34;&#34;&#34;Is the file a pickle bz2 archive file&#34;&#34;&#34;
    return filename[-8:] == &#39;.pkl.bz2&#39; if isstring(filename) and len(filename) &gt;= 8 else False

def is_pkl_gz(filename):
    &#34;&#34;&#34;Is the file a pickle gzip archive file&#34;&#34;&#34;
    return filename[-7:] == &#39;.pkl.gz&#39; if isstring(filename) and len(filename) &gt;= 7 else False

def ispklfile(filename):
    &#34;&#34;&#34;Is the file a pickle archive file&#34;&#34;&#34;
    return ispkl(filename)

def ishtml(filename):
    &#34;&#34;&#34;Is the file an HTMLfile&#34;&#34;&#34;
    return filename.lower()[-5:] == &#39;.html&#39;

def ispickle(filename):
    &#34;&#34;&#34;Is the file a pickle archive file&#34;&#34;&#34;
    return isfile(filename) and os.path.exists(filename) and (((fileext(filename) is not None) and fileext(filename).lower() in [&#39;.pk&#39;, &#39;.pkl&#39;]) or (filename[-4:] == &#39;.pkl&#39;))


def ishdf5(path):
    &#34;&#34;&#34;Is the file an HDF5 file?&#34;&#34;&#34;
    # tables.is_hdf5_file(path)
    # tables.is_pytables_file(path)
    (filename, ext) = os.path.splitext(path)
    if (ext is not None) and (len(ext) &gt; 0) and (ext.lower() in [&#39;.h5&#39;]):
        return True
    else:
        return False


def filebase(filename):
    &#34;&#34;&#34;Return c for filename /a/b/c.ext
    
    .. warning:: Will return /a/b/c.d for multidot filenames wth more than two trailing dots like /a/b/c.d.e.f (e.g. /a/b/my.filename.tar.gz)
    &#34;&#34;&#34;
    (head, tail) = os.path.split(filename)
    (base, ext) = splitext(tail)
    return base


def filepath(filename, depth=0):
    &#34;&#34;&#34;Return /a/b/c for filename /a/b/c/d.ext, /a/b for filename /a/b/c/d.ext if depth=1, etc&#34;&#34;&#34;
    (head, tail) = os.path.split(filename)
    for k in range(depth):
        (head, tail) = os.path.split(head)           
    return head


def delpath(indir, filename):
    &#34;&#34;&#34;Return c/d.ext for filename /a/b/c/d.ext and indir /a/b&#34;&#34;&#34;
    assert indir in filename, &#39;Path &#34;%s&#34; not found in filename &#34;%s&#34;&#39; % (indir, filename)
    indir = os.path.join(indir, &#39;&#39;)  # /a/b -&gt; /a/b/
    return filename.split(indir)[1]

    
def newpath(filename, newdir):
    &#34;&#34;&#34;Return /d/e/c.ext for filename /a/b/c.ext and newdir /d/e/&#34;&#34;&#34;
    (head, tail) = os.path.split(filename)
    return os.path.join(newdir, tail)

def newprefix(filename, newprefix, depth=0):
    &#34;&#34;&#34;Return /a/b/c/h/i.ext for filename /f/g/h/i.ext and prefix /a/b/c and depth=1&#34;&#34;&#34;
    p = filepath(filename, depth=depth)
    return os.path.normpath(filename.replace(p, newprefix))

def newpathdir(filename, olddir, newdir, n=1):
    &#34;&#34;&#34;Return /a/b/n/d/e.ext for filename=/a/b/c/d/e.ext, olddir=c, newdir=n&#34;&#34;&#34;
    p = pathlib.PurePath(filename)
    assert sum([d == olddir for d in p.parts]) == n, &#34;Path must have exactly %s directory matches&#34; % n
    return os.path.join(*[d.replace(olddir, newdir) for d in list(p.parts)])


def newpathroot(filename, newroot):
    &#34;&#34;&#34;Return /r/b/c.ext for filename /a/b/c.ext and new root directory r&#34;&#34;&#34;
    p = pathlib.PurePath(filename)
    path = list(p.parts)    
    if len(p.root) == 0:
        path[0] = newroot
    else:
        path[1] = newroot
    return os.path.join(*path)

def topath(filename, newdir):
    &#34;&#34;&#34;Alias for `vipy.util.newpath`&#34;&#34;&#34;
    return newpath(filename, newdir)


def filefull(f):
    &#34;&#34;&#34;Return /a/b/c for filename /a/b/c.ext&#34;&#34;&#34;
    ext = fileext(f, multidot=True, withdot=True)
    return f.replace(ext, &#39;&#39;) if ext is not None else f


def filetail(filename):
    &#34;&#34;&#34;Return c.ext for filename /a/b/c.ext&#34;&#34;&#34;
    (head, tail) = os.path.split(filename)
    return tail


def matread(txtfile, delimiter=&#39; &#39;):
    &#34;&#34;&#34;Whitespace separated values defining columns, lines define rows.
    Return numpy array&#34;&#34;&#34;
    with open(txtfile, &#39;rb&#39;) as csvfile:
        M = [np.float32(row.split(delimiter)) for row in csvfile]
    return np.array(M)


def imlist(imdir):
    &#34;&#34;&#34;return list of images with absolute path in a directory&#34;&#34;&#34;
    return [os.path.abspath(os.path.join(imdir, item))
            for item in os.listdir(imdir)
            if (isimg(item) and not is_hiddenfile(item))]


def videolist(videodir):
    &#34;&#34;&#34;return list of videos with absolute path in a directory&#34;&#34;&#34;
    return [os.path.abspath(os.path.join(videodir, item))
            for item in os.listdir(videodir)
            if (isvideo(item) and not is_hiddenfile(item))]


def dirlist(indir):
    &#34;&#34;&#34;return list of absolute paths to subdirectories in a directory&#34;&#34;&#34;
    return [os.path.abspath(os.path.join(indir, item))
            for item in os.listdir(indir)
            if (os.path.isdir(os.path.join(indir, item)) and
                not is_hiddenfile(item))]


def dirlist_sorted_bycreation(indir):
    &#34;&#34;&#34;Sort the directory list from newest first to oldest last by creation date&#34;&#34;&#34;
    return sorted(dirlist(indir), key=lambda d: os.stat(d).st_ctime, reverse=True)


def extlist(indir, ext):
    &#34;&#34;&#34;return list of files with absolute path in a directory that have
    the provided extension (with the prepended dot, ext=&#39;.mp4&#39;)&#34;&#34;&#34;
    return [os.path.abspath(os.path.join(indir, item))
            for item in os.listdir(indir)
            if fileext(item) is not None
            and (fileext(item).lower() == ext.lower())]

def listext(indir, ext):
    &#34;&#34;&#34;Alias for extlist&#34;&#34;&#34;
    return extlist(indir, ext)

def jsonlist(indir):
    &#34;&#34;&#34;return list of fJSON iles with absolute path in a directory&#34;&#34;&#34;
    #return extlist(indir, ext=&#39;.json&#39;)  # FIXME: broken.for.wonky.filenames.with.dots.json
    return [os.path.abspath(os.path.join(indir, item))
            for item in os.listdir(indir)
            if len(item) &gt; 5 and item[-5:] == &#39;.json&#39;]

def listjson(indir):
    &#34;&#34;&#34;Alias for jsonlist&#34;&#34;&#34;
    return jsonlist(indir)

def writelist(mylist, outfile, mode=&#39;w&#39;):
    &#34;&#34;&#34;Write list of strings to an output file with each row an element of
    the list&#34;&#34;&#34;
    outfile = os.path.abspath(os.path.expanduser(outfile))
    with open(outfile, mode) as f:
        for s in mylist:
            f.write(str(s) + &#39;\n&#39;)
    return(outfile)


def readlist(infile):
    &#34;&#34;&#34;Read each row of file as an element of the list&#34;&#34;&#34;
    with open(infile, &#39;r&#39;) as f:
        list_of_rows = f.read().splitlines()
    return list_of_rows


def readtxt(infile):
    &#34;&#34;&#34;Read a text file one string per row&#34;&#34;&#34;
    return readlist(infile)


def writecsv(list_of_tuples, outfile=None, mode=&#39;w&#39;, separator=&#39;,&#39;, header=None, comment=&#39;# &#39;):
    &#34;&#34;&#34;Write list of tuples to an output csv file with each list element on a row and tuple elements separated by commas.

    Examples:
    ```python
    vipy.util.writecsv([(1,2,3), (4,5,6)], &#39;/tmp/out.csv&#39;)
    vipy.util.writecsv([(1,2,3), (4,5,6)], &#39;/tmp/out.csv&#39;, separator=&#39;;&#39;))
    vipy.util.writecsv([(1,2,3), (4,5,6)], &#39;/tmp/out.csv&#39;, header=(&#39;h1&#39;,&#39;h2&#39;,&#39;h3&#39;))
    ```

    Args:
        list_of_tuples: a list of tuples each tuple is a row
        outfile: the csv file output
        mode: &#39;w&#39; for overwrite, &#39;a&#39; for append
        separator: a string specifying the separator between columns.  defaults to &#39;,&#39;
        header: a tuple containing strings to be appended to the first row of the csv file
        comment:  the comment symbol to be prepended to the header row 

    Returns:
        the outfile path
    &#34;&#34;&#34;
    
    list_of_tuples = list_of_tuples if not isnumpy(list_of_tuples) else list_of_tuples.tolist()
    list_of_tuples = list_of_tuples if header is None else [tuple([h if k&gt;0 else comment+h for (k,h) in enumerate(header)])]+list_of_tuples  # prepend header with comment symbol
    outfile = os.path.abspath(os.path.expanduser(outfile)) if outfile is not None else tempcsv()
    with open(outfile, mode) as f:
        for u in list_of_tuples:
            n = len(u)
            for (k, v) in enumerate(u):
                if (k + 1) &lt; n:
                    f.write(str(v) + separator)
                else:
                    f.write(str(v) + &#39;\n&#39;)
    return(outfile)


def readcsv(infile, separator=&#39;,&#39;, ignoreheader=False, comment=None, ignore_header=False):
    &#34;&#34;&#34;Read a csv file into a list of lists, ignore any rows prepended with comment symbol, ignore first row if ignoreheader=True

    Args:
        infile: the csv file input
        separator: a string specifying the separator between columns.  defaults to &#39;,&#39;
        ignoreheader: if true, ignore the first row of the csv file
        ignore_header: if true, ignore the first row of the csv file (argument synonym)
        comment:  if provided, ignore all rows with this comment symbol prepended

    Returns:
        a list of lists, each list element containing a list of elements in the corresponding line of the csv file, parsed by separator

    .. note:: this parser does not escape delimiters enclosed in double quotes, as may be assumed by some csv writers
    &#34;&#34;&#34;

    with open(infile, &#39;r&#39;) as f:
        list_of_rows = [[x.strip() for x in r.split(separator)] for r in f]
    list_of_rows = list_of_rows if (len(list_of_rows)==0 or not (ignoreheader or ignore_header)) else list_of_rows[1:]
    list_of_rows = list_of_rows if comment is None else [r for r in list_of_rows if len(r)==0 or r[0][0] != comment]
    return list_of_rows


def readcsvwithheader(infile, separator=&#39;,&#39;):
    &#34;&#34;&#34;Read a csv file into a list of lists&#34;&#34;&#34;
    with open(infile, &#39;r&#39;) as f:
        list_of_rows = [[x.strip() for x in r.split(separator)]
                        for r in f.readlines()]
    header_dict = dict()
    for i in range(len(list_of_rows[0])):
        header_dict[list_of_rows[0][i]] = i
    return list_of_rows[1:], header_dict


def imsavelist(imdir, outfile):
    &#34;&#34;&#34;Write out all images in a directory to a provided file with each
    line containing absolute path to image&#34;&#34;&#34;
    return writelist(imlist(imdir), outfile)


def csvlist(imdir):
    &#34;&#34;&#34;Return a list of absolute paths of *.csv files in current directory&#34;&#34;&#34;
    return [os.path.join(imdir, item) for item in os.listdir(imdir)
            if iscsv(item)]


def pklist(indir):
    &#34;&#34;&#34;Return a list of absolute paths of *.pk files in current directory&#34;&#34;&#34;
    return listpkl(indir)

def listpkl(indir):
    &#34;&#34;&#34;Return a list of absolute paths of *.pk files in current directory&#34;&#34;&#34;
    return [os.path.join(indir, item) for item in os.listdir(indir)
            if ispickle(os.path.join(indir, item))]


def txtlist(imdir):
    &#34;&#34;&#34;Return a list of absolute paths of *.txt files in current directory&#34;&#34;&#34;
    return [os.path.join(imdir, item) for item in os.listdir(imdir)
            if istextfile(item) and not is_hiddenfile(item)]


def imlistidx(filelist, idx_in_filename):
    &#34;&#34;&#34;Return index in list of filename containing index number&#34;&#34;&#34;
    return [i for (i, item) in enumerate(filelist)
            if (item.find(&#39;%d&#39; % idx_in_filename) &gt; 0)]


def mat2gray(img, min=None, max=None):
    &#34;&#34;&#34;Convert numpy array to float32 with 1.0=max and 0=min&#34;&#34;&#34;
    immin = np.min(img) if min is None else min
    immax = np.max(img) if max is None else max
    if (immax - immin) &gt; 0:
        return (np.float32(img) - immin) / (immax - immin)
    else:
        return img


def mdlist(m, n):
    &#34;&#34;&#34;Preallocate 2D list of size MxN&#34;&#34;&#34;
    return [[None] * n for i in range(m)]


def isurl(path):
    &#34;&#34;&#34;Is a path a URL?  It requires a url scheme and url netloc without any common unallowed characters&#34;&#34;&#34;
    try:
        url = urlparse(path)
        return not any([c in path for c in (&#39;&gt;&#39;,&#39;&lt;&#39;,&#39;&#34;&#39;)]) and bool(url.scheme) and bool(url.netloc)
    except:
        return False

def shortuuid(n=8):
    &#34;&#34;&#34;Generate a short UUID with n charaters sampled uniformly at random from lowercase|uppercase|numbers&#34;&#34;&#34;
    return &#39;&#39;.join(random.sample(ALPHABET, n))

def stringhash(s, n=16):
    &#34;&#34;&#34;Generate a repeatable hash with n characters for a string s&#34;&#34;&#34;
    return hashlib.sha256(s.encode(&#39;utf-8&#39;)).hexdigest()[0:n]

def isimageurl(path):
    &#34;&#34;&#34;Is a path a URL with image extension?&#34;&#34;&#34;
    return path is not None and isurl(path) and isimg(path)


def isvideourl(path):
    &#34;&#34;&#34;Is a path a URL with video extension?&#34;&#34;&#34;
    return isurl(path) and isvideo(path)


def isS3url(path):
    &#34;&#34;&#34;Is a path a URL for an S3 object?&#34;&#34;&#34;
    return isurl(path) and urlparse(path).scheme == &#39;s3&#39;


def isyoutubeurl(path):
    &#34;&#34;&#34;Is a path a youtube URL?&#34;&#34;&#34;
    return isurl(path) and (&#39;youtube.com&#39; in path or &#39;youtu.be&#39; in path)

def isRTSPurl(path):
    return isurl(path) and path.startswith(&#39;rtsp://&#39;)

def isRTMPurl(path):
    return is_rtmp_url(path)

def is_rtmp_url(path):
    return isurl(path) and (path.startswith(&#39;rtmp://&#39;) or path.startswith(&#39;rtmps://&#39;))


def islist(x):
    &#34;&#34;&#34;Is an object a python list&#34;&#34;&#34;
    return type(x) is list


def islistoflists(x):
    &#34;&#34;&#34;Is an object a python list of lists x=[[1,2], [3,4]]&#34;&#34;&#34;
    return type(x) is list and type(x[0]) is list


def istupleoftuples(x):
    &#34;&#34;&#34;Is an object a python list of lists x=[[1,2], [3,4]]&#34;&#34;&#34;
    return type(x) is tuple and type(x[0]) is tuple


def isimageobject(x):
    &#34;&#34;&#34;Is an object a vipy.image class Image, ImageCategory, ImageDetection?&#34;&#34;&#34;
    return (str(type(x)) in [&#34;&lt;class &#39;vipy.image.Image&#39;&gt;&#34;,
                             &#34;&lt;class &#39;vipy.image.ImageCategory&#39;&gt;&#34;,
                             &#34;&lt;class &#39;vipy.image.ImageDetection&#39;&gt;&#34;])


def isvideotype(x):
    &#34;&#34;&#34;Is an object a vipy.video class Video, VideoCategory, Scene?&#34;&#34;&#34;
    return (str(type(x)) in [&#34;&lt;class &#39;vipy.video.Video&#39;&gt;&#34;,
                             &#34;&lt;class &#39;vipy.video.VideoCategory&#39;&gt;&#34;,
                             &#34;&lt;class &#39;vipy.video.Scene&#39;&gt;&#34;])

def isvideoobject(x):
    return isvideotype(x)


def isvipyobject(x):
    import vipy.image
    import vipy.video
    return ((isinstance(x, vipy.image.Image) or isinstance(x, vipy.video.Video)) 
            or (islist(x) or istuple(x) and all([isinstance(v, vipy.image.Image) or isinstance(v, vipy.video.Video) for v in x]))
            or (isinstance(x, dict) and all([isinstance(v, vipy.image.Image) or isinstance(v, vipy.video.Video) for (k,v) in x.items()])))


def totuple(x):
    &#34;&#34;&#34;Convert an object to a python tuple?&#34;&#34;&#34;
    if isinstance(x, list):
        return tuple(x)
    elif isinstance(x, tuple):        
        return x
    elif isinstance(x, set):        
        return tuple(x)
    else:
        return (x,)

def to_iterable(x): 
    &#34;&#34;&#34;Convert an object to a singleton tuple if not already a list, tuple or set iterable&#34;&#34;&#34;
    return x if isinstance(x, (list, tuple, set)) else (x,)
        
def tolist(x):
    &#34;&#34;&#34;Convert a python tuple or singleton object to a list if not already a list &#34;&#34;&#34;
    if isinstance(x, list):
        return x
    elif isinstance(x, tuple):        
        return list(x)
    elif isinstance(x, set):        
        return list(x)
    else:
        return [x]

def singletonlist(x):
    &#34;&#34;&#34;Convert a singleton list to a singleton, otherwise return the list&#34;&#34;&#34;
    return x[0] if isinstance(x, list) and len(x)==1 else x

def toset(x):
    &#34;&#34;&#34;Convert a python iterable to a set of not already a set&#34;&#34;&#34;
    if isinstance(x, set):        
        return x    
    elif isinstance(x, list) or isinstance(x, tuple):
        return set(x)
    else:
        return set([x])
    
    
def tolist_or_singleton(x):
    &#34;&#34;&#34;Return list(x) if length of iterator x is not equal to one, else return x or None.  This is useful to return single elements instead of single element lists.&#34;&#34;&#34;
    y = tolist(x)
    return y if len(y)&gt;1 else (y[0] if len(y)==1 else None)


def isimg(path):
    &#34;&#34;&#34;Is an object an image with a supported image extension [&#39;.jpg&#39;,&#39;.jpeg&#39;,&#39;.png&#39;,&#39;.tif&#39;,&#39;.tiff&#39;,&#39;.pgm&#39;,&#39;.ppm&#39;,&#39;.gif&#39;,&#39;.bmp&#39;]?&#34;&#34;&#34;    
    if path is not None and os.path.splitext(path)[1].lower() in [&#39;.jpg&#39;, &#39;.jpeg&#39;, &#39;.png&#39;, &#39;.tif&#39;, &#39;.tiff&#39;, &#39;.pgm&#39;, &#39;.ppm&#39;, &#39;.gif&#39;, &#39;.bmp&#39;]:
        return True
    else:
        return False

def isimage(path):
    &#34;&#34;&#34;Alias for `vipy.util.isimg`&#34;&#34;&#34;
    return isimg(path)
    
def isvideofile(path):
    &#34;&#34;&#34;Alias for `vipy.util.isvideo`&#34;&#34;&#34;
    return isvideo(path)

def isimgfile(path):
    &#34;&#34;&#34;Alias for `vipy.util.isimg`&#34;&#34;&#34;
    return isimg(path)

def has_image_extension(path):
    &#34;&#34;&#34;Alias for `vipy.util.isimg`&#34;&#34;&#34;
    return isimg(path)

def isimagefile(path):
    &#34;&#34;&#34;Alias for `vipy.util.isimg`&#34;&#34;&#34;
    return isimg(path)


def isjpeg(path):
    &#34;&#34;&#34;is the file a .jpg or .jpeg extension?&#34;&#34;&#34;
    return hasextension(path) and fileext(path).lower() == &#39;.jpg&#39; or fileext(path).lower() == &#39;.jpeg&#39;

def iswebp(path):
    &#34;&#34;&#34;is the file a .webp extension?&#34;&#34;&#34;
    return path is not None and hasextension(path) and fileext(path).lower() == &#39;.webp&#39;

def ispng(path):
    &#34;&#34;&#34;is the file a .png or .apng extension?&#34;&#34;&#34;
    return hasextension(path) and (fileext(path).lower() == &#39;.png&#39; or fileext(path).lower() == &#39;.apng&#39;)

def isgif(path):
    &#34;&#34;&#34;is the file a .gif extension?&#34;&#34;&#34;
    return hasextension(path) and fileext(path).lower() == &#39;.gif&#39;

def isjpg(path):
    &#34;&#34;&#34;Alias for `vipy.util.isjpeg`&#34;&#34;&#34;
    return isjpeg(path)


def iscsv(path):
    &#34;&#34;&#34;Is a file a CSV file extension?&#34;&#34;&#34;

    (filename, ext) = (os.path.splitext(path) if path is not None else (&#39;&#39;,&#39;&#39;))
    if ext.lower() in [&#39;.csv&#39;, &#39;.CSV&#39;]:
        return True
    else:
        return False

def isvideo(path):
    &#34;&#34;&#34;Is a filename in path a video with a known video extension [&#39;.avi&#39;,&#39;.mp4&#39;,&#39;.mov&#39;,&#39;.wmv&#39;,&#39;.mpg&#39;, &#39;mkv&#39;, &#39;webm&#39;, &#39;3gp&#39;]?&#34;&#34;&#34;
    if path is not None and os.path.splitext(path)[1].lower() in [&#39;.avi&#39;,&#39;.mp4&#39;,&#39;.mov&#39;,&#39;.wmv&#39;,&#39;.mpg&#39;, &#39;.mkv&#39;, &#39;.webm&#39;, &#39;.3gp&#39;]:
        return True
    else:
        return False


def isnumpy(obj):
    &#34;&#34;&#34;Is a python object a numpy object?&#34;&#34;&#34;
    return (&#39;numpy&#39; in str(type(obj)))

def isnumpyarray(obj):
    &#34;&#34;&#34;Is a python object a numpy array?&#34;&#34;&#34;
    return isnumpy(obj) and &#39;numpy.ndarray&#39; in str(type(obj))


def istextfile(path):
    &#34;&#34;&#34;Is the given file a text file?&#34;&#34;&#34;
    (filename, ext) = (os.path.splitext(path) if path is not None else (&#39;&#39;,&#39;&#39;))
    if ext.lower() in [&#39;.txt&#39;] and (filename[0] != &#39;.&#39;):
        return True
    else:
        return False


def isxml(path):
    &#34;&#34;&#34;Is the given file an xml file?&#34;&#34;&#34;
    (filename, ext) = os.path.splitext(path)
    if ext.lower() in [&#39;.xml&#39;]:
        return True
    else:
        return False


def bgr2gray(im_bgr):
    &#34;&#34;&#34;Wrapper for numpy uint8 BGR image to uint8 numpy grayscale&#34;&#34;&#34;
    return np.array(PIL.Image.fromarray(im_bgr).convert(&#39;L&#39;))


def gray2bgr(im_gray):
    &#34;&#34;&#34;Wrapper for numpy float32 gray image to uint8 numpy BGR&#34;&#34;&#34;
    return np.array(PIL.Image.fromarray(im_gray, mode=&#39;F&#39;).convert(&#39;RGB&#39;))[:,:,::-1]  # Gray -&gt; RGB -&gt; BGR


def gray2rgb(im_gray):
    return bgr2rgb(gray2bgr(im_gray))


def bgr2rgb(im_bgr):
    &#34;&#34;&#34;Wrapper for numpy BGR uint8 to numpy RGB uint8&#34;&#34;&#34;
    return np.array(im_bgr)[:,:,::-1]


def rgb2bgr(im_rgb):
    &#34;&#34;&#34;same as bgr2rgb&#34;&#34;&#34;
    return bgr2rgb(im_rgb)


def bgr2hsv(im_bgr):
    &#34;&#34;&#34;Convert a numpy array in BGR order to HSV&#34;&#34;&#34;
    return np.array(PIL.Image.fromarray(bgr2rgb(im_bgr)).convert(&#39;HSV&#39;))  # BGR -&gt; RGB -&gt; HSV


def gray2hsv(im_gray):
    &#34;&#34;&#34;Convert a numpy array in floating point single channel greyscale order to HSV&#34;&#34;&#34;
    return np.array(PIL.Image.fromarray(gray2rgb(im_gray)).convert(&#39;HSV&#39;))  # Gray -&gt; RGB -&gt; HSV


def isarchive(filename):
    &#34;&#34;&#34;Is filename a zip or gzip compressed tar archive?&#34;&#34;&#34;
    (filebase, ext) = splitext(filename)
    if (ext is not None) and (len(ext) &gt; 0) and (ext.lower() in [
            &#39;.egg&#39;, &#39;.jar&#39;, &#39;.tar&#39;, &#39;.tar.bz2&#39;, &#39;.tar.gz&#39;,
            &#39;.tgz&#39;, &#39;.tz2&#39;, &#39;.zip&#39;, &#39;.gz&#39;]):
        return True
    else:
        (filebase, ext) = splitext(ext[1:])
        if (ext is not None) and (len(ext) &gt; 0) and (ext.lower() in [&#39;.bz2&#39;]):
            return True
        else:
            return False

def istgz(filename):
    &#34;&#34;&#34;Is the filename a .tgz or .tar.gz extension?&#34;&#34;&#34;
    return filename[-4:] == &#39;.tgz&#39; or filename[-7:] == &#39;.tar.gz&#39;

def istar(filename):
    &#34;&#34;&#34;Is the filename a .tar extension?&#34;&#34;&#34;
    return filename[-4:] == &#39;.tar&#39;

def istarbz2(filename):
    &#34;&#34;&#34;Is the filename a .bz2 or .tar.bz2 extension?&#34;&#34;&#34;
    return filename[-8:] == &#39;.tar.bz2&#39;

def tempfilename(suffix=&#39;&#39;):
    &#34;&#34;&#34;Create a temporary filename $TEMPDIR/$UUID.suffix, suffix should include the dot such as suffix=&#39;.jpg&#39;, &#34;&#34;&#34;
    return os.path.join(tempfile.gettempdir(), &#39;%s%s&#39; % (shortuuid(), suffix))


def totempdir(filename):
    &#34;&#34;&#34;Convert a filename &#39;/patj/to/filename.ext&#39; to &#39;/tempdir/filename.ext&#39;&#34;&#34;&#34;
    return os.path.join(tempfile.gettempdir(), filetail(filename))


def templike(filename):
    &#34;&#34;&#34;Create a new temporary filename with the same extension as filename&#34;&#34;&#34;
    return tempfilename(fileext(filename))


def cached(filename):
    &#34;&#34;&#34;Create a new filename in the cache, or tempdir if not found&#34;&#34;&#34;
    if &#39;VIPY_CACHE&#39; in os.environ:
        return os.path.join(remkdir(os.environ[&#39;VIPY_CACHE&#39;]), filetail(filename))
    else:
        return totempdir(filename)


def tempimage(ext=&#39;jpg&#39;):
    &#34;&#34;&#34;Create a temporary image with the given extension&#34;&#34;&#34;
    if ext[0] == &#39;.&#39;:
        ext = ext[1:]
    return tempfilename(suffix=&#39;.&#39; + ext)


def temppng():
    &#34;&#34;&#34;Create a temporay PNG file&#34;&#34;&#34;
    return tempimage(&#39;png&#39;)


def temppickle():
    &#34;&#34;&#34;Create a temporary pickle file&#34;&#34;&#34;
    return tempfilename(suffix=&#39;.pkl&#39;)


def tempjpg():
    &#34;&#34;&#34;Create a temporary JPG file in system temp directory&#34;&#34;&#34;
    return tempimage(&#39;jpg&#39;)


def tempMP4():
    &#34;&#34;&#34;Create a temporary MP4 file in system temp directory&#34;&#34;&#34;
    return tempfilename(suffix=&#39;.mp4&#39;)

def tempWEBP():
    &#34;&#34;&#34;Create a temporary WEBP file in system temp directory&#34;&#34;&#34;
    return tempfilename(suffix=&#39;.webp&#39;)


def tmpjpg():
    &#34;&#34;&#34;Create a temporary JPG file in /tmp&#34;&#34;&#34;
    return &#39;/tmp/%s.jpg&#39; % uuid.uuid4().hex


def tempcsv():
    &#34;&#34;&#34;Create a temporary CSV file&#34;&#34;&#34;
    return tempfilename(suffix=&#39;.csv&#39;)

def temphtml():
    &#34;&#34;&#34;Create a temporary HTMLfile&#34;&#34;&#34;
    return tempfilename(suffix=&#39;.html&#39;)


def temppkl():
    &#34;&#34;&#34;Create a temporary pickle file&#34;&#34;&#34;
    return temppickle()

def temppklbz2():
    &#34;&#34;&#34;Create a temporary .pkl.bz2 file&#34;&#34;&#34;
    return temppickle()+&#39;.bz2&#39;


def tempyaml():
    &#34;&#34;&#34;Create a temporary YAML file&#34;&#34;&#34;
    return tempfilename(suffix=&#39;.yml&#39;)


def tempjson():
    &#34;&#34;&#34;Create a temporary JSON file&#34;&#34;&#34;
    return tempfilename(suffix=&#39;.json&#39;)


def temppdf():
    &#34;&#34;&#34;Create a temporary PDF file&#34;&#34;&#34;
    return tempfilename(suffix=&#39;.pdf&#39;)


def mktemp(ext):
    &#34;&#34;&#34;Create a temporary file with extension .ext&#34;&#34;&#34;
    return tempfilename(suffix=&#39;.&#39; + ext)


def tempdir():
    &#34;&#34;&#34;Wrapper around tempfile, because I can never remember the syntax&#34;&#34;&#34;
    return tempfile.gettempdir()


def imread(imfile):
    &#34;&#34;&#34;Wrapper for opencv imread. Note that color images are imported as
    BGR!&#34;&#34;&#34;
    return np.array(PIL.Image.open(imfile))[:,:,::-1]


def imrescale(im, scale):
    (height, width) = (im.shape[0], im.shape[1])
    return np.array(PIL.Image.fromarray(im).resize((int(np.round(scale * width)), int(np.round(scale * height))), PIL.Image.BILINEAR))


def imresize(im, rows, cols):
    return np.array(PIL.Image.fromarray(im).resize((rows, cols), PIL.Image.BILINEAR))


def touch(filename, mystr=&#39;&#39;):
    &#34;&#34;&#34;Create an empty file containing mystr&#34;&#34;&#34;
    f = open(filename, &#39;w&#39;)
    f.write(str(mystr))
    f.close()


class Stopwatch(object):
    &#34;&#34;&#34;Return elapsed system time in seconds between calls to enter and exit&#34;&#34;&#34;

    def __init__(self):
        self.reset()

    def __enter__(self):
        self.start = time.time()
        self.last = self.start
        return self

    def __exit__(self, *args):
        self.end = time.time()
        self.elapsed = self.end - self.start

    def since(self, start=False):
        &#34;&#34;&#34;Return seconds since start or last call to this method&#34;&#34;&#34;
        now = time.time()
        dur = now - self.start if start is True else now - self.last
        self.last = now
        return dur

    def reset(self):
        self.start = time.time()
        self.last = self.start
        return self

    def duration(self):
        &#34;&#34;&#34;Time in seconds since last reset&#34;&#34;&#34;
        return time.time() - self.start

    
class Timer(object):
    &#34;&#34;&#34;Pretty print elapsed system time in seconds between calls to enter and exit
    
    ```python 
       t = Timer():
       [some code]
       print(t)
       [some more code]
       print(t)

       with Timer():
          [some code]
    ```
       
    &#34;&#34;&#34;
    def __enter__(self):
        self._begin = time.time()
        self._last = self._begin
        return self
        
    def __exit__(self, *args):
        log.info(self.__repr__())

    def __init__(self, sprintf_next=None, sprintf_first=None):
        self._sprintf_next = &#39;[vipy.util.timer]: elapsed=%1.6fs, total=%1.6fs&#39; if sprintf_next is None else sprintf_next
        self._sprintf_first = &#39;[vipy.util.timer]: elapsed=%1.6fs&#39; if sprintf_first is None else sprintf_first
        self._begin = time.time()
        self._last = self._begin
        self._laps = 0        
        try:
            self._sprintf_next % (1.0, 1.0)
            self._sprintf_first % (1.0)            
        except:
            raise ValueError(&#39;Printed display string must be a sprintf style string with one or two number variable like &#34;Elapsed=%1.6f since=%1.6f&#34;&#39;)
            
    def __repr__(self):
        s = str(self._sprintf_next % (time.time() - self._last, (time.time() - self._begin))) if self._laps &gt; 0 else str(self._sprintf_first % (time.time() - self._begin))
        self._last = time.time()
        self._laps += 1
        return s

        
def isfile(path):
    &#34;&#34;&#34;Wrapper for os.path.isfile&#34;&#34;&#34;
    return os.path.isfile(str(path))


def isstring(s):
    &#34;&#34;&#34;Is an object a python string or unicode string?&#34;&#34;&#34;
    return isinstance(s, str)  # python3


def timestamp():
    &#34;&#34;&#34;Return date and time string in form DDMMMYY_HHMMSS&#34;&#34;&#34;
    return str.upper(strftime(&#34;%d%b%y_%I%M%S%p&#34;, localtime()))

def clockstamp():
    &#34;&#34;&#34;Datetime stamp in local timezone with second resolution with format Year-Month-Day Hour:Minute:Second&#34;&#34;&#34;    
    return datetime.now().strftime(&#34;%Y-%m-%d %H:%M:%S&#34;)    

def minutestamp():
    &#34;&#34;&#34;Return date and time string in form DDMMMYY_HHMM&#34;&#34;&#34;
    return str.upper(strftime(&#34;%d%b%y_%I%M%p&#34;, localtime()))


def datestamp():
    &#34;&#34;&#34;Return date and time string in form DDMMMYY&#34;&#34;&#34;
    return str.upper(strftime(&#34;%d%b%y&#34;, localtime()))


def remkdir(path, flush=False):
    &#34;&#34;&#34;Create a given directory if not already exists&#34;&#34;&#34;
    if os.path.isdir(path) is False and len(str(path)) &gt; 0:
        os.makedirs(path)
    elif flush is True:
        shutil.rmtree(path)
        os.makedirs(path)
    return os.path.abspath(os.path.expanduser(path))


def rermdir(path):
    &#34;&#34;&#34;Recursively delete a given directory (if exists), and remake it&#34;&#34;&#34;
    return remkdir(path, flush=True)


def premkdir(filename):
    &#34;&#34;&#34;pre-create directory /path/to/subdir using `vipy.util.remkdir` if it does not exist for outfile=/path/to/subdir/file.ext, and return filename&#34;&#34;&#34;
    remkdir(filepath(filename))
    return filename


def newbase(filename, base):
    &#34;&#34;&#34;Convert filename=/a/b/c.ext base=d -&gt; /a/b/d.ext&#34;&#34;&#34;
    return os.path.join(filepath(filename), &#39;%s.%s&#39; % (base, fileext(filename, withdot=False)))

def toextension(filename, newext):
    &#34;&#34;&#34;Convert filename=&#39;/path/to/myfile.ext&#39; to /path/to/myfile.xyz, such that newext=&#39;xyz&#39; or newext=&#39;.xyz&#39;&#34;&#34;&#34;
    if &#39;.&#39; in newext:
        newext = newext.split(&#39;.&#39;)[-1]
    (filename, oldext) = splitext(filename)
    return filename + &#39;.&#39; + str(newext)

def noextension(filename, ext=None):
    &#34;&#34;&#34;Convert filename=&#39;/path/to/myfile.ext&#39; or filename=&#39;/path/to/myfile.ext1.ext2.ext3&#39; to /path/to/myfile with no extension, removing the appended string past the first dot&#34;&#34;&#34;
    return filename.split(&#39;.&#39;)[0] if ext is None else filename.replace(ext, &#39;&#39;)

def topkl(filename):
    &#34;&#34;&#34;Convert filename=&#39;/path/to/myfile.ext&#39; to /path/to/myfile.pkl&#34;&#34;&#34;
    return toextension(filename, &#39;.pkl&#39;)

def splitext(filename):
    &#34;&#34;&#34;Given /a/b/c.ext return tuple of strings (&#39;/a/b/c&#39;, &#39;.ext&#39;), handling multi-dot extensions like .tar.gz&#34;&#34;&#34;
    (head, tail) = os.path.split(filename)
    ext = fileext(filename, multidot=True, withdot=True)
    base = tail.replace(ext,&#39;&#39;) if ext is not None else tail
    return (os.path.join(head, base), ext)  # for consistency with splitext


def hasextension(filename):
    &#34;&#34;&#34;Does the provided filename have a file extension (e.g. /path/to/file.ext) or not (e.g. /path/to/file)&#34;&#34;&#34;
    return fileext(filename) is not None


def fileext(filename, multidot=True, withdot=True):
    &#34;&#34;&#34;Given filename /a/b/c.ext return &#39;.ext&#39;, or /a/b/c.tar.gz return &#39;.tar.gz&#39;.   If multidot=False, then return &#39;.gz&#39;.  If withdot=False, return &#39;ext&#39;.  Multidot support at most two trailing dots&#34;&#34;&#34;
    (head, tail) = os.path.split(filename)
    try:
        parts = str.rsplit(tail, &#39;.&#39;, 2)
        if len(parts) == 3 and multidot:
            ext = &#39;.%s.%s&#39; % (parts[1], parts[2])  # .tar.gz
        elif len(parts) == 3 and not multidot:
            ext = &#39;.%s&#39; % (parts[2])  # .gz            
        else:
            ext = &#39;.&#39; + parts[1]  # .mp4

    except:
        base = tail
        ext = None
    return ext if withdot else ext[1:]

def mediaextension(filename):
    &#34;&#34;&#34;Return &#39;.mp4&#39; for filename=&#39;/a/b/c.mp4&#39;&#34;&#34;&#34;
    return fileext(filename, multidot=False)

def ismacosx():
    &#34;&#34;&#34;Is the current platform MacOSX?&#34;&#34;&#34;
    (sysname, nodename, release, version, machine) = os.uname()
    return sysname == &#39;Darwin&#39;


def islinux():
    &#34;&#34;&#34;is the current platform Linux?&#34;&#34;&#34;
    (sysname, nodename, release, version, machine) = os.uname()
    return sysname == &#39;Linux&#39;


def imcrop(img, bbox):
    &#34;&#34;&#34;Crop a 2D or 3D numpy image given a vipy.geometry.BoundingBox&#34;&#34;&#34;
    return img[bbox.xmin():bbox.xmax(), bbox.ymin():bbox.ymax()]


class Failed(Exception):
    &#34;&#34;&#34;Raised when unit test fails to throw an exception&#34;&#34;&#34;
    pass


def string_to_pil_interpolation(interp):
    &#34;&#34;&#34;Internal function to convert interp string to interp object&#34;&#34;&#34;
    assert interp in [&#39;bilinear&#39;, &#39;bicubic&#39;, &#39;nearest&#39;], &#34;Invalid interp - Must be in [&#39;bilinear&#39;, &#39;bicubic&#39;, &#39;nearest&#39;]&#34;
    if interp == &#39;bilinear&#39;:
        return PIL.Image.BILINEAR
    elif interp == &#39;bicubic&#39;:
        return PIL.Image.BICUBIC
    elif interp == &#39;nearest&#39;:
        return PIL.Image.NEAREST
    else:
        raise  # should never get here

def symlink(src, dst, overwrite=False):
    &#34;&#34;&#34;Create a symlink from src to dst, overwriting the existing symlink at dst if overwrite=True&#34;&#34;&#34;
    if overwrite and os.path.islink(dst):
        os.unlink(dst)
    os.symlink(src, dst)
    return dst


def truncate_string(s, maxlen):
    &#34;&#34;&#34;If string s is greater than maxlen, truncate and append an ellipsis&#34;&#34;&#34;
    return s if len(s) &lt;= maxlen else str(s)[0:maxlen]+&#39;...&#39;

def escape_string_for_innerHTML(s, escape=((&#39;\n&#39;,&#39;&lt;br&gt;&#39;),(&#39;{&#39;,&#34;&amp;#123;&#34;),(&#39;}&#39;,&#39;&#34;&amp;#125;&#34;&#39;),(&#39;&#34;&#39;, &#39;&amp;quot;&#39;),(&#34;&#39;&#34;,&#34;&amp;#39;&#34;))):
    &#34;&#34;&#34;Convert a string by replacing escape characters with equivalents suitable for copying into an innerHTML element in html.  

    The escaping characters are provided as ((character, replacemant), ...) 

    Given an html file with the format:
    
    &lt;html&gt;&lt;body&gt;&lt;pre&gt;INNER_HTML&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt;
    
    This function converts a string s to an escaped_string such that INNER_HTML replaced with the escaped string will render properly as the string s in-browser.

    This is useful for `vipy.visualize.scene_explorer` to escape json prior to copying into the template
    
    This is pretty hacky, there has got to be a better way ...
    &#34;&#34;&#34;
    for (c,e) in escape:
        s = s.replace(c,e)
    return s
    </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="vipy.util.bgr2gray"><code class="name flex">
<span>def <span class="ident">bgr2gray</span></span>(<span>im_bgr)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapper for numpy uint8 BGR image to uint8 numpy grayscale</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1518-L1520" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def bgr2gray(im_bgr):
    &#34;&#34;&#34;Wrapper for numpy uint8 BGR image to uint8 numpy grayscale&#34;&#34;&#34;
    return np.array(PIL.Image.fromarray(im_bgr).convert(&#39;L&#39;))</code></pre>
</details>
</dd>
<dt id="vipy.util.bgr2hsv"><code class="name flex">
<span>def <span class="ident">bgr2hsv</span></span>(<span>im_bgr)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a numpy array in BGR order to HSV</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1542-L1544" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def bgr2hsv(im_bgr):
    &#34;&#34;&#34;Convert a numpy array in BGR order to HSV&#34;&#34;&#34;
    return np.array(PIL.Image.fromarray(bgr2rgb(im_bgr)).convert(&#39;HSV&#39;))  # BGR -&gt; RGB -&gt; HSV</code></pre>
</details>
</dd>
<dt id="vipy.util.bgr2rgb"><code class="name flex">
<span>def <span class="ident">bgr2rgb</span></span>(<span>im_bgr)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapper for numpy BGR uint8 to numpy RGB uint8</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1532-L1534" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def bgr2rgb(im_bgr):
    &#34;&#34;&#34;Wrapper for numpy BGR uint8 to numpy RGB uint8&#34;&#34;&#34;
    return np.array(im_bgr)[:,:,::-1]</code></pre>
</details>
</dd>
<dt id="vipy.util.cache"><code class="name flex">
<span>def <span class="ident">cache</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>If the VIPY_CACHE environment variable set, return it otherwise return tempdir()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L304-L306" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def cache():
    &#34;&#34;&#34;If the VIPY_CACHE environment variable set, return it otherwise return tempdir()&#34;&#34;&#34;
    return remkdir(os.path.expanduser(os.environ[&#39;VIPY_CACHE&#39;])) if hascache() else tempdir()</code></pre>
</details>
</dd>
<dt id="vipy.util.cached"><code class="name flex">
<span>def <span class="ident">cached</span></span>(<span>filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new filename in the cache, or tempdir if not found</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1593-L1598" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def cached(filename):
    &#34;&#34;&#34;Create a new filename in the cache, or tempdir if not found&#34;&#34;&#34;
    if &#39;VIPY_CACHE&#39; in os.environ:
        return os.path.join(remkdir(os.environ[&#39;VIPY_CACHE&#39;]), filetail(filename))
    else:
        return totempdir(filename)</code></pre>
</details>
</dd>
<dt id="vipy.util.canload"><code class="name flex">
<span>def <span class="ident">canload</span></span>(<span>infile)</span>
</code></dt>
<dd>
<div class="desc"><p>Attempt to load an archive file, and return true if it can be successfully loaded, otherwise False</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L815-L821" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def canload(infile):
    &#34;&#34;&#34;Attempt to load an archive file, and return true if it can be successfully loaded, otherwise False&#34;&#34;&#34;
    try:
        load(infile, abspath=True)
        return True
    except:
        return False</code></pre>
</details>
</dd>
<dt id="vipy.util.catcher"><code class="name flex">
<span>def <span class="ident">catcher</span></span>(<span>f, *args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Call the function f with the provided arguments, and return (True, result) on success and (False, exception) if there is any thrown exception.</p>
<p>Useful for parallel processing
Useful for wrapping a function where execptions are silent.</p>
<p>For example, attempting to remove a file where the filename may be None or not present</p>
<pre><code class="language-python-repl">&gt;&gt;&gt; vipy.util.catcher(lambda f: os.remove(f), None)
&gt;&gt;&gt; vipy.util.catcher(lambda f: os.remove(f), '/path/to/missing.txt'))
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L256-L272" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def catcher(f, *args, **kwargs):
    &#34;&#34;&#34;Call the function f with the provided arguments, and return (True, result) on success and (False, exception) if there is any thrown exception.

    Useful for parallel processing
    Useful for wrapping a function where execptions are silent.

    For example, attempting to remove a file where the filename may be None or not present

    &gt;&gt;&gt; vipy.util.catcher(lambda f: os.remove(f), None)
    &gt;&gt;&gt; vipy.util.catcher(lambda f: os.remove(f), &#39;/path/to/missing.txt&#39;))

    &#34;&#34;&#34;
    assert callable(f)
    try:
        return (True, f(*args, **kwargs))
    except Exception as e:
        return (False, str(e))</code></pre>
</details>
</dd>
<dt id="vipy.util.chunkgen"><code class="name flex">
<span>def <span class="ident">chunkgen</span></span>(<span>inlist, num_chunks)</span>
</code></dt>
<dd>
<div class="desc"><p>Yield a list of lists of length num_chunks, such that each element is a list containing a sequential chunk of the original list.</p>
<pre><code class="language-python">A = next(vipy.util.chunkgen(inlist, num_chunks=3))
assert len(A) == len(inlist) // 3
</code></pre>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;The last chunk will be larger for ragged chunks</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L587-L598" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def chunkgen(inlist, num_chunks):
    &#34;&#34;&#34;Yield a list of lists of length num_chunks, such that each element is a list containing a sequential chunk of the original list.
    
    ```python
    A = next(vipy.util.chunkgen(inlist, num_chunks=3))
    assert len(A) == len(inlist) // 3
    ```
    .. note::  The last chunk will be larger for ragged chunks
    &#34;&#34;&#34;
    (m, n) = (num_chunks, int(np.ceil(float(len(inlist)) / float(num_chunks))))
    for i in range(0,m):
        yield inlist[i * n:min(i * n + n, len(inlist))]</code></pre>
</details>
</dd>
<dt id="vipy.util.chunkgenbysize"><code class="name flex">
<span>def <span class="ident">chunkgenbysize</span></span>(<span>ingen, size_per_chunk)</span>
</code></dt>
<dd>
<div class="desc"><p>Yield a list of lists such that each element is a list
containing a sequential chunk of the original list of length
size_per_chunk</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L608-L613" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def chunkgenbysize(ingen, size_per_chunk):
    &#34;&#34;&#34;Yield a list of lists such that each element is a list
    containing a sequential chunk of the original list of length
    size_per_chunk&#34;&#34;&#34;
    assert size_per_chunk &gt;= 1
    return batched(ingen, size_per_chunk)</code></pre>
</details>
</dd>
<dt id="vipy.util.chunklist"><code class="name flex">
<span>def <span class="ident">chunklist</span></span>(<span>inlist, num_chunks)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert list into a list of lists of length num_chunks, such that each element is a list containing a sequential chunk of the original list.</p>
<pre><code class="language-python">(A,B,C) = vipy.util.chunklist(inlist, num_chunks=3)
assert len(A) == len(inlist) // 3
</code></pre>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;The last chunk will be larger for ragged chunks</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L573-L584" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def chunklist(inlist, num_chunks):
    &#34;&#34;&#34;Convert list into a list of lists of length num_chunks, such that each element is a list containing a sequential chunk of the original list.
    
    ```python
    (A,B,C) = vipy.util.chunklist(inlist, num_chunks=3)
    assert len(A) == len(inlist) // 3
    ```

    .. note::  The last chunk will be larger for ragged chunks
    &#34;&#34;&#34;
    (m, n) = (num_chunks, int(np.ceil(float(len(inlist)) / float(num_chunks))))
    return [inlist[i * n:min(i * n + n, len(inlist))] for i in range(0, m)]</code></pre>
</details>
</dd>
<dt id="vipy.util.chunklistWithOverlap"><code class="name flex">
<span>def <span class="ident">chunklistWithOverlap</span></span>(<span>inlist, size_per_chunk, overlap_per_chunk)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert list into a list of lists such that each element is a list
containing a sequential chunk of the original list of length
size_per_chunk</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L620-L625" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def chunklistWithOverlap(inlist, size_per_chunk, overlap_per_chunk):
    &#34;&#34;&#34;Convert list into a list of lists such that each element is a list
    containing a sequential chunk of the original list of length
    size_per_chunk&#34;&#34;&#34;
    assert size_per_chunk &gt;= 1 and overlap_per_chunk &gt;= 0 and size_per_chunk &gt; overlap_per_chunk
    return [inlist[i-size_per_chunk:i] for i in range(size_per_chunk, len(inlist)+(size_per_chunk-overlap_per_chunk), size_per_chunk - overlap_per_chunk)]</code></pre>
</details>
</dd>
<dt id="vipy.util.chunklistbysize"><code class="name flex">
<span>def <span class="ident">chunklistbysize</span></span>(<span>inlist, size_per_chunk)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert list into a list of lists such that each element is a list
containing a sequential chunk of the original list of length
size_per_chunk</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L601-L606" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def chunklistbysize(inlist, size_per_chunk):
    &#34;&#34;&#34;Convert list into a list of lists such that each element is a list
    containing a sequential chunk of the original list of length
    size_per_chunk&#34;&#34;&#34;
    assert size_per_chunk &gt;= 1
    return [inlist[i:i+size_per_chunk] for i in range(0,len(inlist),size_per_chunk)]</code></pre>
</details>
</dd>
<dt id="vipy.util.chunklistwithoverlap"><code class="name flex">
<span>def <span class="ident">chunklistwithoverlap</span></span>(<span>inlist, size_per_chunk, overlap_per_chunk)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for chunklistWithOverlap</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L628-L630" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def chunklistwithoverlap(inlist, size_per_chunk, overlap_per_chunk):
    &#34;&#34;&#34;Alias for chunklistWithOverlap&#34;&#34;&#34;
    return chunklistWithOverlap(inlist, size_per_chunk, overlap_per_chunk)</code></pre>
</details>
</dd>
<dt id="vipy.util.class_registry"><code class="name flex">
<span>def <span class="ident">class_registry</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a dictionary mapping str(type(obj)) to a JSON loader for all vipy objects.</p>
<p>This function is useful for JSON loading of vipy objects to map to the correct deserialization method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L47-L80" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def class_registry():
    &#34;&#34;&#34;Return a dictionary mapping str(type(obj)) to a JSON loader for all vipy objects.

    This function is useful for JSON loading of vipy objects to map to the correct deserialization method.
    &#34;&#34;&#34;

    import vipy.video
    import vipy.image
    import vipy.dataset

    registry = {&#34;&lt;class &#39;vipy.video.Scene&#39;&gt;&#34;:vipy.video.Scene.from_json,
                &#34;&lt;class &#39;vipy.video.Video&#39;&gt;&#34;:vipy.video.Video.from_json,
                &#34;&lt;class &#39;vipy.video.VideoCategory&#39;&gt;&#34;:vipy.video.VideoCategory.from_json,
                &#34;&lt;class &#39;vipy.image.Image&#39;&gt;&#34;:vipy.image.Image.from_json,
                &#34;&lt;class &#39;vipy.image.ImageCategory&#39;&gt;&#34;:vipy.image.ImageCategory.from_json,
                &#34;&lt;class &#39;vipy.image.ImageDetection&#39;&gt;&#34;:vipy.image.ImageDetection.from_json,            
                &#34;&lt;class &#39;vipy.image.Scene&#39;&gt;&#34;:vipy.image.Scene.from_json,
                &#34;&lt;class &#39;vipy.geometry.BoundingBox&#39;&gt;&#34;:vipy.geometry.BoundingBox.from_json,
                &#34;&lt;class &#39;vipy.object.Track&#39;&gt;&#34;:vipy.object.Track.from_json,
                &#34;&lt;class &#39;vipy.object.Detection&#39;&gt;&#34;:vipy.object.Detection.from_json,
                &#34;&lt;class &#39;vipy.activity.Activity&#39;&gt;&#34;:vipy.activity.Activity.from_json}
    try:
        import pycollector.video
        registry.update( {&#34;&lt;class &#39;pycollector.video.Video&#39;&gt;&#34;:pycollector.video.Video.from_json} )
    except:
        registry.update( {&#34;&lt;class &#39;pycollector.video.Video&#39;&gt;&#34;:lambda x: exec(&#34;raise ValueError(\&#34;&lt;class &#39;pycollector.video.Video&#39;&gt; not found - Run &#39;pip install pycollector&#39; \&#34;)&#34;)})        
    try:
        import pycollector.admin.video
        registry.update( {&#34;&lt;class &#39;pycollector.admin.video.Video&#39;&gt;&#34;:pycollector.admin.video.Video.from_json} )
    except:
        registry.update( {&#34;&lt;class &#39;pycollector.admin.video.Video&#39;&gt;&#34;:lambda x: exec(&#34;raise ValueError(\&#34;&lt;class &#39;pycollector.admin.video.Video&#39;&gt; not found - This is for admin use only \&#34;)&#34;)})        

    registry.update( {None: cPickle.loads} )  # fallback on generic pickle dumps
    return registry</code></pre>
</details>
</dd>
<dt id="vipy.util.clockstamp"><code class="name flex">
<span>def <span class="ident">clockstamp</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Datetime stamp in local timezone with second resolution with format Year-Month-Day Hour:Minute:Second</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1790-L1792" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def clockstamp():
    &#34;&#34;&#34;Datetime stamp in local timezone with second resolution with format Year-Month-Day Hour:Minute:Second&#34;&#34;&#34;    
    return datetime.now().strftime(&#34;%Y-%m-%d %H:%M:%S&#34;)    </code></pre>
</details>
</dd>
<dt id="vipy.util.count_images_in_subdirectories"><code class="name flex">
<span>def <span class="ident">count_images_in_subdirectories</span></span>(<span>indir)</span>
</code></dt>
<dd>
<div class="desc"><p>Count the total number of images in indir/subdir1, indir/subdir2, go down only one level and no further&hellip;</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L414-L419" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def count_images_in_subdirectories(indir):
    &#34;&#34;&#34;Count the total number of images in indir/subdir1, indir/subdir2, go down only one level and no further...&#34;&#34;&#34;
    num_files = 0
    for d in dirlist(outdir):
        num_files += len(imlist(d))
    return num_files</code></pre>
</details>
</dd>
<dt id="vipy.util.countby"><code class="name flex">
<span>def <span class="ident">countby</span></span>(<span>inlist, keyfunc=&lt;function &lt;lambda&gt;&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Return dictionary of keys and group sizes for a grouping of the input list by keyfunc lambda function, sorted by increasing count</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L486-L488" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def countby(inlist, keyfunc=lambda x: x):
    &#34;&#34;&#34;Return dictionary of keys and group sizes for a grouping of the input list by keyfunc lambda function, sorted by increasing count&#34;&#34;&#34; 
    return {k:v for (k,v) in sorted({k:len(v) for (k,v) in groupbyasdict(inlist, keyfunc).items()}.items(), key=lambda x: x[1])}</code></pre>
</details>
</dd>
<dt id="vipy.util.countbyasdict"><code class="name flex">
<span>def <span class="ident">countbyasdict</span></span>(<span>inlist, keyfunc)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for <code><a title="vipy.util.countby" href="#vipy.util.countby">countby()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L499-L501" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def countbyasdict(inlist, keyfunc):
    &#34;&#34;&#34;Alias for `vipy.util.countby`&#34;&#34;&#34;
    return countby(inlist, keyfunc)</code></pre>
</details>
</dd>
<dt id="vipy.util.csvlist"><code class="name flex">
<span>def <span class="ident">csvlist</span></span>(<span>imdir)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of absolute paths of *.csv files in current directory</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1251-L1254" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def csvlist(imdir):
    &#34;&#34;&#34;Return a list of absolute paths of *.csv files in current directory&#34;&#34;&#34;
    return [os.path.join(imdir, item) for item in os.listdir(imdir)
            if iscsv(item)]</code></pre>
</details>
</dd>
<dt id="vipy.util.datestamp"><code class="name flex">
<span>def <span class="ident">datestamp</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Return date and time string in form DDMMMYY</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1799-L1801" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def datestamp():
    &#34;&#34;&#34;Return date and time string in form DDMMMYY&#34;&#34;&#34;
    return str.upper(strftime(&#34;%d%b%y&#34;, localtime()))</code></pre>
</details>
</dd>
<dt id="vipy.util.dedupe"><code class="name flex">
<span>def <span class="ident">dedupe</span></span>(<span>inlist, f)</span>
</code></dt>
<dd>
<div class="desc"><p>Deduplicate the list using the provided lambda function which transforms an element to a dedupe key, such that all elements with the same key are duplicates</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L234-L238" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dedupe(inlist, f):
    &#34;&#34;&#34;Deduplicate the list using the provided lambda function which transforms an element to a dedupe key, such that all elements with the same key are duplicates&#34;&#34;&#34;
    assert callable(f)
    assert isinstance(inlist, list)
    return list({f(x):x for x in inlist}.values())</code></pre>
</details>
</dd>
<dt id="vipy.util.delpath"><code class="name flex">
<span>def <span class="ident">delpath</span></span>(<span>indir, filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Return c/d.ext for filename /a/b/c/d.ext and indir /a/b</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1044-L1048" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def delpath(indir, filename):
    &#34;&#34;&#34;Return c/d.ext for filename /a/b/c/d.ext and indir /a/b&#34;&#34;&#34;
    assert indir in filename, &#39;Path &#34;%s&#34; not found in filename &#34;%s&#34;&#39; % (indir, filename)
    indir = os.path.join(indir, &#39;&#39;)  # /a/b -&gt; /a/b/
    return filename.split(indir)[1]</code></pre>
</details>
</dd>
<dt id="vipy.util.dirlist"><code class="name flex">
<span>def <span class="ident">dirlist</span></span>(<span>indir)</span>
</code></dt>
<dd>
<div class="desc"><p>return list of absolute paths to subdirectories in a directory</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1117-L1122" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dirlist(indir):
    &#34;&#34;&#34;return list of absolute paths to subdirectories in a directory&#34;&#34;&#34;
    return [os.path.abspath(os.path.join(indir, item))
            for item in os.listdir(indir)
            if (os.path.isdir(os.path.join(indir, item)) and
                not is_hiddenfile(item))]</code></pre>
</details>
</dd>
<dt id="vipy.util.dirlist_sorted_bycreation"><code class="name flex">
<span>def <span class="ident">dirlist_sorted_bycreation</span></span>(<span>indir)</span>
</code></dt>
<dd>
<div class="desc"><p>Sort the directory list from newest first to oldest last by creation date</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1125-L1127" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dirlist_sorted_bycreation(indir):
    &#34;&#34;&#34;Sort the directory list from newest first to oldest last by creation date&#34;&#34;&#34;
    return sorted(dirlist(indir), key=lambda d: os.stat(d).st_ctime, reverse=True)</code></pre>
</details>
</dd>
<dt id="vipy.util.dirload"><code class="name flex">
<span>def <span class="ident">dirload</span></span>(<span>indir)</span>
</code></dt>
<dd>
<div class="desc"><p>Load a directory by recursively searching for loadable archives and loading them into a flat list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L230-L232" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dirload(indir):
    &#34;&#34;&#34;Load a directory by recursively searching for loadable archives and loading them into a flat list&#34;&#34;&#34;
    return [x for f in findloadable(indir) for x in load(f)]</code></pre>
</details>
</dd>
<dt id="vipy.util.dividelist"><code class="name flex">
<span>def <span class="ident">dividelist</span></span>(<span>inlist, fractions)</span>
</code></dt>
<dd>
<div class="desc"><p>Divide inlist into a list of lists such that the size of each sublist is the requseted fraction of the original list. </p>
<p>This operation is deterministic and generates the same division in multiple calls.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>inlist</code></strong></dt>
<dd>[list]</dd>
<dt><strong><code>fractions</code></strong></dt>
<dd>[tuple] such as (0.1, 0.7, 0.2)
An iterable of fractions that must be non-negative and sum to one</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L534-L551" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dividelist(inlist, fractions):
    &#34;&#34;&#34;Divide inlist into a list of lists such that the size of each sublist is the requseted fraction of the original list. 

       This operation is deterministic and generates the same division in multiple calls.
       
    Args:
        inlist: [list]
        fractions: [tuple] such as (0.1, 0.7, 0.2)   An iterable of fractions that must be non-negative and sum to one
    &#34;&#34;&#34;
    assert all([f &gt;= 0 and f &lt;=1 for f in fractions])
    assert np.sum(fractions) == 1
    assert len(inlist) &gt;= len(fractions)
    N = np.int32(np.maximum(0, np.ceil(len(inlist)*np.array(fractions))))
    outlist = []
    for n in N:
        outlist.append(inlist[0:n])
        inlist = inlist[n:]
    return outlist</code></pre>
</details>
</dd>
<dt id="vipy.util.env"><code class="name flex">
<span>def <span class="ident">env</span></span>(<span>var=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the VIPY environment variable var, returning None if not present, or all environment variables if var=None.
Var is optionally prepended with 'VIPY_'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L294-L298" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def env(var=None):
    &#34;&#34;&#34;Return the VIPY environment variable var, returning None if not present, or all environment variables if var=None.  Var is optionally prepended with &#39;VIPY_&#39;&#34;&#34;&#34;
    env = {k:v for (k,v) in os.environ.items() if k.startswith(&#39;VIPY_&#39;)}
    var = (&#39;VIPY_&#39;+var) if var is not None and not var.startswith(&#39;VIPY_&#39;) else var
    return env if var is None else (env[var] if var in env else None)</code></pre>
</details>
</dd>
<dt id="vipy.util.escape_string_for_innerHTML"><code class="name flex">
<span>def <span class="ident">escape_string_for_innerHTML</span></span>(<span>s, escape=((&#x27;\n&#x27;, &#x27;&lt;br&gt;&#x27;), (&#x27;{&#x27;, &#x27;&amp;#123;&#x27;), (&#x27;}&#x27;, &#x27;&quot;&amp;#125;&quot;&#x27;), (&#x27;&quot;&#x27;, &#x27;&amp;quot;&#x27;), (&quot;&#x27;&quot;, &#x27;&amp;#39;&#x27;)))</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a string by replacing escape characters with equivalents suitable for copying into an innerHTML element in html.
</p>
<p>The escaping characters are provided as ((character, replacemant), &hellip;) </p>
<p>Given an html file with the format:</p>
<html><body><pre>INNER_HTML</pre></body></html>
<p>This function converts a string s to an escaped_string such that INNER_HTML replaced with the escaped string will render properly as the string s in-browser.</p>
<p>This is useful for <code><a title="vipy.visualize.scene_explorer" href="visualize.html#vipy.visualize.scene_explorer">scene_explorer()</a></code> to escape json prior to copying into the template</p>
<p>This is pretty hacky, there has got to be a better way &hellip;</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1924-L1941" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def escape_string_for_innerHTML(s, escape=((&#39;\n&#39;,&#39;&lt;br&gt;&#39;),(&#39;{&#39;,&#34;&amp;#123;&#34;),(&#39;}&#39;,&#39;&#34;&amp;#125;&#34;&#39;),(&#39;&#34;&#39;, &#39;&amp;quot;&#39;),(&#34;&#39;&#34;,&#34;&amp;#39;&#34;))):
    &#34;&#34;&#34;Convert a string by replacing escape characters with equivalents suitable for copying into an innerHTML element in html.  

    The escaping characters are provided as ((character, replacemant), ...) 

    Given an html file with the format:
    
    &lt;html&gt;&lt;body&gt;&lt;pre&gt;INNER_HTML&lt;/pre&gt;&lt;/body&gt;&lt;/html&gt;
    
    This function converts a string s to an escaped_string such that INNER_HTML replaced with the escaped string will render properly as the string s in-browser.

    This is useful for `vipy.visualize.scene_explorer` to escape json prior to copying into the template
    
    This is pretty hacky, there has got to be a better way ...
    &#34;&#34;&#34;
    for (c,e) in escape:
        s = s.replace(c,e)
    return s</code></pre>
</details>
</dd>
<dt id="vipy.util.extlist"><code class="name flex">
<span>def <span class="ident">extlist</span></span>(<span>indir, ext)</span>
</code></dt>
<dd>
<div class="desc"><p>return list of files with absolute path in a directory that have
the provided extension (with the prepended dot, ext='.mp4')</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1130-L1136" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def extlist(indir, ext):
    &#34;&#34;&#34;return list of files with absolute path in a directory that have
    the provided extension (with the prepended dot, ext=&#39;.mp4&#39;)&#34;&#34;&#34;
    return [os.path.abspath(os.path.join(indir, item))
            for item in os.listdir(indir)
            if fileext(item) is not None
            and (fileext(item).lower() == ext.lower())]</code></pre>
</details>
</dd>
<dt id="vipy.util.filebase"><code class="name flex">
<span>def <span class="ident">filebase</span></span>(<span>filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Return c for filename /a/b/c.ext</p>
<div class="admonition warning">
<p class="admonition-title">Warning:&ensp;Will return /a/b/c.d for multidot filenames wth more than two trailing dots like /a/b/c.d.e.f (e.g. /a/b/my.filename.tar.gz)</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1026-L1033" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def filebase(filename):
    &#34;&#34;&#34;Return c for filename /a/b/c.ext
    
    .. warning:: Will return /a/b/c.d for multidot filenames wth more than two trailing dots like /a/b/c.d.e.f (e.g. /a/b/my.filename.tar.gz)
    &#34;&#34;&#34;
    (head, tail) = os.path.split(filename)
    (base, ext) = splitext(tail)
    return base</code></pre>
</details>
</dd>
<dt id="vipy.util.fileext"><code class="name flex">
<span>def <span class="ident">fileext</span></span>(<span>filename, multidot=True, withdot=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Given filename /a/b/c.ext return '.ext', or /a/b/c.tar.gz return '.tar.gz'.
If multidot=False, then return '.gz'.
If withdot=False, return 'ext'.
Multidot support at most two trailing dots</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1857-L1872" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def fileext(filename, multidot=True, withdot=True):
    &#34;&#34;&#34;Given filename /a/b/c.ext return &#39;.ext&#39;, or /a/b/c.tar.gz return &#39;.tar.gz&#39;.   If multidot=False, then return &#39;.gz&#39;.  If withdot=False, return &#39;ext&#39;.  Multidot support at most two trailing dots&#34;&#34;&#34;
    (head, tail) = os.path.split(filename)
    try:
        parts = str.rsplit(tail, &#39;.&#39;, 2)
        if len(parts) == 3 and multidot:
            ext = &#39;.%s.%s&#39; % (parts[1], parts[2])  # .tar.gz
        elif len(parts) == 3 and not multidot:
            ext = &#39;.%s&#39; % (parts[2])  # .gz            
        else:
            ext = &#39;.&#39; + parts[1]  # .mp4

    except:
        base = tail
        ext = None
    return ext if withdot else ext[1:]</code></pre>
</details>
</dd>
<dt id="vipy.util.filefull"><code class="name flex">
<span>def <span class="ident">filefull</span></span>(<span>f)</span>
</code></dt>
<dd>
<div class="desc"><p>Return /a/b/c for filename /a/b/c.ext</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1083-L1086" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def filefull(f):
    &#34;&#34;&#34;Return /a/b/c for filename /a/b/c.ext&#34;&#34;&#34;
    ext = fileext(f, multidot=True, withdot=True)
    return f.replace(ext, &#39;&#39;) if ext is not None else f</code></pre>
</details>
</dd>
<dt id="vipy.util.filepath"><code class="name flex">
<span>def <span class="ident">filepath</span></span>(<span>filename, depth=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Return /a/b/c for filename /a/b/c/d.ext, /a/b for filename /a/b/c/d.ext if depth=1, etc</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1036-L1041" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def filepath(filename, depth=0):
    &#34;&#34;&#34;Return /a/b/c for filename /a/b/c/d.ext, /a/b for filename /a/b/c/d.ext if depth=1, etc&#34;&#34;&#34;
    (head, tail) = os.path.split(filename)
    for k in range(depth):
        (head, tail) = os.path.split(head)           
    return head</code></pre>
</details>
</dd>
<dt id="vipy.util.filetail"><code class="name flex">
<span>def <span class="ident">filetail</span></span>(<span>filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Return c.ext for filename /a/b/c.ext</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1089-L1092" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def filetail(filename):
    &#34;&#34;&#34;Return c.ext for filename /a/b/c.ext&#34;&#34;&#34;
    (head, tail) = os.path.split(filename)
    return tail</code></pre>
</details>
</dd>
<dt id="vipy.util.findimage"><code class="name flex">
<span>def <span class="ident">findimage</span></span>(<span>basedir)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of absolute paths to image files recursively discovered by walking the directory tree rooted at basedir</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L373-L375" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def findimage(basedir):
    &#34;&#34;&#34;Return a list of absolute paths to image files recursively discovered by walking the directory tree rooted at basedir&#34;&#34;&#34;
    return [str(path.resolve()) for path in pathlib.Path(basedir).rglob(&#39;*&#39;) if isimage(str(path.resolve()))]</code></pre>
</details>
</dd>
<dt id="vipy.util.findimages"><code class="name flex">
<span>def <span class="ident">findimages</span></span>(<span>basedir)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for <code><a title="vipy.util.findimage" href="#vipy.util.findimage">findimage()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L377-L379" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def findimages(basedir):
    &#34;&#34;&#34;Alias for `vipy.util.findimage`&#34;&#34;&#34;
    return findimage(basedir)</code></pre>
</details>
</dd>
<dt id="vipy.util.findjpg"><code class="name flex">
<span>def <span class="ident">findjpg</span></span>(<span>basedir)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of absolute paths to jpg files recursively discovered by walking the directory tree rooted at basedir</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L353-L355" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def findjpg(basedir):
    &#34;&#34;&#34;Return a list of absolute paths to jpg files recursively discovered by walking the directory tree rooted at basedir&#34;&#34;&#34;
    return [str(path.resolve()) for path in pathlib.Path(basedir).rglob(&#39;*.jpg&#39;)]</code></pre>
</details>
</dd>
<dt id="vipy.util.findjson"><code class="name flex">
<span>def <span class="ident">findjson</span></span>(<span>basedir)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of absolute paths to json files recursively discovered by walking the directory tree rooted at basedir</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L357-L359" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def findjson(basedir):
    &#34;&#34;&#34;Return a list of absolute paths to json files recursively discovered by walking the directory tree rooted at basedir&#34;&#34;&#34;
    return [str(path.resolve()) for path in pathlib.Path(basedir).rglob(&#39;*.json&#39;)]</code></pre>
</details>
</dd>
<dt id="vipy.util.findloadable"><code class="name flex">
<span>def <span class="ident">findloadable</span></span>(<span>basedir)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of absolute paths to any archive file loadable by <code>vipy.load</code> (<em>.pkl, </em>.json, *.pkl.bz2).
Recursively search starting from basedir</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L397-L399" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def findloadable(basedir):
    &#34;&#34;&#34;Return a list of absolute paths to any archive file loadable by `vipy.load` (*.pkl, *.json, *.pkl.bz2).  Recursively search starting from basedir&#34;&#34;&#34;
    return findpkl(basedir) + findjson(basedir) + findpklbz2(basedir) + findpickle(basedir)</code></pre>
</details>
</dd>
<dt id="vipy.util.findpdf"><code class="name flex">
<span>def <span class="ident">findpdf</span></span>(<span>basedir)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of absolute paths to pdf files recursively discovered by walking the directory tree rooted at basedir</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L345-L347" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def findpdf(basedir):
    &#34;&#34;&#34;Return a list of absolute paths to pdf files recursively discovered by walking the directory tree rooted at basedir&#34;&#34;&#34;
    return [str(path.resolve()) for path in pathlib.Path(basedir).rglob(&#39;*.pdf&#39;)]</code></pre>
</details>
</dd>
<dt id="vipy.util.findpickle"><code class="name flex">
<span>def <span class="ident">findpickle</span></span>(<span>basedir)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of absolute paths to pkl files recursively discovered by walking the directory tree rooted at basedir</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L337-L339" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def findpickle(basedir):
    &#34;&#34;&#34;Return a list of absolute paths to pkl files recursively discovered by walking the directory tree rooted at basedir&#34;&#34;&#34;
    return [str(path.resolve()) for path in pathlib.Path(basedir).rglob(&#39;*.pickle&#39;)]</code></pre>
</details>
</dd>
<dt id="vipy.util.findpkl"><code class="name flex">
<span>def <span class="ident">findpkl</span></span>(<span>basedir)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of absolute paths to pkl files recursively discovered by walking the directory tree rooted at basedir</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L333-L335" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def findpkl(basedir):
    &#34;&#34;&#34;Return a list of absolute paths to pkl files recursively discovered by walking the directory tree rooted at basedir&#34;&#34;&#34;
    return [str(path.resolve()) for path in pathlib.Path(basedir).rglob(&#39;*.pkl&#39;)]</code></pre>
</details>
</dd>
<dt id="vipy.util.findpklbz2"><code class="name flex">
<span>def <span class="ident">findpklbz2</span></span>(<span>basedir)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of absolute paths to .pkl.bz2 files recursively discovered by walking the directory tree rooted at basedir</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L341-L343" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def findpklbz2(basedir):
    &#34;&#34;&#34;Return a list of absolute paths to .pkl.bz2 files recursively discovered by walking the directory tree rooted at basedir&#34;&#34;&#34;
    return [str(path.resolve()) for path in pathlib.Path(basedir).rglob(&#39;*.pkl.bz2&#39;)]</code></pre>
</details>
</dd>
<dt id="vipy.util.findpng"><code class="name flex">
<span>def <span class="ident">findpng</span></span>(<span>basedir)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of absolute paths to png files recursively discovered by walking the directory tree rooted at basedir</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L349-L351" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def findpng(basedir):
    &#34;&#34;&#34;Return a list of absolute paths to png files recursively discovered by walking the directory tree rooted at basedir&#34;&#34;&#34;
    return [str(path.resolve()) for path in pathlib.Path(basedir).rglob(&#39;*.png&#39;)]</code></pre>
</details>
</dd>
<dt id="vipy.util.findtar"><code class="name flex">
<span>def <span class="ident">findtar</span></span>(<span>basedir)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of absolute paths to tar files recursively discovered by walking the directory tree rooted at basedir</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L365-L367" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def findtar(basedir):
    &#34;&#34;&#34;Return a list of absolute paths to tar files recursively discovered by walking the directory tree rooted at basedir&#34;&#34;&#34;
    return [str(path.resolve()) for path in pathlib.Path(basedir).rglob(&#39;*.tar&#39;)]</code></pre>
</details>
</dd>
<dt id="vipy.util.findtargz"><code class="name flex">
<span>def <span class="ident">findtargz</span></span>(<span>basedir)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of absolute paths to .pkl.bz2 files recursively discovered by walking the directory tree rooted at basedir</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L369-L371" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def findtargz(basedir):
    &#34;&#34;&#34;Return a list of absolute paths to .pkl.bz2 files recursively discovered by walking the directory tree rooted at basedir&#34;&#34;&#34;
    return [str(path.resolve()) for path in pathlib.Path(basedir).rglob(&#39;*.tar.gz&#39;)]</code></pre>
</details>
</dd>
<dt id="vipy.util.findtxt"><code class="name flex">
<span>def <span class="ident">findtxt</span></span>(<span>basedir)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of absolute paths to txt files recursively discovered by walking the directory tree rooted at basedir</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L361-L363" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def findtxt(basedir):
    &#34;&#34;&#34;Return a list of absolute paths to txt files recursively discovered by walking the directory tree rooted at basedir&#34;&#34;&#34;
    return [str(path.resolve()) for path in pathlib.Path(basedir).rglob(&#39;*.txt&#39;)]</code></pre>
</details>
</dd>
<dt id="vipy.util.findvideo"><code class="name flex">
<span>def <span class="ident">findvideo</span></span>(<span>basedir)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of absolute paths to video files recursively discovered by walking the directory tree rooted at basedir</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L381-L383" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def findvideo(basedir):
    &#34;&#34;&#34;Return a list of absolute paths to video files recursively discovered by walking the directory tree rooted at basedir&#34;&#34;&#34;
    return [str(path.resolve()) for path in pathlib.Path(basedir).rglob(&#39;*&#39;) if isvideo(str(path.resolve()))]</code></pre>
</details>
</dd>
<dt id="vipy.util.findvideos"><code class="name flex">
<span>def <span class="ident">findvideos</span></span>(<span>basedir)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for <code><a title="vipy.util.findvideo" href="#vipy.util.findvideo">findvideo()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L393-L395" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def findvideos(basedir):
    &#34;&#34;&#34;Alias for `vipy.util.findvideo`&#34;&#34;&#34;
    return findvideo(basedir)</code></pre>
</details>
</dd>
<dt id="vipy.util.findwebp"><code class="name flex">
<span>def <span class="ident">findwebp</span></span>(<span>basedir)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of absolute paths to video files recursively discovered by walking the directory tree rooted at basedir</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L385-L387" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def findwebp(basedir):
    &#34;&#34;&#34;Return a list of absolute paths to video files recursively discovered by walking the directory tree rooted at basedir&#34;&#34;&#34;
    return [str(path.resolve()) for path in pathlib.Path(basedir).rglob(&#39;*&#39;) if iswebp(str(path.resolve()))]</code></pre>
</details>
</dd>
<dt id="vipy.util.findxml"><code class="name flex">
<span>def <span class="ident">findxml</span></span>(<span>basedir)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of absolute paths to video files recursively discovered by walking the directory tree rooted at basedir</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L389-L391" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def findxml(basedir):
    &#34;&#34;&#34;Return a list of absolute paths to video files recursively discovered by walking the directory tree rooted at basedir&#34;&#34;&#34;
    return [str(path.resolve()) for path in pathlib.Path(basedir).rglob(&#39;*.xml&#39;)]</code></pre>
</details>
</dd>
<dt id="vipy.util.findyaml"><code class="name flex">
<span>def <span class="ident">findyaml</span></span>(<span>basedir)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of absolute paths to yaml files recursively discovered by walking the directory tree rooted at basedir</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L328-L330" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def findyaml(basedir):
    &#34;&#34;&#34;Return a list of absolute paths to yaml files recursively discovered by walking the directory tree rooted at basedir&#34;&#34;&#34;
    return [str(path.resolve()) for path in pathlib.Path(basedir).rglob(&#39;*.yml&#39;)]</code></pre>
</details>
</dd>
<dt id="vipy.util.flatlist"><code class="name flex">
<span>def <span class="ident">flatlist</span></span>(<span>inlist)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert list of tuples into a list expanded by concatenating tuples.
If the input is already flat, return it unchanged.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L523-L525" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def flatlist(inlist):
    &#34;&#34;&#34;Convert list of tuples into a list expanded by concatenating tuples.  If the input is already flat, return it unchanged.&#34;&#34;&#34;
    return [x for r in inlist for x in (r if isinstance(r, (list, tuple, set)) else (r,))]</code></pre>
</details>
</dd>
<dt id="vipy.util.gray2bgr"><code class="name flex">
<span>def <span class="ident">gray2bgr</span></span>(<span>im_gray)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapper for numpy float32 gray image to uint8 numpy BGR</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1523-L1525" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def gray2bgr(im_gray):
    &#34;&#34;&#34;Wrapper for numpy float32 gray image to uint8 numpy BGR&#34;&#34;&#34;
    return np.array(PIL.Image.fromarray(im_gray, mode=&#39;F&#39;).convert(&#39;RGB&#39;))[:,:,::-1]  # Gray -&gt; RGB -&gt; BGR</code></pre>
</details>
</dd>
<dt id="vipy.util.gray2hsv"><code class="name flex">
<span>def <span class="ident">gray2hsv</span></span>(<span>im_gray)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a numpy array in floating point single channel greyscale order to HSV</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1547-L1549" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def gray2hsv(im_gray):
    &#34;&#34;&#34;Convert a numpy array in floating point single channel greyscale order to HSV&#34;&#34;&#34;
    return np.array(PIL.Image.fromarray(gray2rgb(im_gray)).convert(&#39;HSV&#39;))  # Gray -&gt; RGB -&gt; HSV</code></pre>
</details>
</dd>
<dt id="vipy.util.gray2jet"><code class="name flex">
<span>def <span class="ident">gray2jet</span></span>(<span>img)</span>
</code></dt>
<dd>
<div class="desc"><p>[0,1] grayscale to [0.255] RGB</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L736-L740" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def gray2jet(img):
    &#34;&#34;&#34;[0,1] grayscale to [0.255] RGB&#34;&#34;&#34;
    import matplotlib.pyplot as plt
    jet = plt.get_cmap(&#39;jet&#39;)
    return np.uint8(255.0 * jet(img)[:, :, 0:3])</code></pre>
</details>
</dd>
<dt id="vipy.util.gray2rgb"><code class="name flex">
<span>def <span class="ident">gray2rgb</span></span>(<span>im_gray)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1528-L1529" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def gray2rgb(im_gray):
    return bgr2rgb(gray2bgr(im_gray))</code></pre>
</details>
</dd>
<dt id="vipy.util.groupby"><code class="name flex">
<span>def <span class="ident">groupby</span></span>(<span>initer, keyfunc)</span>
</code></dt>
<dd>
<div class="desc"><p>groupby on unsorted input iterable (initer)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L463-L465" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def groupby(initer, keyfunc):
    &#34;&#34;&#34;groupby on unsorted input iterable (initer)&#34;&#34;&#34;
    return itertools_groupby(sorted(initer, key=keyfunc), keyfunc)</code></pre>
</details>
</dd>
<dt id="vipy.util.groupbyasdict"><code class="name flex">
<span>def <span class="ident">groupbyasdict</span></span>(<span>togroup, keyfunc, valuefunc=&lt;function &lt;lambda&gt;&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Return dictionary of keys and lists from groupby on unsorted inset, where keyfunc is a lambda function on elements in inset</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>togroup</code></strong></dt>
<dd>an iteraable of elements to group</dd>
<dt><strong><code>keyfunc</code></strong></dt>
<dd>a lambda function to operate on elements of togroup such that the value returned from the lambda is the equality key for grouping</dd>
<dt><strong><code>valuefunc</code></strong></dt>
<dd>a lambda function to operate on elements of to group such that the value returned from the lambda is a transform of the element to be grouped</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A dictionary with unique keys returned from keyfunc, and values are lists of elements in togroup with the same key</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L473-L484" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def groupbyasdict(togroup, keyfunc, valuefunc=lambda x: x):
    &#34;&#34;&#34;Return dictionary of keys and lists from groupby on unsorted inset, where keyfunc is a lambda function on elements in inset
    
    Args:
        togroup: an iteraable of elements to group
        keyfunc:  a lambda function to operate on elements of togroup such that the value returned from the lambda is the equality key for grouping
        valuefunc: a lambda function to operate on elements of to group such that the value returned from the lambda is a transform of the element to be grouped
    Returns:
        A dictionary with unique keys returned from keyfunc, and values are lists of elements in togroup with the same key

    &#34;&#34;&#34;
    return {k: [valuefunc(vi) for vi in v] for (k, v) in groupby(togroup, keyfunc)}</code></pre>
</details>
</dd>
<dt id="vipy.util.has_image_extension"><code class="name flex">
<span>def <span class="ident">has_image_extension</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for <code><a title="vipy.util.isimg" href="#vipy.util.isimg">isimg()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1444-L1446" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def has_image_extension(path):
    &#34;&#34;&#34;Alias for `vipy.util.isimg`&#34;&#34;&#34;
    return isimg(path)</code></pre>
</details>
</dd>
<dt id="vipy.util.hascache"><code class="name flex">
<span>def <span class="ident">hascache</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Is the VIPY_CACHE environment variable set?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L300-L302" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def hascache():
    &#34;&#34;&#34;Is the VIPY_CACHE environment variable set?&#34;&#34;&#34;
    return &#39;VIPY_CACHE&#39; in os.environ</code></pre>
</details>
</dd>
<dt id="vipy.util.hasextension"><code class="name flex">
<span>def <span class="ident">hasextension</span></span>(<span>filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Does the provided filename have a file extension (e.g. /path/to/file.ext) or not (e.g. /path/to/file)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1852-L1854" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def hasextension(filename):
    &#34;&#34;&#34;Does the provided filename have a file extension (e.g. /path/to/file.ext) or not (e.g. /path/to/file)&#34;&#34;&#34;
    return fileext(filename) is not None</code></pre>
</details>
</dd>
<dt id="vipy.util.imcrop"><code class="name flex">
<span>def <span class="ident">imcrop</span></span>(<span>img, bbox)</span>
</code></dt>
<dd>
<div class="desc"><p>Crop a 2D or 3D numpy image given a vipy.geometry.BoundingBox</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1890-L1892" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def imcrop(img, bbox):
    &#34;&#34;&#34;Crop a 2D or 3D numpy image given a vipy.geometry.BoundingBox&#34;&#34;&#34;
    return img[bbox.xmin():bbox.xmax(), bbox.ymin():bbox.ymax()]</code></pre>
</details>
</dd>
<dt id="vipy.util.imlist"><code class="name flex">
<span>def <span class="ident">imlist</span></span>(<span>imdir)</span>
</code></dt>
<dd>
<div class="desc"><p>return list of images with absolute path in a directory</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1103-L1107" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def imlist(imdir):
    &#34;&#34;&#34;return list of images with absolute path in a directory&#34;&#34;&#34;
    return [os.path.abspath(os.path.join(imdir, item))
            for item in os.listdir(imdir)
            if (isimg(item) and not is_hiddenfile(item))]</code></pre>
</details>
</dd>
<dt id="vipy.util.imlistidx"><code class="name flex">
<span>def <span class="ident">imlistidx</span></span>(<span>filelist, idx_in_filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Return index in list of filename containing index number</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1273-L1276" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def imlistidx(filelist, idx_in_filename):
    &#34;&#34;&#34;Return index in list of filename containing index number&#34;&#34;&#34;
    return [i for (i, item) in enumerate(filelist)
            if (item.find(&#39;%d&#39; % idx_in_filename) &gt; 0)]</code></pre>
</details>
</dd>
<dt id="vipy.util.imread"><code class="name flex">
<span>def <span class="ident">imread</span></span>(<span>imfile)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapper for opencv imread. Note that color images are imported as
BGR!</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1680-L1683" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def imread(imfile):
    &#34;&#34;&#34;Wrapper for opencv imread. Note that color images are imported as
    BGR!&#34;&#34;&#34;
    return np.array(PIL.Image.open(imfile))[:,:,::-1]</code></pre>
</details>
</dd>
<dt id="vipy.util.imrescale"><code class="name flex">
<span>def <span class="ident">imrescale</span></span>(<span>im, scale)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1686-L1688" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def imrescale(im, scale):
    (height, width) = (im.shape[0], im.shape[1])
    return np.array(PIL.Image.fromarray(im).resize((int(np.round(scale * width)), int(np.round(scale * height))), PIL.Image.BILINEAR))</code></pre>
</details>
</dd>
<dt id="vipy.util.imresize"><code class="name flex">
<span>def <span class="ident">imresize</span></span>(<span>im, rows, cols)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1691-L1692" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def imresize(im, rows, cols):
    return np.array(PIL.Image.fromarray(im).resize((rows, cols), PIL.Image.BILINEAR))</code></pre>
</details>
</dd>
<dt id="vipy.util.imsavelist"><code class="name flex">
<span>def <span class="ident">imsavelist</span></span>(<span>imdir, outfile)</span>
</code></dt>
<dd>
<div class="desc"><p>Write out all images in a directory to a provided file with each
line containing absolute path to image</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1245-L1248" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def imsavelist(imdir, outfile):
    &#34;&#34;&#34;Write out all images in a directory to a provided file with each
    line containing absolute path to image&#34;&#34;&#34;
    return writelist(imlist(imdir), outfile)</code></pre>
</details>
</dd>
<dt id="vipy.util.imwrite"><code class="name flex">
<span>def <span class="ident">imwrite</span></span>(<span>img, imfile=None, writeas=None, quality=75)</span>
</code></dt>
<dd>
<div class="desc"><p>Write a floating point 2D numpy image as jet or gray, 3D numpy as
rgb or bgr</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L685-L722" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def imwrite(img, imfile=None, writeas=None, quality=75):
    &#34;&#34;&#34;Write a floating point 2D numpy image as jet or gray, 3D numpy as
    rgb or bgr&#34;&#34;&#34;
    if imfile is None:
        imfile = temppng()
    if not isnumpy(img):
        raise ValueError(&#39;image must by numpy object&#39;)
    if writeas is None:
        if img.ndim == 2:
            writeas = &#39;gray&#39;
        else:
            writeas = &#39;bgr&#39;

    imfile = os.path.expanduser(imfile)
    if writeas in [&#39;jet&#39;]:
        imwritejet(img, imfile)
    elif writeas in [&#39;gray&#39;]:
        imwritegray(img, imfile)
    elif writeas in [&#39;rgb&#39;]:
        if img.ndim != 3:
            raise ValueError(&#39;numpy array must be 3D&#39;)
        if img.dtype == np.dtype(&#39;uint8&#39;):
            PIL.Image.fromarray(rgb2bgr(img)).save(imfile, quality=quality)  # convert to BGR
        elif img.dtype == np.dtype(&#39;float32&#39;):
            # convert to uint8 then BGR
            PIL.Image.fromarray(rgb2bgr(np.uint8(255.0 * img))).save(imfile)
    elif writeas in [&#39;bgr&#39;]:
        if img.ndim != 3:
            raise ValueError(&#39;numpy array must be 3D&#39;)
        if img.dtype == np.dtype(&#39;uint8&#39;):
            PIL.Image.fromarray(img).save(imfile, quality=quality)  # convert to BGR
        elif img.dtype == np.dtype(&#39;float32&#39;):
            # convert to uint8 then BGR
            PIL.Image.fromarray(np.uint8(255.0 * img)).save(imfile, quality=quality)
    else:
        raise ValueError(&#39;unsupported writeas&#39;)

    return imfile</code></pre>
</details>
</dd>
<dt id="vipy.util.imwritegray"><code class="name flex">
<span>def <span class="ident">imwritegray</span></span>(<span>img, imfile=None, quality=75)</span>
</code></dt>
<dd>
<div class="desc"><p>Write a floating point grayscale numpy image in [0,1] as [0,255] grayscale</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L666-L682" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def imwritegray(img, imfile=None, quality=75):
    &#34;&#34;&#34;Write a floating point grayscale numpy image in [0,1] as [0,255] grayscale&#34;&#34;&#34;
    if imfile is None:
        imfile = temppng()
    if isnumpy(img):
        if img.dtype == np.dtype(&#39;uint8&#39;):
            # Assume that uint8 is in the range [0,255]
            PIL.Image.fromarray(img).save(os.path.expanduser(imfile), quality=quality)
        elif img.dtype == np.dtype(&#39;float32&#39;):
            # Convert [0, 1.0] to uint8 [0,255]
            PIL.Image.fromarray(np.uint8(img * 255.0)).save(os.path.expanduser(imfile), quality=quality)
        else:
            raise ValueError(&#39;Unsupported datatype - &#39;
                             &#39;Numpy array must be uint8 or float32&#39;)
    else:
        raise ValueError(&#39;Input must be numpy array&#39;)
    return imfile</code></pre>
</details>
</dd>
<dt id="vipy.util.imwritejet"><code class="name flex">
<span>def <span class="ident">imwritejet</span></span>(<span>img, imfile=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Write a grayscale numpy image as a jet colormapped image to the
given file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L632-L646" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def imwritejet(img, imfile=None):
    &#34;&#34;&#34;Write a grayscale numpy image as a jet colormapped image to the
    given file&#34;&#34;&#34;
    if imfile is None:
        imfile = temppng()

    if isnumpy(img):
        if img.ndim == 2:
            cm = plt.get_cmap(&#39;gist_rainbow&#39;)
            PIL.Image.fromarray(np.uint8(255 * cm(img)[:,:,:3])).save(os.path.expanduser(imfile))
        else:
            raise ValueError(&#39;Input must be a 2D numpy array&#39;)
    else:
        raise ValueError(&#39;Input must be numpy array&#39;)
    return imfile</code></pre>
</details>
</dd>
<dt id="vipy.util.isRTMPurl"><code class="name flex">
<span>def <span class="ident">isRTMPurl</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1332-L1333" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isRTMPurl(path):
    return is_rtmp_url(path)</code></pre>
</details>
</dd>
<dt id="vipy.util.isRTSPurl"><code class="name flex">
<span>def <span class="ident">isRTSPurl</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1329-L1330" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isRTSPurl(path):
    return isurl(path) and path.startswith(&#39;rtsp://&#39;)</code></pre>
</details>
</dd>
<dt id="vipy.util.isS3url"><code class="name flex">
<span>def <span class="ident">isS3url</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"><p>Is a path a URL for an S3 object?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1320-L1322" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isS3url(path):
    &#34;&#34;&#34;Is a path a URL for an S3 object?&#34;&#34;&#34;
    return isurl(path) and urlparse(path).scheme == &#39;s3&#39;</code></pre>
</details>
</dd>
<dt id="vipy.util.is_email_address"><code class="name flex">
<span>def <span class="ident">is_email_address</span></span>(<span>email)</span>
</code></dt>
<dd>
<div class="desc"><p>Is the provided string an email address?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L751-L754" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def is_email_address(email):
    &#34;&#34;&#34;Is the provided string an email address?&#34;&#34;&#34;
    regex = r&#39;\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b&#39;
    return re.fullmatch(regex, email) is not None</code></pre>
</details>
</dd>
<dt id="vipy.util.is_hiddenfile"><code class="name flex">
<span>def <span class="ident">is_hiddenfile</span></span>(<span>filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Does the filename start with a period?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L757-L759" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def is_hiddenfile(filename):
    &#34;&#34;&#34;Does the filename start with a period?&#34;&#34;&#34;
    return filename[0] == &#39;.&#39;</code></pre>
</details>
</dd>
<dt id="vipy.util.is_jsonable"><code class="name flex">
<span>def <span class="ident">is_jsonable</span></span>(<span>obj)</span>
</code></dt>
<dd>
<div class="desc"><p>Return true if can be successfully converted to json (without actually doing it) by recursive type checking</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L218-L228" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def is_jsonable(obj):
    &#34;&#34;&#34;Return true if can be successfully converted to json (without actually doing it) by recursive type checking&#34;&#34;&#34;
    if isinstance(obj, (str, int, float, bool, type(None))):
        return True  # JSON types
    elif isinstance(obj, (list, tuple)):
        return all(is_jsonable(item) for item in obj)
    elif isinstance(obj, dict):
        # JSON object keys *must* be strings
        return all(isinstance(key, str) and is_jsonable(value) for key, value in obj.items())
    else:
        return False</code></pre>
</details>
</dd>
<dt id="vipy.util.is_pkl_gz"><code class="name flex">
<span>def <span class="ident">is_pkl_gz</span></span>(<span>filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Is the file a pickle gzip archive file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L998-L1000" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def is_pkl_gz(filename):
    &#34;&#34;&#34;Is the file a pickle gzip archive file&#34;&#34;&#34;
    return filename[-7:] == &#39;.pkl.gz&#39; if isstring(filename) and len(filename) &gt;= 7 else False</code></pre>
</details>
</dd>
<dt id="vipy.util.is_rtmp_url"><code class="name flex">
<span>def <span class="ident">is_rtmp_url</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1335-L1336" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def is_rtmp_url(path):
    return isurl(path) and (path.startswith(&#39;rtmp://&#39;) or path.startswith(&#39;rtmps://&#39;))</code></pre>
</details>
</dd>
<dt id="vipy.util.isarchive"><code class="name flex">
<span>def <span class="ident">isarchive</span></span>(<span>filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Is filename a zip or gzip compressed tar archive?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1552-L1564" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isarchive(filename):
    &#34;&#34;&#34;Is filename a zip or gzip compressed tar archive?&#34;&#34;&#34;
    (filebase, ext) = splitext(filename)
    if (ext is not None) and (len(ext) &gt; 0) and (ext.lower() in [
            &#39;.egg&#39;, &#39;.jar&#39;, &#39;.tar&#39;, &#39;.tar.bz2&#39;, &#39;.tar.gz&#39;,
            &#39;.tgz&#39;, &#39;.tz2&#39;, &#39;.zip&#39;, &#39;.gz&#39;]):
        return True
    else:
        (filebase, ext) = splitext(ext[1:])
        if (ext is not None) and (len(ext) &gt; 0) and (ext.lower() in [&#39;.bz2&#39;]):
            return True
        else:
            return False</code></pre>
</details>
</dd>
<dt id="vipy.util.iscsv"><code class="name flex">
<span>def <span class="ident">iscsv</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"><p>Is a file a CSV file extension?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1474-L1481" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def iscsv(path):
    &#34;&#34;&#34;Is a file a CSV file extension?&#34;&#34;&#34;

    (filename, ext) = (os.path.splitext(path) if path is not None else (&#39;&#39;,&#39;&#39;))
    if ext.lower() in [&#39;.csv&#39;, &#39;.CSV&#39;]:
        return True
    else:
        return False</code></pre>
</details>
</dd>
<dt id="vipy.util.isexe"><code class="name flex">
<span>def <span class="ident">isexe</span></span>(<span>filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Is the file an executable binary?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L968-L970" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isexe(filename):
    &#34;&#34;&#34;Is the file an executable binary?&#34;&#34;&#34;
    return os.path.isfile(filename) and os.access(filename, os.X_OK)</code></pre>
</details>
</dd>
<dt id="vipy.util.isextension"><code class="name flex">
<span>def <span class="ident">isextension</span></span>(<span>filename, ext)</span>
</code></dt>
<dd>
<div class="desc"><p>Does the filename end with the extension ext? </p>
<pre><code class="language-python">isextension('/path/to/myfile.json', 'json') == True
isextension('/path/to/myfile.json', '.json') == True
isextension('/path/to/myfile.json', '.pkl') == False
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L978-L988" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isextension(filename, ext):
    &#34;&#34;&#34;Does the filename end with the extension ext? 
    
    ```python
    isextension(&#39;/path/to/myfile.json&#39;, &#39;json&#39;) == True
    isextension(&#39;/path/to/myfile.json&#39;, &#39;.json&#39;) == True
    isextension(&#39;/path/to/myfile.json&#39;, &#39;.pkl&#39;) == False
    ```

    &#34;&#34;&#34;
    return filename is not None and filename.endswith(ext)</code></pre>
</details>
</dd>
<dt id="vipy.util.isfile"><code class="name flex">
<span>def <span class="ident">isfile</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapper for os.path.isfile</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1776-L1778" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isfile(path):
    &#34;&#34;&#34;Wrapper for os.path.isfile&#34;&#34;&#34;
    return os.path.isfile(str(path))</code></pre>
</details>
</dd>
<dt id="vipy.util.isfloat"><code class="name flex">
<span>def <span class="ident">isfloat</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"><p>Is the input a float or a string that can be converted to float?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L657-L663" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isfloat(x):
    &#34;&#34;&#34;Is the input a float or a string that can be converted to float?&#34;&#34;&#34;
    try:
        float(x)
        return True
    except ValueError:
        return False</code></pre>
</details>
</dd>
<dt id="vipy.util.isgif"><code class="name flex">
<span>def <span class="ident">isgif</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"><p>is the file a .gif extension?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1465-L1467" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isgif(path):
    &#34;&#34;&#34;is the file a .gif extension?&#34;&#34;&#34;
    return hasextension(path) and fileext(path).lower() == &#39;.gif&#39;</code></pre>
</details>
</dd>
<dt id="vipy.util.ishdf5"><code class="name flex">
<span>def <span class="ident">ishdf5</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"><p>Is the file an HDF5 file?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1015-L1023" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def ishdf5(path):
    &#34;&#34;&#34;Is the file an HDF5 file?&#34;&#34;&#34;
    # tables.is_hdf5_file(path)
    # tables.is_pytables_file(path)
    (filename, ext) = os.path.splitext(path)
    if (ext is not None) and (len(ext) &gt; 0) and (ext.lower() in [&#39;.h5&#39;]):
        return True
    else:
        return False</code></pre>
</details>
</dd>
<dt id="vipy.util.ishtml"><code class="name flex">
<span>def <span class="ident">ishtml</span></span>(<span>filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Is the file an HTMLfile</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1006-L1008" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def ishtml(filename):
    &#34;&#34;&#34;Is the file an HTMLfile&#34;&#34;&#34;
    return filename.lower()[-5:] == &#39;.html&#39;</code></pre>
</details>
</dd>
<dt id="vipy.util.isimage"><code class="name flex">
<span>def <span class="ident">isimage</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for <code><a title="vipy.util.isimg" href="#vipy.util.isimg">isimg()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1432-L1434" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isimage(path):
    &#34;&#34;&#34;Alias for `vipy.util.isimg`&#34;&#34;&#34;
    return isimg(path)</code></pre>
</details>
</dd>
<dt id="vipy.util.isimagefile"><code class="name flex">
<span>def <span class="ident">isimagefile</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for <code><a title="vipy.util.isimg" href="#vipy.util.isimg">isimg()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1448-L1450" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isimagefile(path):
    &#34;&#34;&#34;Alias for `vipy.util.isimg`&#34;&#34;&#34;
    return isimg(path)</code></pre>
</details>
</dd>
<dt id="vipy.util.isimageobject"><code class="name flex">
<span>def <span class="ident">isimageobject</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"><p>Is an object a vipy.image class Image, ImageCategory, ImageDetection?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1354-L1358" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isimageobject(x):
    &#34;&#34;&#34;Is an object a vipy.image class Image, ImageCategory, ImageDetection?&#34;&#34;&#34;
    return (str(type(x)) in [&#34;&lt;class &#39;vipy.image.Image&#39;&gt;&#34;,
                             &#34;&lt;class &#39;vipy.image.ImageCategory&#39;&gt;&#34;,
                             &#34;&lt;class &#39;vipy.image.ImageDetection&#39;&gt;&#34;])</code></pre>
</details>
</dd>
<dt id="vipy.util.isimageurl"><code class="name flex">
<span>def <span class="ident">isimageurl</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"><p>Is a path a URL with image extension?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1310-L1312" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isimageurl(path):
    &#34;&#34;&#34;Is a path a URL with image extension?&#34;&#34;&#34;
    return path is not None and isurl(path) and isimg(path)</code></pre>
</details>
</dd>
<dt id="vipy.util.isimg"><code class="name flex">
<span>def <span class="ident">isimg</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"><p>Is an object an image with a supported image extension ['.jpg','.jpeg','.png','.tif','.tiff','.pgm','.ppm','.gif','.bmp']?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1425-L1430" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isimg(path):
    &#34;&#34;&#34;Is an object an image with a supported image extension [&#39;.jpg&#39;,&#39;.jpeg&#39;,&#39;.png&#39;,&#39;.tif&#39;,&#39;.tiff&#39;,&#39;.pgm&#39;,&#39;.ppm&#39;,&#39;.gif&#39;,&#39;.bmp&#39;]?&#34;&#34;&#34;    
    if path is not None and os.path.splitext(path)[1].lower() in [&#39;.jpg&#39;, &#39;.jpeg&#39;, &#39;.png&#39;, &#39;.tif&#39;, &#39;.tiff&#39;, &#39;.pgm&#39;, &#39;.ppm&#39;, &#39;.gif&#39;, &#39;.bmp&#39;]:
        return True
    else:
        return False</code></pre>
</details>
</dd>
<dt id="vipy.util.isimgfile"><code class="name flex">
<span>def <span class="ident">isimgfile</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for <code><a title="vipy.util.isimg" href="#vipy.util.isimg">isimg()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1440-L1442" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isimgfile(path):
    &#34;&#34;&#34;Alias for `vipy.util.isimg`&#34;&#34;&#34;
    return isimg(path)</code></pre>
</details>
</dd>
<dt id="vipy.util.isinstalled"><code class="name flex">
<span>def <span class="ident">isinstalled</span></span>(<span>cmd)</span>
</code></dt>
<dd>
<div class="desc"><p>Is the command is available on the path</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L973-L975" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isinstalled(cmd):
    &#34;&#34;&#34;Is the command is available on the path&#34;&#34;&#34;
    return shutil.which(cmd) is not None</code></pre>
</details>
</dd>
<dt id="vipy.util.isjpeg"><code class="name flex">
<span>def <span class="ident">isjpeg</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"><p>is the file a .jpg or .jpeg extension?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1453-L1455" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isjpeg(path):
    &#34;&#34;&#34;is the file a .jpg or .jpeg extension?&#34;&#34;&#34;
    return hasextension(path) and fileext(path).lower() == &#39;.jpg&#39; or fileext(path).lower() == &#39;.jpeg&#39;</code></pre>
</details>
</dd>
<dt id="vipy.util.isjpg"><code class="name flex">
<span>def <span class="ident">isjpg</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for <code><a title="vipy.util.isjpeg" href="#vipy.util.isjpeg">isjpeg()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1469-L1471" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isjpg(path):
    &#34;&#34;&#34;Alias for `vipy.util.isjpeg`&#34;&#34;&#34;
    return isjpeg(path)</code></pre>
</details>
</dd>
<dt id="vipy.util.isjsonfile"><code class="name flex">
<span>def <span class="ident">isjsonfile</span></span>(<span>filename)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L437-L438" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isjsonfile(filename):
    return isinstance(filename, str) and len(filename) &gt; 5 and filename[-5:] == &#39;.json&#39;</code></pre>
</details>
</dd>
<dt id="vipy.util.islinux"><code class="name flex">
<span>def <span class="ident">islinux</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>is the current platform Linux?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1884-L1887" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def islinux():
    &#34;&#34;&#34;is the current platform Linux?&#34;&#34;&#34;
    (sysname, nodename, release, version, machine) = os.uname()
    return sysname == &#39;Linux&#39;</code></pre>
</details>
</dd>
<dt id="vipy.util.islist"><code class="name flex">
<span>def <span class="ident">islist</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"><p>Is an object a python list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1339-L1341" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def islist(x):
    &#34;&#34;&#34;Is an object a python list&#34;&#34;&#34;
    return type(x) is list</code></pre>
</details>
</dd>
<dt id="vipy.util.islistoflists"><code class="name flex">
<span>def <span class="ident">islistoflists</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"><p>Is an object a python list of lists x=[[1,2], [3,4]]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1344-L1346" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def islistoflists(x):
    &#34;&#34;&#34;Is an object a python list of lists x=[[1,2], [3,4]]&#34;&#34;&#34;
    return type(x) is list and type(x[0]) is list</code></pre>
</details>
</dd>
<dt id="vipy.util.ismacosx"><code class="name flex">
<span>def <span class="ident">ismacosx</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Is the current platform MacOSX?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1878-L1881" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def ismacosx():
    &#34;&#34;&#34;Is the current platform MacOSX?&#34;&#34;&#34;
    (sysname, nodename, release, version, machine) = os.uname()
    return sysname == &#39;Darwin&#39;</code></pre>
</details>
</dd>
<dt id="vipy.util.isnumber"><code class="name flex">
<span>def <span class="ident">isnumber</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"><p>Is the input a python type of a number or a string containing a number?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L652-L654" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isnumber(x):
    &#34;&#34;&#34;Is the input a python type of a number or a string containing a number?&#34;&#34;&#34;
    return isinstance(x, (int, float)) or (isnumpy(x) and np.isscalar(x)) or (isstring(x) and isfloat(x))</code></pre>
</details>
</dd>
<dt id="vipy.util.isnumpy"><code class="name flex">
<span>def <span class="ident">isnumpy</span></span>(<span>obj)</span>
</code></dt>
<dd>
<div class="desc"><p>Is a python object a numpy object?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1491-L1493" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isnumpy(obj):
    &#34;&#34;&#34;Is a python object a numpy object?&#34;&#34;&#34;
    return (&#39;numpy&#39; in str(type(obj)))</code></pre>
</details>
</dd>
<dt id="vipy.util.isnumpyarray"><code class="name flex">
<span>def <span class="ident">isnumpyarray</span></span>(<span>obj)</span>
</code></dt>
<dd>
<div class="desc"><p>Is a python object a numpy array?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1495-L1497" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isnumpyarray(obj):
    &#34;&#34;&#34;Is a python object a numpy array?&#34;&#34;&#34;
    return isnumpy(obj) and &#39;numpy.ndarray&#39; in str(type(obj))</code></pre>
</details>
</dd>
<dt id="vipy.util.ispickle"><code class="name flex">
<span>def <span class="ident">ispickle</span></span>(<span>filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Is the file a pickle archive file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1010-L1012" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def ispickle(filename):
    &#34;&#34;&#34;Is the file a pickle archive file&#34;&#34;&#34;
    return isfile(filename) and os.path.exists(filename) and (((fileext(filename) is not None) and fileext(filename).lower() in [&#39;.pk&#39;, &#39;.pkl&#39;]) or (filename[-4:] == &#39;.pkl&#39;))</code></pre>
</details>
</dd>
<dt id="vipy.util.ispkl"><code class="name flex">
<span>def <span class="ident">ispkl</span></span>(<span>filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Is the file a pickle archive file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L990-L992" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def ispkl(filename):
    &#34;&#34;&#34;Is the file a pickle archive file&#34;&#34;&#34;
    return filename[-4:] == &#39;.pkl&#39; if isstring(filename) and len(filename) &gt;= 4 else False</code></pre>
</details>
</dd>
<dt id="vipy.util.ispklbz2"><code class="name flex">
<span>def <span class="ident">ispklbz2</span></span>(<span>filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Is the file a pickle bz2 archive file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L994-L996" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def ispklbz2(filename):
    &#34;&#34;&#34;Is the file a pickle bz2 archive file&#34;&#34;&#34;
    return filename[-8:] == &#39;.pkl.bz2&#39; if isstring(filename) and len(filename) &gt;= 8 else False</code></pre>
</details>
</dd>
<dt id="vipy.util.ispklfile"><code class="name flex">
<span>def <span class="ident">ispklfile</span></span>(<span>filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Is the file a pickle archive file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1002-L1004" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def ispklfile(filename):
    &#34;&#34;&#34;Is the file a pickle archive file&#34;&#34;&#34;
    return ispkl(filename)</code></pre>
</details>
</dd>
<dt id="vipy.util.ispng"><code class="name flex">
<span>def <span class="ident">ispng</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"><p>is the file a .png or .apng extension?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1461-L1463" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def ispng(path):
    &#34;&#34;&#34;is the file a .png or .apng extension?&#34;&#34;&#34;
    return hasextension(path) and (fileext(path).lower() == &#39;.png&#39; or fileext(path).lower() == &#39;.apng&#39;)</code></pre>
</details>
</dd>
<dt id="vipy.util.isstring"><code class="name flex">
<span>def <span class="ident">isstring</span></span>(<span>s)</span>
</code></dt>
<dd>
<div class="desc"><p>Is an object a python string or unicode string?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1781-L1783" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isstring(s):
    &#34;&#34;&#34;Is an object a python string or unicode string?&#34;&#34;&#34;
    return isinstance(s, str)  # python3</code></pre>
</details>
</dd>
<dt id="vipy.util.istar"><code class="name flex">
<span>def <span class="ident">istar</span></span>(<span>filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Is the filename a .tar extension?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1570-L1572" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def istar(filename):
    &#34;&#34;&#34;Is the filename a .tar extension?&#34;&#34;&#34;
    return filename[-4:] == &#39;.tar&#39;</code></pre>
</details>
</dd>
<dt id="vipy.util.istarbz2"><code class="name flex">
<span>def <span class="ident">istarbz2</span></span>(<span>filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Is the filename a .bz2 or .tar.bz2 extension?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1574-L1576" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def istarbz2(filename):
    &#34;&#34;&#34;Is the filename a .bz2 or .tar.bz2 extension?&#34;&#34;&#34;
    return filename[-8:] == &#39;.tar.bz2&#39;</code></pre>
</details>
</dd>
<dt id="vipy.util.istextfile"><code class="name flex">
<span>def <span class="ident">istextfile</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"><p>Is the given file a text file?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1500-L1506" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def istextfile(path):
    &#34;&#34;&#34;Is the given file a text file?&#34;&#34;&#34;
    (filename, ext) = (os.path.splitext(path) if path is not None else (&#39;&#39;,&#39;&#39;))
    if ext.lower() in [&#39;.txt&#39;] and (filename[0] != &#39;.&#39;):
        return True
    else:
        return False</code></pre>
</details>
</dd>
<dt id="vipy.util.istgz"><code class="name flex">
<span>def <span class="ident">istgz</span></span>(<span>filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Is the filename a .tgz or .tar.gz extension?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1566-L1568" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def istgz(filename):
    &#34;&#34;&#34;Is the filename a .tgz or .tar.gz extension?&#34;&#34;&#34;
    return filename[-4:] == &#39;.tgz&#39; or filename[-7:] == &#39;.tar.gz&#39;</code></pre>
</details>
</dd>
<dt id="vipy.util.istupleoftuples"><code class="name flex">
<span>def <span class="ident">istupleoftuples</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"><p>Is an object a python list of lists x=[[1,2], [3,4]]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1349-L1351" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def istupleoftuples(x):
    &#34;&#34;&#34;Is an object a python list of lists x=[[1,2], [3,4]]&#34;&#34;&#34;
    return type(x) is tuple and type(x[0]) is tuple</code></pre>
</details>
</dd>
<dt id="vipy.util.isuint8"><code class="name flex">
<span>def <span class="ident">isuint8</span></span>(<span>img)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L649-L650" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isuint8(img):
    return isnumpy(img) and img.dtype == np.dtype(&#39;uint8&#39;)</code></pre>
</details>
</dd>
<dt id="vipy.util.isurl"><code class="name flex">
<span>def <span class="ident">isurl</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"><p>Is a path a URL?
It requires a url scheme and url netloc without any common unallowed characters</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1294-L1300" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isurl(path):
    &#34;&#34;&#34;Is a path a URL?  It requires a url scheme and url netloc without any common unallowed characters&#34;&#34;&#34;
    try:
        url = urlparse(path)
        return not any([c in path for c in (&#39;&gt;&#39;,&#39;&lt;&#39;,&#39;&#34;&#39;)]) and bool(url.scheme) and bool(url.netloc)
    except:
        return False</code></pre>
</details>
</dd>
<dt id="vipy.util.isvideo"><code class="name flex">
<span>def <span class="ident">isvideo</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"><p>Is a filename in path a video with a known video extension ['.avi','.mp4','.mov','.wmv','.mpg', 'mkv', 'webm', '3gp']?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1483-L1488" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isvideo(path):
    &#34;&#34;&#34;Is a filename in path a video with a known video extension [&#39;.avi&#39;,&#39;.mp4&#39;,&#39;.mov&#39;,&#39;.wmv&#39;,&#39;.mpg&#39;, &#39;mkv&#39;, &#39;webm&#39;, &#39;3gp&#39;]?&#34;&#34;&#34;
    if path is not None and os.path.splitext(path)[1].lower() in [&#39;.avi&#39;,&#39;.mp4&#39;,&#39;.mov&#39;,&#39;.wmv&#39;,&#39;.mpg&#39;, &#39;.mkv&#39;, &#39;.webm&#39;, &#39;.3gp&#39;]:
        return True
    else:
        return False</code></pre>
</details>
</dd>
<dt id="vipy.util.isvideofile"><code class="name flex">
<span>def <span class="ident">isvideofile</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for <code><a title="vipy.util.isvideo" href="#vipy.util.isvideo">isvideo()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1436-L1438" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isvideofile(path):
    &#34;&#34;&#34;Alias for `vipy.util.isvideo`&#34;&#34;&#34;
    return isvideo(path)</code></pre>
</details>
</dd>
<dt id="vipy.util.isvideoobject"><code class="name flex">
<span>def <span class="ident">isvideoobject</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1367-L1368" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isvideoobject(x):
    return isvideotype(x)</code></pre>
</details>
</dd>
<dt id="vipy.util.isvideotype"><code class="name flex">
<span>def <span class="ident">isvideotype</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"><p>Is an object a vipy.video class Video, VideoCategory, Scene?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1361-L1365" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isvideotype(x):
    &#34;&#34;&#34;Is an object a vipy.video class Video, VideoCategory, Scene?&#34;&#34;&#34;
    return (str(type(x)) in [&#34;&lt;class &#39;vipy.video.Video&#39;&gt;&#34;,
                             &#34;&lt;class &#39;vipy.video.VideoCategory&#39;&gt;&#34;,
                             &#34;&lt;class &#39;vipy.video.Scene&#39;&gt;&#34;])</code></pre>
</details>
</dd>
<dt id="vipy.util.isvideourl"><code class="name flex">
<span>def <span class="ident">isvideourl</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"><p>Is a path a URL with video extension?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1315-L1317" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isvideourl(path):
    &#34;&#34;&#34;Is a path a URL with video extension?&#34;&#34;&#34;
    return isurl(path) and isvideo(path)</code></pre>
</details>
</dd>
<dt id="vipy.util.isvipyobject"><code class="name flex">
<span>def <span class="ident">isvipyobject</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1371-L1376" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isvipyobject(x):
    import vipy.image
    import vipy.video
    return ((isinstance(x, vipy.image.Image) or isinstance(x, vipy.video.Video)) 
            or (islist(x) or istuple(x) and all([isinstance(v, vipy.image.Image) or isinstance(v, vipy.video.Video) for v in x]))
            or (isinstance(x, dict) and all([isinstance(v, vipy.image.Image) or isinstance(v, vipy.video.Video) for (k,v) in x.items()])))</code></pre>
</details>
</dd>
<dt id="vipy.util.iswebp"><code class="name flex">
<span>def <span class="ident">iswebp</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"><p>is the file a .webp extension?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1457-L1459" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def iswebp(path):
    &#34;&#34;&#34;is the file a .webp extension?&#34;&#34;&#34;
    return path is not None and hasextension(path) and fileext(path).lower() == &#39;.webp&#39;</code></pre>
</details>
</dd>
<dt id="vipy.util.isxml"><code class="name flex">
<span>def <span class="ident">isxml</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"><p>Is the given file an xml file?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1509-L1515" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isxml(path):
    &#34;&#34;&#34;Is the given file an xml file?&#34;&#34;&#34;
    (filename, ext) = os.path.splitext(path)
    if ext.lower() in [&#39;.xml&#39;]:
        return True
    else:
        return False</code></pre>
</details>
</dd>
<dt id="vipy.util.isyoutubeurl"><code class="name flex">
<span>def <span class="ident">isyoutubeurl</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"><p>Is a path a youtube URL?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1325-L1327" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isyoutubeurl(path):
    &#34;&#34;&#34;Is a path a youtube URL?&#34;&#34;&#34;
    return isurl(path) and (&#39;youtube.com&#39; in path or &#39;youtu.be&#39; in path)</code></pre>
</details>
</dd>
<dt id="vipy.util.jet"><code class="name flex">
<span>def <span class="ident">jet</span></span>(<span>n, bgr=False)</span>
</code></dt>
<dd>
<div class="desc"><p>jet colormap</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L743-L748" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def jet(n, bgr=False):
    &#34;&#34;&#34;jet colormap&#34;&#34;&#34;
    from matplotlib import cm
    cmap = cm.get_cmap(&#39;jet&#39;, n)
    rgb = np.uint8(255 * cmap(np.arange(n)))
    return rgb if bgr is False else np.fliplr(rgb)</code></pre>
</details>
</dd>
<dt id="vipy.util.jsonlist"><code class="name flex">
<span>def <span class="ident">jsonlist</span></span>(<span>indir)</span>
</code></dt>
<dd>
<div class="desc"><p>return list of fJSON iles with absolute path in a directory</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1142-L1147" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def jsonlist(indir):
    &#34;&#34;&#34;return list of fJSON iles with absolute path in a directory&#34;&#34;&#34;
    #return extlist(indir, ext=&#39;.json&#39;)  # FIXME: broken.for.wonky.filenames.with.dots.json
    return [os.path.abspath(os.path.join(indir, item))
            for item in os.listdir(indir)
            if len(item) &gt; 5 and item[-5:] == &#39;.json&#39;]</code></pre>
</details>
</dd>
<dt id="vipy.util.keymax"><code class="name flex">
<span>def <span class="ident">keymax</span></span>(<span>d)</span>
</code></dt>
<dd>
<div class="desc"><p>Return key in dictionary containing maximum value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L422-L427" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def keymax(d):
    &#34;&#34;&#34;Return key in dictionary containing maximum value&#34;&#34;&#34;
    vmax = max(d.values())
    for (k, v) in d.items():
        if v == vmax:
            return k</code></pre>
</details>
</dd>
<dt id="vipy.util.keymin"><code class="name flex">
<span>def <span class="ident">keymin</span></span>(<span>d)</span>
</code></dt>
<dd>
<div class="desc"><p>Return key in dictionary containing minimum value</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L429-L434" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def keymin(d):
    &#34;&#34;&#34;Return key in dictionary containing minimum value&#34;&#34;&#34;
    vmin = min(d.values())
    for (k, v) in d.items():
        if v == vmin:
            return k</code></pre>
</details>
</dd>
<dt id="vipy.util.listext"><code class="name flex">
<span>def <span class="ident">listext</span></span>(<span>indir, ext)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for extlist</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1138-L1140" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def listext(indir, ext):
    &#34;&#34;&#34;Alias for extlist&#34;&#34;&#34;
    return extlist(indir, ext)</code></pre>
</details>
</dd>
<dt id="vipy.util.listjson"><code class="name flex">
<span>def <span class="ident">listjson</span></span>(<span>indir)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for jsonlist</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1149-L1151" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def listjson(indir):
    &#34;&#34;&#34;Alias for jsonlist&#34;&#34;&#34;
    return jsonlist(indir)</code></pre>
</details>
</dd>
<dt id="vipy.util.listpkl"><code class="name flex">
<span>def <span class="ident">listpkl</span></span>(<span>indir)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of absolute paths of *.pk files in current directory</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1261-L1264" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def listpkl(indir):
    &#34;&#34;&#34;Return a list of absolute paths of *.pk files in current directory&#34;&#34;&#34;
    return [os.path.join(indir, item) for item in os.listdir(indir)
            if ispickle(os.path.join(indir, item))]</code></pre>
</details>
</dd>
<dt id="vipy.util.load"><code class="name flex">
<span>def <span class="ident">load</span></span>(<span>infile, abspath=True, freeze=True, relocatable=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Load variables from a relocatable archive file format, either dill pickle, JSON format or JSON directory format.</p>
<p>Loading is performed by attemping the following:</p>
<ol>
<li>If the input file is a directory, return a <code><a title="vipy.dataset.Dataset" href="dataset.html#vipy.dataset.Dataset">Dataset</a></code> with lazy loading of all pkl or json files recursively discovered in this directory.</li>
<li>If the input file is a pickle or json file, load it</li>
<li>if abspath=true, then convert relative paths to absolute paths for object when loaded</li>
<li>If freeze=True, then disable the python reference cycle garbage collector for the object loaded by this file</li>
</ol>
<pre><code class="language-python">im = vipy.image.owl()
f = vipy.util.save(im)
im = vipy.util.load(im)
</code></pre>
<p>Args:
infile: [str] file saved using <code><a title="vipy.util.save" href="#vipy.util.save">save()</a></code> with extension [.pkl, .json].
This may also be a directory tree containing json or pkl files
abspath: [bool] If true, then convert all vipy objects with relative paths to absolute paths. If False, then preserve relative paths and warn user.
freeze: [bool] If True, then disable python reference cycle garbage collector for this loaded object.
relocatable: [bool] If True, then perform relocatable relative and absolute paths for vipy objects containing filenames
Returns:
The object in the archive file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L134-L215" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def load(infile, abspath=True, freeze=True, relocatable=True):
    &#34;&#34;&#34;Load variables from a relocatable archive file format, either dill pickle, JSON format or JSON directory format.
       
       Loading is performed by attemping the following:

       1. If the input file is a directory, return a `vipy.dataset.Dataset` with lazy loading of all pkl or json files recursively discovered in this directory.
       2. If the input file is a pickle or json file, load it
       3. if abspath=true, then convert relative paths to absolute paths for object when loaded
       4. If freeze=True, then disable the python reference cycle garbage collector for the object loaded by this file
    
    ```python
    im = vipy.image.owl()
    f = vipy.util.save(im)
    im = vipy.util.load(im)
    ```

       Args:
           infile: [str] file saved using `vipy.util.save` with extension [.pkl, .json].  This may also be a directory tree containing json or pkl files 
           abspath: [bool] If true, then convert all vipy objects with relative paths to absolute paths. If False, then preserve relative paths and warn user.
           freeze: [bool] If True, then disable python reference cycle garbage collector for this loaded object. 
           relocatable: [bool] If True, then perform relocatable relative and absolute paths for vipy objects containing filenames
       Returns:
           The object in the archive file
    &#34;&#34;&#34;
    if freeze:
        gc.disable()
        
    infile = os.path.abspath(os.path.expanduser(infile))

    if ispkl(infile):
        with open(infile, &#39;rb&#39;) as f:
            obj = default_pickle.load(f)
    elif isjsonfile(infile):
        with open(infile, &#39;r&#39;) as f:
            loadobj = json.load(f)
        registry = class_registry()
        assert isinstance(loadobj, list) or isinstance(loadobj, dict), &#34;invalid vipy JSON serialization format&#34;
        if isinstance(loadobj, list) and all([isinstance(d, dict) for d in loadobj]) and all([c in registry for d in loadobj for (c,v) in d.items()]):
            obj = [registry[c](v) for d in loadobj for (c,v) in d.items()]
        elif isinstance(loadobj, dict) and all([c in registry for (c,d) in loadobj.items()]):
            obj = [registry[c](v) for (c,v) in loadobj.items()]
            obj = obj[0] if len(obj) == 1 else obj
        else:
            obj = loadobj
    elif ispklbz2(infile):
        return pklbz2(infile)
    elif os.path.isdir(infile):        
        import vipy.dataset
        return vipy.dataset.Dataset.from_directory(infile)
    else:
        raise ValueError(&#39;unknown file type&#39;)
    
    # Relocatable vipy object?
    testobj = tolist(obj)[0] if len(tolist(obj)) &gt; 0 else None
    if relocatable and testobj is not None and hasattr(testobj, &#39;filename&#39;) and testobj.filename() is not None:
        if not os.path.isabs(testobj.filename()):
            if not abspath:
                warnings.warn(&#39;Loading archive &#34;%s&#34; with relative paths.  Changing directory to &#34;%s&#34;.  Disable this warning with vipy.util.load(..., abspath=True).&#39; % (infile, filepath(infile)))
                os.chdir(filepath(infile))
            else:
                # Absolute path?  The loaded archive will no longer be relocatable if you save this to a new archive, and the videos directory cannot be moved
                pwd = os.getcwd()  # save current directory
                os.chdir(filepath(infile))  # change to archive directory
                objout = [o.abspath() if o.filename() is not None else o for o in tolist(obj)]  # set absolute paths relative to archive directory
                obj = objout if isinstance(obj, list) else objout[0]
                os.chdir(pwd)  # restore current directory
        elif not testobj.hasfilename():
            warnings.warn(&#39;Loading &#34;%s&#34; that contains path (e.g. &#34;%s&#34;) which does not exist&#39; % (infile, testobj.filename()))

    # Large vipy object?  Disable garbage collection.
    #   - Python uses reference counting for the primary garbage collection mechanism, but also uses reference cycle checks to search for dependencies between objects.
    #   - All vipy objects are self contained, and do not have reference cycles.  However, there is no way to mark an individual object which does not participate in reference cycle counting.
    #   - This means that a large number of vipy objects, garbage collection can take minutes searching for cycles which are never there.  To fix this, globally disable the garbage collector.
    #   - Note that refernece counting is still performed, we are just disabling reference *cycle* counting using the generational garbage collector.
    #   - This can be re-enabled at any time by &#34;import gc; gc.enable()&#34;
    #   - If you use %autoreload iPython magic command, note that this will be very slow.  You should set %sutoreload 0
    #   - Alternatively, load as JSON and all attributes will be unpacked on demand and stored in a packed format that is not tracked (e.g. tuple of strings) by the reference cycle counter
    if freeze:
        gc.enable()
        gc.collect()
        gc.freeze() 
    return obj</code></pre>
</details>
</dd>
<dt id="vipy.util.load_opencv_yaml"><code class="name flex">
<span>def <span class="ident">load_opencv_yaml</span></span>(<span>yamlfile)</span>
</code></dt>
<dd>
<div class="desc"><p>Load a numpy array from YAML file exported from OpenCV</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L891-L893" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def load_opencv_yaml(yamlfile):
    &#34;&#34;&#34;Load a numpy array from YAML file exported from OpenCV&#34;&#34;&#34;
    return np.squeeze(np.array(cv.Load(yamlfile)))</code></pre>
</details>
</dd>
<dt id="vipy.util.loadh5"><code class="name flex">
<span>def <span class="ident">loadh5</span></span>(<span>filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Load an HDF5 file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L771-L779" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def loadh5(filename):
    &#34;&#34;&#34;Load an HDF5 file&#34;&#34;&#34;
    if ishdf5(filename):
        try_import(&#39;h5py&#39;); import h5py
        f = h5py.File(filename, &#39;r&#39;)
        obj = f[filebase(filename)].value  # FIXME: lazy evaluation?
        return obj
    else:
        raise ValueError(&#39;Invalid HDF5 file &#34;%s&#34; &#39; % filename)</code></pre>
</details>
</dd>
<dt id="vipy.util.loadmat73"><code class="name flex">
<span>def <span class="ident">loadmat73</span></span>(<span>matfile, keys=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Matlab 7.3 format, keys should be a list of keys to access HDF5
file as f[key1][key2]&hellip;
Returned as numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L783-L793" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def loadmat73(matfile, keys=None):
    &#34;&#34;&#34;Matlab 7.3 format, keys should be a list of keys to access HDF5
    file as f[key1][key2]...  Returned as numpy array&#34;&#34;&#34;
    try_import(&#39;h5py&#39;); import h5py
    f = h5py.File(matfile, &#39;r&#39;)
    if keys is None:
        return f
    else:
        for k in keys:
            f = f[k]
        return np.array(f)</code></pre>
</details>
</dd>
<dt id="vipy.util.mat2gray"><code class="name flex">
<span>def <span class="ident">mat2gray</span></span>(<span>img, min=None, max=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert numpy array to float32 with 1.0=max and 0=min</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1279-L1286" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def mat2gray(img, min=None, max=None):
    &#34;&#34;&#34;Convert numpy array to float32 with 1.0=max and 0=min&#34;&#34;&#34;
    immin = np.min(img) if min is None else min
    immax = np.max(img) if max is None else max
    if (immax - immin) &gt; 0:
        return (np.float32(img) - immin) / (immax - immin)
    else:
        return img</code></pre>
</details>
</dd>
<dt id="vipy.util.matread"><code class="name flex">
<span>def <span class="ident">matread</span></span>(<span>txtfile, delimiter=' ')</span>
</code></dt>
<dd>
<div class="desc"><p>Whitespace separated values defining columns, lines define rows.
Return numpy array</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1095-L1100" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def matread(txtfile, delimiter=&#39; &#39;):
    &#34;&#34;&#34;Whitespace separated values defining columns, lines define rows.
    Return numpy array&#34;&#34;&#34;
    with open(txtfile, &#39;rb&#39;) as csvfile:
        M = [np.float32(row.split(delimiter)) for row in csvfile]
    return np.array(M)</code></pre>
</details>
</dd>
<dt id="vipy.util.matrix_to_opencv_yaml"><code class="name flex">
<span>def <span class="ident">matrix_to_opencv_yaml</span></span>(<span>yamlfile, mtxlist, mtxname=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Write list of matrices to OpenCV yaml file format with given
variable names</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L896-L926" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def matrix_to_opencv_yaml(yamlfile, mtxlist, mtxname=None):
    &#34;&#34;&#34;Write list of matrices to OpenCV yaml file format with given
    variable names&#34;&#34;&#34;
    def _write_matrix(f, M, mtxname):
        f.write(&#39;    %s: !!opencv-matrix\n&#39; % mtxname)
        f.write(&#39;       rows: %d\n&#39; % M.shape[0])
        f.write(&#39;       cols: %d\n&#39; % (M.shape[1] if M.ndim == 2 else 1))
        f.write(&#39;       dt: f\n&#39;)
        f.write(&#39;       data: [ &#39;)
        datastr = &#39;&#39;
        for (k, x) in enumerate(M.flatten()):
            datastr += &#39;%.6e&#39; % x
            if (k + 1 == M.size):
                f.write(datastr)
                break
            datastr += &#39;, &#39;
            if ((k + 1) % 4) == 0:
                f.write(datastr + &#39;\n           &#39;)
                datastr = &#39;&#39;
        f.write(&#39;]\n&#39;)

    # Write me!
    mtxlist = tolist(mtxlist)
    if mtxname is None:
        mtxname = [&#39;mtx_%02d&#39; % k for k in range(0, len(mtxlist))]
    with open(yamlfile, &#39;w&#39;) as f:
        f.write(&#39;%YAML:1.0\n&#39;)
        for (m, mname) in zip(mtxlist, mtxname):
            _write_matrix(f, m, mname)

    return yamlfile</code></pre>
</details>
</dd>
<dt id="vipy.util.mdlist"><code class="name flex">
<span>def <span class="ident">mdlist</span></span>(<span>m, n)</span>
</code></dt>
<dd>
<div class="desc"><p>Preallocate 2D list of size MxN</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1289-L1291" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def mdlist(m, n):
    &#34;&#34;&#34;Preallocate 2D list of size MxN&#34;&#34;&#34;
    return [[None] * n for i in range(m)]</code></pre>
</details>
</dd>
<dt id="vipy.util.mediaextension"><code class="name flex">
<span>def <span class="ident">mediaextension</span></span>(<span>filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Return '.mp4' for filename='/a/b/c.mp4'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1874-L1876" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def mediaextension(filename):
    &#34;&#34;&#34;Return &#39;.mp4&#39; for filename=&#39;/a/b/c.mp4&#39;&#34;&#34;&#34;
    return fileext(filename, multidot=False)</code></pre>
</details>
</dd>
<dt id="vipy.util.mergedict"><code class="name flex">
<span>def <span class="ident">mergedict</span></span>(<span>*args)</span>
</code></dt>
<dd>
<div class="desc"><p>Combine keys of two or more dictionaries and return a dictionary deep copy.</p>
<pre><code class="language-python">d1 = {1:2}
d2 = {3:4}
d3 = mergedict(d1,d2)
assert d3 == {1:2, 3:4}
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L275-L291" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def mergedict(*args):
    &#34;&#34;&#34;Combine keys of two or more dictionaries and return a dictionary deep copy.
    
    ```python
    d1 = {1:2}
    d2 = {3:4}
    d3 = mergedict(d1,d2)
    assert d3 == {1:2, 3:4}
    ```

    &#34;&#34;&#34;
    assert all(isinstance(d, dict) for d in args)
    assert len(args) &gt; 0
    d = copy.deepcopy(args[0])
    for o in args[1:]:
        d.update(o)
    return d</code></pre>
</details>
</dd>
<dt id="vipy.util.minutestamp"><code class="name flex">
<span>def <span class="ident">minutestamp</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Return date and time string in form DDMMMYY_HHMM</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1794-L1796" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def minutestamp():
    &#34;&#34;&#34;Return date and time string in form DDMMMYY_HHMM&#34;&#34;&#34;
    return str.upper(strftime(&#34;%d%b%y_%I%M%p&#34;, localtime()))</code></pre>
</details>
</dd>
<dt id="vipy.util.mktemp"><code class="name flex">
<span>def <span class="ident">mktemp</span></span>(<span>ext)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a temporary file with extension .ext</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1670-L1672" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def mktemp(ext):
    &#34;&#34;&#34;Create a temporary file with extension .ext&#34;&#34;&#34;
    return tempfilename(suffix=&#39;.&#39; + ext)</code></pre>
</details>
</dd>
<dt id="vipy.util.most_frequent"><code class="name flex">
<span>def <span class="ident">most_frequent</span></span>(<span>inlist, topk=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the most frequent element as determined by element equality</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L494-L497" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def most_frequent(inlist, topk=1):
    &#34;&#34;&#34;Return the most frequent element as determined by element equality&#34;&#34;&#34;
    ranked = list(countby(inlist).keys())
    return ranked[-topk:] if topk is not None else ranked</code></pre>
</details>
</dd>
<dt id="vipy.util.newbase"><code class="name flex">
<span>def <span class="ident">newbase</span></span>(<span>filename, base)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert filename=/a/b/c.ext base=d -&gt; /a/b/d.ext</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1825-L1827" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def newbase(filename, base):
    &#34;&#34;&#34;Convert filename=/a/b/c.ext base=d -&gt; /a/b/d.ext&#34;&#34;&#34;
    return os.path.join(filepath(filename), &#39;%s.%s&#39; % (base, fileext(filename, withdot=False)))</code></pre>
</details>
</dd>
<dt id="vipy.util.newpath"><code class="name flex">
<span>def <span class="ident">newpath</span></span>(<span>filename, newdir)</span>
</code></dt>
<dd>
<div class="desc"><p>Return /d/e/c.ext for filename /a/b/c.ext and newdir /d/e/</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1051-L1054" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def newpath(filename, newdir):
    &#34;&#34;&#34;Return /d/e/c.ext for filename /a/b/c.ext and newdir /d/e/&#34;&#34;&#34;
    (head, tail) = os.path.split(filename)
    return os.path.join(newdir, tail)</code></pre>
</details>
</dd>
<dt id="vipy.util.newpathdir"><code class="name flex">
<span>def <span class="ident">newpathdir</span></span>(<span>filename, olddir, newdir, n=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Return /a/b/n/d/e.ext for filename=/a/b/c/d/e.ext, olddir=c, newdir=n</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1061-L1065" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def newpathdir(filename, olddir, newdir, n=1):
    &#34;&#34;&#34;Return /a/b/n/d/e.ext for filename=/a/b/c/d/e.ext, olddir=c, newdir=n&#34;&#34;&#34;
    p = pathlib.PurePath(filename)
    assert sum([d == olddir for d in p.parts]) == n, &#34;Path must have exactly %s directory matches&#34; % n
    return os.path.join(*[d.replace(olddir, newdir) for d in list(p.parts)])</code></pre>
</details>
</dd>
<dt id="vipy.util.newpathroot"><code class="name flex">
<span>def <span class="ident">newpathroot</span></span>(<span>filename, newroot)</span>
</code></dt>
<dd>
<div class="desc"><p>Return /r/b/c.ext for filename /a/b/c.ext and new root directory r</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1068-L1076" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def newpathroot(filename, newroot):
    &#34;&#34;&#34;Return /r/b/c.ext for filename /a/b/c.ext and new root directory r&#34;&#34;&#34;
    p = pathlib.PurePath(filename)
    path = list(p.parts)    
    if len(p.root) == 0:
        path[0] = newroot
    else:
        path[1] = newroot
    return os.path.join(*path)</code></pre>
</details>
</dd>
<dt id="vipy.util.newprefix"><code class="name flex">
<span>def <span class="ident">newprefix</span></span>(<span>filename, newprefix, depth=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Return /a/b/c/h/i.ext for filename /f/g/h/i.ext and prefix /a/b/c and depth=1</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1056-L1059" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def newprefix(filename, newprefix, depth=0):
    &#34;&#34;&#34;Return /a/b/c/h/i.ext for filename /f/g/h/i.ext and prefix /a/b/c and depth=1&#34;&#34;&#34;
    p = filepath(filename, depth=depth)
    return os.path.normpath(filename.replace(p, newprefix))</code></pre>
</details>
</dd>
<dt id="vipy.util.noextension"><code class="name flex">
<span>def <span class="ident">noextension</span></span>(<span>filename, ext=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert filename='/path/to/myfile.ext' or filename='/path/to/myfile.ext1.ext2.ext3' to /path/to/myfile with no extension, removing the appended string past the first dot</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1836-L1838" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def noextension(filename, ext=None):
    &#34;&#34;&#34;Convert filename=&#39;/path/to/myfile.ext&#39; or filename=&#39;/path/to/myfile.ext1.ext2.ext3&#39; to /path/to/myfile with no extension, removing the appended string past the first dot&#34;&#34;&#34;
    return filename.split(&#39;.&#39;)[0] if ext is None else filename.replace(ext, &#39;&#39;)</code></pre>
</details>
</dd>
<dt id="vipy.util.pairwise"><code class="name flex">
<span>def <span class="ident">pairwise</span></span>(<span>iterable, prepad=False, postpad=False, padval=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Equivalent to python-3.10 itertools.pairwise. </p>
<pre><code class="language-python-repl">&gt;&gt;&gt; pairwise('ABCD') --&gt; (A,B), (B,C), (C,D)
&gt;&gt;&gt; pairwise('ABCD', prepad=True, padval=0) --&gt; (0,A), (A,B), (B,C), (C,D)
&gt;&gt;&gt; pairwise('ABCD', postpad=True) --&gt; (A,B), (B,C), (C,D), (D,None)
&gt;&gt;&gt; pairwise([(1,1),(2,2)], prepad=True, postpad=True, padval=(None,None)) --&gt; [((None, None), (1, 1)), ((1, 1), (2, 2)), ((2, 2), (None, None))]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L554-L570" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def pairwise(iterable, prepad=False, postpad=False, padval=None):
    &#34;&#34;&#34;Equivalent to python-3.10 itertools.pairwise. 
    
    &gt;&gt;&gt; pairwise(&#39;ABCD&#39;) --&gt; (A,B), (B,C), (C,D)
    &gt;&gt;&gt; pairwise(&#39;ABCD&#39;, prepad=True, padval=0) --&gt; (0,A), (A,B), (B,C), (C,D)
    &gt;&gt;&gt; pairwise(&#39;ABCD&#39;, postpad=True) --&gt; (A,B), (B,C), (C,D), (D,None)
    &gt;&gt;&gt; pairwise([(1,1),(2,2)], prepad=True, postpad=True, padval=(None,None)) --&gt; [((None, None), (1, 1)), ((1, 1), (2, 2)), ((2, 2), (None, None))]
    &#34;&#34;&#34;
    
    a, b = tee(iterable, 2)
    if prepad:
        a = chain([padval], a)
    else:
        b0 = next(b, None)
    if postpad:
        b = chain(b, [padval])
    return zip(a, b)</code></pre>
</details>
</dd>
<dt id="vipy.util.permutelist"><code class="name flex">
<span>def <span class="ident">permutelist</span></span>(<span>inlist, seed=None)</span>
</code></dt>
<dd>
<div class="desc"><p>randomly permute list order.
Permutation is deterministic (same permutation on multiple calls) if specified.
Shuffle is not in place</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L510-L517" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def permutelist(inlist, seed=None):
    &#34;&#34;&#34;randomly permute list order.  Permutation is deterministic (same permutation on multiple calls) if specified.  Shuffle is not in place&#34;&#34;&#34;
    if seed is not None:
        np.random.seed(seed)  # deterministic        
    outlist = [inlist[k] for k in np.random.permutation(list(range(0, len(inlist))))]
    if seed is not None:
        np.random.seed()  # re-init randomness
    return outlist</code></pre>
</details>
</dd>
<dt id="vipy.util.pklbz2"><code class="name flex">
<span>def <span class="ident">pklbz2</span></span>(<span>filename, obj=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Read/Write a bz2 compressed pickle file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L241-L253" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def pklbz2(filename, obj=None):
    &#34;&#34;&#34;Read/Write a bz2 compressed pickle file&#34;&#34;&#34;
    assert filename[-8:] == &#39;.pkl.bz2&#39;, &#34;Invalid filename - must be &#39;*.pkl.bz2&#39;&#34;
    if obj is not None:
        f = bz2.BZ2File(filename, &#39;wb&#39;)
        default_pickle.dump(obj, f)
        f.close()
        return filename
    else:
        f = bz2.BZ2File(filename, &#39;rb&#39;)
        obj = default_pickle.load(f)
        f.close()
        return obj</code></pre>
</details>
</dd>
<dt id="vipy.util.pklist"><code class="name flex">
<span>def <span class="ident">pklist</span></span>(<span>indir)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of absolute paths of *.pk files in current directory</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1257-L1259" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def pklist(indir):
    &#34;&#34;&#34;Return a list of absolute paths of *.pk files in current directory&#34;&#34;&#34;
    return listpkl(indir)</code></pre>
</details>
</dd>
<dt id="vipy.util.premkdir"><code class="name flex">
<span>def <span class="ident">premkdir</span></span>(<span>filename)</span>
</code></dt>
<dd>
<div class="desc"><p>pre-create directory /path/to/subdir using <code><a title="vipy.util.remkdir" href="#vipy.util.remkdir">remkdir()</a></code> if it does not exist for outfile=/path/to/subdir/file.ext, and return filename</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1819-L1822" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def premkdir(filename):
    &#34;&#34;&#34;pre-create directory /path/to/subdir using `vipy.util.remkdir` if it does not exist for outfile=/path/to/subdir/file.ext, and return filename&#34;&#34;&#34;
    remkdir(filepath(filename))
    return filename</code></pre>
</details>
</dd>
<dt id="vipy.util.print_and_return"><code class="name flex">
<span>def <span class="ident">print_and_return</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L725-L727" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def print_and_return(x):
    log.info(x)
    return x</code></pre>
</details>
</dd>
<dt id="vipy.util.readcsv"><code class="name flex">
<span>def <span class="ident">readcsv</span></span>(<span>infile, separator=',', ignoreheader=False, comment=None, ignore_header=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Read a csv file into a list of lists, ignore any rows prepended with comment symbol, ignore first row if ignoreheader=True</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>infile</code></strong></dt>
<dd>the csv file input</dd>
<dt><strong><code>separator</code></strong></dt>
<dd>a string specifying the separator between columns.
defaults to ','</dd>
<dt><strong><code>ignoreheader</code></strong></dt>
<dd>if true, ignore the first row of the csv file</dd>
<dt><strong><code>ignore_header</code></strong></dt>
<dd>if true, ignore the first row of the csv file (argument synonym)</dd>
<dt><strong><code>comment</code></strong></dt>
<dd>if provided, ignore all rows with this comment symbol prepended</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>a list of lists, each list element containing a list of elements in the corresponding line of the csv file, parsed by separator</p>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;this parser does not escape delimiters enclosed in double quotes, as may be assumed by some csv writers</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1211-L1231" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def readcsv(infile, separator=&#39;,&#39;, ignoreheader=False, comment=None, ignore_header=False):
    &#34;&#34;&#34;Read a csv file into a list of lists, ignore any rows prepended with comment symbol, ignore first row if ignoreheader=True

    Args:
        infile: the csv file input
        separator: a string specifying the separator between columns.  defaults to &#39;,&#39;
        ignoreheader: if true, ignore the first row of the csv file
        ignore_header: if true, ignore the first row of the csv file (argument synonym)
        comment:  if provided, ignore all rows with this comment symbol prepended

    Returns:
        a list of lists, each list element containing a list of elements in the corresponding line of the csv file, parsed by separator

    .. note:: this parser does not escape delimiters enclosed in double quotes, as may be assumed by some csv writers
    &#34;&#34;&#34;

    with open(infile, &#39;r&#39;) as f:
        list_of_rows = [[x.strip() for x in r.split(separator)] for r in f]
    list_of_rows = list_of_rows if (len(list_of_rows)==0 or not (ignoreheader or ignore_header)) else list_of_rows[1:]
    list_of_rows = list_of_rows if comment is None else [r for r in list_of_rows if len(r)==0 or r[0][0] != comment]
    return list_of_rows</code></pre>
</details>
</dd>
<dt id="vipy.util.readcsvwithheader"><code class="name flex">
<span>def <span class="ident">readcsvwithheader</span></span>(<span>infile, separator=',')</span>
</code></dt>
<dd>
<div class="desc"><p>Read a csv file into a list of lists</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1234-L1242" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def readcsvwithheader(infile, separator=&#39;,&#39;):
    &#34;&#34;&#34;Read a csv file into a list of lists&#34;&#34;&#34;
    with open(infile, &#39;r&#39;) as f:
        list_of_rows = [[x.strip() for x in r.split(separator)]
                        for r in f.readlines()]
    header_dict = dict()
    for i in range(len(list_of_rows[0])):
        header_dict[list_of_rows[0][i]] = i
    return list_of_rows[1:], header_dict</code></pre>
</details>
</dd>
<dt id="vipy.util.readjson"><code class="name flex">
<span>def <span class="ident">readjson</span></span>(<span>jsonfile, strict=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Read jsonfile=/path/to/file.json and return the json parsed object, issue warning if jsonfile does not have .json extension and strict=True</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L447-L453" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def readjson(jsonfile, strict=True):
    &#34;&#34;&#34;Read jsonfile=/path/to/file.json and return the json parsed object, issue warning if jsonfile does not have .json extension and strict=True&#34;&#34;&#34;
    if not isjsonfile(jsonfile) and strict:
        warnings.warn(&#39;Attempting to read JSON file &#34;%s&#34; without .json extension&#39; % jsonfile)
    with open(jsonfile) as f:
        data = json.loads(f.read())
    return data</code></pre>
</details>
</dd>
<dt id="vipy.util.readlist"><code class="name flex">
<span>def <span class="ident">readlist</span></span>(<span>infile)</span>
</code></dt>
<dd>
<div class="desc"><p>Read each row of file as an element of the list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1163-L1167" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def readlist(infile):
    &#34;&#34;&#34;Read each row of file as an element of the list&#34;&#34;&#34;
    with open(infile, &#39;r&#39;) as f:
        list_of_rows = f.read().splitlines()
    return list_of_rows</code></pre>
</details>
</dd>
<dt id="vipy.util.readtxt"><code class="name flex">
<span>def <span class="ident">readtxt</span></span>(<span>infile)</span>
</code></dt>
<dd>
<div class="desc"><p>Read a text file one string per row</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1170-L1172" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def readtxt(infile):
    &#34;&#34;&#34;Read a text file one string per row&#34;&#34;&#34;
    return readlist(infile)</code></pre>
</details>
</dd>
<dt id="vipy.util.readyaml"><code class="name flex">
<span>def <span class="ident">readyaml</span></span>(<span>yamlfile)</span>
</code></dt>
<dd>
<div class="desc"><p>Read a yaml file and return a parsed dictionary, this is slow for large yaml files</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L401-L411" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def readyaml(yamlfile):
    &#34;&#34;&#34;Read a yaml file and return a parsed dictionary, this is slow for large yaml files&#34;&#34;&#34;
    try_import(&#39;yaml&#39;, &#39;pyyaml&#39;)
    import yaml    
    try:
            from yaml import CLoader as Loader
    except ImportError:
            from yaml import Loader

    with open(yamlfile, &#39;r&#39;) as f:
        return yaml.load(f.read(), Loader=Loader)  # yaml.CLoader is faster, but not installed via pip</code></pre>
</details>
</dd>
<dt id="vipy.util.remkdir"><code class="name flex">
<span>def <span class="ident">remkdir</span></span>(<span>path, flush=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a given directory if not already exists</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1804-L1811" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def remkdir(path, flush=False):
    &#34;&#34;&#34;Create a given directory if not already exists&#34;&#34;&#34;
    if os.path.isdir(path) is False and len(str(path)) &gt; 0:
        os.makedirs(path)
    elif flush is True:
        shutil.rmtree(path)
        os.makedirs(path)
    return os.path.abspath(os.path.expanduser(path))</code></pre>
</details>
</dd>
<dt id="vipy.util.repath"><code class="name flex">
<span>def <span class="ident">repath</span></span>(<span>v, srcpath, dstpath)</span>
</code></dt>
<dd>
<div class="desc"><p>Change the filename with prefix srcpath to dstpath, for any element in v that supports the filename() api</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L826-L836" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def repath(v, srcpath, dstpath):
    &#34;&#34;&#34;Change the filename with prefix srcpath to dstpath, for any element in v that supports the filename() api&#34;&#34;&#34;
    if not islist(v) and (hasattr(v, &#39;filename&#39;) and hasattr(v, &#39;clone&#39;)):
        vc = v.filename( v.filename().replace(os.path.normpath(srcpath), os.path.normpath(dstpath))) if v.filename() is not None else v
    elif islist(v) and all([(hasattr(vv, &#39;filename&#39;) and hasattr(vv, &#39;clone&#39;)) for vv in v]):
        vc = [vv.filename( vv.filename().replace(os.path.normpath(srcpath), os.path.normpath(dstpath))) if vv.filename() is not None else vv for vv in v ]
    elif isstring(v):
        vc = v.replace(os.path.normpath(srcpath), os.path.normpath(dstpath))
    else:
        raise ValueError(&#39;Input must be a singleton or list of vipy.image.Image() or vipy.video.Video() objects, not type &#34;%s&#34;&#39; % (str(type(v))))
    return vc</code></pre>
</details>
</dd>
<dt id="vipy.util.rermdir"><code class="name flex">
<span>def <span class="ident">rermdir</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"><p>Recursively delete a given directory (if exists), and remake it</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1814-L1816" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rermdir(path):
    &#34;&#34;&#34;Recursively delete a given directory (if exists), and remake it&#34;&#34;&#34;
    return remkdir(path, flush=True)</code></pre>
</details>
</dd>
<dt id="vipy.util.rgb2bgr"><code class="name flex">
<span>def <span class="ident">rgb2bgr</span></span>(<span>im_rgb)</span>
</code></dt>
<dd>
<div class="desc"><p>same as bgr2rgb</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1537-L1539" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rgb2bgr(im_rgb):
    &#34;&#34;&#34;same as bgr2rgb&#34;&#34;&#34;
    return bgr2rgb(im_rgb)</code></pre>
</details>
</dd>
<dt id="vipy.util.rmdir"><code class="name flex">
<span>def <span class="ident">rmdir</span></span>(<span>indir)</span>
</code></dt>
<dd>
<div class="desc"><p>Recursively remove directory and all contents (if the directory exists)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L528-L532" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rmdir(indir):
    &#34;&#34;&#34;Recursively remove directory and all contents (if the directory exists)&#34;&#34;&#34;
    if os.path.exists(indir) and os.path.isdir(indir):
        shutil.rmtree(indir)
    return indir</code></pre>
</details>
</dd>
<dt id="vipy.util.save"><code class="name flex">
<span>def <span class="ident">save</span></span>(<span>vars, outfile=None, backup=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Save variables to an archive file.</p>
<p>This function allows vipy objects to be serialized to disk for later loading.</p>
<pre><code class="language-python">im = vipy.image.owl()
im = vipy.util.load(vipy.util.save(im))   # round trip
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>vars</code></strong></dt>
<dd>A python object to save.
This can be any serializable python object</dd>
<dt><strong><code>outfile</code></strong></dt>
<dd>An output file to save.
Must have extension [.pkl, .json, .pkl.bz2].
If None, will save to a temporary JSON file.</dd>
</dl>
<p>backup [bool]:
If true and the outfile already exists, make a copy and save as outfile.bak before overwriting
Returns
A path to the saved archive file.
Load using <code><a title="vipy.util.load" href="#vipy.util.load">load()</a></code>. </p>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;JSON is preferred as an archive format for vipy.
Be sure to install the excellent ultrajson library (pip install ujson) for fast serialization.</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L83-L131" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def save(vars, outfile=None, backup=False):
    &#34;&#34;&#34;Save variables to an archive file.

    This function allows vipy objects to be serialized to disk for later loading.

    ```python
    im = vipy.image.owl()
    im = vipy.util.load(vipy.util.save(im))   # round trip
    ```

    Args:
        vars: A python object to save.  This can be any serializable python object
        outfile:  An output file to save.  Must have extension [.pkl, .json, .pkl.bz2].  If None, will save to a temporary JSON file.
        backup [bool]:  If true and the outfile already exists, make a copy and save as outfile.bak before overwriting
    Returns
        A path to the saved archive file.  Load using `vipy.util.load`. 

    .. note:: JSON is preferred as an archive format for vipy.  Be sure to install the excellent ultrajson library (pip install ujson) for fast serialization.
    &#34;&#34;&#34;
    allowable = set([&#39;.pkl&#39;, &#39;.json&#39;, &#39;.pkl.bz2&#39;])
    outfile = tempjson() if outfile is None else outfile

    if backup and os.path.exists(outfile):
        shutil.copyfile(outfile, outfile+&#39;.bak&#39;)
    remkdir(filepath(outfile))
    if ispkl(outfile):
        with open(outfile, &#39;wb&#39;) as f:
            default_pickle.dump(vars, f)

    elif isjsonfile(outfile):
        saveobj = vars
        registry = class_registry()
        if isinstance(saveobj, list) and all([str(type(d)) in registry for d in saveobj]):
            j = [{str(type(d)):d.json(encode=False)} for d in saveobj] if isinstance(saveobj, list) else ({str(type(d)):d.json(encode=False)} for d in saveobj)
        elif str(type(saveobj)) in registry:
            j = {str(type(saveobj)):saveobj.json(encode=False)}
        else:
            j = saveobj

        s = json.dumps(j, ensure_ascii=False)  # load to memory (faster than json.dump), will throw exception if it cannot serialize
        with open(outfile, &#39;w&#39;) as f:
            f.write(s)            

    elif ispklbz2(outfile):
        return pklbz2(outfile, vars)
    else:
        raise ValueError(&#39;Unknown file extension for save file &#34;%s&#34; - must be in %s&#39; % (fileext(outfile), str(allowable)))
    
    return os.path.abspath(outfile)</code></pre>
</details>
</dd>
<dt id="vipy.util.save_opencv_yaml"><code class="name flex">
<span>def <span class="ident">save_opencv_yaml</span></span>(<span>yamlfile, mat)</span>
</code></dt>
<dd>
<div class="desc"><p>Save a numpy array to YAML file importable by OpenCV</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L929-L955" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def save_opencv_yaml(yamlfile, mat):
    &#34;&#34;&#34;Save a numpy array to YAML file importable by OpenCV&#34;&#34;&#34;

    def _write_matrix(f, M):
        f.write(&#39;    mtx_01: !!opencv-matrix\n&#39;)
        f.write(&#39;       rows: %d\n&#39; % M.shape[0])
        f.write(&#39;       cols: %d\n&#39; % (M.shape[1] if M.ndim == 2 else 1))
        f.write(&#39;       dt: f\n&#39;)
        f.write(&#39;       data: [ &#39;)
        datastr = &#39;&#39;
        for (k, x) in enumerate(M.flatten()):
            datastr += &#39;%.6e&#39; % x
            if (k + 1 == M.size):
                f.write(datastr)
                break
            datastr += &#39;, &#39;
            if ((k + 1) % 4) == 0:
                f.write(datastr + &#39;\n           &#39;)
                datastr = &#39;&#39;

        f.write(&#39;]\n&#39;)

    with open(yamlfile, &#39;w&#39;) as f:
        f.write(&#39;%YAML:1.0\n&#39;)
        _write_matrix(f, mat)

    return yamlfile</code></pre>
</details>
</dd>
<dt id="vipy.util.savetemp"><code class="name flex">
<span>def <span class="ident">savetemp</span></span>(<span>img)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L730-L733" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def savetemp(img):
    f = &#39;/tmp/%s.png&#39; % uuid.uuid1().hex
    PIL.Image.fromarray(img.astype(np.uint8)).save(f)
    return f</code></pre>
</details>
</dd>
<dt id="vipy.util.scpload"><code class="name flex">
<span>def <span class="ident">scpload</span></span>(<span>url)</span>
</code></dt>
<dd>
<div class="desc"><p>Load an archive file saved using <code><a title="vipy.util.scpsave" href="#vipy.util.scpsave">scpsave()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L885-L888" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def scpload(url):
    &#34;&#34;&#34;Load an archive file saved using `vipy.util.scpsave`&#34;&#34;&#34;
    import vipy.downloader
    return load(vipy.downloader.scp(url, templike(url)))</code></pre>
</details>
</dd>
<dt id="vipy.util.scpsave"><code class="name flex">
<span>def <span class="ident">scpsave</span></span>(<span>V, username=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Save an archive file to load via SCP.</p>
<p>Use case:</p>
<ul>
<li>This archive format is useful to allow access to videos and images that are accessible behind a remote server for which you have access via SSH key-based authentication.</li>
<li>You create this archive on the remote server, and all vipy objects are replaced with references to remote media.</li>
<li>Every video or image is replaced with a URL of the format 'scp://USER@HOST:/path/to.mp4'.
</li>
<li>Vipy will use your SSH keys to SCP these media files from USER@HOST on demand, so that the videos are cached for you on your local machine when you need them.</li>
<li>This is useful for transparently visualizing large datasets that are hidden behind an SSH-only accessible server</li>
</ul>
<p>Usage:</p>
<pre><code class="language-python">outfile = vipy.util.scpsave([vipy.video.Video(filename='/path/to.mp4)])  # run on remote machine that you have SSH key access
V = vipy.util.scpload(outfile)  # run on local machine that has SSH key access to remote machine
V[0].load()  # this will SCP the videos from 'scp:///path/to.mp4' to $VIPY_CACHE/to.mp4 transparently and on demand
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>V</code></strong></dt>
<dd>[vipy objects] A list of vipy objects or <code><a title="vipy.dataset.Dataset" href="dataset.html#vipy.dataset.Dataset">Dataset</a></code></dd>
<dt><strong><code>username</code></strong></dt>
<dd>[str] Your username on the remote machine to select the proper SSH key</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A temp archive file stored on the remote machine that will be downloaded and loaded via SCP, such that each element in the list will be fetched via scp when pixels are loaded.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L839-L882" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def scpsave(V, username=None):
    &#34;&#34;&#34;Save an archive file to load via SCP.

    Use case:

    - This archive format is useful to allow access to videos and images that are accessible behind a remote server for which you have access via SSH key-based authentication.
    - You create this archive on the remote server, and all vipy objects are replaced with references to remote media.
    - Every video or image is replaced with a URL of the format &#39;scp://USER@HOST:/path/to.mp4&#39;.  
    - Vipy will use your SSH keys to SCP these media files from USER@HOST on demand, so that the videos are cached for you on your local machine when you need them.
    - This is useful for transparently visualizing large datasets that are hidden behind an SSH-only accessible server

    Usage:
    
    ```python
    outfile = vipy.util.scpsave([vipy.video.Video(filename=&#39;/path/to.mp4)])  # run on remote machine that you have SSH key access
    V = vipy.util.scpload(outfile)  # run on local machine that has SSH key access to remote machine
    V[0].load()  # this will SCP the videos from &#39;scp:///path/to.mp4&#39; to $VIPY_CACHE/to.mp4 transparently and on demand
    ```

    Args:
        V: [vipy objects] A list of vipy objects or `vipy.dataset.Dataset`
        username: [str] Your username on the remote machine to select the proper SSH key

    Returns:
        A temp archive file stored on the remote machine that will be downloaded and loaded via SCP, such that each element in the list will be fetched via scp when pixels are loaded.

    &#34;&#34;&#34;
    
    import vipy.image
    import vipy.video

    if isinstance(V, vipy.dataset.Dataset) and V._isvipy():
        v = V.localmap(lambda v: v.clone().url(&#39;scp://%s%s:%s&#39; % ((&#39;%s@&#39; % username) if username is not None else &#39;&#39;, socket.gethostname(), v.filename())).nofilename())
    elif (isinstance(V, vipy.image.Image) or isinstance(V, vipy.video.Video)) and V.hasfilename():        
        v = V.clone().url(&#39;scp://%s%s:%s&#39; % ((&#39;%s@&#39; % username) if username is not None else &#39;&#39;, socket.gethostname(), V.filename())).nofilename()
    elif islist(V) and all([isinstance(v, vipy.image.Image) or isinstance(v, vipy.video.Video) for v in V]):
        v = [v.clone().url(&#39;scp://%s%s:%s&#39; % ((&#39;%s@&#39; % username) if username is not None else &#39;&#39;, socket.gethostname(), v.abspath().filename())).nofilename() for v in V]
    else:
        v = V # no vipy objects

    pklfile = &#39;scp://%s%s:%s&#39; % ((&#39;%s@&#39; % username) if username is not None else &#39;&#39;, socket.gethostname(), save(v, temppkl()))
    cmd = &#34;V = vipy.util.scpload(&#39;%s&#39;)&#34; % pklfile
    log.info(&#39;[vipy.util.scpsave]: On a local machine where you have public key ssh access to this remote machine run:\n&gt;&gt;&gt; %s\n&#39; % cmd)
    return pklfile</code></pre>
</details>
</dd>
<dt id="vipy.util.seconds_to_MMSS_colon_notation"><code class="name flex">
<span>def <span class="ident">seconds_to_MMSS_colon_notation</span></span>(<span>sec)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert integer seconds into MM:SS colon format.
If sec=121, then return '02:01'.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L312-L315" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def seconds_to_MMSS_colon_notation(sec):
    &#34;&#34;&#34;Convert integer seconds into MM:SS colon format.  If sec=121, then return &#39;02:01&#39;. &#34;&#34;&#34;
    assert isinstance(sec, int) and sec &lt;= 99*60 + 59 and sec &gt;= 0
    return &#39;%02d:%02d&#39; % (int(sec/60.0), sec % 60)</code></pre>
</details>
</dd>
<dt id="vipy.util.seq"><code class="name flex">
<span>def <span class="ident">seq</span></span>(<span>start, stop, step=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Equivalent to matlab [start:step:stop]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L762-L768" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def seq(start, stop, step=1):
    &#34;&#34;&#34;Equivalent to matlab [start:step:stop]&#34;&#34;&#34;
    n = int(round((stop - start) / float(step)))
    if n &gt; 1:
        return([start + step * i for i in range(n + 1)])
    else:
        return([])</code></pre>
</details>
</dd>
<dt id="vipy.util.shortuuid"><code class="name flex">
<span>def <span class="ident">shortuuid</span></span>(<span>n=8)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a short UUID with n charaters sampled uniformly at random from lowercase|uppercase|numbers</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1302-L1304" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def shortuuid(n=8):
    &#34;&#34;&#34;Generate a short UUID with n charaters sampled uniformly at random from lowercase|uppercase|numbers&#34;&#34;&#34;
    return &#39;&#39;.join(random.sample(ALPHABET, n))</code></pre>
</details>
</dd>
<dt id="vipy.util.shufflelist"><code class="name flex">
<span>def <span class="ident">shufflelist</span></span>(<span>inlist)</span>
</code></dt>
<dd>
<div class="desc"><p>Randomly shuffle a list, returning the shuffled list. Shuffle is not in-place</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L519-L521" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def shufflelist(inlist):
    &#34;&#34;&#34;Randomly shuffle a list, returning the shuffled list. Shuffle is not in-place&#34;&#34;&#34;
    return random.sample(inlist, len(inlist))</code></pre>
</details>
</dd>
<dt id="vipy.util.singletonlist"><code class="name flex">
<span>def <span class="ident">singletonlist</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a singleton list to a singleton, otherwise return the list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1405-L1407" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def singletonlist(x):
    &#34;&#34;&#34;Convert a singleton list to a singleton, otherwise return the list&#34;&#34;&#34;
    return x[0] if isinstance(x, list) and len(x)==1 else x</code></pre>
</details>
</dd>
<dt id="vipy.util.softmax"><code class="name flex">
<span>def <span class="ident">softmax</span></span>(<span>x, temperature=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Row-wise softmax</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L503-L507" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def softmax(x, temperature=1.0):
    &#34;&#34;&#34;Row-wise softmax&#34;&#34;&#34;
    assert x.ndim == 2
    z = np.exp((x - np.max(x, axis=1).reshape(x.shape[0], 1)) / temperature)
    return z / np.sum(z, axis=1).reshape(x.shape[0], 1)</code></pre>
</details>
</dd>
<dt id="vipy.util.splitext"><code class="name flex">
<span>def <span class="ident">splitext</span></span>(<span>filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Given /a/b/c.ext return tuple of strings ('/a/b/c', '.ext'), handling multi-dot extensions like .tar.gz</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1844-L1849" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def splitext(filename):
    &#34;&#34;&#34;Given /a/b/c.ext return tuple of strings (&#39;/a/b/c&#39;, &#39;.ext&#39;), handling multi-dot extensions like .tar.gz&#34;&#34;&#34;
    (head, tail) = os.path.split(filename)
    ext = fileext(filename, multidot=True, withdot=True)
    base = tail.replace(ext,&#39;&#39;) if ext is not None else tail
    return (os.path.join(head, base), ext)  # for consistency with splitext</code></pre>
</details>
</dd>
<dt id="vipy.util.string_to_pil_interpolation"><code class="name flex">
<span>def <span class="ident">string_to_pil_interpolation</span></span>(<span>interp)</span>
</code></dt>
<dd>
<div class="desc"><p>Internal function to convert interp string to interp object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1900-L1910" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def string_to_pil_interpolation(interp):
    &#34;&#34;&#34;Internal function to convert interp string to interp object&#34;&#34;&#34;
    assert interp in [&#39;bilinear&#39;, &#39;bicubic&#39;, &#39;nearest&#39;], &#34;Invalid interp - Must be in [&#39;bilinear&#39;, &#39;bicubic&#39;, &#39;nearest&#39;]&#34;
    if interp == &#39;bilinear&#39;:
        return PIL.Image.BILINEAR
    elif interp == &#39;bicubic&#39;:
        return PIL.Image.BICUBIC
    elif interp == &#39;nearest&#39;:
        return PIL.Image.NEAREST
    else:
        raise  # should never get here</code></pre>
</details>
</dd>
<dt id="vipy.util.stringhash"><code class="name flex">
<span>def <span class="ident">stringhash</span></span>(<span>s, n=16)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a repeatable hash with n characters for a string s</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1306-L1308" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def stringhash(s, n=16):
    &#34;&#34;&#34;Generate a repeatable hash with n characters for a string s&#34;&#34;&#34;
    return hashlib.sha256(s.encode(&#39;utf-8&#39;)).hexdigest()[0:n]</code></pre>
</details>
</dd>
<dt id="vipy.util.sumby"><code class="name flex">
<span>def <span class="ident">sumby</span></span>(<span>inlist, keyfunc=&lt;function &lt;lambda&gt;&gt;, valuefunc=&lt;function &lt;lambda&gt;&gt;)</span>
</code></dt>
<dd>
<div class="desc"><p>Given an inlist of tuples [('a',1), ('a',2), ('b',4)], group by the keyfunc, then sum over the values in valuefunc.
Returns ductionary over keys, sum reduced over valuefunc.
Example returns {'a':3,'b':4}.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L490-L492" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def sumby(inlist, keyfunc=lambda x: x[0], valuefunc=lambda x: x[1]):
    &#34;&#34;&#34;Given an inlist of tuples [(&#39;a&#39;,1), (&#39;a&#39;,2), (&#39;b&#39;,4)], group by the keyfunc, then sum over the values in valuefunc.  Returns ductionary over keys, sum reduced over valuefunc.  Example returns {&#39;a&#39;:3,&#39;b&#39;:4}.&#34;&#34;&#34;
    return {k:sum([valuefunc(vi) for vi in v]) for (k,v) in groupbyasdict(inlist, keyfunc).items()}</code></pre>
</details>
</dd>
<dt id="vipy.util.symlink"><code class="name flex">
<span>def <span class="ident">symlink</span></span>(<span>src, dst, overwrite=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a symlink from src to dst, overwriting the existing symlink at dst if overwrite=True</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1912-L1917" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def symlink(src, dst, overwrite=False):
    &#34;&#34;&#34;Create a symlink from src to dst, overwriting the existing symlink at dst if overwrite=True&#34;&#34;&#34;
    if overwrite and os.path.islink(dst):
        os.unlink(dst)
    os.symlink(src, dst)
    return dst</code></pre>
</details>
</dd>
<dt id="vipy.util.take"><code class="name flex">
<span>def <span class="ident">take</span></span>(<span>inlist, k)</span>
</code></dt>
<dd>
<div class="desc"><p>Take k elements at random from inlist</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L796-L798" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def take(inlist, k):
    &#34;&#34;&#34;Take k elements at random from inlist&#34;&#34;&#34;
    return [inlist[i] for i in np.random.permutation(range(len(inlist)))[0:k]] if len(inlist)&gt;k else inlist</code></pre>
</details>
</dd>
<dt id="vipy.util.takelast"><code class="name flex">
<span>def <span class="ident">takelast</span></span>(<span>inlist)</span>
</code></dt>
<dd>
<div class="desc"><p>Take last element from inlist or return None if empty</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L804-L806" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def takelast(inlist):
    &#34;&#34;&#34;Take last element from inlist or return None if empty&#34;&#34;&#34;
    return tolist(inlist)[-1] if len(tolist(inlist))&gt;=1 else None</code></pre>
</details>
</dd>
<dt id="vipy.util.takeone"><code class="name flex">
<span>def <span class="ident">takeone</span></span>(<span>inlist)</span>
</code></dt>
<dd>
<div class="desc"><p>Take one element at random from inlist or return None if empty</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L800-L802" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def takeone(inlist):
    &#34;&#34;&#34;Take one element at random from inlist or return None if empty&#34;&#34;&#34;
    return take(list(inlist), k=1)[0] if len(inlist)&gt;=1 else None   # -&gt; random.sample()?</code></pre>
</details>
</dd>
<dt id="vipy.util.tempMP4"><code class="name flex">
<span>def <span class="ident">tempMP4</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a temporary MP4 file in system temp directory</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1623-L1625" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def tempMP4():
    &#34;&#34;&#34;Create a temporary MP4 file in system temp directory&#34;&#34;&#34;
    return tempfilename(suffix=&#39;.mp4&#39;)</code></pre>
</details>
</dd>
<dt id="vipy.util.tempWEBP"><code class="name flex">
<span>def <span class="ident">tempWEBP</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a temporary WEBP file in system temp directory</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1627-L1629" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def tempWEBP():
    &#34;&#34;&#34;Create a temporary WEBP file in system temp directory&#34;&#34;&#34;
    return tempfilename(suffix=&#39;.webp&#39;)</code></pre>
</details>
</dd>
<dt id="vipy.util.tempcsv"><code class="name flex">
<span>def <span class="ident">tempcsv</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a temporary CSV file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1637-L1639" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def tempcsv():
    &#34;&#34;&#34;Create a temporary CSV file&#34;&#34;&#34;
    return tempfilename(suffix=&#39;.csv&#39;)</code></pre>
</details>
</dd>
<dt id="vipy.util.tempdir"><code class="name flex">
<span>def <span class="ident">tempdir</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapper around tempfile, because I can never remember the syntax</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1675-L1677" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def tempdir():
    &#34;&#34;&#34;Wrapper around tempfile, because I can never remember the syntax&#34;&#34;&#34;
    return tempfile.gettempdir()</code></pre>
</details>
</dd>
<dt id="vipy.util.tempfilename"><code class="name flex">
<span>def <span class="ident">tempfilename</span></span>(<span>suffix='')</span>
</code></dt>
<dd>
<div class="desc"><p>Create a temporary filename $TEMPDIR/$UUID.suffix, suffix should include the dot such as suffix='.jpg',</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1578-L1580" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def tempfilename(suffix=&#39;&#39;):
    &#34;&#34;&#34;Create a temporary filename $TEMPDIR/$UUID.suffix, suffix should include the dot such as suffix=&#39;.jpg&#39;, &#34;&#34;&#34;
    return os.path.join(tempfile.gettempdir(), &#39;%s%s&#39; % (shortuuid(), suffix))</code></pre>
</details>
</dd>
<dt id="vipy.util.temphtml"><code class="name flex">
<span>def <span class="ident">temphtml</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a temporary HTMLfile</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1641-L1643" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def temphtml():
    &#34;&#34;&#34;Create a temporary HTMLfile&#34;&#34;&#34;
    return tempfilename(suffix=&#39;.html&#39;)</code></pre>
</details>
</dd>
<dt id="vipy.util.tempimage"><code class="name flex">
<span>def <span class="ident">tempimage</span></span>(<span>ext='jpg')</span>
</code></dt>
<dd>
<div class="desc"><p>Create a temporary image with the given extension</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1601-L1605" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def tempimage(ext=&#39;jpg&#39;):
    &#34;&#34;&#34;Create a temporary image with the given extension&#34;&#34;&#34;
    if ext[0] == &#39;.&#39;:
        ext = ext[1:]
    return tempfilename(suffix=&#39;.&#39; + ext)</code></pre>
</details>
</dd>
<dt id="vipy.util.tempjpg"><code class="name flex">
<span>def <span class="ident">tempjpg</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a temporary JPG file in system temp directory</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1618-L1620" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def tempjpg():
    &#34;&#34;&#34;Create a temporary JPG file in system temp directory&#34;&#34;&#34;
    return tempimage(&#39;jpg&#39;)</code></pre>
</details>
</dd>
<dt id="vipy.util.tempjson"><code class="name flex">
<span>def <span class="ident">tempjson</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a temporary JSON file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1660-L1662" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def tempjson():
    &#34;&#34;&#34;Create a temporary JSON file&#34;&#34;&#34;
    return tempfilename(suffix=&#39;.json&#39;)</code></pre>
</details>
</dd>
<dt id="vipy.util.templike"><code class="name flex">
<span>def <span class="ident">templike</span></span>(<span>filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a new temporary filename with the same extension as filename</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1588-L1590" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def templike(filename):
    &#34;&#34;&#34;Create a new temporary filename with the same extension as filename&#34;&#34;&#34;
    return tempfilename(fileext(filename))</code></pre>
</details>
</dd>
<dt id="vipy.util.temppdf"><code class="name flex">
<span>def <span class="ident">temppdf</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a temporary PDF file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1665-L1667" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def temppdf():
    &#34;&#34;&#34;Create a temporary PDF file&#34;&#34;&#34;
    return tempfilename(suffix=&#39;.pdf&#39;)</code></pre>
</details>
</dd>
<dt id="vipy.util.temppickle"><code class="name flex">
<span>def <span class="ident">temppickle</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a temporary pickle file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1613-L1615" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def temppickle():
    &#34;&#34;&#34;Create a temporary pickle file&#34;&#34;&#34;
    return tempfilename(suffix=&#39;.pkl&#39;)</code></pre>
</details>
</dd>
<dt id="vipy.util.temppkl"><code class="name flex">
<span>def <span class="ident">temppkl</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a temporary pickle file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1646-L1648" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def temppkl():
    &#34;&#34;&#34;Create a temporary pickle file&#34;&#34;&#34;
    return temppickle()</code></pre>
</details>
</dd>
<dt id="vipy.util.temppklbz2"><code class="name flex">
<span>def <span class="ident">temppklbz2</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a temporary .pkl.bz2 file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1650-L1652" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def temppklbz2():
    &#34;&#34;&#34;Create a temporary .pkl.bz2 file&#34;&#34;&#34;
    return temppickle()+&#39;.bz2&#39;</code></pre>
</details>
</dd>
<dt id="vipy.util.temppng"><code class="name flex">
<span>def <span class="ident">temppng</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a temporay PNG file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1608-L1610" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def temppng():
    &#34;&#34;&#34;Create a temporay PNG file&#34;&#34;&#34;
    return tempimage(&#39;png&#39;)</code></pre>
</details>
</dd>
<dt id="vipy.util.tempyaml"><code class="name flex">
<span>def <span class="ident">tempyaml</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a temporary YAML file</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1655-L1657" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def tempyaml():
    &#34;&#34;&#34;Create a temporary YAML file&#34;&#34;&#34;
    return tempfilename(suffix=&#39;.yml&#39;)</code></pre>
</details>
</dd>
<dt id="vipy.util.timestamp"><code class="name flex">
<span>def <span class="ident">timestamp</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Return date and time string in form DDMMMYY_HHMMSS</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1786-L1788" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def timestamp():
    &#34;&#34;&#34;Return date and time string in form DDMMMYY_HHMMSS&#34;&#34;&#34;
    return str.upper(strftime(&#34;%d%b%y_%I%M%S%p&#34;, localtime()))</code></pre>
</details>
</dd>
<dt id="vipy.util.tmpjpg"><code class="name flex">
<span>def <span class="ident">tmpjpg</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a temporary JPG file in /tmp</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1632-L1634" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def tmpjpg():
    &#34;&#34;&#34;Create a temporary JPG file in /tmp&#34;&#34;&#34;
    return &#39;/tmp/%s.jpg&#39; % uuid.uuid4().hex</code></pre>
</details>
</dd>
<dt id="vipy.util.to_iterable"><code class="name flex">
<span>def <span class="ident">to_iterable</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert an object to a singleton tuple if not already a list, tuple or set iterable</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1390-L1392" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def to_iterable(x): 
    &#34;&#34;&#34;Convert an object to a singleton tuple if not already a list, tuple or set iterable&#34;&#34;&#34;
    return x if isinstance(x, (list, tuple, set)) else (x,)</code></pre>
</details>
</dd>
<dt id="vipy.util.tocache"><code class="name flex">
<span>def <span class="ident">tocache</span></span>(<span>filename)</span>
</code></dt>
<dd>
<div class="desc"><p>If the VIPY_CACHE environment variable is set, then return the filename=subpath/to/file.ext in the cache as VIPY_CACHE/subpath/to/file.ext.
Otherwise, return the file in the system temp</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L308-L310" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def tocache(filename):
    &#34;&#34;&#34;If the VIPY_CACHE environment variable is set, then return the filename=subpath/to/file.ext in the cache as VIPY_CACHE/subpath/to/file.ext.  Otherwise, return the file in the system temp&#34;&#34;&#34;
    return os.path.join(cache(), filename)</code></pre>
</details>
</dd>
<dt id="vipy.util.toextension"><code class="name flex">
<span>def <span class="ident">toextension</span></span>(<span>filename, newext)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert filename='/path/to/myfile.ext' to /path/to/myfile.xyz, such that newext='xyz' or newext='.xyz'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1829-L1834" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def toextension(filename, newext):
    &#34;&#34;&#34;Convert filename=&#39;/path/to/myfile.ext&#39; to /path/to/myfile.xyz, such that newext=&#39;xyz&#39; or newext=&#39;.xyz&#39;&#34;&#34;&#34;
    if &#39;.&#39; in newext:
        newext = newext.split(&#39;.&#39;)[-1]
    (filename, oldext) = splitext(filename)
    return filename + &#39;.&#39; + str(newext)</code></pre>
</details>
</dd>
<dt id="vipy.util.tofilename"><code class="name flex">
<span>def <span class="ident">tofilename</span></span>(<span>s, hyphen=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert arbitrary string to valid filename with underscores
replacing invalid chars</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L958-L965" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def tofilename(s, hyphen=True):
    &#34;&#34;&#34;Convert arbitrary string to valid filename with underscores
    replacing invalid chars&#34;&#34;&#34;
    valid_chars = &#34;-_.%s%s&#34; % (str.ascii_letters, str.digits)
    s = str.replace(s, &#39; &#39;, &#39;_&#39;)
    if hyphen:
        s = str.replace(s, &#39;-&#39;, &#39;_&#39;)
    return &#34;&#34;.join(x for x in s if x in valid_chars)</code></pre>
</details>
</dd>
<dt id="vipy.util.tolist"><code class="name flex">
<span>def <span class="ident">tolist</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a python tuple or singleton object to a list if not already a list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1394-L1403" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def tolist(x):
    &#34;&#34;&#34;Convert a python tuple or singleton object to a list if not already a list &#34;&#34;&#34;
    if isinstance(x, list):
        return x
    elif isinstance(x, tuple):        
        return list(x)
    elif isinstance(x, set):        
        return list(x)
    else:
        return [x]</code></pre>
</details>
</dd>
<dt id="vipy.util.tolist_or_singleton"><code class="name flex">
<span>def <span class="ident">tolist_or_singleton</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"><p>Return list(x) if length of iterator x is not equal to one, else return x or None.
This is useful to return single elements instead of single element lists.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1419-L1422" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def tolist_or_singleton(x):
    &#34;&#34;&#34;Return list(x) if length of iterator x is not equal to one, else return x or None.  This is useful to return single elements instead of single element lists.&#34;&#34;&#34;
    y = tolist(x)
    return y if len(y)&gt;1 else (y[0] if len(y)==1 else None)</code></pre>
</details>
</dd>
<dt id="vipy.util.topath"><code class="name flex">
<span>def <span class="ident">topath</span></span>(<span>filename, newdir)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for <code><a title="vipy.util.newpath" href="#vipy.util.newpath">newpath()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1078-L1080" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def topath(filename, newdir):
    &#34;&#34;&#34;Alias for `vipy.util.newpath`&#34;&#34;&#34;
    return newpath(filename, newdir)</code></pre>
</details>
</dd>
<dt id="vipy.util.topkl"><code class="name flex">
<span>def <span class="ident">topkl</span></span>(<span>filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert filename='/path/to/myfile.ext' to /path/to/myfile.pkl</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1840-L1842" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def topkl(filename):
    &#34;&#34;&#34;Convert filename=&#39;/path/to/myfile.ext&#39; to /path/to/myfile.pkl&#34;&#34;&#34;
    return toextension(filename, &#39;.pkl&#39;)</code></pre>
</details>
</dd>
<dt id="vipy.util.toset"><code class="name flex">
<span>def <span class="ident">toset</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a python iterable to a set of not already a set</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1409-L1416" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def toset(x):
    &#34;&#34;&#34;Convert a python iterable to a set of not already a set&#34;&#34;&#34;
    if isinstance(x, set):        
        return x    
    elif isinstance(x, list) or isinstance(x, tuple):
        return set(x)
    else:
        return set([x])</code></pre>
</details>
</dd>
<dt id="vipy.util.totempdir"><code class="name flex">
<span>def <span class="ident">totempdir</span></span>(<span>filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a filename '/patj/to/filename.ext' to '/tempdir/filename.ext'</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1583-L1585" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def totempdir(filename):
    &#34;&#34;&#34;Convert a filename &#39;/patj/to/filename.ext&#39; to &#39;/tempdir/filename.ext&#39;&#34;&#34;&#34;
    return os.path.join(tempfile.gettempdir(), filetail(filename))</code></pre>
</details>
</dd>
<dt id="vipy.util.totuple"><code class="name flex">
<span>def <span class="ident">totuple</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert an object to a python tuple?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1379-L1388" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def totuple(x):
    &#34;&#34;&#34;Convert an object to a python tuple?&#34;&#34;&#34;
    if isinstance(x, list):
        return tuple(x)
    elif isinstance(x, tuple):        
        return x
    elif isinstance(x, set):        
        return tuple(x)
    else:
        return (x,)</code></pre>
</details>
</dd>
<dt id="vipy.util.touch"><code class="name flex">
<span>def <span class="ident">touch</span></span>(<span>filename, mystr='')</span>
</code></dt>
<dd>
<div class="desc"><p>Create an empty file containing mystr</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1695-L1699" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def touch(filename, mystr=&#39;&#39;):
    &#34;&#34;&#34;Create an empty file containing mystr&#34;&#34;&#34;
    f = open(filename, &#39;w&#39;)
    f.write(str(mystr))
    f.close()</code></pre>
</details>
</dd>
<dt id="vipy.util.triplets"><code class="name flex">
<span>def <span class="ident">triplets</span></span>(<span>inlist)</span>
</code></dt>
<dd>
<div class="desc"><p>Yield triplets (1,2,3), (4,5,6), &hellip;
from list inlist=[1,2,3,4,5,6,&hellip;]</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L615-L618" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def triplets(inlist):
    &#34;&#34;&#34;Yield triplets (1,2,3), (4,5,6), ...  from list inlist=[1,2,3,4,5,6,...]&#34;&#34;&#34;
    for k in range(0, len(inlist), 3):
        yield (inlist[k], inlist[k+1] if (k+1)&lt;len(inlist) else None, inlist[k+2] if (k+2)&lt;len(inlist) else None)</code></pre>
</details>
</dd>
<dt id="vipy.util.truncate_string"><code class="name flex">
<span>def <span class="ident">truncate_string</span></span>(<span>s, maxlen)</span>
</code></dt>
<dd>
<div class="desc"><p>If string s is greater than maxlen, truncate and append an ellipsis</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1920-L1922" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def truncate_string(s, maxlen):
    &#34;&#34;&#34;If string s is greater than maxlen, truncate and append an ellipsis&#34;&#34;&#34;
    return s if len(s) &lt;= maxlen else str(s)[0:maxlen]+&#39;...&#39;</code></pre>
</details>
</dd>
<dt id="vipy.util.try_import"><code class="name flex">
<span>def <span class="ident">try_import</span></span>(<span>package, pipname=None, message=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Show a helpful error message for missing optional packages</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L317-L325" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def try_import(package, pipname=None, message=None):
    &#34;&#34;&#34;Show a helpful error message for missing optional packages&#34;&#34;&#34;
    try:
        importlib.import_module(package)
    except:
        if message is not None:
            raise ImportError(message)
        else:
            raise ImportError(&#39;Optional package &#34;%s&#34; not installed -  Run &#34;pip install %s&#34; or &#34;pip install vipy[all]&#34; &#39; % (package, package if pipname is None else pipname))</code></pre>
</details>
</dd>
<dt id="vipy.util.tryjson"><code class="name flex">
<span>def <span class="ident">tryjson</span></span>(<span>jsonfile)</span>
</code></dt>
<dd>
<div class="desc"><p>Attempt to load the json file, return True if loadable, False if not</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L455-L461" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def tryjson(jsonfile):
    &#34;&#34;&#34;Attempt to load the json file, return True if loadable, False if not&#34;&#34;&#34;
    try:
        readjson(jsonfile, strict=False)
        return True
    except Exception as e:
        return False</code></pre>
</details>
</dd>
<dt id="vipy.util.tryload"><code class="name flex">
<span>def <span class="ident">tryload</span></span>(<span>infile, abspath=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Attempt to load a pkl file, and return the value if successful and None if not</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L808-L813" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def tryload(infile, abspath=False):
    &#34;&#34;&#34;Attempt to load a pkl file, and return the value if successful and None if not&#34;&#34;&#34;
    try:
        return load(infile, abspath=abspath)
    except:
        return None</code></pre>
</details>
</dd>
<dt id="vipy.util.txtlist"><code class="name flex">
<span>def <span class="ident">txtlist</span></span>(<span>imdir)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a list of absolute paths of *.txt files in current directory</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1267-L1270" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def txtlist(imdir):
    &#34;&#34;&#34;Return a list of absolute paths of *.txt files in current directory&#34;&#34;&#34;
    return [os.path.join(imdir, item) for item in os.listdir(imdir)
            if istextfile(item) and not is_hiddenfile(item)]</code></pre>
</details>
</dd>
<dt id="vipy.util.videolist"><code class="name flex">
<span>def <span class="ident">videolist</span></span>(<span>videodir)</span>
</code></dt>
<dd>
<div class="desc"><p>return list of videos with absolute path in a directory</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1110-L1114" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def videolist(videodir):
    &#34;&#34;&#34;return list of videos with absolute path in a directory&#34;&#34;&#34;
    return [os.path.abspath(os.path.join(videodir, item))
            for item in os.listdir(videodir)
            if (isvideo(item) and not is_hiddenfile(item))]</code></pre>
</details>
</dd>
<dt id="vipy.util.vipy_groupby"><code class="name flex">
<span>def <span class="ident">vipy_groupby</span></span>(<span>inset, keyfunc)</span>
</code></dt>
<dd>
<div class="desc"><p>groupby on unsorted inset</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L468-L470" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def vipy_groupby(inset, keyfunc):
    &#34;&#34;&#34;groupby on unsorted inset&#34;&#34;&#34;
    return groupby(inset, keyfunc)</code></pre>
</details>
</dd>
<dt id="vipy.util.writecsv"><code class="name flex">
<span>def <span class="ident">writecsv</span></span>(<span>list_of_tuples, outfile=None, mode='w', separator=',', header=None, comment='# ')</span>
</code></dt>
<dd>
<div class="desc"><p>Write list of tuples to an output csv file with each list element on a row and tuple elements separated by commas.</p>
<p>Examples:</p>
<pre><code class="language-python">vipy.util.writecsv([(1,2,3), (4,5,6)], '/tmp/out.csv')
vipy.util.writecsv([(1,2,3), (4,5,6)], '/tmp/out.csv', separator=';'))
vipy.util.writecsv([(1,2,3), (4,5,6)], '/tmp/out.csv', header=('h1','h2','h3'))
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>list_of_tuples</code></strong></dt>
<dd>a list of tuples each tuple is a row</dd>
<dt><strong><code>outfile</code></strong></dt>
<dd>the csv file output</dd>
<dt><strong><code>mode</code></strong></dt>
<dd>'w' for overwrite, 'a' for append</dd>
<dt><strong><code>separator</code></strong></dt>
<dd>a string specifying the separator between columns.
defaults to ','</dd>
<dt><strong><code>header</code></strong></dt>
<dd>a tuple containing strings to be appended to the first row of the csv file</dd>
<dt><strong><code>comment</code></strong></dt>
<dd>the comment symbol to be prepended to the header row </dd>
</dl>
<h2 id="returns">Returns</h2>
<p>the outfile path</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1175-L1208" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def writecsv(list_of_tuples, outfile=None, mode=&#39;w&#39;, separator=&#39;,&#39;, header=None, comment=&#39;# &#39;):
    &#34;&#34;&#34;Write list of tuples to an output csv file with each list element on a row and tuple elements separated by commas.

    Examples:
    ```python
    vipy.util.writecsv([(1,2,3), (4,5,6)], &#39;/tmp/out.csv&#39;)
    vipy.util.writecsv([(1,2,3), (4,5,6)], &#39;/tmp/out.csv&#39;, separator=&#39;;&#39;))
    vipy.util.writecsv([(1,2,3), (4,5,6)], &#39;/tmp/out.csv&#39;, header=(&#39;h1&#39;,&#39;h2&#39;,&#39;h3&#39;))
    ```

    Args:
        list_of_tuples: a list of tuples each tuple is a row
        outfile: the csv file output
        mode: &#39;w&#39; for overwrite, &#39;a&#39; for append
        separator: a string specifying the separator between columns.  defaults to &#39;,&#39;
        header: a tuple containing strings to be appended to the first row of the csv file
        comment:  the comment symbol to be prepended to the header row 

    Returns:
        the outfile path
    &#34;&#34;&#34;
    
    list_of_tuples = list_of_tuples if not isnumpy(list_of_tuples) else list_of_tuples.tolist()
    list_of_tuples = list_of_tuples if header is None else [tuple([h if k&gt;0 else comment+h for (k,h) in enumerate(header)])]+list_of_tuples  # prepend header with comment symbol
    outfile = os.path.abspath(os.path.expanduser(outfile)) if outfile is not None else tempcsv()
    with open(outfile, mode) as f:
        for u in list_of_tuples:
            n = len(u)
            for (k, v) in enumerate(u):
                if (k + 1) &lt; n:
                    f.write(str(v) + separator)
                else:
                    f.write(str(v) + &#39;\n&#39;)
    return(outfile)</code></pre>
</details>
</dd>
<dt id="vipy.util.writejson"><code class="name flex">
<span>def <span class="ident">writejson</span></span>(<span>d, outfile)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L441-L444" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def writejson(d, outfile):
    with open(outfile, &#39;w&#39;) as f:
        json.dump(d, f)
    return outfile</code></pre>
</details>
</dd>
<dt id="vipy.util.writelist"><code class="name flex">
<span>def <span class="ident">writelist</span></span>(<span>mylist, outfile, mode='w')</span>
</code></dt>
<dd>
<div class="desc"><p>Write list of strings to an output file with each row an element of
the list</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1153-L1160" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def writelist(mylist, outfile, mode=&#39;w&#39;):
    &#34;&#34;&#34;Write list of strings to an output file with each row an element of
    the list&#34;&#34;&#34;
    outfile = os.path.abspath(os.path.expanduser(outfile))
    with open(outfile, mode) as f:
        for s in mylist:
            f.write(str(s) + &#39;\n&#39;)
    return(outfile)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="vipy.util.Failed"><code class="flex name class">
<span>class <span class="ident">Failed</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Raised when unit test fails to throw an exception</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1895-L1897" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Failed(Exception):
    &#34;&#34;&#34;Raised when unit test fails to throw an exception&#34;&#34;&#34;
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="vipy.util.Stopwatch"><code class="flex name class">
<span>class <span class="ident">Stopwatch</span></span>
</code></dt>
<dd>
<div class="desc"><p>Return elapsed system time in seconds between calls to enter and exit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1702-L1731" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Stopwatch(object):
    &#34;&#34;&#34;Return elapsed system time in seconds between calls to enter and exit&#34;&#34;&#34;

    def __init__(self):
        self.reset()

    def __enter__(self):
        self.start = time.time()
        self.last = self.start
        return self

    def __exit__(self, *args):
        self.end = time.time()
        self.elapsed = self.end - self.start

    def since(self, start=False):
        &#34;&#34;&#34;Return seconds since start or last call to this method&#34;&#34;&#34;
        now = time.time()
        dur = now - self.start if start is True else now - self.last
        self.last = now
        return dur

    def reset(self):
        self.start = time.time()
        self.last = self.start
        return self

    def duration(self):
        &#34;&#34;&#34;Time in seconds since last reset&#34;&#34;&#34;
        return time.time() - self.start</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="vipy.util.Stopwatch.duration"><code class="name flex">
<span>def <span class="ident">duration</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Time in seconds since last reset</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1729-L1731" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def duration(self):
    &#34;&#34;&#34;Time in seconds since last reset&#34;&#34;&#34;
    return time.time() - self.start</code></pre>
</details>
</dd>
<dt id="vipy.util.Stopwatch.reset"><code class="name flex">
<span>def <span class="ident">reset</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1724-L1727" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def reset(self):
    self.start = time.time()
    self.last = self.start
    return self</code></pre>
</details>
</dd>
<dt id="vipy.util.Stopwatch.since"><code class="name flex">
<span>def <span class="ident">since</span></span>(<span>self, start=False)</span>
</code></dt>
<dd>
<div class="desc"><p>Return seconds since start or last call to this method</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1717-L1722" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def since(self, start=False):
    &#34;&#34;&#34;Return seconds since start or last call to this method&#34;&#34;&#34;
    now = time.time()
    dur = now - self.start if start is True else now - self.last
    self.last = now
    return dur</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="vipy.util.Timer"><code class="flex name class">
<span>class <span class="ident">Timer</span></span>
<span>(</span><span>sprintf_next=None, sprintf_first=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Pretty print elapsed system time in seconds between calls to enter and exit</p>
<pre><code class="language-python">   t = Timer():
   [some code]
   print(t)
   [some more code]
   print(t)

   with Timer():
      [some code]
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/108adf37dddb6863992360c9360c5c6317ace42e/vipy/util.py#L1734-L1773" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Timer(object):
    &#34;&#34;&#34;Pretty print elapsed system time in seconds between calls to enter and exit
    
    ```python 
       t = Timer():
       [some code]
       print(t)
       [some more code]
       print(t)

       with Timer():
          [some code]
    ```
       
    &#34;&#34;&#34;
    def __enter__(self):
        self._begin = time.time()
        self._last = self._begin
        return self
        
    def __exit__(self, *args):
        log.info(self.__repr__())

    def __init__(self, sprintf_next=None, sprintf_first=None):
        self._sprintf_next = &#39;[vipy.util.timer]: elapsed=%1.6fs, total=%1.6fs&#39; if sprintf_next is None else sprintf_next
        self._sprintf_first = &#39;[vipy.util.timer]: elapsed=%1.6fs&#39; if sprintf_first is None else sprintf_first
        self._begin = time.time()
        self._last = self._begin
        self._laps = 0        
        try:
            self._sprintf_next % (1.0, 1.0)
            self._sprintf_first % (1.0)            
        except:
            raise ValueError(&#39;Printed display string must be a sprintf style string with one or two number variable like &#34;Elapsed=%1.6f since=%1.6f&#34;&#39;)
            
    def __repr__(self):
        s = str(self._sprintf_next % (time.time() - self._last, (time.time() - self._begin))) if self._laps &gt; 0 else str(self._sprintf_first % (time.time() - self._begin))
        self._last = time.time()
        self._laps += 1
        return s</code></pre>
</details>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="VIPY" href="https://github.com/visym/vipy/">
<img src="https://www.visym.com/labs/images/visym_logo_black_notext.png" alt="" width="60">
</a>
<h1 style="font-size:200%;"><b>VIPY:</b> Visual Dataset Transformation</h1>
</header>
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = './doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="vipy" href="index.html">vipy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="vipy.util.bgr2gray" href="#vipy.util.bgr2gray">bgr2gray</a></code></li>
<li><code><a title="vipy.util.bgr2hsv" href="#vipy.util.bgr2hsv">bgr2hsv</a></code></li>
<li><code><a title="vipy.util.bgr2rgb" href="#vipy.util.bgr2rgb">bgr2rgb</a></code></li>
<li><code><a title="vipy.util.cache" href="#vipy.util.cache">cache</a></code></li>
<li><code><a title="vipy.util.cached" href="#vipy.util.cached">cached</a></code></li>
<li><code><a title="vipy.util.canload" href="#vipy.util.canload">canload</a></code></li>
<li><code><a title="vipy.util.catcher" href="#vipy.util.catcher">catcher</a></code></li>
<li><code><a title="vipy.util.chunkgen" href="#vipy.util.chunkgen">chunkgen</a></code></li>
<li><code><a title="vipy.util.chunkgenbysize" href="#vipy.util.chunkgenbysize">chunkgenbysize</a></code></li>
<li><code><a title="vipy.util.chunklist" href="#vipy.util.chunklist">chunklist</a></code></li>
<li><code><a title="vipy.util.chunklistWithOverlap" href="#vipy.util.chunklistWithOverlap">chunklistWithOverlap</a></code></li>
<li><code><a title="vipy.util.chunklistbysize" href="#vipy.util.chunklistbysize">chunklistbysize</a></code></li>
<li><code><a title="vipy.util.chunklistwithoverlap" href="#vipy.util.chunklistwithoverlap">chunklistwithoverlap</a></code></li>
<li><code><a title="vipy.util.class_registry" href="#vipy.util.class_registry">class_registry</a></code></li>
<li><code><a title="vipy.util.clockstamp" href="#vipy.util.clockstamp">clockstamp</a></code></li>
<li><code><a title="vipy.util.count_images_in_subdirectories" href="#vipy.util.count_images_in_subdirectories">count_images_in_subdirectories</a></code></li>
<li><code><a title="vipy.util.countby" href="#vipy.util.countby">countby</a></code></li>
<li><code><a title="vipy.util.countbyasdict" href="#vipy.util.countbyasdict">countbyasdict</a></code></li>
<li><code><a title="vipy.util.csvlist" href="#vipy.util.csvlist">csvlist</a></code></li>
<li><code><a title="vipy.util.datestamp" href="#vipy.util.datestamp">datestamp</a></code></li>
<li><code><a title="vipy.util.dedupe" href="#vipy.util.dedupe">dedupe</a></code></li>
<li><code><a title="vipy.util.delpath" href="#vipy.util.delpath">delpath</a></code></li>
<li><code><a title="vipy.util.dirlist" href="#vipy.util.dirlist">dirlist</a></code></li>
<li><code><a title="vipy.util.dirlist_sorted_bycreation" href="#vipy.util.dirlist_sorted_bycreation">dirlist_sorted_bycreation</a></code></li>
<li><code><a title="vipy.util.dirload" href="#vipy.util.dirload">dirload</a></code></li>
<li><code><a title="vipy.util.dividelist" href="#vipy.util.dividelist">dividelist</a></code></li>
<li><code><a title="vipy.util.env" href="#vipy.util.env">env</a></code></li>
<li><code><a title="vipy.util.escape_string_for_innerHTML" href="#vipy.util.escape_string_for_innerHTML">escape_string_for_innerHTML</a></code></li>
<li><code><a title="vipy.util.extlist" href="#vipy.util.extlist">extlist</a></code></li>
<li><code><a title="vipy.util.filebase" href="#vipy.util.filebase">filebase</a></code></li>
<li><code><a title="vipy.util.fileext" href="#vipy.util.fileext">fileext</a></code></li>
<li><code><a title="vipy.util.filefull" href="#vipy.util.filefull">filefull</a></code></li>
<li><code><a title="vipy.util.filepath" href="#vipy.util.filepath">filepath</a></code></li>
<li><code><a title="vipy.util.filetail" href="#vipy.util.filetail">filetail</a></code></li>
<li><code><a title="vipy.util.findimage" href="#vipy.util.findimage">findimage</a></code></li>
<li><code><a title="vipy.util.findimages" href="#vipy.util.findimages">findimages</a></code></li>
<li><code><a title="vipy.util.findjpg" href="#vipy.util.findjpg">findjpg</a></code></li>
<li><code><a title="vipy.util.findjson" href="#vipy.util.findjson">findjson</a></code></li>
<li><code><a title="vipy.util.findloadable" href="#vipy.util.findloadable">findloadable</a></code></li>
<li><code><a title="vipy.util.findpdf" href="#vipy.util.findpdf">findpdf</a></code></li>
<li><code><a title="vipy.util.findpickle" href="#vipy.util.findpickle">findpickle</a></code></li>
<li><code><a title="vipy.util.findpkl" href="#vipy.util.findpkl">findpkl</a></code></li>
<li><code><a title="vipy.util.findpklbz2" href="#vipy.util.findpklbz2">findpklbz2</a></code></li>
<li><code><a title="vipy.util.findpng" href="#vipy.util.findpng">findpng</a></code></li>
<li><code><a title="vipy.util.findtar" href="#vipy.util.findtar">findtar</a></code></li>
<li><code><a title="vipy.util.findtargz" href="#vipy.util.findtargz">findtargz</a></code></li>
<li><code><a title="vipy.util.findtxt" href="#vipy.util.findtxt">findtxt</a></code></li>
<li><code><a title="vipy.util.findvideo" href="#vipy.util.findvideo">findvideo</a></code></li>
<li><code><a title="vipy.util.findvideos" href="#vipy.util.findvideos">findvideos</a></code></li>
<li><code><a title="vipy.util.findwebp" href="#vipy.util.findwebp">findwebp</a></code></li>
<li><code><a title="vipy.util.findxml" href="#vipy.util.findxml">findxml</a></code></li>
<li><code><a title="vipy.util.findyaml" href="#vipy.util.findyaml">findyaml</a></code></li>
<li><code><a title="vipy.util.flatlist" href="#vipy.util.flatlist">flatlist</a></code></li>
<li><code><a title="vipy.util.gray2bgr" href="#vipy.util.gray2bgr">gray2bgr</a></code></li>
<li><code><a title="vipy.util.gray2hsv" href="#vipy.util.gray2hsv">gray2hsv</a></code></li>
<li><code><a title="vipy.util.gray2jet" href="#vipy.util.gray2jet">gray2jet</a></code></li>
<li><code><a title="vipy.util.gray2rgb" href="#vipy.util.gray2rgb">gray2rgb</a></code></li>
<li><code><a title="vipy.util.groupby" href="#vipy.util.groupby">groupby</a></code></li>
<li><code><a title="vipy.util.groupbyasdict" href="#vipy.util.groupbyasdict">groupbyasdict</a></code></li>
<li><code><a title="vipy.util.has_image_extension" href="#vipy.util.has_image_extension">has_image_extension</a></code></li>
<li><code><a title="vipy.util.hascache" href="#vipy.util.hascache">hascache</a></code></li>
<li><code><a title="vipy.util.hasextension" href="#vipy.util.hasextension">hasextension</a></code></li>
<li><code><a title="vipy.util.imcrop" href="#vipy.util.imcrop">imcrop</a></code></li>
<li><code><a title="vipy.util.imlist" href="#vipy.util.imlist">imlist</a></code></li>
<li><code><a title="vipy.util.imlistidx" href="#vipy.util.imlistidx">imlistidx</a></code></li>
<li><code><a title="vipy.util.imread" href="#vipy.util.imread">imread</a></code></li>
<li><code><a title="vipy.util.imrescale" href="#vipy.util.imrescale">imrescale</a></code></li>
<li><code><a title="vipy.util.imresize" href="#vipy.util.imresize">imresize</a></code></li>
<li><code><a title="vipy.util.imsavelist" href="#vipy.util.imsavelist">imsavelist</a></code></li>
<li><code><a title="vipy.util.imwrite" href="#vipy.util.imwrite">imwrite</a></code></li>
<li><code><a title="vipy.util.imwritegray" href="#vipy.util.imwritegray">imwritegray</a></code></li>
<li><code><a title="vipy.util.imwritejet" href="#vipy.util.imwritejet">imwritejet</a></code></li>
<li><code><a title="vipy.util.isRTMPurl" href="#vipy.util.isRTMPurl">isRTMPurl</a></code></li>
<li><code><a title="vipy.util.isRTSPurl" href="#vipy.util.isRTSPurl">isRTSPurl</a></code></li>
<li><code><a title="vipy.util.isS3url" href="#vipy.util.isS3url">isS3url</a></code></li>
<li><code><a title="vipy.util.is_email_address" href="#vipy.util.is_email_address">is_email_address</a></code></li>
<li><code><a title="vipy.util.is_hiddenfile" href="#vipy.util.is_hiddenfile">is_hiddenfile</a></code></li>
<li><code><a title="vipy.util.is_jsonable" href="#vipy.util.is_jsonable">is_jsonable</a></code></li>
<li><code><a title="vipy.util.is_pkl_gz" href="#vipy.util.is_pkl_gz">is_pkl_gz</a></code></li>
<li><code><a title="vipy.util.is_rtmp_url" href="#vipy.util.is_rtmp_url">is_rtmp_url</a></code></li>
<li><code><a title="vipy.util.isarchive" href="#vipy.util.isarchive">isarchive</a></code></li>
<li><code><a title="vipy.util.iscsv" href="#vipy.util.iscsv">iscsv</a></code></li>
<li><code><a title="vipy.util.isexe" href="#vipy.util.isexe">isexe</a></code></li>
<li><code><a title="vipy.util.isextension" href="#vipy.util.isextension">isextension</a></code></li>
<li><code><a title="vipy.util.isfile" href="#vipy.util.isfile">isfile</a></code></li>
<li><code><a title="vipy.util.isfloat" href="#vipy.util.isfloat">isfloat</a></code></li>
<li><code><a title="vipy.util.isgif" href="#vipy.util.isgif">isgif</a></code></li>
<li><code><a title="vipy.util.ishdf5" href="#vipy.util.ishdf5">ishdf5</a></code></li>
<li><code><a title="vipy.util.ishtml" href="#vipy.util.ishtml">ishtml</a></code></li>
<li><code><a title="vipy.util.isimage" href="#vipy.util.isimage">isimage</a></code></li>
<li><code><a title="vipy.util.isimagefile" href="#vipy.util.isimagefile">isimagefile</a></code></li>
<li><code><a title="vipy.util.isimageobject" href="#vipy.util.isimageobject">isimageobject</a></code></li>
<li><code><a title="vipy.util.isimageurl" href="#vipy.util.isimageurl">isimageurl</a></code></li>
<li><code><a title="vipy.util.isimg" href="#vipy.util.isimg">isimg</a></code></li>
<li><code><a title="vipy.util.isimgfile" href="#vipy.util.isimgfile">isimgfile</a></code></li>
<li><code><a title="vipy.util.isinstalled" href="#vipy.util.isinstalled">isinstalled</a></code></li>
<li><code><a title="vipy.util.isjpeg" href="#vipy.util.isjpeg">isjpeg</a></code></li>
<li><code><a title="vipy.util.isjpg" href="#vipy.util.isjpg">isjpg</a></code></li>
<li><code><a title="vipy.util.isjsonfile" href="#vipy.util.isjsonfile">isjsonfile</a></code></li>
<li><code><a title="vipy.util.islinux" href="#vipy.util.islinux">islinux</a></code></li>
<li><code><a title="vipy.util.islist" href="#vipy.util.islist">islist</a></code></li>
<li><code><a title="vipy.util.islistoflists" href="#vipy.util.islistoflists">islistoflists</a></code></li>
<li><code><a title="vipy.util.ismacosx" href="#vipy.util.ismacosx">ismacosx</a></code></li>
<li><code><a title="vipy.util.isnumber" href="#vipy.util.isnumber">isnumber</a></code></li>
<li><code><a title="vipy.util.isnumpy" href="#vipy.util.isnumpy">isnumpy</a></code></li>
<li><code><a title="vipy.util.isnumpyarray" href="#vipy.util.isnumpyarray">isnumpyarray</a></code></li>
<li><code><a title="vipy.util.ispickle" href="#vipy.util.ispickle">ispickle</a></code></li>
<li><code><a title="vipy.util.ispkl" href="#vipy.util.ispkl">ispkl</a></code></li>
<li><code><a title="vipy.util.ispklbz2" href="#vipy.util.ispklbz2">ispklbz2</a></code></li>
<li><code><a title="vipy.util.ispklfile" href="#vipy.util.ispklfile">ispklfile</a></code></li>
<li><code><a title="vipy.util.ispng" href="#vipy.util.ispng">ispng</a></code></li>
<li><code><a title="vipy.util.isstring" href="#vipy.util.isstring">isstring</a></code></li>
<li><code><a title="vipy.util.istar" href="#vipy.util.istar">istar</a></code></li>
<li><code><a title="vipy.util.istarbz2" href="#vipy.util.istarbz2">istarbz2</a></code></li>
<li><code><a title="vipy.util.istextfile" href="#vipy.util.istextfile">istextfile</a></code></li>
<li><code><a title="vipy.util.istgz" href="#vipy.util.istgz">istgz</a></code></li>
<li><code><a title="vipy.util.istupleoftuples" href="#vipy.util.istupleoftuples">istupleoftuples</a></code></li>
<li><code><a title="vipy.util.isuint8" href="#vipy.util.isuint8">isuint8</a></code></li>
<li><code><a title="vipy.util.isurl" href="#vipy.util.isurl">isurl</a></code></li>
<li><code><a title="vipy.util.isvideo" href="#vipy.util.isvideo">isvideo</a></code></li>
<li><code><a title="vipy.util.isvideofile" href="#vipy.util.isvideofile">isvideofile</a></code></li>
<li><code><a title="vipy.util.isvideoobject" href="#vipy.util.isvideoobject">isvideoobject</a></code></li>
<li><code><a title="vipy.util.isvideotype" href="#vipy.util.isvideotype">isvideotype</a></code></li>
<li><code><a title="vipy.util.isvideourl" href="#vipy.util.isvideourl">isvideourl</a></code></li>
<li><code><a title="vipy.util.isvipyobject" href="#vipy.util.isvipyobject">isvipyobject</a></code></li>
<li><code><a title="vipy.util.iswebp" href="#vipy.util.iswebp">iswebp</a></code></li>
<li><code><a title="vipy.util.isxml" href="#vipy.util.isxml">isxml</a></code></li>
<li><code><a title="vipy.util.isyoutubeurl" href="#vipy.util.isyoutubeurl">isyoutubeurl</a></code></li>
<li><code><a title="vipy.util.jet" href="#vipy.util.jet">jet</a></code></li>
<li><code><a title="vipy.util.jsonlist" href="#vipy.util.jsonlist">jsonlist</a></code></li>
<li><code><a title="vipy.util.keymax" href="#vipy.util.keymax">keymax</a></code></li>
<li><code><a title="vipy.util.keymin" href="#vipy.util.keymin">keymin</a></code></li>
<li><code><a title="vipy.util.listext" href="#vipy.util.listext">listext</a></code></li>
<li><code><a title="vipy.util.listjson" href="#vipy.util.listjson">listjson</a></code></li>
<li><code><a title="vipy.util.listpkl" href="#vipy.util.listpkl">listpkl</a></code></li>
<li><code><a title="vipy.util.load" href="#vipy.util.load">load</a></code></li>
<li><code><a title="vipy.util.load_opencv_yaml" href="#vipy.util.load_opencv_yaml">load_opencv_yaml</a></code></li>
<li><code><a title="vipy.util.loadh5" href="#vipy.util.loadh5">loadh5</a></code></li>
<li><code><a title="vipy.util.loadmat73" href="#vipy.util.loadmat73">loadmat73</a></code></li>
<li><code><a title="vipy.util.mat2gray" href="#vipy.util.mat2gray">mat2gray</a></code></li>
<li><code><a title="vipy.util.matread" href="#vipy.util.matread">matread</a></code></li>
<li><code><a title="vipy.util.matrix_to_opencv_yaml" href="#vipy.util.matrix_to_opencv_yaml">matrix_to_opencv_yaml</a></code></li>
<li><code><a title="vipy.util.mdlist" href="#vipy.util.mdlist">mdlist</a></code></li>
<li><code><a title="vipy.util.mediaextension" href="#vipy.util.mediaextension">mediaextension</a></code></li>
<li><code><a title="vipy.util.mergedict" href="#vipy.util.mergedict">mergedict</a></code></li>
<li><code><a title="vipy.util.minutestamp" href="#vipy.util.minutestamp">minutestamp</a></code></li>
<li><code><a title="vipy.util.mktemp" href="#vipy.util.mktemp">mktemp</a></code></li>
<li><code><a title="vipy.util.most_frequent" href="#vipy.util.most_frequent">most_frequent</a></code></li>
<li><code><a title="vipy.util.newbase" href="#vipy.util.newbase">newbase</a></code></li>
<li><code><a title="vipy.util.newpath" href="#vipy.util.newpath">newpath</a></code></li>
<li><code><a title="vipy.util.newpathdir" href="#vipy.util.newpathdir">newpathdir</a></code></li>
<li><code><a title="vipy.util.newpathroot" href="#vipy.util.newpathroot">newpathroot</a></code></li>
<li><code><a title="vipy.util.newprefix" href="#vipy.util.newprefix">newprefix</a></code></li>
<li><code><a title="vipy.util.noextension" href="#vipy.util.noextension">noextension</a></code></li>
<li><code><a title="vipy.util.pairwise" href="#vipy.util.pairwise">pairwise</a></code></li>
<li><code><a title="vipy.util.permutelist" href="#vipy.util.permutelist">permutelist</a></code></li>
<li><code><a title="vipy.util.pklbz2" href="#vipy.util.pklbz2">pklbz2</a></code></li>
<li><code><a title="vipy.util.pklist" href="#vipy.util.pklist">pklist</a></code></li>
<li><code><a title="vipy.util.premkdir" href="#vipy.util.premkdir">premkdir</a></code></li>
<li><code><a title="vipy.util.print_and_return" href="#vipy.util.print_and_return">print_and_return</a></code></li>
<li><code><a title="vipy.util.readcsv" href="#vipy.util.readcsv">readcsv</a></code></li>
<li><code><a title="vipy.util.readcsvwithheader" href="#vipy.util.readcsvwithheader">readcsvwithheader</a></code></li>
<li><code><a title="vipy.util.readjson" href="#vipy.util.readjson">readjson</a></code></li>
<li><code><a title="vipy.util.readlist" href="#vipy.util.readlist">readlist</a></code></li>
<li><code><a title="vipy.util.readtxt" href="#vipy.util.readtxt">readtxt</a></code></li>
<li><code><a title="vipy.util.readyaml" href="#vipy.util.readyaml">readyaml</a></code></li>
<li><code><a title="vipy.util.remkdir" href="#vipy.util.remkdir">remkdir</a></code></li>
<li><code><a title="vipy.util.repath" href="#vipy.util.repath">repath</a></code></li>
<li><code><a title="vipy.util.rermdir" href="#vipy.util.rermdir">rermdir</a></code></li>
<li><code><a title="vipy.util.rgb2bgr" href="#vipy.util.rgb2bgr">rgb2bgr</a></code></li>
<li><code><a title="vipy.util.rmdir" href="#vipy.util.rmdir">rmdir</a></code></li>
<li><code><a title="vipy.util.save" href="#vipy.util.save">save</a></code></li>
<li><code><a title="vipy.util.save_opencv_yaml" href="#vipy.util.save_opencv_yaml">save_opencv_yaml</a></code></li>
<li><code><a title="vipy.util.savetemp" href="#vipy.util.savetemp">savetemp</a></code></li>
<li><code><a title="vipy.util.scpload" href="#vipy.util.scpload">scpload</a></code></li>
<li><code><a title="vipy.util.scpsave" href="#vipy.util.scpsave">scpsave</a></code></li>
<li><code><a title="vipy.util.seconds_to_MMSS_colon_notation" href="#vipy.util.seconds_to_MMSS_colon_notation">seconds_to_MMSS_colon_notation</a></code></li>
<li><code><a title="vipy.util.seq" href="#vipy.util.seq">seq</a></code></li>
<li><code><a title="vipy.util.shortuuid" href="#vipy.util.shortuuid">shortuuid</a></code></li>
<li><code><a title="vipy.util.shufflelist" href="#vipy.util.shufflelist">shufflelist</a></code></li>
<li><code><a title="vipy.util.singletonlist" href="#vipy.util.singletonlist">singletonlist</a></code></li>
<li><code><a title="vipy.util.softmax" href="#vipy.util.softmax">softmax</a></code></li>
<li><code><a title="vipy.util.splitext" href="#vipy.util.splitext">splitext</a></code></li>
<li><code><a title="vipy.util.string_to_pil_interpolation" href="#vipy.util.string_to_pil_interpolation">string_to_pil_interpolation</a></code></li>
<li><code><a title="vipy.util.stringhash" href="#vipy.util.stringhash">stringhash</a></code></li>
<li><code><a title="vipy.util.sumby" href="#vipy.util.sumby">sumby</a></code></li>
<li><code><a title="vipy.util.symlink" href="#vipy.util.symlink">symlink</a></code></li>
<li><code><a title="vipy.util.take" href="#vipy.util.take">take</a></code></li>
<li><code><a title="vipy.util.takelast" href="#vipy.util.takelast">takelast</a></code></li>
<li><code><a title="vipy.util.takeone" href="#vipy.util.takeone">takeone</a></code></li>
<li><code><a title="vipy.util.tempMP4" href="#vipy.util.tempMP4">tempMP4</a></code></li>
<li><code><a title="vipy.util.tempWEBP" href="#vipy.util.tempWEBP">tempWEBP</a></code></li>
<li><code><a title="vipy.util.tempcsv" href="#vipy.util.tempcsv">tempcsv</a></code></li>
<li><code><a title="vipy.util.tempdir" href="#vipy.util.tempdir">tempdir</a></code></li>
<li><code><a title="vipy.util.tempfilename" href="#vipy.util.tempfilename">tempfilename</a></code></li>
<li><code><a title="vipy.util.temphtml" href="#vipy.util.temphtml">temphtml</a></code></li>
<li><code><a title="vipy.util.tempimage" href="#vipy.util.tempimage">tempimage</a></code></li>
<li><code><a title="vipy.util.tempjpg" href="#vipy.util.tempjpg">tempjpg</a></code></li>
<li><code><a title="vipy.util.tempjson" href="#vipy.util.tempjson">tempjson</a></code></li>
<li><code><a title="vipy.util.templike" href="#vipy.util.templike">templike</a></code></li>
<li><code><a title="vipy.util.temppdf" href="#vipy.util.temppdf">temppdf</a></code></li>
<li><code><a title="vipy.util.temppickle" href="#vipy.util.temppickle">temppickle</a></code></li>
<li><code><a title="vipy.util.temppkl" href="#vipy.util.temppkl">temppkl</a></code></li>
<li><code><a title="vipy.util.temppklbz2" href="#vipy.util.temppklbz2">temppklbz2</a></code></li>
<li><code><a title="vipy.util.temppng" href="#vipy.util.temppng">temppng</a></code></li>
<li><code><a title="vipy.util.tempyaml" href="#vipy.util.tempyaml">tempyaml</a></code></li>
<li><code><a title="vipy.util.timestamp" href="#vipy.util.timestamp">timestamp</a></code></li>
<li><code><a title="vipy.util.tmpjpg" href="#vipy.util.tmpjpg">tmpjpg</a></code></li>
<li><code><a title="vipy.util.to_iterable" href="#vipy.util.to_iterable">to_iterable</a></code></li>
<li><code><a title="vipy.util.tocache" href="#vipy.util.tocache">tocache</a></code></li>
<li><code><a title="vipy.util.toextension" href="#vipy.util.toextension">toextension</a></code></li>
<li><code><a title="vipy.util.tofilename" href="#vipy.util.tofilename">tofilename</a></code></li>
<li><code><a title="vipy.util.tolist" href="#vipy.util.tolist">tolist</a></code></li>
<li><code><a title="vipy.util.tolist_or_singleton" href="#vipy.util.tolist_or_singleton">tolist_or_singleton</a></code></li>
<li><code><a title="vipy.util.topath" href="#vipy.util.topath">topath</a></code></li>
<li><code><a title="vipy.util.topkl" href="#vipy.util.topkl">topkl</a></code></li>
<li><code><a title="vipy.util.toset" href="#vipy.util.toset">toset</a></code></li>
<li><code><a title="vipy.util.totempdir" href="#vipy.util.totempdir">totempdir</a></code></li>
<li><code><a title="vipy.util.totuple" href="#vipy.util.totuple">totuple</a></code></li>
<li><code><a title="vipy.util.touch" href="#vipy.util.touch">touch</a></code></li>
<li><code><a title="vipy.util.triplets" href="#vipy.util.triplets">triplets</a></code></li>
<li><code><a title="vipy.util.truncate_string" href="#vipy.util.truncate_string">truncate_string</a></code></li>
<li><code><a title="vipy.util.try_import" href="#vipy.util.try_import">try_import</a></code></li>
<li><code><a title="vipy.util.tryjson" href="#vipy.util.tryjson">tryjson</a></code></li>
<li><code><a title="vipy.util.tryload" href="#vipy.util.tryload">tryload</a></code></li>
<li><code><a title="vipy.util.txtlist" href="#vipy.util.txtlist">txtlist</a></code></li>
<li><code><a title="vipy.util.videolist" href="#vipy.util.videolist">videolist</a></code></li>
<li><code><a title="vipy.util.vipy_groupby" href="#vipy.util.vipy_groupby">vipy_groupby</a></code></li>
<li><code><a title="vipy.util.writecsv" href="#vipy.util.writecsv">writecsv</a></code></li>
<li><code><a title="vipy.util.writejson" href="#vipy.util.writejson">writejson</a></code></li>
<li><code><a title="vipy.util.writelist" href="#vipy.util.writelist">writelist</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="vipy.util.Failed" href="#vipy.util.Failed">Failed</a></code></h4>
</li>
<li>
<h4><code><a title="vipy.util.Stopwatch" href="#vipy.util.Stopwatch">Stopwatch</a></code></h4>
<ul class="">
<li><code><a title="vipy.util.Stopwatch.duration" href="#vipy.util.Stopwatch.duration">duration</a></code></li>
<li><code><a title="vipy.util.Stopwatch.reset" href="#vipy.util.Stopwatch.reset">reset</a></code></li>
<li><code><a title="vipy.util.Stopwatch.since" href="#vipy.util.Stopwatch.since">since</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vipy.util.Timer" href="#vipy.util.Timer">Timer</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
