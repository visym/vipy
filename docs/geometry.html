<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.6" />
<meta name="google-site-verification" content="aB8LkQegj94_TJPdrcJm2ldIRWyXY82Jp24Gtkdgyn0" />
<title>vipy.geometry API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vipy.geometry</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L1-L1309" class="git-link">Browse git</a>
</summary>
<pre><code class="python">import math
import numpy as np
from itertools import product
from vipy.util import try_import, isnumpy, isnumber, tolist
from vipy.linalg import columnvector

try:
    import ujson as json  # faster
except ImportError:
    import json


def covariance_to_ellipse(cov):
    &#34;&#34;&#34;2x2 covariance matrix to ellipse (major_axis_length, minor_axis_length, angle_in_radians)&#34;&#34;&#34;
    assert isnumpy(cov) and cov.shape == (2,2), &#34;Invalid input&#34;
    (d,V) = np.linalg.eig(cov)
    return np.array((d[0], d[1], math.atan2(V[1,0], V[0,0])))  # (major_axis_len, minor_axis_len, angle_in_radians)


def dehomogenize(p):
    &#34;&#34;&#34;Convert 3x1 homogenous point (x,y,h) to 2x1 non-homogenous point (x/h, y/h)&#34;&#34;&#34;
    assert isnumpy(p)    
    if p.ndim == 1:
        assert len(p) == 3
        return p[0:2] / p[2]
    elif p.ndim == 2:
        assert isnumpy(p) and p.shape[0] == 3, &#34;Invalid input&#34;
        p = columnvector(p) if p.ndim == 1 else p
        return p[0:-1, :] / p[-1,:]
    else:
        return ValueError(&#39;p must be 1d or 2d&#39;)
    

def homogenize(p):
    &#34;&#34;&#34;Convert 2xN non-homogenous points (x,y) to 3xN non-homogenous point (x, y, 1)&#34;&#34;&#34;
    assert isnumpy(p)
    if p.ndim == 1:
        return np.hstack( (p, 1) )
    elif p.ndim == 2:
        assert p.shape[0] == 2, &#34;Invalid input&#34;
        p = columnvector(p) if p.ndim == 1 else p
        return np.vstack((p, np.ones_like(p[-1])))
    else:
        return ValueError(&#39;p must be 1d or 2d&#39;)


def apply_homography(H,p):
    &#34;&#34;&#34;Apply a 3x3 homography H to non-homogenous point p and return a transformed point &#34;&#34;&#34;
    assert isnumpy(H) and isnumpy(p) and H.shape == (3,3) and p.shape[0] == 2, &#34;Invalid input&#34;
    return dehomogenize(np.dot(H, homogenize(p)))


def similarity_transform_2x3(c=(0,0), r=0, s=1):
    &#34;&#34;&#34;Return a 2x3 similarity transform with rotation r (radians), scale s and origin c=(x,y)&#34;&#34;&#34;
    assert isinstance(c, tuple) and len(c) == 2 and isnumber(r) and isnumber(s), &#34;Invalid input&#34;
    deg = r * 180. / math.pi
    a = s * np.cos(r)
    b = s * np.sin(r)
    (x,y) = (c[0], c[1])
    return np.array([[a, b, (1 - a) * x - b * y], [-b, a, b * x + (1 - a) * y]])


def similarity_transform(txy=(0,0), r=0, s=1):
    &#34;&#34;&#34;Return a 3x3 similarity transformation with translation tuple txy=(x,y), rotation r (radians, scale=s&#34;&#34;&#34;
    assert isinstance(txy, tuple) and len(txy) == 2 and isnumber(r) and isnumber(s), &#34;Invalid input&#34;
    R = np.asarray([[np.cos(r), -np.sin(r), 0], [np.sin(r), np.cos(r), 0], [0,0,1]])
    S = np.asarray([[s,0,0], [0, s, 0], [0,0,1]])
    T = np.asarray([[0,0,txy[0]], [0,0,txy[1]], [0,0,0]])
    return S * R + T  # composition


def affine_transform(txy=(0,0), r=0, sx=1, sy=1, kx=0, ky=0):
    &#34;&#34;&#34;Compose and return a 3x3 affine transformation for translation txy=(0,0), rotation r (radians), scalex=sx, scaley=sy, shearx=kx, sheary=ky.
    
    Usage:
    
    ```python
    A = vipy.geometry.affine_transform(r=np.pi/4)
    vipy.image.Image(array=vipy.geometry.imtransform(im.array(), A), colorspace=&#39;float&#39;)
    ```
    
    Equivalently:

    ```python
    im = vipy.image.RandomImage().affine_transform(A)    
    ```
    
    &#34;&#34;&#34;
    assert isinstance(txy, tuple) and len(txy) == 2 and isnumber(r) and isnumber(sx) and isnumber(sy) and isnumber(kx) and isnumber(ky), &#34;Invalid input&#34;
    R = np.asarray([[np.cos(r), -np.sin(r), 0], [np.sin(r), np.cos(r), 0], [0,0,1]])
    S = np.asarray([[sx,0,0], [0, sy, 0], [0,0,1]])
    K = np.asarray([[1,ky,0], [kx,1,0], [0,0,1]])
    T = np.asarray([[0,0,txy[0]], [0,0,txy[1]], [0,0,0]])
    return K * S * R + T  # composition


def random_affine_transform(txy=((0,1),(0,1)), r=(0,1), sx=(0.1,1), sy=(0.1,1), kx=(0.1,1), ky=(0.1,1)):
    &#34;&#34;&#34;Return a random 3x3 affine transformation matrix for the provided ranges, inputs must be tuples&#34;&#34;&#34;
    assert isinstance(txy, tuple) and isinstance(txy[0], tuple) and isinstance(txy[1], tuple) and isinstance(r, tuple) and isinstance(sx, tuple) and isinstance(sy, tuple) and isinstance(kx, tuple) and isinstance(ky, tuple), &#34;Invalid input&#34;
    uniform_random_in_range = lambda t: np.random.uniform(t[0], t[1])
    return affine_transform(txy=(uniform_random_in_range(txy[0]), uniform_random_in_range(txy[1])),
                            r=uniform_random_in_range(r),
                            sx=uniform_random_in_range(sx),
                            sy=uniform_random_in_range(sy),
                            kx=uniform_random_in_range(kx),
                            ky=uniform_random_in_range(ky))


def imtransform(img, A, border=&#39;zero&#39;):
    &#34;&#34;&#34;Transform an numpy array image (MxNx3) following the affine or similiarity transformation A&#34;&#34;&#34;
    assert isnumpy(img) and isnumpy(A), &#34;invalid input&#34;
    assert border in [&#39;zero&#39;, &#39;replicate&#39;]
    try_import(&#39;cv2&#39;, &#39;opencv-python&#39;); import cv2
    borderMode = cv2.BORDER_REPLICATE if border==&#39;replicate&#39; else cv2.BORDER_CONSTANT
    if A.shape == (3,3):
        return cv2.warpPerspective(img, A, (img.shape[1], img.shape[0]), borderMode=borderMode)        
    else:
        return cv2.warpAffine(img, A, (img.shape[1], img.shape[0]), borderMode=borderMode)        



def normalize(x, eps=1E-16):
    &#34;&#34;&#34;Given a vector x, return the vector unit normalized as float64&#34;&#34;&#34;
    assert isnumpy(x), &#34;Invalid input&#34;
    return x / (np.linalg.norm(x.astype(np.float64)) + eps)

def imagebox(shape):
    return BoundingBox(xmin=0, ymin=0, width=shape[1], height=shape[0])



class BoundingBox():
    &#34;&#34;&#34;Core bounding box class with flexible constructors in this priority order:
          (xmin,ymin,xmax,ymax)
          (xmin,ymin,width,height)
          (centroid[0],centroid[1],width,height)
          (xcentroid,ycentroid,width,height)
          xywh=(xmin,ymin,width,height)
          ulbr=(xmin,ymin,xmax,ymax)
          bounding rectangle of binary mask image&#34;&#34;&#34;

    __slots__ = [&#39;_xmin&#39;, &#39;_ymin&#39;, &#39;_xmax&#39;, &#39;_ymax&#39;]        
    def __init__(self, xmin=None, ymin=None, xmax=None, ymax=None, centroid=None, xcentroid=None, ycentroid=None, width=None, height=None, mask=None, xywh=None, ulbr=None, ulbrdict=None):

        if ulbrdict is not None:
            self._xmin = ulbrdict[&#39;_xmin&#39;]
            self._ymin = ulbrdict[&#39;_ymin&#39;]
            self._xmax = ulbrdict[&#39;_xmax&#39;]
            self._ymax = ulbrdict[&#39;_ymax&#39;]                                  
        elif xmin is not None and ymin is not None and xmax is not None and ymax is not None:
            assert (isnumber(xmin) and isnumber(ymin) and isnumber(xmax) and isnumber(ymax)), &#39;Box coordinates must be integers or floats not &#34;%s&#34;&#39; % str(type(xmin))
            self._xmin = float(xmin)
            self._ymin = float(ymin)
            self._xmax = float(xmax)
            self._ymax = float(ymax)
        elif xmin is not None and ymin is not None and width is not None and height is not None:
            assert (isnumber(xmin) and isnumber(ymin) and isnumber(width) and isnumber(height)), &#39;Box coordinates must be integers or floats not &#34;%s&#34;&#39; % str(type(width))
            self._xmin = float(xmin)
            self._ymin = float(ymin)
            self._xmax = self._xmin + float(width)
            self._ymax = self._ymin + float(height)
        elif centroid is not None and width is not None and height is not None:
            assert (len(centroid) == 2 and isnumber(centroid[0]) and isnumber(centroid[1]) and isnumber(width) and isnumber(height)), &#39;Invalid box coordinates&#39;
            self._xmin = float(centroid[0]) - float(width) / 2.0
            self._ymin = float(centroid[1]) - float(height) / 2.0
            self._xmax = float(centroid[0]) + float(width) / 2.0
            self._ymax = float(centroid[1]) + float(height) / 2.0
        elif xcentroid is not None and ycentroid is not None and width is not None and height is not None:
            self._xmin = float(xcentroid) - (float(width) / 2.0)
            self._ymin = float(ycentroid) - (float(height) / 2.0)
            self._xmax = float(xcentroid) + (float(width) / 2.0)
            self._ymax = float(ycentroid) + (float(height) / 2.0)
        elif xywh is not None:
            self.xywh(xywh)
        elif ulbr is not None:
            self.ulbr(ulbr)
        elif mask is not None:
            # Bounding rectangle of non-zero pixels in a binary mask image
            if not isnumpy(mask) or np.sum(mask) == 0:
                raise ValueError(&#39;Mask input must be numpy array with at least one non-zero entry&#39;)
            imx = np.sum(mask, axis=0)
            imy = np.sum(mask, axis=1)
            self._xmin = np.argwhere(imx &gt; 0)[0]
            self._ymin = np.argwhere(imy &gt; 0)[0]
            self._xmax = np.argwhere(imx &gt; 0)[-1]
            self._ymax = np.argwhere(imy &gt; 0)[-1]
        else:
            raise ValueError(&#39;invalid constructor input&#39;)

    @classmethod
    def cast(cls, bb, flush=False):
        assert isinstance(bb, (BoundingBox, Point2d))
        bb = bb if isinstance(bb, BoundingBox) else bb.boundingbox()
        return cls(xywh=bb.xywh())
    
    @classmethod
    def from_json(cls, s):
        d = json.loads(s) if not isinstance(s, dict) else s
        d = {&#39;_&#39;+k if not k.startswith(&#39;_&#39;) else k:v for (k,v) in d.items()}  # from prettyjson (add &#34;_&#34; prefix to attributes)                
        return cls(ulbrdict=d)

    def dict(self):
        &#34;&#34;&#34;Return a python dictionary containing the relevant serialized attributes suitable for JSON encoding&#34;&#34;&#34;
        return self.json(encode=False)

    def __json__(self):
        &#34;&#34;&#34;Serialization method for json package&#34;&#34;&#34;
        return self.json(encode=True)
    
    def json(self, encode=True):
        d = {k.lstrip(&#39;_&#39;):getattr(self, k) for k in BoundingBox.__slots__}  # prettyjson (remove &#34;_&#34; prefix to attributes)        
        return json.dumps(d) if encode else d

    def clone(self):
        return BoundingBox(xmin=self._xmin, xmax=self._xmax, ymin=self._ymin, ymax=self._ymax)
    def bbclone(self):
        return BoundingBox(xmin=self._xmin, xmax=self._xmax, ymin=self._ymin, ymax=self._ymax)

    def __eq__(self, other):
        &#34;&#34;&#34;Bounding box equality (integer resolution of corners)&#34;&#34;&#34;
        return isinstance(other, BoundingBox) and self.clone().int().xywh() == other.clone().int().xywh()

    def __neq__(self, other):
        &#34;&#34;&#34;Bounding box non-equality&#34;&#34;&#34;
        return not self.__eq__(other)

    def __repr__(self):
        return str(&#39;&lt;vipy.geometry.BoundingBox: xmin=%s, ymin=%s, width=%s, height=%s&gt;&#39; % (self.xmin(), self.ymin(), self.width(), self.height()))

    def __str__(self):
        return self.__repr__()
    
    def xmin(self, x=None):
        &#34;&#34;&#34;x coordinate of upper left corner of box, x-axis is image column&#34;&#34;&#34;
        self._xmin = self._xmin if x is None else x
        return self._xmin if x is None else self

    def ul(self):
        &#34;&#34;&#34;Upper left coordinate (x,y)&#34;&#34;&#34;
        return (self._xmin, self._ymin)

    def ulx(self):
        &#34;&#34;&#34;Upper left coordinate (x)&#34;&#34;&#34;
        return self.ul()[0]

    def uly(self):
        &#34;&#34;&#34;Upper left coordinate (y)&#34;&#34;&#34;
        return self.ul()[1]

    def ur(self):
        &#34;&#34;&#34;Upper right coordinate (x,y)&#34;&#34;&#34;
        return (self._xmax, self._ymin)

    def urx(self):
        &#34;&#34;&#34;Upper right coordinate (x)&#34;&#34;&#34;
        return self.ur()[0]

    def ury(self):
        &#34;&#34;&#34;Upper right coordinate (y)&#34;&#34;&#34;
        return self.ur()[1]

    def ll(self):
        &#34;&#34;&#34;Lower left coordinate (x,y), synonym for bl()&#34;&#34;&#34;
        return (self._xmin, self._ymax)

    def bl(self):
        &#34;&#34;&#34;Bottom left coordinate (x,y), synonym for ll()&#34;&#34;&#34;
        return (self._xmin, self._ymax)

    def blx(self):
        &#34;&#34;&#34;Bottom left coordinate (x)&#34;&#34;&#34;
        return self.bl()[0]

    def bly(self):
        &#34;&#34;&#34;Bottom left coordinate (y)&#34;&#34;&#34;
        return self.bl()[1]

    def lr(self):
        &#34;&#34;&#34;Lower right coordinate (x,y), synonym for br()&#34;&#34;&#34;
        return (self._xmax, self._ymax)

    def br(self):
        &#34;&#34;&#34;Bottom right coordinate (x,y), synonym for lr()&#34;&#34;&#34;
        return (self._xmax, self._ymax)

    def brx(self):
        &#34;&#34;&#34;Bottom right coordinate (x)&#34;&#34;&#34;
        return self.br()[0]

    def bry(self):
        &#34;&#34;&#34;Bottom right coordinate (y)&#34;&#34;&#34;
        return self.br()[1]

    def ymin(self, y=None):
        &#34;&#34;&#34;y coordinate of upper left corner of box, y-axis is image row, set if provided&#34;&#34;&#34;
        self._ymin = self._ymin if y is None else y
        return self._ymin if y is None else self

    def xmax(self, x=None):
        &#34;&#34;&#34;x coordinate of lower right corner of box, x-axis is image column&#34;&#34;&#34;
        self._xmax = self._xmax if x is None else x
        return self._xmax if x is None else self

    def ymax(self, y=None):
        &#34;&#34;&#34;y coordinate of lower right corner of box, y-axis is image row&#34;&#34;&#34;
        self._ymax = self._ymax if y is None else y
        return self._ymax if y is None else self

    def upperleft(self):
        &#34;&#34;&#34;Return the (x,y) upper left corner coordinate of the box&#34;&#34;&#34;
        return (self.xmin(), self.ymin())

    def bottomleft(self):
        &#34;&#34;&#34;Return the (x,y) lower left corner coordinate of the box&#34;&#34;&#34;
        return (self.xmin(), self.ymax())

    def upperright(self):
        &#34;&#34;&#34;Return the (x,y) upper right corner coordinate of the box&#34;&#34;&#34;
        return (self.xmax(), self.ymin())

    def bottomright(self):
        &#34;&#34;&#34;Return the (x,y) lower right corner coordinate of the box&#34;&#34;&#34;
        return (self.xmax(), self.ymax())

    def isinteger(self):
        return (isinstance(self._xmin, int) and
                isinstance(self._ymin, int) and
                isinstance(self._xmax, int) and
                isinstance(self._ymax, int))
                
    def int(self):
        &#34;&#34;&#34;Convert corners to integer with rounding, in-place update&#34;&#34;&#34;
        (w,h) = (int(np.round(self.width())), int(np.round(self.height())))
        self._xmin = int(np.round(self._xmin))
        self._ymin = int(np.round(self._ymin))
        self._xmax = int(np.round(self._xmax))
        self._ymax = int(np.round(self._ymax))
        if w != self.width():
            self.right(w - self.width())  # preserve aspect ratio due to rounding by +/- right side of box 
        if h != self.height():
            self.bottom(h-self.height())  # preserve aspect ratio due to rounding by +/- bottom of box
        return self

    def float(self):
        &#34;&#34;&#34;Convert corners to float&#34;&#34;&#34;
        self._xmin = float(self._xmin)
        self._ymin = float(self._ymin)
        self._xmax = float(self._xmax)
        self._ymax = float(self._ymax)
        return self

    def significant_digits(self, n):
        &#34;&#34;&#34;Convert corners to have at most n significant digits for efficient JSON storage&#34;&#34;&#34;
        assert isinstance(n, int) and n&gt;=0
        self._xmin = round(self._xmin, n)
        self._ymin = round(self._ymin, n)
        self._xmax = round(self._xmax, n)
        self._ymax = round(self._ymax, n)
        return self
        
    def translate(self, dx=0, dy=0):
        &#34;&#34;&#34;Translate the bounding box by dx in x and dy in y&#34;&#34;&#34;
        self._xmin = self._xmin + dx
        self._ymin = self._ymin + dy
        self._xmax = self._xmax + dx
        self._ymax = self._ymax + dy
        return self

    def to_origin(self):
        &#34;&#34;&#34;Translate the bounding box so that (xmin, ymin) = (0,0)&#34;&#34;&#34;
        return self.translate(-self.xmin(), -self.ymin())
    
    def set_origin(self, other):
        &#34;&#34;&#34;Set the origin of the coordinates of this bounding box to be relative to the upper left of the other bounding box&#34;&#34;&#34;
        assert isinstance(other, BoundingBox), &#34;Invalid BoundingBox() input of type &#39;%s&#39;&#34; % str(type(other))
        return self.translate(other.xmin(), other.ymin())                
    
    def offset(self, dx=0, dy=0):
        &#34;&#34;&#34;Alias for translate&#34;&#34;&#34;
        return self.translate(dx, dy)

    def invalid(self):
        &#34;&#34;&#34;Is the box a valid bounding box?&#34;&#34;&#34;
        #is_undefined = np.isnan(self._xmin) or np.isnan(self._ymin) or np.isnan(self._xmax) or np.isnan(self._ymax)
        is_valid = ((self._xmax - self._xmin) &gt;= 0) and ((self._ymax - self._ymin) &gt;= 0)  # if nan, will return False
        return not is_valid

    def valid(self):
        return not self.invalid()

    def isvalid(self):
        return not self.invalid()

    def isdegenerate(self):
        return self.invalid()
        
    def isnonnegative(self):
        return (self.xmin() &gt;= 0 and
                self.ymin() &gt;= 0 and
                self.xmax() &gt;= 0 and
                self.ymax() &gt;= 0)

    def width(self):
        return self._xmax - self._xmin
    
    def setwidth(self, w):
        &#34;&#34;&#34;Set new width keeping centroid constant&#34;&#34;&#34;
        if w &lt;= 0:
            raise ValueError(&#39;invalid width&#39;)
        worig = (self._xmax - self._xmin)
        self._xmax += float((w - worig) / 2.0)
        self._xmin -= float((w - worig) / 2.0)
        return self

    def setheight(self, h):
        &#34;&#34;&#34;Set new height keeping centroid constant&#34;&#34;&#34;
        if h &lt;= 0:
            raise ValueError(&#39;invalid height&#39;)
        horig = self._ymax - self._ymin
        self._ymax += float((h - horig) / 2.0)
        self._ymin -= float((h - horig) / 2.0)
        return self

    def height(self):
        return self._ymax - self._ymin

    def centroid(self, c=None):
        &#34;&#34;&#34;(x,y) tuple of centroid position of bounding box&#34;&#34;&#34;        
        if c is None:
            (height, width) = (self._ymax-self._ymin, self._xmax-self._xmin)            
            return (self._xmin + (float(width) / 2.0), self._ymin + (float(height) / 2.0))
        else:
            assert len(c) == 2
            (height, width) = (self._ymax-self._ymin, self._xmax-self._xmin)
            self._xmin = float(c[0]) - (width / 2.0)
            self._ymin = float(c[1]) - (height / 2.0)
            self._xmax = float(c[0]) + (width / 2.0)
            self._ymax = float(c[1]) + (height / 2.0)
            return self
            
    def x_centroid(self):
        return self.centroid()[0]

    def xcentroid(self):
        &#34;&#34;&#34;Alias for x_centroid()&#34;&#34;&#34;
        return self.centroid()[0]
    def centroid_x(self):
        &#34;&#34;&#34;Alias for x_centroid()&#34;&#34;&#34;
        return self.centroid()[0]
            
    def y_centroid(self):
        return self.centroid()[1]

    def ycentroid(self):
        &#34;&#34;&#34;Alias for y_centroid()&#34;&#34;&#34;
        return self.centroid()[1]
    def centroid_y(self):
        &#34;&#34;&#34;Alias for y_centroid()&#34;&#34;&#34;
        return self.centroid()[1]
    
    def area(self):
        &#34;&#34;&#34;Return the area=width*height of the bounding box, internal method useful for multiple inheritance&#34;&#34;&#34;
        (height, width) = (self._ymax-self._ymin, self._xmax-self._xmin)        
        return width * height if (height&gt;0 and width&gt;0) else 0
    
    def to_xywh(self, xywh=None):
        &#34;&#34;&#34;Return bounding box corners as (x,y,width,height) tuple&#34;&#34;&#34;
        if xywh is None:
            (height, width) = (self._ymax-self._ymin, self._xmax-self._xmin)                    
            return tuple([self._xmin, self._ymin, width, height])
        else:
            assert len(xywh) == 4, &#34;Invalid (xmin,ymin,width,height) input&#34;
            self._xmin = float(xywh[0])
            self._ymin = float(xywh[1])
            self._xmax = float(self._xmin + xywh[2])
            self._ymax = float(self._ymin + xywh[3])
            return self

    def xywh(self, xywh_=None):
        &#34;&#34;&#34;Alias for to_xywh&#34;&#34;&#34;
        return self.to_xywh(xywh_)

    def cxywh(self, cxywh=None):
        &#34;&#34;&#34;Return or set bounding box corners as (centroidx,centroidy,width,height) tuple&#34;&#34;&#34;
        if cxywh is None:
            (height, width) = (self._ymax-self._ymin, self._xmax-self._xmin)                    
            return tuple([self.x_centroid(), self.y_centroid(), width, height])
        else:
            assert len(cxywh) == 4, &#34;Invalid (xcentroid, ycentroid, width, height) input&#34;
            return self.centroid( (cxywh[0], cxywh[1]) ).setwidth(cxywh[2]).setheight(cxywh[3])            
    
    def ulbr(self, ulbr=None):
        &#34;&#34;&#34;Return bounding box corners as upper left, bottom right (xmin, ymin, xmax, ymax)&#34;&#34;&#34;
        if ulbr is None:
            return (self._xmin, self._ymin, self._xmax, self._ymax)            
        else:
            assert len(ulbr) == 4, &#34;Invalid (xmin,ymin,xmax,ymax) input&#34;
            self._xmin = float(ulbr[0])
            self._ymin = float(ulbr[1])
            self._xmax = float(ulbr[2])
            self._ymax = float(ulbr[3])
            return self

    def to_ulbr(self, ulbr=None):
        &#34;&#34;&#34;Alias for ulbr()&#34;&#34;&#34;
        return self.ulbr(ulbr)
    
    def dx(self, bb):
        &#34;&#34;&#34;Offset bounding box by same xmin as provided box&#34;&#34;&#34;
        return bb._xmin - self._xmin

    def dy(self, bb):
        &#34;&#34;&#34;Offset bounding box by ymin of provided box&#34;&#34;&#34;
        return bb._ymin - self._ymin

    def sqdist(self, bb):
        &#34;&#34;&#34;Squared Euclidean distance between upper left corners of two bounding boxes&#34;&#34;&#34;
        assert isinstance(bb, BoundingBox), &#34;Invalid BoundingBox() input of type &#39;%s&#39;&#34; % str(type(bb))                
        return np.power(self.dx(bb), 2.0) + np.power(self.dy(bb), 2.0)

    def dist(self, bb):
        &#34;&#34;&#34;Distance between centroids of two bounding boxes&#34;&#34;&#34;
        assert isinstance(bb, BoundingBox), &#34;Invalid BoundingBox() input of type &#39;%s&#39;&#34; % str(type(bb))                
        return np.sqrt(np.sum(np.square(np.array(bb.centroid()) - np.array(self.centroid()))))

    def pdist(self, bb, sigma=None):
        &#34;&#34;&#34;Normalized Gaussian distance in [0,1] between centroids of two bounding boxes, where 0 is far and 1 is same with sigma=maxdim() of this box&#34;&#34;&#34;
        assert isinstance(bb, BoundingBox), &#34;Invalid BoundingBox() input of type &#39;%s&#39;&#34; % str(type(bb))
        return np.exp(-self.sqdist(bb)/(float(2*self.maxdim()*self.maxdim()) if sigma is None else float(2.0*sigma*sigma)))

    def iou(self, bb, area=None, otherarea=None):
        &#34;&#34;&#34;area of intersection / area of union&#34;&#34;&#34;
        assert bb is None or isinstance(bb, BoundingBox), &#34;Invalid BoundingBox() input of type &#39;%s&#39;&#34; % str(type(bb))        
        if bb is None:
            return 0
        w = min(self._xmax, bb._xmax) - max(self._xmin, bb._xmin)
        if w &lt;= 0:
            return 0  # invalid (no overlap), early exit
        h = min(self._ymax, bb._ymax) - max(self._ymin, bb._ymin)
        if h &lt;= 0:
            return 0  # invalid (no overlap), early exit

        area_intersection = w * h
        area_union = ((self.area() if area is None else area) +
                      (bb.area() if otherarea is None else otherarea) -
                      area_intersection)
        return (area_intersection / float(area_union)) if area_union &gt; 0 else 0

    def intersection_over_union(self, bb):
        &#34;&#34;&#34;Alias for iou&#34;&#34;&#34;
        return self.iou(bb)

    def area_of_intersection(self, bb, strict=True):
        &#34;&#34;&#34;area of intersection&#34;&#34;&#34;
        if strict:
            assert isinstance(bb, BoundingBox), &#34;Invalid BoundingBox() input of type &#39;%s&#39;&#34; % str(type(bb))                
        w = min(self._xmax, bb._xmax) - max(self._xmin, bb._xmin)
        if w &lt;= 0:
            return 0  # invalid (no overlap), early exit 
        h = min(self._ymax, bb._ymax) - max(self._ymin, bb._ymin)
        if h &lt;= 0:
            return 0  # invalid (no overlap), early exit 
        return w*h

    def area_of_union(self, bb):
        return self.area() + bb.area() - self.area_of_intersection(bb)
        
    def cover(self, bb):
        &#34;&#34;&#34;Fraction of this bounding box intersected by other bbox (bb).

        .. note:: 
        
            - Cover is often more useful than `vipy.geometry.BoundingBox.iou` as a measure of overlap due to bounding box distortion from partially occluded object proposals.  
            - For example, an object proposal of a person may generate a smaller box (e.g. just the torso) when the lower body is occluded whereas a track will have the full body box.  
            - `vipy.geometry.BoundingBox.maxcover` is a better measure of assignment in this case.  

        &#34;&#34;&#34;
        a = float(self.area())
        return (self.area_of_intersection(bb) / a) if a&gt;0 else 0

    def maxcover(self, bb, area=None, otherarea=None):
        &#34;&#34;&#34;The maximum cover of self to bb and bb to self&#34;&#34;&#34;
        aoi = self.area_of_intersection(bb, strict=False)
        (area, otherarea) = (self.area() if area is None else area, bb.area() if otherarea is None else otherarea)
        return float(max((aoi/area) if area&gt;0 else 0, (aoi/otherarea) if otherarea&gt;0 else 0))
    
    def shapeiou(self, bb, area=None, otherarea=None):
        &#34;&#34;&#34;Shape IoU is the IoU with the upper left corners aligned. This measures the deformation of the two boxes by removing the effect of translation&#34;&#34;&#34;
        #return self.iou(bb.clone().translate(dx=self._xmin-bb._xmin, dy=self._ymin-bb._ymin))  # equivalent to
        assert isinstance(bb, BoundingBox), &#34;Invalid input - must be BoundingBox()&#34;
        w = min(self._xmax, bb._xmax + (self._xmin-bb._xmin)) - max(self._xmin, bb._xmin + (self._xmin-bb._xmin))
        h = min(self._ymax, bb._ymax + (self._ymin-bb._ymin)) - max(self._ymin, bb._ymin + (self._ymin-bb._ymin))
        area_intersection = w * h
        area_union = ((self.area() if area is None else area) +
                      (bb.area() if otherarea is None else otherarea)
                      - area_intersection)
        return (area_intersection / float(area_union)) if area_union&gt;0 else 0
        
    def intersection(self, bb, strict=True):
        &#34;&#34;&#34;Intersection of two bounding boxes, throw an error on degeneracy of intersection result (if strict=True)&#34;&#34;&#34;
        assert isinstance(bb, BoundingBox), &#34;Invalid BoundingBox() input of type &#39;%s&#39;&#34; % str(type(bb))                        
        self._xmin = max(bb._xmin, self._xmin)
        self._ymin = max(bb._ymin, self._ymin)
        self._xmax = min(bb._xmax, self._xmax)
        self._ymax = min(bb._ymax, self._ymax)
        if strict and self.isdegenerate():
            raise ValueError(&#39;Degenerate intersection for bounding boxes &#34;%s&#34; and &#34;%s&#34;&#39; % (str(bb), str(self)))
        return self

    def hasintersection(self, bb, iou=None, cover=None, maxcover=None, bbcover=None, area=None, otherarea=None, gate=0):
        &#34;&#34;&#34;Return true if self and bb overlap by any amount, or by the cover threshold (if provided) or the iou threshold (if provided).  This is a convenience function that allows for shared computation for fast non-maximum suppression.&#34;&#34;&#34;

        if not (((self._xmax if self._xmax &lt; bb._xmax else bb._xmax) - (self._xmin if self._xmin &gt; bb._xmin else bb._xmin)) &gt; (-gate) and
                ((self._ymax if self._ymax &lt; bb._ymax else bb._ymax) - (self._ymin if self._ymin &gt; bb._ymin else bb._ymin)) &gt; (-gate)):  # faster than min(x,y)-max(x,y)
            return False  # does not intersect
        
        elif maxcover is not None or iou is not None or cover is not None or bbcover is not None:
            aoi = self.area_of_intersection(bb, strict=False)            
            otherarea = otherarea if otherarea is not None else (bb.area() if (maxcover is not None or bbcover is not None or iou is not None) else 0)
            area = area if area is not None else (self.area() if (maxcover is not None or cover is not None or iou is not None) else 0)
            return (((maxcover is not None) and (max(aoi/area, aoi/otherarea) &gt; maxcover)) or
                    ((iou is not None) and ((aoi / (area+otherarea-aoi)) &gt;= iou)) or
                    ((cover is not None) and ((aoi / area) &gt;= cover)) or
                    ((bbcover is not None) and ((aoi / otherarea) &gt;= bbcover)))
        else:
            return True

    def union(self, bb):
        &#34;&#34;&#34;Union of one or more bounding boxes with this box&#34;&#34;&#34;        
        bblist = tolist(bb)        
        assert all([isinstance(bb, BoundingBox) for bb in bblist]), &#34;Invalid BoundingBox() input&#34;
        self._xmin = min([bb._xmin for bb in bblist] + [self._xmin])
        self._ymin = min([bb._ymin for bb in bblist] + [self._ymin])
        self._xmax = max([bb._xmax for bb in bblist] + [self._xmax])
        self._ymax = max([bb._ymax for bb in bblist] + [self._ymax])
        return self

    def isinside(self, bb):
        &#34;&#34;&#34;Is this boundingbox fully within the provided bounding box?&#34;&#34;&#34;
        assert isinstance(bb, BoundingBox)
        return self.hasintersection(bb) and self.cover(bb) == 1.0
        
    def ispointinside(self, p):
        &#34;&#34;&#34;Is the 2D point p=(x,y) inside this boundingbox, or is the p=boundingbox() inside this bounding box?&#34;&#34;&#34;
        assert len(p) == 2, &#34;Invalid 2D point=(x,y) input&#34;
        return (p[0] &gt;= self._xmin) and (p[1] &gt;= self._ymin) and (p[0] &lt;= self._xmax) and (p[1] &lt;= self._ymax)

    def is_point_inside(self, p):
        &#34;&#34;&#34;synonym for `vipy.geometry.BoundingBox.ispointinside`&#34;&#34;&#34;
        return self.ispointinside(p)
    
    def dilate(self, scale=1):
        &#34;&#34;&#34;Change scale of bounding box keeping centroid constant&#34;&#34;&#34;
        assert isnumber(scale), &#34;Invalid input&#34;
        w = (self._xmax - self._xmin)
        h = (self._ymax - self._ymin)
        c = self.centroid()
        old_x = self._xmin
        old_y = self._ymin
        new_x = (float(w) / 2.0) * scale
        new_y = (float(h) / 2.0) * scale
        self._xmin = c[0] - new_x
        self._ymin = c[1] - new_y
        self._xmax = c[0] + new_x
        self._ymax = c[1] + new_y
        return self

    def dilatepx(self, px):
        &#34;&#34;&#34;Dilate by a given pixel amount on all sides, keeping centroid constant&#34;&#34;&#34;
        self._xmin = self._xmin - px
        self._ymin = self._ymin - px
        self._xmax = self._xmax + px
        self._ymax = self._ymax + px
        return self

    def dilate_height(self, scale=1):
        &#34;&#34;&#34;Change scale of bounding box in y direction keeping centroid constant&#34;&#34;&#34;
        h = self.height()
        c = self.centroid()
        self._ymin = c[1] - (float(h) / 2.0) * scale
        self._ymax = c[1] + (float(h) / 2.0) * scale
        return self

    def dilate_width(self, scale=1):
        &#34;&#34;&#34;Change scale of bounding box in x direction keeping centroid constant&#34;&#34;&#34;
        w = self._xmax - self._xmin
        c = self.centroid()
        self._xmin = c[0] - (float(w) / 2.0) * scale
        self._xmax = c[0] + (float(w) / 2.0) * scale
        return self

    def top(self, dy):
        &#34;&#34;&#34;Make top of box taller (closer to top of image) by an offset dy&#34;&#34;&#34;
        self._ymin = self._ymin - dy
        return self

    def bottom(self, dy):
        &#34;&#34;&#34;Make bottom of box taller (closer to bottom of image) by an offset dy&#34;&#34;&#34;
        self._ymax = self._ymax + dy
        return self

    def left(self, dx):
        &#34;&#34;&#34;Make left of box wider (closer to left side of image) by an offset dx&#34;&#34;&#34;
        self._xmin = self._xmin - dx
        return self

    def right(self, dx):
        &#34;&#34;&#34;Make right of box wider (closer to right side of image) by an offset dx&#34;&#34;&#34;
        self._xmax = self._xmax + dx
        return self

    def rescale(self, s):
        &#34;&#34;&#34;Multiply the box corners by a scale factor&#34;&#34;&#34;
        self._xmin = s * self._xmin
        self._ymin = s * self._ymin
        self._xmax = s * self._xmax
        self._ymax = s * self._ymax
        return self

    def scale_x(self, s):
        &#34;&#34;&#34;Multiply the box corners in the x dimension by a scale factor&#34;&#34;&#34;
        self._xmin = s * self._xmin
        self._xmax = s * self._xmax
        return self

    def scale_y(self, s):
        &#34;&#34;&#34;Multiply the box corners in the y dimension by a scale factor&#34;&#34;&#34;
        self._ymin = s * self._ymin
        self._ymax = s * self._ymax
        return self

    def resize(self, width, height):
        &#34;&#34;&#34;Change the aspect ratio width and height of the box&#34;&#34;&#34;
        self.setwidth(width)
        self.setheight(height)
        return self

    def rot90cw(self, H, W):
        &#34;&#34;&#34;Rotate a bounding box such that if an image of size (H,W) is rotated 90 deg clockwise, the boxes align&#34;&#34;&#34;
        (x,y,w,h) = self.xywh()
        (blx, bly) = self.bottomleft()
        return self.xywh((H - bly, blx, h, w))

    def rot90ccw(self, H, W):
        &#34;&#34;&#34;Rotate a bounding box such that if an image of size (H,W) is rotated 90 deg counter clockwise, the boxes align&#34;&#34;&#34;
        (x,y,w,h) = self.xywh()
        (urx, ury) = self.upperright()
        return self.xywh((ury, W - urx, h, w))

    def fliplr(self, img=None, width=None):
        &#34;&#34;&#34;Flip the box left/right consistent with fliplr of the provided img (or consistent with the image width)&#34;&#34;&#34;
        if img is not None:
            assert isnumpy(img), &#34;Invalid numpy image input&#34;
            width = img.shape[1]
        else:
            assert isnumber(width), &#34;Invalid width&#34;
        (x,y,w,h) = self.xywh()
        self._xmin = width - self._xmax
        self._xmax = self._xmin + w
        return self

    def flipud(self, img=None, height=None):
        &#34;&#34;&#34;Flip the box up/down consistent with flipud of the provided img (or consistent with the image height)&#34;&#34;&#34;
        if img is not None:
            assert isnumpy(img), &#34;Invalid numpy image input&#34;
            height = img.shape[0]
        else:
            assert height is not None and isnumber(height), &#34;Invalid height&#34;
        (x,y,w,h) = self.xywh()
        self._ymin = height - self._ymax
        self._ymax = self._ymin + h
        return self

    def imscale(self, im):
        &#34;&#34;&#34;Given a vipy.image object im, scale the box to be within [0,1], relative to height and width of image&#34;&#34;&#34;
        w = (1.0 / float(im.width()))
        h = (1.0 / float(im.height()))
        self._xmin = w * self._xmin
        self._ymin = h * self._ymin
        self._xmax = w * self._xmax
        self._ymax = h * self._ymax
        return self

    def maxsquare(self):
        &#34;&#34;&#34;Set the bounding box to be square by setting width and height to the maximum dimension of the box, keeping centroid constant&#34;&#34;&#34;
        (height, width) = (self._ymax-self._ymin, self._xmax-self._xmin)                            
        if width != height:
            dim = float(max(width, height))
            c = self.centroid()
            self._xmin = c[0] - (dim / 2.0)
            self._ymin = c[1] - (dim / 2.0)
            self._xmax = c[0] + (dim / 2.0)
            self._ymax = c[1] + (dim / 2.0)
        return self

    def issquare(self):
        return np.allclose(self.height(), self.width())

    def iseven(self):
        &#34;&#34;&#34;Are all corners even number integers?&#34;&#34;&#34;
        return (isinstance(self.xmin(), int) and self.xmin() % 2 == 0 and
                isinstance(self.ymin(), int) and self.ymin() % 2 == 0 and
                isinstance(self.xmax(), int) and self.xmax() % 2 == 0 and
                isinstance(self.ymax(), int) and self.ymax() % 2 == 0)

    def even(self):
        &#34;&#34;&#34;Force all corners to be even number integers.  This is helpful for FFMPEG crop filters.&#34;&#34;&#34;
        self.int()
        self._xmin = (self._xmin // 2) * 2
        self._ymin = (self._ymin // 2) * 2
        self._xmax = (self._xmax // 2) * 2
        self._ymax = (self._ymax // 2) * 2
        return self

    def minsquare(self):
        &#34;&#34;&#34;Set the bounding box to be square by setting width and height to the minimum dimension of the box, keeping centroid constant&#34;&#34;&#34;
        (height, width) = (self._ymax-self._ymin, self._xmax-self._xmin)                            
        if width != height:
            dim = float(min(width, height))
            c = self.centroid()
            self._xmin = c[0] - (dim / 2.0)
            self._ymin = c[1] - (dim / 2.0)
            self._xmax = c[0] + (dim / 2.0)
            self._ymax = c[1] + (dim / 2.0)
        return self

    def hasoverlap(self, img=None, width=None, height=None):
        &#34;&#34;&#34;Does the bounding box intersect with the provided image rectangle?&#34;&#34;&#34;
        if img is not None:
            assert isnumpy(img), &#34;Invalid image input&#34;
            (width, height) = (img.shape[1], img.shape[0])
        else:
            assert width is not None and height is not None, &#34;Invalid width and height - both must be provided&#34;
            assert isnumber(width) and isnumber(height), &#34;Invalid width and height - both must be numbers&#34;
        return self.area_of_intersection(BoundingBox(xmin=0, ymin=0, width=width, height=height)) &gt; 0

    def isinterior(self, width, height, border=1.0):
        &#34;&#34;&#34;Is this boundingbox fully within the provided image rectangle?  
        
           * If border in [0,1], then the image is dilated by a border percentage prior to computing interior, useful to check if self is near the image edge
           * If border=0.8, then the image rectangle is dilated by 80% (smaller) keeping the centroid constant. 
        &#34;&#34;&#34;
        assert border &gt; 0 and border &lt;= 1, &#34;Border must be a dilation fraction of the image, such that the image centroid is constant and the sides are dilated by a scale [0,1]&#34;
        return self.isinside(imagebox((height, width)).dilate(border))

    def iminterior(self, W, H):
        &#34;&#34;&#34;Transform bounding box to be interior to the image rectangle with shape (W,H).  
           Transform is applyed by computing smallest (dx,dy) translation that it is interior to the image rectangle, then clip to the image rectangle if it is too big to fit
        &#34;&#34;&#34;        
        assert self.intersection(BoundingBox(xmin=0, ymin=0, width=W, height=H)).area() &gt; 0, &#34;Bounding box must intersect image rectangle&#34;
        self.translate(dx=0 if self.xmin()&gt;0 else -self.xmin(),
                       dy=0 if self.ymin()&gt;0 else -self.ymin())
        self.translate(dx=0 if self.xmax()&lt;W else -(W-self.xmax()),
                       dy=0 if self.ymax()&lt;H else -(H-self.ymax()))
        return self.imclip(width=W, height=H)
        
    def imclip(self, img=None, width=None, height=None):
        &#34;&#34;&#34;Clip bounding box to image rectangle [0,0,width,height] or img.shape=(width, height) and, throw an exception on an invalid box&#34;&#34;&#34;
        if img is not None:
            assert isnumpy(img), &#34;Invalid numpy image input&#34;
            (height, width) = (img.shape[0], img.shape[1])
        else:
            assert width is not None and height is not None, &#34;Invalid width and height - both must be provided&#34;
            assert isnumber(width) and isnumber(height), &#34;Invalid width and height - both must be numbers&#34;
        return self.intersection(BoundingBox(xmin=0, ymin=0, width=width, height=height), strict=True)

    def imclipshape(self, W, H):
        &#34;&#34;&#34;Clip bounding box to image rectangle [0,0,W-1,H-1], throw an exception on an invalid box&#34;&#34;&#34;
        return self.imclip(width=W, height=H)

    def convexhull(self, fr):
        &#34;&#34;&#34;Given a set of points [[x1,y1],[x2,xy],...], return the bounding rectangle, typecast to float&#34;&#34;&#34;
        self._xmin = float(np.min(fr[:,0]))
        self._ymin = float(np.min(fr[:,1]))
        self._xmax = float(np.max(fr[:,0]))
        self._ymax = float(np.max(fr[:,1]))
        return self

    def aspectratio(self):
        &#34;&#34;&#34;Return the aspect ratio (width/height) of the box&#34;&#34;&#34;
        (height, width) = (self._ymax-self._ymin, self._xmax-self._xmin)                            
        assert height &gt; 0
        return float(width) / float(height)

    def shape(self):
        &#34;&#34;&#34;Return the (height, width) tuple for the box shape&#34;&#34;&#34;
        return (self._ymax-self._ymin, self._xmax-self._xmin)                            
    
    def mindimension(self):
        &#34;&#34;&#34;Return min(width, height) typecast to float&#34;&#34;&#34;
        return float(np.min(self.shape()))

    def mindim(self):
        &#34;&#34;&#34;Return min(width, height) typecast to float&#34;&#34;&#34;
        return float(np.min(self.shape()))

    def maxdim(self):
        &#34;&#34;&#34;Return max(width, height) typecast to float&#34;&#34;&#34;
        return float(np.max(self.shape())) 
    
    def ellipse(self):
        &#34;&#34;&#34;Convert the boundingbox to a vipy.geometry.Ellipse object&#34;&#34;&#34;
        (xcenter,ycenter) = self.centroid()
        return Ellipse(self.width() / 2.0, self.height() / 2.0, xcenter, ycenter, 0)

    def average(self, other):
        &#34;&#34;&#34;Compute the average bounding box between self and other, and set self to the average.  Other may be a singleton bounding box or a list of bounding boxes&#34;&#34;&#34;
        assert all([isinstance(bb, BoundingBox) for bb in tolist(other)]), &#34;Invalid input - must be BoundingBox&#34;        
        return self.ulbr(np.mean( [self.ulbr()] + [bb.ulbr() for bb in tolist(other)], axis=0))

    def averageshape(self, other):
        &#34;&#34;&#34;Compute the average bounding box width and height between self and other.  Other may be a singleton bounding box or a list of bounding boxes&#34;&#34;&#34;
        assert all([isinstance(bb, BoundingBox) for bb in tolist(other)]), &#34;Invalid input - must be BoundingBox&#34;        
        (xmin, ymin, xmax, ymax) = np.mean( [self.ulbr()] + [bb.ulbr() for bb in tolist(other)], axis=0)
        self.setwidth(xmax-xmin)
        self.setheight(ymax-ymin)        
        return self

    def medianshape(self, other):
        &#34;&#34;&#34;Compute the median bounding box width and height between self and other.  Other may be a singleton bounding box or a list of bounding boxes&#34;&#34;&#34;
        assert all([isinstance(bb, BoundingBox) for bb in tolist(other)]), &#34;Invalid input - must be BoundingBox&#34;        
        (height, width) = np.median( [self.shape()] + [bb.shape() for bb in tolist(other)], axis=0)
        self.setwidth(width)
        self.setheight(height)
        return self

    def shapedist(self, other):
        &#34;&#34;&#34;L1 distance between (width,height) of two boxes&#34;&#34;&#34;
        assert isinstance(other, BoundingBox), &#34;Invalid input - must be BoundingBox()&#34;                
        return np.abs(self.width()-other.width())  + np.abs(self.height()-other.height())

    def affine(self, A):
        &#34;&#34;&#34;Apply an 2x3 affine transformation to the box centroid.  

        .. note::  This transformation is performed on the centroid and not the box corners, so the box will still be rectilinear after the transform
        &#34;&#34;&#34;
        assert isnumpy(A) and A.shape == (2,3), &#34;A must be a 2x3 affine transformation matrix&#34;
        return self.centroid(np.dot(A, homogenize(np.array(self.centroid()))))

    def projective(self, A):
        &#34;&#34;&#34;Apply an 3x3 projective transformation to the box centroid.  
        
        .. note:: This transformation is performed on the centroid and not the box corners, so the box will still be rectilinear after the transform
        &#34;&#34;&#34;
        assert isnumpy(A) and A.shape == (3,3), &#34;A must be a 3x3 affine transformation matrix&#34;
        return self.centroid(dehomogenize(np.dot(A, homogenize(np.array(self.centroid())))))
    
    def crop(self, img):
        &#34;&#34;&#34;Crop an HxW 2D numpy image, HxWxC 3D numpy image, or NxHxWxC 4D numpy image array using this bounding box applied to HxW dimensions.  Crop is performed in-place. &#34;&#34;&#34;
        assert isnumpy(img) and img.ndim in [2,3,4]
        assert self.isinteger(), &#34;Box corners must be integer - try calling self.int()&#34;

        if img.ndim == 2:
            return img[self.ymin():self.ymax(), self.xmin():self.xmax()]  # HxW
        elif img.ndim == 3:
            return img[self.ymin():self.ymax(), self.xmin():self.xmax(), :]  # HxWxC
        else: 
            return img[:, self.ymin():self.ymax(), self.xmin():self.xmax(), :]  # NxHxWxC

    def grid(self, rows, cols):
        &#34;&#34;&#34;Split a bounding box into the smallest grid of non-overlapping bounding boxes such that the union is the original box&#34;&#34;&#34;
        (w,h) = (self.width()/cols, self.height()/rows)
        return [BoundingBox(xmin=x, ymin=y, width=w, height=h) for x in np.arange(self._xmin, self._xmax, w) for y in np.arange(self._ymin, self._ymax, h)]

    
class Ellipse():
    __slots__ = [&#39;_major&#39;, &#39;_minor&#39;, &#39;_xcenter&#39;, &#39;_ycenter&#39;, &#39;_phi&#39;]
    def __init__(self, semi_major, semi_minor, xcenter, ycenter, phi):
        &#34;&#34;&#34;Ellipse parameterization, for length of semimajor (half width of ellipse) and semiminor axis (half height), center point and angle phi in radians&#34;&#34;&#34;
        self._major = semi_major
        self._minor = semi_minor
        self._xcenter = xcenter
        self._ycenter = ycenter
        self._phi = phi

    def __repr__(self):
        return str(&#39;&lt;vipy.geometry.Ellipse: semimajor=%s, semiminor=%s, xcenter=%s, ycenter=%s, phi=%s (rad)&gt;&#39; % (self._major, self._minor, self._xcenter, self._ycenter, self._phi))

    def dict(self):
        return {&#39;semimajor&#39;:self._major, &#39;semiminor&#39;:self._minor, &#39;xcenter&#39;:self._xcenter, &#39;ycenter&#39;:self._ycenter, &#39;phi&#39;:self._phi}
    
    def area(self):
        &#34;&#34;&#34;Area of ellipse&#34;&#34;&#34;
        return math.pi * self._major * self._minor

    def center(self):
        &#34;&#34;&#34;Return centroid&#34;&#34;&#34;
        return (self._xcenter, self._ycenter)

    def centroid(self):
        &#34;&#34;&#34;Alias for center&#34;&#34;&#34;
        return self.center()

    
    def axes(self):
        &#34;&#34;&#34;Return the (major,minor) axis lengths&#34;&#34;&#34;
        return (self._major, self._minor)

    def angle(self):
        &#34;&#34;&#34;Return the angle phi (in degrees)&#34;&#34;&#34;
        return (self._phi * 180 / math.pi)

    def rescale(self, scale):
        &#34;&#34;&#34;Scale ellipse by scale factor&#34;&#34;&#34;
        assert isnumber(scale), &#34;Invalid input&#34;
        self._major *= scale
        self._minor *= scale
        self._xcenter *= scale
        self._ycenter *= scale
        return self

    def boundingbox(self):
        &#34;&#34;&#34; Estimate an equivalent bounding box based on scaling to a common area.
        Note, this does not factor in rotation.
        (c*l)*(c*w) = a_e  --&gt; c = sqrt(a_e / a_r) &#34;&#34;&#34;
        assert self._phi == 0, &#34;This function does not currently factor in rotation&#34;

        bbox = BoundingBox(width=2 * self._major, height=2 * self._minor, xcentroid=self._xcenter, ycentroid=self._ycenter)
        a_r = bbox.area()
        c = (self.area() / a_r) ** 0.5
        bbox2 = bbox.clone().dilate(c)
        return bbox2

    def inside(self, x, y=None):
        &#34;&#34;&#34;Return true if a point p=(x,y) is inside the ellipse&#34;&#34;&#34;
        p = (x,y) if y is not None else x
        assert len(p) == 2, &#34;Invalid input&#34;
        assert self._phi == 0, &#34;inside only currently supported for phi=0&#34;
        return ((np.square(p[0] - self._xcenter) / np.square(self._major)) + (np.square(p[1] - self._ycenter) / np.square(self._minor))) &lt;= 1

    def mask(self):
        &#34;&#34;&#34;Return a binary mask of size equal to the bounding box such that the pixels correspond to the interior of the ellipse&#34;&#34;&#34;
        (H,W) = (int(np.round(2 * self._minor)), int(np.round(2 * self._major)))
        img = np.zeros((H,W), dtype=bool)
        for (y,x) in product(range(0,H), range(0,W)):
            img[y,x] = self.inside(x,y)
        return img

def union(bblist):
    &#34;&#34;&#34;Return the union of a list of vipy.geometry.BoundingBox&#34;&#34;&#34;
    return bblist[0].clone().union(bblist)    

def RandomBox():
    &#34;&#34;&#34;Return a random `vipy.geometry.BoundindBox` for unit testing&#34;&#34;&#34;
    return BoundingBox(xmin=np.random.rand(), ymin=np.random.rand(), width=10*np.random.rand(), height=10*np.random.rand())


class Point2d():
    &#34;&#34;&#34;vipy.geometry.Point2d class&#34;&#34;&#34;
    __slots__ = [&#39;_x&#39;, &#39;_y&#39;, &#39;_r&#39;]
    
    def __init__(self, x, y, r=None):
        &#34;&#34;&#34;2D point parameterization&#34;&#34;&#34;
        assert math.isfinite(x)
        assert math.isfinite(y)
        assert r&gt;=0                        
        self._x = x
        self._y = y
        self._r = r if r is not None else 0       

    def __repr__(self):
        return str(&#39;&lt;vipy.geometry.Point2d: x=%s, y=%s%s&gt;&#39; % (self._x, self._y, (&#39;, r=%s&#39; % self._r) if self._r !=0 else &#39;&#39;))

    @property
    def x(self):
        return self._x
    
    @property
    def y(self):
        return self._y

    @property
    def r(self):
        return self._r

    @property
    def radius(self):
        return self._r

    def diameter(self):
        return 2*self.r
    
    @property
    def coord(self):
        return (self._x, self._y)

    @classmethod
    def from_json(cls, s):
        d = json.loads(s) if not isinstance(s, dict) else s        
        return cls(d[&#39;x&#39;], d[&#39;y&#39;], d[&#39;r&#39;])

    @classmethod
    def origin(cls):
        return Point2d(0,0)

    def boundingbox(self):
        return BoundingBox(xcentroid=self.x, ycentroid=self.y, width=2*self.r, height=2*self.r)
    
    def __getitem__(self, k):
        return self.coord[k]
    
    def __iter__(self):
        for c in self.coord:
            yield c
                
    def __sub__(self, p):
        assert isinstance(p, Point2d), &#34;invalid input&#34;        
        return Point2d(self._x-p._x, self._y-p._y, self._r)

    def __add__(self, p):
        assert isinstance(p, Point2d), &#34;invalid input&#34;        
        return Point2d(self._x+p._x, self._y+p._y, self._r)

    def __neg__(self, p):
        assert isinstance(p, Point2d), &#34;invalid input&#34;        
        return Point2d(-self._x, -self._y, self._r)
    
    def __gt__(self, p):
        assert isinstance(p, Point2d), &#34;invalid input&#34;
        return self._x &gt; p._x and self._y &gt; p._y

    def __lt__(self, p):
        assert isinstance(p, Point2d), &#34;invalid input&#34;
        return self._x &lt; p._x and self._y &lt; p._y

    def __eq__(self, p):
        assert isinstance(p, Point2d), &#34;invalid input&#34;
        return self.clone().int().coord == p.clone().int().coord

    def __len__(self):
        return len(self.coord)

    def dict(self):
        return {&#39;x&#39;:self._x, &#39;y&#39;:self._y, &#39;r&#39;:self._r}

    def json(self):
        return json.dumps(self.dict())
    
    def is_positive(self):
        return self._x&gt;0 and self._y&gt;0
    
    def is_inside_boundingbox(self, bb):
        assert isinstance(bb, BoundingBox), &#34;invalid input&#34;
        return bb.is_point_inside(self.coord)

    def dist(self, p):
        assert isinstance(p, Point2d), &#34;invalid input&#34;
        return math.sqrt((self.x-p.x)**2 + (self.y-p.y)**2)
    
    def is_inside_radius(self, p):
        assert isinstance(p, Point2d), &#34;invalid input&#34;
        return self.dist(p) &lt;= self.r
    
    def is_inside_imagebox(self, width, height):
        return self.is_inside_boundingbox(BoundingBox(xmin=0, ymin=0, width=width, height=height))

    def significant_digits(self, n):
        &#34;&#34;&#34;Convert corners to have at most n significant digits for efficient JSON storage&#34;&#34;&#34;
        assert isinstance(n, int) and n&gt;=0
        self._x = round(self._x, n)
        self._y = round(self._y, n)
        self._r = round(self._r, n)                   
        return self
        
    def translate(self, dx=0, dy=0):
        &#34;&#34;&#34;Translate the coordinates by dx in x and dy in y&#34;&#34;&#34;
        self._x = self._x + dx
        self._y = self._y + dy
        return self

    def offset(self, dx=0, dy=0):
        &#34;&#34;&#34;Alias for translate&#34;&#34;&#34;
        return self.translate(dx, dy)

    
    def rescale(self, s):
        &#34;&#34;&#34;Multiply the coordinates by a scale factor&#34;&#34;&#34;
        self._x = s * self._x
        self._y = s * self._y
        self._r = s * self._r                   
        return self

    def scale_x(self, s=1):
        &#34;&#34;&#34;Multiply the x coordinate (and radius) by a scale factor&#34;&#34;&#34;
        self._x = s * self._x
        self._r = s * self._r
        return self
        
    def scale_y(self, s=1):
        &#34;&#34;&#34;Multiply the y coordinate by a scale factor&#34;&#34;&#34;
        self._y = s * self._y
        return self
        
    def scale_r(self, s=1):
        &#34;&#34;&#34;Multiply the r coordinate by a scale factor&#34;&#34;&#34;
        self._r = s * self._r        
        return self

    def isinteger(self):
        return (isinstance(self._x, int) and
                isinstance(self._y, int))
                
    def int(self):
        &#34;&#34;&#34;Convert coords to integer with rounding, in-place update&#34;&#34;&#34;
        self._x = int(np.round(self._x))
        self._y = int(np.round(self._y))
        return self

    def float(self):
        &#34;&#34;&#34;Convert coords to float&#34;&#34;&#34;
        self._x = float(self._x)
        self._y = float(self._y)
        return self

    def fliplr(self, img=None, width=None):
        &#34;&#34;&#34;Flip the x coordinate left/right consistent with fliplr of the provided img (or consistent with the image width)&#34;&#34;&#34;
        if img is not None:
            assert isnumpy(img), &#34;Invalid numpy image input&#34;
            width = img.shape[1]
        else:
            assert isnumber(width), &#34;Invalid width&#34;
        self._x = width - self._x
        return self

    def flipud(self, img=None, height=None):
        &#34;&#34;&#34;Flip the y coordinate up/down consistent with flipud of the provided img (or consistent with the image height)&#34;&#34;&#34;
        if img is not None:
            assert isnumpy(img), &#34;Invalid numpy image input&#34;
            height = img.shape[0]
        else:
            assert height is not None and isnumber(height), &#34;Invalid height&#34;
        self._y = height - self._y
        return self
  
    def dilate(self, scale=1):
        self._r = scale*self._r
        return self

    def clone(self):
        return Point2d(self._x, self._y, self._r)
        
    def rot90cw(self, H, W):
        &#34;&#34;&#34;Rotate a point such that if an image of size (H,W) is rotated 90 deg clockwise, the point rotates with the image&#34;&#34;&#34;        
        (x,y) = self.coord
        p = self.clone()
        p._x = H - y
        p._y = x
        return p

    def rot90ccw(self, H, W):
        &#34;&#34;&#34;Rotate a point such that if an image of size (H,W) is rotated 90 deg counter clockwise, the point rotates with the image&#34;&#34;&#34;
        (x, y) = self.coord
        p = self.clone()
        p._x = y
        p._y = W-x
        return p

    def hasoverlap(self, img=None, width=None, height=None):
        &#34;&#34;&#34;Does the point inside with the provided image rectangle?&#34;&#34;&#34;
        if img is not None:
            assert isnumpy(img), &#34;Invalid image input&#34;
            (width, height) = (img.shape[1], img.shape[0])
        return self.is_inside_imagebox(width, height)

    def imclip(self, img=None, width=None, height=None):
        &#34;&#34;&#34;clip does not apply to points&#34;&#34;&#34;
        return self

    def area_of_intersection(self, p):
        &#34;&#34;&#34;area of intersection&#34;&#34;&#34;
        return self.boundingbox().area_of_intersection(p.boundingbox())

    def area_of_union(self, p):
        return self.boundingbox().area_of_union(p.boundingbox())

    def iou(self, p):
        return self.boundingbox().iou(p.boundingbox())
    
    def cover(self, p):
        return self.boundingbox().cover(p.boundingbox())

    def has_intersection(self, p):
        return (self.r + p.r) &gt;= self.dist(p)

    def xmin(self):
        return self.x - self.r

    def xmax(self):
        return self.x + self.r

    def ymin(self):
        return self.y - self.r

    def ymax(self):
        return self.y + self.r

    def width(self):
        return self.diameter()

    def height(self):
        return self.diameter()

    def union(self, points):
        bb = self.boundingbox().union( (p.boundingbox() for p in points) )
        return Point2d(bb.xcentroid(), bb.ycentroid(), max(bb.height(), bb.width())/2)
    
    
def RandomPoint2d(xmax=256, ymax=256, rmax=256):
    return Point2d(float(xmax*np.random.rand()), float(ymax*np.random.rand()), float(rmax*np.random.rand()) if rmax is not None else None)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="vipy.geometry.RandomBox"><code class="name flex">
<span>def <span class="ident">RandomBox</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a random <code>vipy.geometry.BoundindBox</code> for unit testing</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L1043-L1045" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def RandomBox():
    &#34;&#34;&#34;Return a random `vipy.geometry.BoundindBox` for unit testing&#34;&#34;&#34;
    return BoundingBox(xmin=np.random.rand(), ymin=np.random.rand(), width=10*np.random.rand(), height=10*np.random.rand())</code></pre>
</details>
</dd>
<dt id="vipy.geometry.RandomPoint2d"><code class="name flex">
<span>def <span class="ident">RandomPoint2d</span></span>(<span>xmax=256, ymax=256, rmax=256)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L1308-L1309" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def RandomPoint2d(xmax=256, ymax=256, rmax=256):
    return Point2d(float(xmax*np.random.rand()), float(ymax*np.random.rand()), float(rmax*np.random.rand()) if rmax is not None else None)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.affine_transform"><code class="name flex">
<span>def <span class="ident">affine_transform</span></span>(<span>txy=(0, 0), r=0, sx=1, sy=1, kx=0, ky=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Compose and return a 3x3 affine transformation for translation txy=(0,0), rotation r (radians), scalex=sx, scaley=sy, shearx=kx, sheary=ky.</p>
<p>Usage:</p>
<pre><code class="language-python">A = vipy.geometry.affine_transform(r=np.pi/4)
vipy.image.Image(array=vipy.geometry.imtransform(im.array(), A), colorspace='float')
</code></pre>
<p>Equivalently:</p>
<pre><code class="language-python">im = vipy.image.RandomImage().affine_transform(A)    
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L72-L94" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def affine_transform(txy=(0,0), r=0, sx=1, sy=1, kx=0, ky=0):
    &#34;&#34;&#34;Compose and return a 3x3 affine transformation for translation txy=(0,0), rotation r (radians), scalex=sx, scaley=sy, shearx=kx, sheary=ky.
    
    Usage:
    
    ```python
    A = vipy.geometry.affine_transform(r=np.pi/4)
    vipy.image.Image(array=vipy.geometry.imtransform(im.array(), A), colorspace=&#39;float&#39;)
    ```
    
    Equivalently:

    ```python
    im = vipy.image.RandomImage().affine_transform(A)    
    ```
    
    &#34;&#34;&#34;
    assert isinstance(txy, tuple) and len(txy) == 2 and isnumber(r) and isnumber(sx) and isnumber(sy) and isnumber(kx) and isnumber(ky), &#34;Invalid input&#34;
    R = np.asarray([[np.cos(r), -np.sin(r), 0], [np.sin(r), np.cos(r), 0], [0,0,1]])
    S = np.asarray([[sx,0,0], [0, sy, 0], [0,0,1]])
    K = np.asarray([[1,ky,0], [kx,1,0], [0,0,1]])
    T = np.asarray([[0,0,txy[0]], [0,0,txy[1]], [0,0,0]])
    return K * S * R + T  # composition</code></pre>
</details>
</dd>
<dt id="vipy.geometry.apply_homography"><code class="name flex">
<span>def <span class="ident">apply_homography</span></span>(<span>H, p)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply a 3x3 homography H to non-homogenous point p and return a transformed point</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L47-L50" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def apply_homography(H,p):
    &#34;&#34;&#34;Apply a 3x3 homography H to non-homogenous point p and return a transformed point &#34;&#34;&#34;
    assert isnumpy(H) and isnumpy(p) and H.shape == (3,3) and p.shape[0] == 2, &#34;Invalid input&#34;
    return dehomogenize(np.dot(H, homogenize(p)))</code></pre>
</details>
</dd>
<dt id="vipy.geometry.covariance_to_ellipse"><code class="name flex">
<span>def <span class="ident">covariance_to_ellipse</span></span>(<span>cov)</span>
</code></dt>
<dd>
<div class="desc"><p>2x2 covariance matrix to ellipse (major_axis_length, minor_axis_length, angle_in_radians)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L13-L17" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def covariance_to_ellipse(cov):
    &#34;&#34;&#34;2x2 covariance matrix to ellipse (major_axis_length, minor_axis_length, angle_in_radians)&#34;&#34;&#34;
    assert isnumpy(cov) and cov.shape == (2,2), &#34;Invalid input&#34;
    (d,V) = np.linalg.eig(cov)
    return np.array((d[0], d[1], math.atan2(V[1,0], V[0,0])))  # (major_axis_len, minor_axis_len, angle_in_radians)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.dehomogenize"><code class="name flex">
<span>def <span class="ident">dehomogenize</span></span>(<span>p)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert 3x1 homogenous point (x,y,h) to 2x1 non-homogenous point (x/h, y/h)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L20-L31" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dehomogenize(p):
    &#34;&#34;&#34;Convert 3x1 homogenous point (x,y,h) to 2x1 non-homogenous point (x/h, y/h)&#34;&#34;&#34;
    assert isnumpy(p)    
    if p.ndim == 1:
        assert len(p) == 3
        return p[0:2] / p[2]
    elif p.ndim == 2:
        assert isnumpy(p) and p.shape[0] == 3, &#34;Invalid input&#34;
        p = columnvector(p) if p.ndim == 1 else p
        return p[0:-1, :] / p[-1,:]
    else:
        return ValueError(&#39;p must be 1d or 2d&#39;)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.homogenize"><code class="name flex">
<span>def <span class="ident">homogenize</span></span>(<span>p)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert 2xN non-homogenous points (x,y) to 3xN non-homogenous point (x, y, 1)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L34-L44" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def homogenize(p):
    &#34;&#34;&#34;Convert 2xN non-homogenous points (x,y) to 3xN non-homogenous point (x, y, 1)&#34;&#34;&#34;
    assert isnumpy(p)
    if p.ndim == 1:
        return np.hstack( (p, 1) )
    elif p.ndim == 2:
        assert p.shape[0] == 2, &#34;Invalid input&#34;
        p = columnvector(p) if p.ndim == 1 else p
        return np.vstack((p, np.ones_like(p[-1])))
    else:
        return ValueError(&#39;p must be 1d or 2d&#39;)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.imagebox"><code class="name flex">
<span>def <span class="ident">imagebox</span></span>(<span>shape)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L127-L128" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def imagebox(shape):
    return BoundingBox(xmin=0, ymin=0, width=shape[1], height=shape[0])</code></pre>
</details>
</dd>
<dt id="vipy.geometry.imtransform"><code class="name flex">
<span>def <span class="ident">imtransform</span></span>(<span>img, A, border='zero')</span>
</code></dt>
<dd>
<div class="desc"><p>Transform an numpy array image (MxNx3) following the affine or similiarity transformation A</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L109-L118" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def imtransform(img, A, border=&#39;zero&#39;):
    &#34;&#34;&#34;Transform an numpy array image (MxNx3) following the affine or similiarity transformation A&#34;&#34;&#34;
    assert isnumpy(img) and isnumpy(A), &#34;invalid input&#34;
    assert border in [&#39;zero&#39;, &#39;replicate&#39;]
    try_import(&#39;cv2&#39;, &#39;opencv-python&#39;); import cv2
    borderMode = cv2.BORDER_REPLICATE if border==&#39;replicate&#39; else cv2.BORDER_CONSTANT
    if A.shape == (3,3):
        return cv2.warpPerspective(img, A, (img.shape[1], img.shape[0]), borderMode=borderMode)        
    else:
        return cv2.warpAffine(img, A, (img.shape[1], img.shape[0]), borderMode=borderMode)        </code></pre>
</details>
</dd>
<dt id="vipy.geometry.normalize"><code class="name flex">
<span>def <span class="ident">normalize</span></span>(<span>x, eps=1e-16)</span>
</code></dt>
<dd>
<div class="desc"><p>Given a vector x, return the vector unit normalized as float64</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L122-L125" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def normalize(x, eps=1E-16):
    &#34;&#34;&#34;Given a vector x, return the vector unit normalized as float64&#34;&#34;&#34;
    assert isnumpy(x), &#34;Invalid input&#34;
    return x / (np.linalg.norm(x.astype(np.float64)) + eps)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.random_affine_transform"><code class="name flex">
<span>def <span class="ident">random_affine_transform</span></span>(<span>txy=((0, 1), (0, 1)), r=(0, 1), sx=(0.1, 1), sy=(0.1, 1), kx=(0.1, 1), ky=(0.1, 1))</span>
</code></dt>
<dd>
<div class="desc"><p>Return a random 3x3 affine transformation matrix for the provided ranges, inputs must be tuples</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L97-L106" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def random_affine_transform(txy=((0,1),(0,1)), r=(0,1), sx=(0.1,1), sy=(0.1,1), kx=(0.1,1), ky=(0.1,1)):
    &#34;&#34;&#34;Return a random 3x3 affine transformation matrix for the provided ranges, inputs must be tuples&#34;&#34;&#34;
    assert isinstance(txy, tuple) and isinstance(txy[0], tuple) and isinstance(txy[1], tuple) and isinstance(r, tuple) and isinstance(sx, tuple) and isinstance(sy, tuple) and isinstance(kx, tuple) and isinstance(ky, tuple), &#34;Invalid input&#34;
    uniform_random_in_range = lambda t: np.random.uniform(t[0], t[1])
    return affine_transform(txy=(uniform_random_in_range(txy[0]), uniform_random_in_range(txy[1])),
                            r=uniform_random_in_range(r),
                            sx=uniform_random_in_range(sx),
                            sy=uniform_random_in_range(sy),
                            kx=uniform_random_in_range(kx),
                            ky=uniform_random_in_range(ky))</code></pre>
</details>
</dd>
<dt id="vipy.geometry.similarity_transform"><code class="name flex">
<span>def <span class="ident">similarity_transform</span></span>(<span>txy=(0, 0), r=0, s=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a 3x3 similarity transformation with translation tuple txy=(x,y), rotation r (radians, scale=s</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L63-L69" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def similarity_transform(txy=(0,0), r=0, s=1):
    &#34;&#34;&#34;Return a 3x3 similarity transformation with translation tuple txy=(x,y), rotation r (radians, scale=s&#34;&#34;&#34;
    assert isinstance(txy, tuple) and len(txy) == 2 and isnumber(r) and isnumber(s), &#34;Invalid input&#34;
    R = np.asarray([[np.cos(r), -np.sin(r), 0], [np.sin(r), np.cos(r), 0], [0,0,1]])
    S = np.asarray([[s,0,0], [0, s, 0], [0,0,1]])
    T = np.asarray([[0,0,txy[0]], [0,0,txy[1]], [0,0,0]])
    return S * R + T  # composition</code></pre>
</details>
</dd>
<dt id="vipy.geometry.similarity_transform_2x3"><code class="name flex">
<span>def <span class="ident">similarity_transform_2x3</span></span>(<span>c=(0, 0), r=0, s=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a 2x3 similarity transform with rotation r (radians), scale s and origin c=(x,y)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L53-L60" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def similarity_transform_2x3(c=(0,0), r=0, s=1):
    &#34;&#34;&#34;Return a 2x3 similarity transform with rotation r (radians), scale s and origin c=(x,y)&#34;&#34;&#34;
    assert isinstance(c, tuple) and len(c) == 2 and isnumber(r) and isnumber(s), &#34;Invalid input&#34;
    deg = r * 180. / math.pi
    a = s * np.cos(r)
    b = s * np.sin(r)
    (x,y) = (c[0], c[1])
    return np.array([[a, b, (1 - a) * x - b * y], [-b, a, b * x + (1 - a) * y]])</code></pre>
</details>
</dd>
<dt id="vipy.geometry.union"><code class="name flex">
<span>def <span class="ident">union</span></span>(<span>bblist)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the union of a list of vipy.geometry.BoundingBox</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L1039-L1041" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def union(bblist):
    &#34;&#34;&#34;Return the union of a list of vipy.geometry.BoundingBox&#34;&#34;&#34;
    return bblist[0].clone().union(bblist)    </code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="vipy.geometry.BoundingBox"><code class="flex name class">
<span>class <span class="ident">BoundingBox</span></span>
<span>(</span><span>xmin=None, ymin=None, xmax=None, ymax=None, centroid=None, xcentroid=None, ycentroid=None, width=None, height=None, mask=None, xywh=None, ulbr=None, ulbrdict=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Core bounding box class with flexible constructors in this priority order:
(xmin,ymin,xmax,ymax)
(xmin,ymin,width,height)
(centroid[0],centroid[1],width,height)
(xcentroid,ycentroid,width,height)
xywh=(xmin,ymin,width,height)
ulbr=(xmin,ymin,xmax,ymax)
bounding rectangle of binary mask image</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L132-L963" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class BoundingBox():
    &#34;&#34;&#34;Core bounding box class with flexible constructors in this priority order:
          (xmin,ymin,xmax,ymax)
          (xmin,ymin,width,height)
          (centroid[0],centroid[1],width,height)
          (xcentroid,ycentroid,width,height)
          xywh=(xmin,ymin,width,height)
          ulbr=(xmin,ymin,xmax,ymax)
          bounding rectangle of binary mask image&#34;&#34;&#34;

    __slots__ = [&#39;_xmin&#39;, &#39;_ymin&#39;, &#39;_xmax&#39;, &#39;_ymax&#39;]        
    def __init__(self, xmin=None, ymin=None, xmax=None, ymax=None, centroid=None, xcentroid=None, ycentroid=None, width=None, height=None, mask=None, xywh=None, ulbr=None, ulbrdict=None):

        if ulbrdict is not None:
            self._xmin = ulbrdict[&#39;_xmin&#39;]
            self._ymin = ulbrdict[&#39;_ymin&#39;]
            self._xmax = ulbrdict[&#39;_xmax&#39;]
            self._ymax = ulbrdict[&#39;_ymax&#39;]                                  
        elif xmin is not None and ymin is not None and xmax is not None and ymax is not None:
            assert (isnumber(xmin) and isnumber(ymin) and isnumber(xmax) and isnumber(ymax)), &#39;Box coordinates must be integers or floats not &#34;%s&#34;&#39; % str(type(xmin))
            self._xmin = float(xmin)
            self._ymin = float(ymin)
            self._xmax = float(xmax)
            self._ymax = float(ymax)
        elif xmin is not None and ymin is not None and width is not None and height is not None:
            assert (isnumber(xmin) and isnumber(ymin) and isnumber(width) and isnumber(height)), &#39;Box coordinates must be integers or floats not &#34;%s&#34;&#39; % str(type(width))
            self._xmin = float(xmin)
            self._ymin = float(ymin)
            self._xmax = self._xmin + float(width)
            self._ymax = self._ymin + float(height)
        elif centroid is not None and width is not None and height is not None:
            assert (len(centroid) == 2 and isnumber(centroid[0]) and isnumber(centroid[1]) and isnumber(width) and isnumber(height)), &#39;Invalid box coordinates&#39;
            self._xmin = float(centroid[0]) - float(width) / 2.0
            self._ymin = float(centroid[1]) - float(height) / 2.0
            self._xmax = float(centroid[0]) + float(width) / 2.0
            self._ymax = float(centroid[1]) + float(height) / 2.0
        elif xcentroid is not None and ycentroid is not None and width is not None and height is not None:
            self._xmin = float(xcentroid) - (float(width) / 2.0)
            self._ymin = float(ycentroid) - (float(height) / 2.0)
            self._xmax = float(xcentroid) + (float(width) / 2.0)
            self._ymax = float(ycentroid) + (float(height) / 2.0)
        elif xywh is not None:
            self.xywh(xywh)
        elif ulbr is not None:
            self.ulbr(ulbr)
        elif mask is not None:
            # Bounding rectangle of non-zero pixels in a binary mask image
            if not isnumpy(mask) or np.sum(mask) == 0:
                raise ValueError(&#39;Mask input must be numpy array with at least one non-zero entry&#39;)
            imx = np.sum(mask, axis=0)
            imy = np.sum(mask, axis=1)
            self._xmin = np.argwhere(imx &gt; 0)[0]
            self._ymin = np.argwhere(imy &gt; 0)[0]
            self._xmax = np.argwhere(imx &gt; 0)[-1]
            self._ymax = np.argwhere(imy &gt; 0)[-1]
        else:
            raise ValueError(&#39;invalid constructor input&#39;)

    @classmethod
    def cast(cls, bb, flush=False):
        assert isinstance(bb, (BoundingBox, Point2d))
        bb = bb if isinstance(bb, BoundingBox) else bb.boundingbox()
        return cls(xywh=bb.xywh())
    
    @classmethod
    def from_json(cls, s):
        d = json.loads(s) if not isinstance(s, dict) else s
        d = {&#39;_&#39;+k if not k.startswith(&#39;_&#39;) else k:v for (k,v) in d.items()}  # from prettyjson (add &#34;_&#34; prefix to attributes)                
        return cls(ulbrdict=d)

    def dict(self):
        &#34;&#34;&#34;Return a python dictionary containing the relevant serialized attributes suitable for JSON encoding&#34;&#34;&#34;
        return self.json(encode=False)

    def __json__(self):
        &#34;&#34;&#34;Serialization method for json package&#34;&#34;&#34;
        return self.json(encode=True)
    
    def json(self, encode=True):
        d = {k.lstrip(&#39;_&#39;):getattr(self, k) for k in BoundingBox.__slots__}  # prettyjson (remove &#34;_&#34; prefix to attributes)        
        return json.dumps(d) if encode else d

    def clone(self):
        return BoundingBox(xmin=self._xmin, xmax=self._xmax, ymin=self._ymin, ymax=self._ymax)
    def bbclone(self):
        return BoundingBox(xmin=self._xmin, xmax=self._xmax, ymin=self._ymin, ymax=self._ymax)

    def __eq__(self, other):
        &#34;&#34;&#34;Bounding box equality (integer resolution of corners)&#34;&#34;&#34;
        return isinstance(other, BoundingBox) and self.clone().int().xywh() == other.clone().int().xywh()

    def __neq__(self, other):
        &#34;&#34;&#34;Bounding box non-equality&#34;&#34;&#34;
        return not self.__eq__(other)

    def __repr__(self):
        return str(&#39;&lt;vipy.geometry.BoundingBox: xmin=%s, ymin=%s, width=%s, height=%s&gt;&#39; % (self.xmin(), self.ymin(), self.width(), self.height()))

    def __str__(self):
        return self.__repr__()
    
    def xmin(self, x=None):
        &#34;&#34;&#34;x coordinate of upper left corner of box, x-axis is image column&#34;&#34;&#34;
        self._xmin = self._xmin if x is None else x
        return self._xmin if x is None else self

    def ul(self):
        &#34;&#34;&#34;Upper left coordinate (x,y)&#34;&#34;&#34;
        return (self._xmin, self._ymin)

    def ulx(self):
        &#34;&#34;&#34;Upper left coordinate (x)&#34;&#34;&#34;
        return self.ul()[0]

    def uly(self):
        &#34;&#34;&#34;Upper left coordinate (y)&#34;&#34;&#34;
        return self.ul()[1]

    def ur(self):
        &#34;&#34;&#34;Upper right coordinate (x,y)&#34;&#34;&#34;
        return (self._xmax, self._ymin)

    def urx(self):
        &#34;&#34;&#34;Upper right coordinate (x)&#34;&#34;&#34;
        return self.ur()[0]

    def ury(self):
        &#34;&#34;&#34;Upper right coordinate (y)&#34;&#34;&#34;
        return self.ur()[1]

    def ll(self):
        &#34;&#34;&#34;Lower left coordinate (x,y), synonym for bl()&#34;&#34;&#34;
        return (self._xmin, self._ymax)

    def bl(self):
        &#34;&#34;&#34;Bottom left coordinate (x,y), synonym for ll()&#34;&#34;&#34;
        return (self._xmin, self._ymax)

    def blx(self):
        &#34;&#34;&#34;Bottom left coordinate (x)&#34;&#34;&#34;
        return self.bl()[0]

    def bly(self):
        &#34;&#34;&#34;Bottom left coordinate (y)&#34;&#34;&#34;
        return self.bl()[1]

    def lr(self):
        &#34;&#34;&#34;Lower right coordinate (x,y), synonym for br()&#34;&#34;&#34;
        return (self._xmax, self._ymax)

    def br(self):
        &#34;&#34;&#34;Bottom right coordinate (x,y), synonym for lr()&#34;&#34;&#34;
        return (self._xmax, self._ymax)

    def brx(self):
        &#34;&#34;&#34;Bottom right coordinate (x)&#34;&#34;&#34;
        return self.br()[0]

    def bry(self):
        &#34;&#34;&#34;Bottom right coordinate (y)&#34;&#34;&#34;
        return self.br()[1]

    def ymin(self, y=None):
        &#34;&#34;&#34;y coordinate of upper left corner of box, y-axis is image row, set if provided&#34;&#34;&#34;
        self._ymin = self._ymin if y is None else y
        return self._ymin if y is None else self

    def xmax(self, x=None):
        &#34;&#34;&#34;x coordinate of lower right corner of box, x-axis is image column&#34;&#34;&#34;
        self._xmax = self._xmax if x is None else x
        return self._xmax if x is None else self

    def ymax(self, y=None):
        &#34;&#34;&#34;y coordinate of lower right corner of box, y-axis is image row&#34;&#34;&#34;
        self._ymax = self._ymax if y is None else y
        return self._ymax if y is None else self

    def upperleft(self):
        &#34;&#34;&#34;Return the (x,y) upper left corner coordinate of the box&#34;&#34;&#34;
        return (self.xmin(), self.ymin())

    def bottomleft(self):
        &#34;&#34;&#34;Return the (x,y) lower left corner coordinate of the box&#34;&#34;&#34;
        return (self.xmin(), self.ymax())

    def upperright(self):
        &#34;&#34;&#34;Return the (x,y) upper right corner coordinate of the box&#34;&#34;&#34;
        return (self.xmax(), self.ymin())

    def bottomright(self):
        &#34;&#34;&#34;Return the (x,y) lower right corner coordinate of the box&#34;&#34;&#34;
        return (self.xmax(), self.ymax())

    def isinteger(self):
        return (isinstance(self._xmin, int) and
                isinstance(self._ymin, int) and
                isinstance(self._xmax, int) and
                isinstance(self._ymax, int))
                
    def int(self):
        &#34;&#34;&#34;Convert corners to integer with rounding, in-place update&#34;&#34;&#34;
        (w,h) = (int(np.round(self.width())), int(np.round(self.height())))
        self._xmin = int(np.round(self._xmin))
        self._ymin = int(np.round(self._ymin))
        self._xmax = int(np.round(self._xmax))
        self._ymax = int(np.round(self._ymax))
        if w != self.width():
            self.right(w - self.width())  # preserve aspect ratio due to rounding by +/- right side of box 
        if h != self.height():
            self.bottom(h-self.height())  # preserve aspect ratio due to rounding by +/- bottom of box
        return self

    def float(self):
        &#34;&#34;&#34;Convert corners to float&#34;&#34;&#34;
        self._xmin = float(self._xmin)
        self._ymin = float(self._ymin)
        self._xmax = float(self._xmax)
        self._ymax = float(self._ymax)
        return self

    def significant_digits(self, n):
        &#34;&#34;&#34;Convert corners to have at most n significant digits for efficient JSON storage&#34;&#34;&#34;
        assert isinstance(n, int) and n&gt;=0
        self._xmin = round(self._xmin, n)
        self._ymin = round(self._ymin, n)
        self._xmax = round(self._xmax, n)
        self._ymax = round(self._ymax, n)
        return self
        
    def translate(self, dx=0, dy=0):
        &#34;&#34;&#34;Translate the bounding box by dx in x and dy in y&#34;&#34;&#34;
        self._xmin = self._xmin + dx
        self._ymin = self._ymin + dy
        self._xmax = self._xmax + dx
        self._ymax = self._ymax + dy
        return self

    def to_origin(self):
        &#34;&#34;&#34;Translate the bounding box so that (xmin, ymin) = (0,0)&#34;&#34;&#34;
        return self.translate(-self.xmin(), -self.ymin())
    
    def set_origin(self, other):
        &#34;&#34;&#34;Set the origin of the coordinates of this bounding box to be relative to the upper left of the other bounding box&#34;&#34;&#34;
        assert isinstance(other, BoundingBox), &#34;Invalid BoundingBox() input of type &#39;%s&#39;&#34; % str(type(other))
        return self.translate(other.xmin(), other.ymin())                
    
    def offset(self, dx=0, dy=0):
        &#34;&#34;&#34;Alias for translate&#34;&#34;&#34;
        return self.translate(dx, dy)

    def invalid(self):
        &#34;&#34;&#34;Is the box a valid bounding box?&#34;&#34;&#34;
        #is_undefined = np.isnan(self._xmin) or np.isnan(self._ymin) or np.isnan(self._xmax) or np.isnan(self._ymax)
        is_valid = ((self._xmax - self._xmin) &gt;= 0) and ((self._ymax - self._ymin) &gt;= 0)  # if nan, will return False
        return not is_valid

    def valid(self):
        return not self.invalid()

    def isvalid(self):
        return not self.invalid()

    def isdegenerate(self):
        return self.invalid()
        
    def isnonnegative(self):
        return (self.xmin() &gt;= 0 and
                self.ymin() &gt;= 0 and
                self.xmax() &gt;= 0 and
                self.ymax() &gt;= 0)

    def width(self):
        return self._xmax - self._xmin
    
    def setwidth(self, w):
        &#34;&#34;&#34;Set new width keeping centroid constant&#34;&#34;&#34;
        if w &lt;= 0:
            raise ValueError(&#39;invalid width&#39;)
        worig = (self._xmax - self._xmin)
        self._xmax += float((w - worig) / 2.0)
        self._xmin -= float((w - worig) / 2.0)
        return self

    def setheight(self, h):
        &#34;&#34;&#34;Set new height keeping centroid constant&#34;&#34;&#34;
        if h &lt;= 0:
            raise ValueError(&#39;invalid height&#39;)
        horig = self._ymax - self._ymin
        self._ymax += float((h - horig) / 2.0)
        self._ymin -= float((h - horig) / 2.0)
        return self

    def height(self):
        return self._ymax - self._ymin

    def centroid(self, c=None):
        &#34;&#34;&#34;(x,y) tuple of centroid position of bounding box&#34;&#34;&#34;        
        if c is None:
            (height, width) = (self._ymax-self._ymin, self._xmax-self._xmin)            
            return (self._xmin + (float(width) / 2.0), self._ymin + (float(height) / 2.0))
        else:
            assert len(c) == 2
            (height, width) = (self._ymax-self._ymin, self._xmax-self._xmin)
            self._xmin = float(c[0]) - (width / 2.0)
            self._ymin = float(c[1]) - (height / 2.0)
            self._xmax = float(c[0]) + (width / 2.0)
            self._ymax = float(c[1]) + (height / 2.0)
            return self
            
    def x_centroid(self):
        return self.centroid()[0]

    def xcentroid(self):
        &#34;&#34;&#34;Alias for x_centroid()&#34;&#34;&#34;
        return self.centroid()[0]
    def centroid_x(self):
        &#34;&#34;&#34;Alias for x_centroid()&#34;&#34;&#34;
        return self.centroid()[0]
            
    def y_centroid(self):
        return self.centroid()[1]

    def ycentroid(self):
        &#34;&#34;&#34;Alias for y_centroid()&#34;&#34;&#34;
        return self.centroid()[1]
    def centroid_y(self):
        &#34;&#34;&#34;Alias for y_centroid()&#34;&#34;&#34;
        return self.centroid()[1]
    
    def area(self):
        &#34;&#34;&#34;Return the area=width*height of the bounding box, internal method useful for multiple inheritance&#34;&#34;&#34;
        (height, width) = (self._ymax-self._ymin, self._xmax-self._xmin)        
        return width * height if (height&gt;0 and width&gt;0) else 0
    
    def to_xywh(self, xywh=None):
        &#34;&#34;&#34;Return bounding box corners as (x,y,width,height) tuple&#34;&#34;&#34;
        if xywh is None:
            (height, width) = (self._ymax-self._ymin, self._xmax-self._xmin)                    
            return tuple([self._xmin, self._ymin, width, height])
        else:
            assert len(xywh) == 4, &#34;Invalid (xmin,ymin,width,height) input&#34;
            self._xmin = float(xywh[0])
            self._ymin = float(xywh[1])
            self._xmax = float(self._xmin + xywh[2])
            self._ymax = float(self._ymin + xywh[3])
            return self

    def xywh(self, xywh_=None):
        &#34;&#34;&#34;Alias for to_xywh&#34;&#34;&#34;
        return self.to_xywh(xywh_)

    def cxywh(self, cxywh=None):
        &#34;&#34;&#34;Return or set bounding box corners as (centroidx,centroidy,width,height) tuple&#34;&#34;&#34;
        if cxywh is None:
            (height, width) = (self._ymax-self._ymin, self._xmax-self._xmin)                    
            return tuple([self.x_centroid(), self.y_centroid(), width, height])
        else:
            assert len(cxywh) == 4, &#34;Invalid (xcentroid, ycentroid, width, height) input&#34;
            return self.centroid( (cxywh[0], cxywh[1]) ).setwidth(cxywh[2]).setheight(cxywh[3])            
    
    def ulbr(self, ulbr=None):
        &#34;&#34;&#34;Return bounding box corners as upper left, bottom right (xmin, ymin, xmax, ymax)&#34;&#34;&#34;
        if ulbr is None:
            return (self._xmin, self._ymin, self._xmax, self._ymax)            
        else:
            assert len(ulbr) == 4, &#34;Invalid (xmin,ymin,xmax,ymax) input&#34;
            self._xmin = float(ulbr[0])
            self._ymin = float(ulbr[1])
            self._xmax = float(ulbr[2])
            self._ymax = float(ulbr[3])
            return self

    def to_ulbr(self, ulbr=None):
        &#34;&#34;&#34;Alias for ulbr()&#34;&#34;&#34;
        return self.ulbr(ulbr)
    
    def dx(self, bb):
        &#34;&#34;&#34;Offset bounding box by same xmin as provided box&#34;&#34;&#34;
        return bb._xmin - self._xmin

    def dy(self, bb):
        &#34;&#34;&#34;Offset bounding box by ymin of provided box&#34;&#34;&#34;
        return bb._ymin - self._ymin

    def sqdist(self, bb):
        &#34;&#34;&#34;Squared Euclidean distance between upper left corners of two bounding boxes&#34;&#34;&#34;
        assert isinstance(bb, BoundingBox), &#34;Invalid BoundingBox() input of type &#39;%s&#39;&#34; % str(type(bb))                
        return np.power(self.dx(bb), 2.0) + np.power(self.dy(bb), 2.0)

    def dist(self, bb):
        &#34;&#34;&#34;Distance between centroids of two bounding boxes&#34;&#34;&#34;
        assert isinstance(bb, BoundingBox), &#34;Invalid BoundingBox() input of type &#39;%s&#39;&#34; % str(type(bb))                
        return np.sqrt(np.sum(np.square(np.array(bb.centroid()) - np.array(self.centroid()))))

    def pdist(self, bb, sigma=None):
        &#34;&#34;&#34;Normalized Gaussian distance in [0,1] between centroids of two bounding boxes, where 0 is far and 1 is same with sigma=maxdim() of this box&#34;&#34;&#34;
        assert isinstance(bb, BoundingBox), &#34;Invalid BoundingBox() input of type &#39;%s&#39;&#34; % str(type(bb))
        return np.exp(-self.sqdist(bb)/(float(2*self.maxdim()*self.maxdim()) if sigma is None else float(2.0*sigma*sigma)))

    def iou(self, bb, area=None, otherarea=None):
        &#34;&#34;&#34;area of intersection / area of union&#34;&#34;&#34;
        assert bb is None or isinstance(bb, BoundingBox), &#34;Invalid BoundingBox() input of type &#39;%s&#39;&#34; % str(type(bb))        
        if bb is None:
            return 0
        w = min(self._xmax, bb._xmax) - max(self._xmin, bb._xmin)
        if w &lt;= 0:
            return 0  # invalid (no overlap), early exit
        h = min(self._ymax, bb._ymax) - max(self._ymin, bb._ymin)
        if h &lt;= 0:
            return 0  # invalid (no overlap), early exit

        area_intersection = w * h
        area_union = ((self.area() if area is None else area) +
                      (bb.area() if otherarea is None else otherarea) -
                      area_intersection)
        return (area_intersection / float(area_union)) if area_union &gt; 0 else 0

    def intersection_over_union(self, bb):
        &#34;&#34;&#34;Alias for iou&#34;&#34;&#34;
        return self.iou(bb)

    def area_of_intersection(self, bb, strict=True):
        &#34;&#34;&#34;area of intersection&#34;&#34;&#34;
        if strict:
            assert isinstance(bb, BoundingBox), &#34;Invalid BoundingBox() input of type &#39;%s&#39;&#34; % str(type(bb))                
        w = min(self._xmax, bb._xmax) - max(self._xmin, bb._xmin)
        if w &lt;= 0:
            return 0  # invalid (no overlap), early exit 
        h = min(self._ymax, bb._ymax) - max(self._ymin, bb._ymin)
        if h &lt;= 0:
            return 0  # invalid (no overlap), early exit 
        return w*h

    def area_of_union(self, bb):
        return self.area() + bb.area() - self.area_of_intersection(bb)
        
    def cover(self, bb):
        &#34;&#34;&#34;Fraction of this bounding box intersected by other bbox (bb).

        .. note:: 
        
            - Cover is often more useful than `vipy.geometry.BoundingBox.iou` as a measure of overlap due to bounding box distortion from partially occluded object proposals.  
            - For example, an object proposal of a person may generate a smaller box (e.g. just the torso) when the lower body is occluded whereas a track will have the full body box.  
            - `vipy.geometry.BoundingBox.maxcover` is a better measure of assignment in this case.  

        &#34;&#34;&#34;
        a = float(self.area())
        return (self.area_of_intersection(bb) / a) if a&gt;0 else 0

    def maxcover(self, bb, area=None, otherarea=None):
        &#34;&#34;&#34;The maximum cover of self to bb and bb to self&#34;&#34;&#34;
        aoi = self.area_of_intersection(bb, strict=False)
        (area, otherarea) = (self.area() if area is None else area, bb.area() if otherarea is None else otherarea)
        return float(max((aoi/area) if area&gt;0 else 0, (aoi/otherarea) if otherarea&gt;0 else 0))
    
    def shapeiou(self, bb, area=None, otherarea=None):
        &#34;&#34;&#34;Shape IoU is the IoU with the upper left corners aligned. This measures the deformation of the two boxes by removing the effect of translation&#34;&#34;&#34;
        #return self.iou(bb.clone().translate(dx=self._xmin-bb._xmin, dy=self._ymin-bb._ymin))  # equivalent to
        assert isinstance(bb, BoundingBox), &#34;Invalid input - must be BoundingBox()&#34;
        w = min(self._xmax, bb._xmax + (self._xmin-bb._xmin)) - max(self._xmin, bb._xmin + (self._xmin-bb._xmin))
        h = min(self._ymax, bb._ymax + (self._ymin-bb._ymin)) - max(self._ymin, bb._ymin + (self._ymin-bb._ymin))
        area_intersection = w * h
        area_union = ((self.area() if area is None else area) +
                      (bb.area() if otherarea is None else otherarea)
                      - area_intersection)
        return (area_intersection / float(area_union)) if area_union&gt;0 else 0
        
    def intersection(self, bb, strict=True):
        &#34;&#34;&#34;Intersection of two bounding boxes, throw an error on degeneracy of intersection result (if strict=True)&#34;&#34;&#34;
        assert isinstance(bb, BoundingBox), &#34;Invalid BoundingBox() input of type &#39;%s&#39;&#34; % str(type(bb))                        
        self._xmin = max(bb._xmin, self._xmin)
        self._ymin = max(bb._ymin, self._ymin)
        self._xmax = min(bb._xmax, self._xmax)
        self._ymax = min(bb._ymax, self._ymax)
        if strict and self.isdegenerate():
            raise ValueError(&#39;Degenerate intersection for bounding boxes &#34;%s&#34; and &#34;%s&#34;&#39; % (str(bb), str(self)))
        return self

    def hasintersection(self, bb, iou=None, cover=None, maxcover=None, bbcover=None, area=None, otherarea=None, gate=0):
        &#34;&#34;&#34;Return true if self and bb overlap by any amount, or by the cover threshold (if provided) or the iou threshold (if provided).  This is a convenience function that allows for shared computation for fast non-maximum suppression.&#34;&#34;&#34;

        if not (((self._xmax if self._xmax &lt; bb._xmax else bb._xmax) - (self._xmin if self._xmin &gt; bb._xmin else bb._xmin)) &gt; (-gate) and
                ((self._ymax if self._ymax &lt; bb._ymax else bb._ymax) - (self._ymin if self._ymin &gt; bb._ymin else bb._ymin)) &gt; (-gate)):  # faster than min(x,y)-max(x,y)
            return False  # does not intersect
        
        elif maxcover is not None or iou is not None or cover is not None or bbcover is not None:
            aoi = self.area_of_intersection(bb, strict=False)            
            otherarea = otherarea if otherarea is not None else (bb.area() if (maxcover is not None or bbcover is not None or iou is not None) else 0)
            area = area if area is not None else (self.area() if (maxcover is not None or cover is not None or iou is not None) else 0)
            return (((maxcover is not None) and (max(aoi/area, aoi/otherarea) &gt; maxcover)) or
                    ((iou is not None) and ((aoi / (area+otherarea-aoi)) &gt;= iou)) or
                    ((cover is not None) and ((aoi / area) &gt;= cover)) or
                    ((bbcover is not None) and ((aoi / otherarea) &gt;= bbcover)))
        else:
            return True

    def union(self, bb):
        &#34;&#34;&#34;Union of one or more bounding boxes with this box&#34;&#34;&#34;        
        bblist = tolist(bb)        
        assert all([isinstance(bb, BoundingBox) for bb in bblist]), &#34;Invalid BoundingBox() input&#34;
        self._xmin = min([bb._xmin for bb in bblist] + [self._xmin])
        self._ymin = min([bb._ymin for bb in bblist] + [self._ymin])
        self._xmax = max([bb._xmax for bb in bblist] + [self._xmax])
        self._ymax = max([bb._ymax for bb in bblist] + [self._ymax])
        return self

    def isinside(self, bb):
        &#34;&#34;&#34;Is this boundingbox fully within the provided bounding box?&#34;&#34;&#34;
        assert isinstance(bb, BoundingBox)
        return self.hasintersection(bb) and self.cover(bb) == 1.0
        
    def ispointinside(self, p):
        &#34;&#34;&#34;Is the 2D point p=(x,y) inside this boundingbox, or is the p=boundingbox() inside this bounding box?&#34;&#34;&#34;
        assert len(p) == 2, &#34;Invalid 2D point=(x,y) input&#34;
        return (p[0] &gt;= self._xmin) and (p[1] &gt;= self._ymin) and (p[0] &lt;= self._xmax) and (p[1] &lt;= self._ymax)

    def is_point_inside(self, p):
        &#34;&#34;&#34;synonym for `vipy.geometry.BoundingBox.ispointinside`&#34;&#34;&#34;
        return self.ispointinside(p)
    
    def dilate(self, scale=1):
        &#34;&#34;&#34;Change scale of bounding box keeping centroid constant&#34;&#34;&#34;
        assert isnumber(scale), &#34;Invalid input&#34;
        w = (self._xmax - self._xmin)
        h = (self._ymax - self._ymin)
        c = self.centroid()
        old_x = self._xmin
        old_y = self._ymin
        new_x = (float(w) / 2.0) * scale
        new_y = (float(h) / 2.0) * scale
        self._xmin = c[0] - new_x
        self._ymin = c[1] - new_y
        self._xmax = c[0] + new_x
        self._ymax = c[1] + new_y
        return self

    def dilatepx(self, px):
        &#34;&#34;&#34;Dilate by a given pixel amount on all sides, keeping centroid constant&#34;&#34;&#34;
        self._xmin = self._xmin - px
        self._ymin = self._ymin - px
        self._xmax = self._xmax + px
        self._ymax = self._ymax + px
        return self

    def dilate_height(self, scale=1):
        &#34;&#34;&#34;Change scale of bounding box in y direction keeping centroid constant&#34;&#34;&#34;
        h = self.height()
        c = self.centroid()
        self._ymin = c[1] - (float(h) / 2.0) * scale
        self._ymax = c[1] + (float(h) / 2.0) * scale
        return self

    def dilate_width(self, scale=1):
        &#34;&#34;&#34;Change scale of bounding box in x direction keeping centroid constant&#34;&#34;&#34;
        w = self._xmax - self._xmin
        c = self.centroid()
        self._xmin = c[0] - (float(w) / 2.0) * scale
        self._xmax = c[0] + (float(w) / 2.0) * scale
        return self

    def top(self, dy):
        &#34;&#34;&#34;Make top of box taller (closer to top of image) by an offset dy&#34;&#34;&#34;
        self._ymin = self._ymin - dy
        return self

    def bottom(self, dy):
        &#34;&#34;&#34;Make bottom of box taller (closer to bottom of image) by an offset dy&#34;&#34;&#34;
        self._ymax = self._ymax + dy
        return self

    def left(self, dx):
        &#34;&#34;&#34;Make left of box wider (closer to left side of image) by an offset dx&#34;&#34;&#34;
        self._xmin = self._xmin - dx
        return self

    def right(self, dx):
        &#34;&#34;&#34;Make right of box wider (closer to right side of image) by an offset dx&#34;&#34;&#34;
        self._xmax = self._xmax + dx
        return self

    def rescale(self, s):
        &#34;&#34;&#34;Multiply the box corners by a scale factor&#34;&#34;&#34;
        self._xmin = s * self._xmin
        self._ymin = s * self._ymin
        self._xmax = s * self._xmax
        self._ymax = s * self._ymax
        return self

    def scale_x(self, s):
        &#34;&#34;&#34;Multiply the box corners in the x dimension by a scale factor&#34;&#34;&#34;
        self._xmin = s * self._xmin
        self._xmax = s * self._xmax
        return self

    def scale_y(self, s):
        &#34;&#34;&#34;Multiply the box corners in the y dimension by a scale factor&#34;&#34;&#34;
        self._ymin = s * self._ymin
        self._ymax = s * self._ymax
        return self

    def resize(self, width, height):
        &#34;&#34;&#34;Change the aspect ratio width and height of the box&#34;&#34;&#34;
        self.setwidth(width)
        self.setheight(height)
        return self

    def rot90cw(self, H, W):
        &#34;&#34;&#34;Rotate a bounding box such that if an image of size (H,W) is rotated 90 deg clockwise, the boxes align&#34;&#34;&#34;
        (x,y,w,h) = self.xywh()
        (blx, bly) = self.bottomleft()
        return self.xywh((H - bly, blx, h, w))

    def rot90ccw(self, H, W):
        &#34;&#34;&#34;Rotate a bounding box such that if an image of size (H,W) is rotated 90 deg counter clockwise, the boxes align&#34;&#34;&#34;
        (x,y,w,h) = self.xywh()
        (urx, ury) = self.upperright()
        return self.xywh((ury, W - urx, h, w))

    def fliplr(self, img=None, width=None):
        &#34;&#34;&#34;Flip the box left/right consistent with fliplr of the provided img (or consistent with the image width)&#34;&#34;&#34;
        if img is not None:
            assert isnumpy(img), &#34;Invalid numpy image input&#34;
            width = img.shape[1]
        else:
            assert isnumber(width), &#34;Invalid width&#34;
        (x,y,w,h) = self.xywh()
        self._xmin = width - self._xmax
        self._xmax = self._xmin + w
        return self

    def flipud(self, img=None, height=None):
        &#34;&#34;&#34;Flip the box up/down consistent with flipud of the provided img (or consistent with the image height)&#34;&#34;&#34;
        if img is not None:
            assert isnumpy(img), &#34;Invalid numpy image input&#34;
            height = img.shape[0]
        else:
            assert height is not None and isnumber(height), &#34;Invalid height&#34;
        (x,y,w,h) = self.xywh()
        self._ymin = height - self._ymax
        self._ymax = self._ymin + h
        return self

    def imscale(self, im):
        &#34;&#34;&#34;Given a vipy.image object im, scale the box to be within [0,1], relative to height and width of image&#34;&#34;&#34;
        w = (1.0 / float(im.width()))
        h = (1.0 / float(im.height()))
        self._xmin = w * self._xmin
        self._ymin = h * self._ymin
        self._xmax = w * self._xmax
        self._ymax = h * self._ymax
        return self

    def maxsquare(self):
        &#34;&#34;&#34;Set the bounding box to be square by setting width and height to the maximum dimension of the box, keeping centroid constant&#34;&#34;&#34;
        (height, width) = (self._ymax-self._ymin, self._xmax-self._xmin)                            
        if width != height:
            dim = float(max(width, height))
            c = self.centroid()
            self._xmin = c[0] - (dim / 2.0)
            self._ymin = c[1] - (dim / 2.0)
            self._xmax = c[0] + (dim / 2.0)
            self._ymax = c[1] + (dim / 2.0)
        return self

    def issquare(self):
        return np.allclose(self.height(), self.width())

    def iseven(self):
        &#34;&#34;&#34;Are all corners even number integers?&#34;&#34;&#34;
        return (isinstance(self.xmin(), int) and self.xmin() % 2 == 0 and
                isinstance(self.ymin(), int) and self.ymin() % 2 == 0 and
                isinstance(self.xmax(), int) and self.xmax() % 2 == 0 and
                isinstance(self.ymax(), int) and self.ymax() % 2 == 0)

    def even(self):
        &#34;&#34;&#34;Force all corners to be even number integers.  This is helpful for FFMPEG crop filters.&#34;&#34;&#34;
        self.int()
        self._xmin = (self._xmin // 2) * 2
        self._ymin = (self._ymin // 2) * 2
        self._xmax = (self._xmax // 2) * 2
        self._ymax = (self._ymax // 2) * 2
        return self

    def minsquare(self):
        &#34;&#34;&#34;Set the bounding box to be square by setting width and height to the minimum dimension of the box, keeping centroid constant&#34;&#34;&#34;
        (height, width) = (self._ymax-self._ymin, self._xmax-self._xmin)                            
        if width != height:
            dim = float(min(width, height))
            c = self.centroid()
            self._xmin = c[0] - (dim / 2.0)
            self._ymin = c[1] - (dim / 2.0)
            self._xmax = c[0] + (dim / 2.0)
            self._ymax = c[1] + (dim / 2.0)
        return self

    def hasoverlap(self, img=None, width=None, height=None):
        &#34;&#34;&#34;Does the bounding box intersect with the provided image rectangle?&#34;&#34;&#34;
        if img is not None:
            assert isnumpy(img), &#34;Invalid image input&#34;
            (width, height) = (img.shape[1], img.shape[0])
        else:
            assert width is not None and height is not None, &#34;Invalid width and height - both must be provided&#34;
            assert isnumber(width) and isnumber(height), &#34;Invalid width and height - both must be numbers&#34;
        return self.area_of_intersection(BoundingBox(xmin=0, ymin=0, width=width, height=height)) &gt; 0

    def isinterior(self, width, height, border=1.0):
        &#34;&#34;&#34;Is this boundingbox fully within the provided image rectangle?  
        
           * If border in [0,1], then the image is dilated by a border percentage prior to computing interior, useful to check if self is near the image edge
           * If border=0.8, then the image rectangle is dilated by 80% (smaller) keeping the centroid constant. 
        &#34;&#34;&#34;
        assert border &gt; 0 and border &lt;= 1, &#34;Border must be a dilation fraction of the image, such that the image centroid is constant and the sides are dilated by a scale [0,1]&#34;
        return self.isinside(imagebox((height, width)).dilate(border))

    def iminterior(self, W, H):
        &#34;&#34;&#34;Transform bounding box to be interior to the image rectangle with shape (W,H).  
           Transform is applyed by computing smallest (dx,dy) translation that it is interior to the image rectangle, then clip to the image rectangle if it is too big to fit
        &#34;&#34;&#34;        
        assert self.intersection(BoundingBox(xmin=0, ymin=0, width=W, height=H)).area() &gt; 0, &#34;Bounding box must intersect image rectangle&#34;
        self.translate(dx=0 if self.xmin()&gt;0 else -self.xmin(),
                       dy=0 if self.ymin()&gt;0 else -self.ymin())
        self.translate(dx=0 if self.xmax()&lt;W else -(W-self.xmax()),
                       dy=0 if self.ymax()&lt;H else -(H-self.ymax()))
        return self.imclip(width=W, height=H)
        
    def imclip(self, img=None, width=None, height=None):
        &#34;&#34;&#34;Clip bounding box to image rectangle [0,0,width,height] or img.shape=(width, height) and, throw an exception on an invalid box&#34;&#34;&#34;
        if img is not None:
            assert isnumpy(img), &#34;Invalid numpy image input&#34;
            (height, width) = (img.shape[0], img.shape[1])
        else:
            assert width is not None and height is not None, &#34;Invalid width and height - both must be provided&#34;
            assert isnumber(width) and isnumber(height), &#34;Invalid width and height - both must be numbers&#34;
        return self.intersection(BoundingBox(xmin=0, ymin=0, width=width, height=height), strict=True)

    def imclipshape(self, W, H):
        &#34;&#34;&#34;Clip bounding box to image rectangle [0,0,W-1,H-1], throw an exception on an invalid box&#34;&#34;&#34;
        return self.imclip(width=W, height=H)

    def convexhull(self, fr):
        &#34;&#34;&#34;Given a set of points [[x1,y1],[x2,xy],...], return the bounding rectangle, typecast to float&#34;&#34;&#34;
        self._xmin = float(np.min(fr[:,0]))
        self._ymin = float(np.min(fr[:,1]))
        self._xmax = float(np.max(fr[:,0]))
        self._ymax = float(np.max(fr[:,1]))
        return self

    def aspectratio(self):
        &#34;&#34;&#34;Return the aspect ratio (width/height) of the box&#34;&#34;&#34;
        (height, width) = (self._ymax-self._ymin, self._xmax-self._xmin)                            
        assert height &gt; 0
        return float(width) / float(height)

    def shape(self):
        &#34;&#34;&#34;Return the (height, width) tuple for the box shape&#34;&#34;&#34;
        return (self._ymax-self._ymin, self._xmax-self._xmin)                            
    
    def mindimension(self):
        &#34;&#34;&#34;Return min(width, height) typecast to float&#34;&#34;&#34;
        return float(np.min(self.shape()))

    def mindim(self):
        &#34;&#34;&#34;Return min(width, height) typecast to float&#34;&#34;&#34;
        return float(np.min(self.shape()))

    def maxdim(self):
        &#34;&#34;&#34;Return max(width, height) typecast to float&#34;&#34;&#34;
        return float(np.max(self.shape())) 
    
    def ellipse(self):
        &#34;&#34;&#34;Convert the boundingbox to a vipy.geometry.Ellipse object&#34;&#34;&#34;
        (xcenter,ycenter) = self.centroid()
        return Ellipse(self.width() / 2.0, self.height() / 2.0, xcenter, ycenter, 0)

    def average(self, other):
        &#34;&#34;&#34;Compute the average bounding box between self and other, and set self to the average.  Other may be a singleton bounding box or a list of bounding boxes&#34;&#34;&#34;
        assert all([isinstance(bb, BoundingBox) for bb in tolist(other)]), &#34;Invalid input - must be BoundingBox&#34;        
        return self.ulbr(np.mean( [self.ulbr()] + [bb.ulbr() for bb in tolist(other)], axis=0))

    def averageshape(self, other):
        &#34;&#34;&#34;Compute the average bounding box width and height between self and other.  Other may be a singleton bounding box or a list of bounding boxes&#34;&#34;&#34;
        assert all([isinstance(bb, BoundingBox) for bb in tolist(other)]), &#34;Invalid input - must be BoundingBox&#34;        
        (xmin, ymin, xmax, ymax) = np.mean( [self.ulbr()] + [bb.ulbr() for bb in tolist(other)], axis=0)
        self.setwidth(xmax-xmin)
        self.setheight(ymax-ymin)        
        return self

    def medianshape(self, other):
        &#34;&#34;&#34;Compute the median bounding box width and height between self and other.  Other may be a singleton bounding box or a list of bounding boxes&#34;&#34;&#34;
        assert all([isinstance(bb, BoundingBox) for bb in tolist(other)]), &#34;Invalid input - must be BoundingBox&#34;        
        (height, width) = np.median( [self.shape()] + [bb.shape() for bb in tolist(other)], axis=0)
        self.setwidth(width)
        self.setheight(height)
        return self

    def shapedist(self, other):
        &#34;&#34;&#34;L1 distance between (width,height) of two boxes&#34;&#34;&#34;
        assert isinstance(other, BoundingBox), &#34;Invalid input - must be BoundingBox()&#34;                
        return np.abs(self.width()-other.width())  + np.abs(self.height()-other.height())

    def affine(self, A):
        &#34;&#34;&#34;Apply an 2x3 affine transformation to the box centroid.  

        .. note::  This transformation is performed on the centroid and not the box corners, so the box will still be rectilinear after the transform
        &#34;&#34;&#34;
        assert isnumpy(A) and A.shape == (2,3), &#34;A must be a 2x3 affine transformation matrix&#34;
        return self.centroid(np.dot(A, homogenize(np.array(self.centroid()))))

    def projective(self, A):
        &#34;&#34;&#34;Apply an 3x3 projective transformation to the box centroid.  
        
        .. note:: This transformation is performed on the centroid and not the box corners, so the box will still be rectilinear after the transform
        &#34;&#34;&#34;
        assert isnumpy(A) and A.shape == (3,3), &#34;A must be a 3x3 affine transformation matrix&#34;
        return self.centroid(dehomogenize(np.dot(A, homogenize(np.array(self.centroid())))))
    
    def crop(self, img):
        &#34;&#34;&#34;Crop an HxW 2D numpy image, HxWxC 3D numpy image, or NxHxWxC 4D numpy image array using this bounding box applied to HxW dimensions.  Crop is performed in-place. &#34;&#34;&#34;
        assert isnumpy(img) and img.ndim in [2,3,4]
        assert self.isinteger(), &#34;Box corners must be integer - try calling self.int()&#34;

        if img.ndim == 2:
            return img[self.ymin():self.ymax(), self.xmin():self.xmax()]  # HxW
        elif img.ndim == 3:
            return img[self.ymin():self.ymax(), self.xmin():self.xmax(), :]  # HxWxC
        else: 
            return img[:, self.ymin():self.ymax(), self.xmin():self.xmax(), :]  # NxHxWxC

    def grid(self, rows, cols):
        &#34;&#34;&#34;Split a bounding box into the smallest grid of non-overlapping bounding boxes such that the union is the original box&#34;&#34;&#34;
        (w,h) = (self.width()/cols, self.height()/rows)
        return [BoundingBox(xmin=x, ymin=y, width=w, height=h) for x in np.arange(self._xmin, self._xmax, w) for y in np.arange(self._ymin, self._ymax, h)]</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="vipy.object.Detection" href="object.html#vipy.object.Detection">Detection</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="vipy.geometry.BoundingBox.cast"><code class="name flex">
<span>def <span class="ident">cast</span></span>(<span>bb, flush=False)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="vipy.geometry.BoundingBox.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>s)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="vipy.geometry.BoundingBox.affine"><code class="name flex">
<span>def <span class="ident">affine</span></span>(<span>self, A)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply an 2x3 affine transformation to the box centroid.
</p>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;This transformation is performed on the centroid and not the box corners, so the box will still be rectilinear after the transform</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L932-L938" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def affine(self, A):
    &#34;&#34;&#34;Apply an 2x3 affine transformation to the box centroid.  

    .. note::  This transformation is performed on the centroid and not the box corners, so the box will still be rectilinear after the transform
    &#34;&#34;&#34;
    assert isnumpy(A) and A.shape == (2,3), &#34;A must be a 2x3 affine transformation matrix&#34;
    return self.centroid(np.dot(A, homogenize(np.array(self.centroid()))))</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.area"><code class="name flex">
<span>def <span class="ident">area</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the area=width*height of the bounding box, internal method useful for multiple inheritance</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L461-L464" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def area(self):
    &#34;&#34;&#34;Return the area=width*height of the bounding box, internal method useful for multiple inheritance&#34;&#34;&#34;
    (height, width) = (self._ymax-self._ymin, self._xmax-self._xmin)        
    return width * height if (height&gt;0 and width&gt;0) else 0</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.area_of_intersection"><code class="name flex">
<span>def <span class="ident">area_of_intersection</span></span>(<span>self, bb, strict=True)</span>
</code></dt>
<dd>
<div class="desc"><p>area of intersection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L553-L563" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def area_of_intersection(self, bb, strict=True):
    &#34;&#34;&#34;area of intersection&#34;&#34;&#34;
    if strict:
        assert isinstance(bb, BoundingBox), &#34;Invalid BoundingBox() input of type &#39;%s&#39;&#34; % str(type(bb))                
    w = min(self._xmax, bb._xmax) - max(self._xmin, bb._xmin)
    if w &lt;= 0:
        return 0  # invalid (no overlap), early exit 
    h = min(self._ymax, bb._ymax) - max(self._ymin, bb._ymin)
    if h &lt;= 0:
        return 0  # invalid (no overlap), early exit 
    return w*h</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.area_of_union"><code class="name flex">
<span>def <span class="ident">area_of_union</span></span>(<span>self, bb)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L565-L566" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def area_of_union(self, bb):
    return self.area() + bb.area() - self.area_of_intersection(bb)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.aspectratio"><code class="name flex">
<span>def <span class="ident">aspectratio</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the aspect ratio (width/height) of the box</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L879-L883" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def aspectratio(self):
    &#34;&#34;&#34;Return the aspect ratio (width/height) of the box&#34;&#34;&#34;
    (height, width) = (self._ymax-self._ymin, self._xmax-self._xmin)                            
    assert height &gt; 0
    return float(width) / float(height)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.average"><code class="name flex">
<span>def <span class="ident">average</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the average bounding box between self and other, and set self to the average.
Other may be a singleton bounding box or a list of bounding boxes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L906-L909" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def average(self, other):
    &#34;&#34;&#34;Compute the average bounding box between self and other, and set self to the average.  Other may be a singleton bounding box or a list of bounding boxes&#34;&#34;&#34;
    assert all([isinstance(bb, BoundingBox) for bb in tolist(other)]), &#34;Invalid input - must be BoundingBox&#34;        
    return self.ulbr(np.mean( [self.ulbr()] + [bb.ulbr() for bb in tolist(other)], axis=0))</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.averageshape"><code class="name flex">
<span>def <span class="ident">averageshape</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the average bounding box width and height between self and other.
Other may be a singleton bounding box or a list of bounding boxes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L911-L917" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def averageshape(self, other):
    &#34;&#34;&#34;Compute the average bounding box width and height between self and other.  Other may be a singleton bounding box or a list of bounding boxes&#34;&#34;&#34;
    assert all([isinstance(bb, BoundingBox) for bb in tolist(other)]), &#34;Invalid input - must be BoundingBox&#34;        
    (xmin, ymin, xmax, ymax) = np.mean( [self.ulbr()] + [bb.ulbr() for bb in tolist(other)], axis=0)
    self.setwidth(xmax-xmin)
    self.setheight(ymax-ymin)        
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.bbclone"><code class="name flex">
<span>def <span class="ident">bbclone</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L216-L217" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def bbclone(self):
    return BoundingBox(xmin=self._xmin, xmax=self._xmax, ymin=self._ymin, ymax=self._ymax)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.bl"><code class="name flex">
<span>def <span class="ident">bl</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Bottom left coordinate (x,y), synonym for ll()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L266-L268" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def bl(self):
    &#34;&#34;&#34;Bottom left coordinate (x,y), synonym for ll()&#34;&#34;&#34;
    return (self._xmin, self._ymax)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.blx"><code class="name flex">
<span>def <span class="ident">blx</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Bottom left coordinate (x)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L270-L272" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def blx(self):
    &#34;&#34;&#34;Bottom left coordinate (x)&#34;&#34;&#34;
    return self.bl()[0]</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.bly"><code class="name flex">
<span>def <span class="ident">bly</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Bottom left coordinate (y)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L274-L276" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def bly(self):
    &#34;&#34;&#34;Bottom left coordinate (y)&#34;&#34;&#34;
    return self.bl()[1]</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.bottom"><code class="name flex">
<span>def <span class="ident">bottom</span></span>(<span>self, dy)</span>
</code></dt>
<dd>
<div class="desc"><p>Make bottom of box taller (closer to bottom of image) by an offset dy</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L697-L700" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def bottom(self, dy):
    &#34;&#34;&#34;Make bottom of box taller (closer to bottom of image) by an offset dy&#34;&#34;&#34;
    self._ymax = self._ymax + dy
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.bottomleft"><code class="name flex">
<span>def <span class="ident">bottomleft</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the (x,y) lower left corner coordinate of the box</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L313-L315" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def bottomleft(self):
    &#34;&#34;&#34;Return the (x,y) lower left corner coordinate of the box&#34;&#34;&#34;
    return (self.xmin(), self.ymax())</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.bottomright"><code class="name flex">
<span>def <span class="ident">bottomright</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the (x,y) lower right corner coordinate of the box</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L321-L323" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def bottomright(self):
    &#34;&#34;&#34;Return the (x,y) lower right corner coordinate of the box&#34;&#34;&#34;
    return (self.xmax(), self.ymax())</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.br"><code class="name flex">
<span>def <span class="ident">br</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Bottom right coordinate (x,y), synonym for lr()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L282-L284" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def br(self):
    &#34;&#34;&#34;Bottom right coordinate (x,y), synonym for lr()&#34;&#34;&#34;
    return (self._xmax, self._ymax)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.brx"><code class="name flex">
<span>def <span class="ident">brx</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Bottom right coordinate (x)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L286-L288" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def brx(self):
    &#34;&#34;&#34;Bottom right coordinate (x)&#34;&#34;&#34;
    return self.br()[0]</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.bry"><code class="name flex">
<span>def <span class="ident">bry</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Bottom right coordinate (y)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L290-L292" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def bry(self):
    &#34;&#34;&#34;Bottom right coordinate (y)&#34;&#34;&#34;
    return self.br()[1]</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.centroid"><code class="name flex">
<span>def <span class="ident">centroid</span></span>(<span>self, c=None)</span>
</code></dt>
<dd>
<div class="desc"><p>(x,y) tuple of centroid position of bounding box</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L427-L439" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def centroid(self, c=None):
    &#34;&#34;&#34;(x,y) tuple of centroid position of bounding box&#34;&#34;&#34;        
    if c is None:
        (height, width) = (self._ymax-self._ymin, self._xmax-self._xmin)            
        return (self._xmin + (float(width) / 2.0), self._ymin + (float(height) / 2.0))
    else:
        assert len(c) == 2
        (height, width) = (self._ymax-self._ymin, self._xmax-self._xmin)
        self._xmin = float(c[0]) - (width / 2.0)
        self._ymin = float(c[1]) - (height / 2.0)
        self._xmax = float(c[0]) + (width / 2.0)
        self._ymax = float(c[1]) + (height / 2.0)
        return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.centroid_x"><code class="name flex">
<span>def <span class="ident">centroid_x</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for x_centroid()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L447-L449" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def centroid_x(self):
    &#34;&#34;&#34;Alias for x_centroid()&#34;&#34;&#34;
    return self.centroid()[0]</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.centroid_y"><code class="name flex">
<span>def <span class="ident">centroid_y</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for y_centroid()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L457-L459" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def centroid_y(self):
    &#34;&#34;&#34;Alias for y_centroid()&#34;&#34;&#34;
    return self.centroid()[1]</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.clone"><code class="name flex">
<span>def <span class="ident">clone</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L214-L215" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def clone(self):
    return BoundingBox(xmin=self._xmin, xmax=self._xmax, ymin=self._ymin, ymax=self._ymax)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.convexhull"><code class="name flex">
<span>def <span class="ident">convexhull</span></span>(<span>self, fr)</span>
</code></dt>
<dd>
<div class="desc"><p>Given a set of points [[x1,y1],[x2,xy],&hellip;], return the bounding rectangle, typecast to float</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L871-L877" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def convexhull(self, fr):
    &#34;&#34;&#34;Given a set of points [[x1,y1],[x2,xy],...], return the bounding rectangle, typecast to float&#34;&#34;&#34;
    self._xmin = float(np.min(fr[:,0]))
    self._ymin = float(np.min(fr[:,1]))
    self._xmax = float(np.max(fr[:,0]))
    self._ymax = float(np.max(fr[:,1]))
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.cover"><code class="name flex">
<span>def <span class="ident">cover</span></span>(<span>self, bb)</span>
</code></dt>
<dd>
<div class="desc"><p>Fraction of this bounding box intersected by other bbox (bb).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<ul>
<li>Cover is often more useful than <code><a title="vipy.geometry.BoundingBox.iou" href="#vipy.geometry.BoundingBox.iou">BoundingBox.iou()</a></code> as a measure of overlap due to bounding box distortion from partially occluded object proposals.
</li>
<li>For example, an object proposal of a person may generate a smaller box (e.g. just the torso) when the lower body is occluded whereas a track will have the full body box.
</li>
<li><code><a title="vipy.geometry.BoundingBox.maxcover" href="#vipy.geometry.BoundingBox.maxcover">BoundingBox.maxcover()</a></code> is a better measure of assignment in this case.</li>
</ul>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L568-L579" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def cover(self, bb):
    &#34;&#34;&#34;Fraction of this bounding box intersected by other bbox (bb).

    .. note:: 
    
        - Cover is often more useful than `vipy.geometry.BoundingBox.iou` as a measure of overlap due to bounding box distortion from partially occluded object proposals.  
        - For example, an object proposal of a person may generate a smaller box (e.g. just the torso) when the lower body is occluded whereas a track will have the full body box.  
        - `vipy.geometry.BoundingBox.maxcover` is a better measure of assignment in this case.  

    &#34;&#34;&#34;
    a = float(self.area())
    return (self.area_of_intersection(bb) / a) if a&gt;0 else 0</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.crop"><code class="name flex">
<span>def <span class="ident">crop</span></span>(<span>self, img)</span>
</code></dt>
<dd>
<div class="desc"><p>Crop an HxW 2D numpy image, HxWxC 3D numpy image, or NxHxWxC 4D numpy image array using this bounding box applied to HxW dimensions.
Crop is performed in-place.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L948-L958" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def crop(self, img):
    &#34;&#34;&#34;Crop an HxW 2D numpy image, HxWxC 3D numpy image, or NxHxWxC 4D numpy image array using this bounding box applied to HxW dimensions.  Crop is performed in-place. &#34;&#34;&#34;
    assert isnumpy(img) and img.ndim in [2,3,4]
    assert self.isinteger(), &#34;Box corners must be integer - try calling self.int()&#34;

    if img.ndim == 2:
        return img[self.ymin():self.ymax(), self.xmin():self.xmax()]  # HxW
    elif img.ndim == 3:
        return img[self.ymin():self.ymax(), self.xmin():self.xmax(), :]  # HxWxC
    else: 
        return img[:, self.ymin():self.ymax(), self.xmin():self.xmax(), :]  # NxHxWxC</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.cxywh"><code class="name flex">
<span>def <span class="ident">cxywh</span></span>(<span>self, cxywh=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return or set bounding box corners as (centroidx,centroidy,width,height) tuple</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L483-L490" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def cxywh(self, cxywh=None):
    &#34;&#34;&#34;Return or set bounding box corners as (centroidx,centroidy,width,height) tuple&#34;&#34;&#34;
    if cxywh is None:
        (height, width) = (self._ymax-self._ymin, self._xmax-self._xmin)                    
        return tuple([self.x_centroid(), self.y_centroid(), width, height])
    else:
        assert len(cxywh) == 4, &#34;Invalid (xcentroid, ycentroid, width, height) input&#34;
        return self.centroid( (cxywh[0], cxywh[1]) ).setwidth(cxywh[2]).setheight(cxywh[3])            </code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.dict"><code class="name flex">
<span>def <span class="ident">dict</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a python dictionary containing the relevant serialized attributes suitable for JSON encoding</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L202-L204" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dict(self):
    &#34;&#34;&#34;Return a python dictionary containing the relevant serialized attributes suitable for JSON encoding&#34;&#34;&#34;
    return self.json(encode=False)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.dilate"><code class="name flex">
<span>def <span class="ident">dilate</span></span>(<span>self, scale=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Change scale of bounding box keeping centroid constant</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L652-L666" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dilate(self, scale=1):
    &#34;&#34;&#34;Change scale of bounding box keeping centroid constant&#34;&#34;&#34;
    assert isnumber(scale), &#34;Invalid input&#34;
    w = (self._xmax - self._xmin)
    h = (self._ymax - self._ymin)
    c = self.centroid()
    old_x = self._xmin
    old_y = self._ymin
    new_x = (float(w) / 2.0) * scale
    new_y = (float(h) / 2.0) * scale
    self._xmin = c[0] - new_x
    self._ymin = c[1] - new_y
    self._xmax = c[0] + new_x
    self._ymax = c[1] + new_y
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.dilate_height"><code class="name flex">
<span>def <span class="ident">dilate_height</span></span>(<span>self, scale=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Change scale of bounding box in y direction keeping centroid constant</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L676-L682" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dilate_height(self, scale=1):
    &#34;&#34;&#34;Change scale of bounding box in y direction keeping centroid constant&#34;&#34;&#34;
    h = self.height()
    c = self.centroid()
    self._ymin = c[1] - (float(h) / 2.0) * scale
    self._ymax = c[1] + (float(h) / 2.0) * scale
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.dilate_width"><code class="name flex">
<span>def <span class="ident">dilate_width</span></span>(<span>self, scale=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Change scale of bounding box in x direction keeping centroid constant</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L684-L690" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dilate_width(self, scale=1):
    &#34;&#34;&#34;Change scale of bounding box in x direction keeping centroid constant&#34;&#34;&#34;
    w = self._xmax - self._xmin
    c = self.centroid()
    self._xmin = c[0] - (float(w) / 2.0) * scale
    self._xmax = c[0] + (float(w) / 2.0) * scale
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.dilatepx"><code class="name flex">
<span>def <span class="ident">dilatepx</span></span>(<span>self, px)</span>
</code></dt>
<dd>
<div class="desc"><p>Dilate by a given pixel amount on all sides, keeping centroid constant</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L668-L674" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dilatepx(self, px):
    &#34;&#34;&#34;Dilate by a given pixel amount on all sides, keeping centroid constant&#34;&#34;&#34;
    self._xmin = self._xmin - px
    self._ymin = self._ymin - px
    self._xmax = self._xmax + px
    self._ymax = self._ymax + px
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.dist"><code class="name flex">
<span>def <span class="ident">dist</span></span>(<span>self, bb)</span>
</code></dt>
<dd>
<div class="desc"><p>Distance between centroids of two bounding boxes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L521-L524" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dist(self, bb):
    &#34;&#34;&#34;Distance between centroids of two bounding boxes&#34;&#34;&#34;
    assert isinstance(bb, BoundingBox), &#34;Invalid BoundingBox() input of type &#39;%s&#39;&#34; % str(type(bb))                
    return np.sqrt(np.sum(np.square(np.array(bb.centroid()) - np.array(self.centroid()))))</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.dx"><code class="name flex">
<span>def <span class="ident">dx</span></span>(<span>self, bb)</span>
</code></dt>
<dd>
<div class="desc"><p>Offset bounding box by same xmin as provided box</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L508-L510" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dx(self, bb):
    &#34;&#34;&#34;Offset bounding box by same xmin as provided box&#34;&#34;&#34;
    return bb._xmin - self._xmin</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.dy"><code class="name flex">
<span>def <span class="ident">dy</span></span>(<span>self, bb)</span>
</code></dt>
<dd>
<div class="desc"><p>Offset bounding box by ymin of provided box</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L512-L514" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dy(self, bb):
    &#34;&#34;&#34;Offset bounding box by ymin of provided box&#34;&#34;&#34;
    return bb._ymin - self._ymin</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.ellipse"><code class="name flex">
<span>def <span class="ident">ellipse</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert the boundingbox to a vipy.geometry.Ellipse object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L901-L904" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def ellipse(self):
    &#34;&#34;&#34;Convert the boundingbox to a vipy.geometry.Ellipse object&#34;&#34;&#34;
    (xcenter,ycenter) = self.centroid()
    return Ellipse(self.width() / 2.0, self.height() / 2.0, xcenter, ycenter, 0)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.even"><code class="name flex">
<span>def <span class="ident">even</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Force all corners to be even number integers.
This is helpful for FFMPEG crop filters.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L806-L813" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def even(self):
    &#34;&#34;&#34;Force all corners to be even number integers.  This is helpful for FFMPEG crop filters.&#34;&#34;&#34;
    self.int()
    self._xmin = (self._xmin // 2) * 2
    self._ymin = (self._ymin // 2) * 2
    self._xmax = (self._xmax // 2) * 2
    self._ymax = (self._ymax // 2) * 2
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.fliplr"><code class="name flex">
<span>def <span class="ident">fliplr</span></span>(<span>self, img=None, width=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Flip the box left/right consistent with fliplr of the provided img (or consistent with the image width)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L750-L760" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def fliplr(self, img=None, width=None):
    &#34;&#34;&#34;Flip the box left/right consistent with fliplr of the provided img (or consistent with the image width)&#34;&#34;&#34;
    if img is not None:
        assert isnumpy(img), &#34;Invalid numpy image input&#34;
        width = img.shape[1]
    else:
        assert isnumber(width), &#34;Invalid width&#34;
    (x,y,w,h) = self.xywh()
    self._xmin = width - self._xmax
    self._xmax = self._xmin + w
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.flipud"><code class="name flex">
<span>def <span class="ident">flipud</span></span>(<span>self, img=None, height=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Flip the box up/down consistent with flipud of the provided img (or consistent with the image height)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L762-L772" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def flipud(self, img=None, height=None):
    &#34;&#34;&#34;Flip the box up/down consistent with flipud of the provided img (or consistent with the image height)&#34;&#34;&#34;
    if img is not None:
        assert isnumpy(img), &#34;Invalid numpy image input&#34;
        height = img.shape[0]
    else:
        assert height is not None and isnumber(height), &#34;Invalid height&#34;
    (x,y,w,h) = self.xywh()
    self._ymin = height - self._ymax
    self._ymax = self._ymin + h
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.float"><code class="name flex">
<span>def <span class="ident">float</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert corners to float</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L344-L350" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def float(self):
    &#34;&#34;&#34;Convert corners to float&#34;&#34;&#34;
    self._xmin = float(self._xmin)
    self._ymin = float(self._ymin)
    self._xmax = float(self._xmax)
    self._ymax = float(self._ymax)
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.grid"><code class="name flex">
<span>def <span class="ident">grid</span></span>(<span>self, rows, cols)</span>
</code></dt>
<dd>
<div class="desc"><p>Split a bounding box into the smallest grid of non-overlapping bounding boxes such that the union is the original box</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L960-L963" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def grid(self, rows, cols):
    &#34;&#34;&#34;Split a bounding box into the smallest grid of non-overlapping bounding boxes such that the union is the original box&#34;&#34;&#34;
    (w,h) = (self.width()/cols, self.height()/rows)
    return [BoundingBox(xmin=x, ymin=y, width=w, height=h) for x in np.arange(self._xmin, self._xmax, w) for y in np.arange(self._ymin, self._ymax, h)]</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.hasintersection"><code class="name flex">
<span>def <span class="ident">hasintersection</span></span>(<span>self, bb, iou=None, cover=None, maxcover=None, bbcover=None, area=None, otherarea=None, gate=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Return true if self and bb overlap by any amount, or by the cover threshold (if provided) or the iou threshold (if provided).
This is a convenience function that allows for shared computation for fast non-maximum suppression.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L610-L626" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def hasintersection(self, bb, iou=None, cover=None, maxcover=None, bbcover=None, area=None, otherarea=None, gate=0):
    &#34;&#34;&#34;Return true if self and bb overlap by any amount, or by the cover threshold (if provided) or the iou threshold (if provided).  This is a convenience function that allows for shared computation for fast non-maximum suppression.&#34;&#34;&#34;

    if not (((self._xmax if self._xmax &lt; bb._xmax else bb._xmax) - (self._xmin if self._xmin &gt; bb._xmin else bb._xmin)) &gt; (-gate) and
            ((self._ymax if self._ymax &lt; bb._ymax else bb._ymax) - (self._ymin if self._ymin &gt; bb._ymin else bb._ymin)) &gt; (-gate)):  # faster than min(x,y)-max(x,y)
        return False  # does not intersect
    
    elif maxcover is not None or iou is not None or cover is not None or bbcover is not None:
        aoi = self.area_of_intersection(bb, strict=False)            
        otherarea = otherarea if otherarea is not None else (bb.area() if (maxcover is not None or bbcover is not None or iou is not None) else 0)
        area = area if area is not None else (self.area() if (maxcover is not None or cover is not None or iou is not None) else 0)
        return (((maxcover is not None) and (max(aoi/area, aoi/otherarea) &gt; maxcover)) or
                ((iou is not None) and ((aoi / (area+otherarea-aoi)) &gt;= iou)) or
                ((cover is not None) and ((aoi / area) &gt;= cover)) or
                ((bbcover is not None) and ((aoi / otherarea) &gt;= bbcover)))
    else:
        return True</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.hasoverlap"><code class="name flex">
<span>def <span class="ident">hasoverlap</span></span>(<span>self, img=None, width=None, height=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Does the bounding box intersect with the provided image rectangle?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L827-L835" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def hasoverlap(self, img=None, width=None, height=None):
    &#34;&#34;&#34;Does the bounding box intersect with the provided image rectangle?&#34;&#34;&#34;
    if img is not None:
        assert isnumpy(img), &#34;Invalid image input&#34;
        (width, height) = (img.shape[1], img.shape[0])
    else:
        assert width is not None and height is not None, &#34;Invalid width and height - both must be provided&#34;
        assert isnumber(width) and isnumber(height), &#34;Invalid width and height - both must be numbers&#34;
    return self.area_of_intersection(BoundingBox(xmin=0, ymin=0, width=width, height=height)) &gt; 0</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.height"><code class="name flex">
<span>def <span class="ident">height</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L424-L425" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def height(self):
    return self._ymax - self._ymin</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.imclip"><code class="name flex">
<span>def <span class="ident">imclip</span></span>(<span>self, img=None, width=None, height=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Clip bounding box to image rectangle [0,0,width,height] or img.shape=(width, height) and, throw an exception on an invalid box</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L857-L865" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def imclip(self, img=None, width=None, height=None):
    &#34;&#34;&#34;Clip bounding box to image rectangle [0,0,width,height] or img.shape=(width, height) and, throw an exception on an invalid box&#34;&#34;&#34;
    if img is not None:
        assert isnumpy(img), &#34;Invalid numpy image input&#34;
        (height, width) = (img.shape[0], img.shape[1])
    else:
        assert width is not None and height is not None, &#34;Invalid width and height - both must be provided&#34;
        assert isnumber(width) and isnumber(height), &#34;Invalid width and height - both must be numbers&#34;
    return self.intersection(BoundingBox(xmin=0, ymin=0, width=width, height=height), strict=True)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.imclipshape"><code class="name flex">
<span>def <span class="ident">imclipshape</span></span>(<span>self, W, H)</span>
</code></dt>
<dd>
<div class="desc"><p>Clip bounding box to image rectangle [0,0,W-1,H-1], throw an exception on an invalid box</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L867-L869" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def imclipshape(self, W, H):
    &#34;&#34;&#34;Clip bounding box to image rectangle [0,0,W-1,H-1], throw an exception on an invalid box&#34;&#34;&#34;
    return self.imclip(width=W, height=H)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.iminterior"><code class="name flex">
<span>def <span class="ident">iminterior</span></span>(<span>self, W, H)</span>
</code></dt>
<dd>
<div class="desc"><p>Transform bounding box to be interior to the image rectangle with shape (W,H).<br>
Transform is applyed by computing smallest (dx,dy) translation that it is interior to the image rectangle, then clip to the image rectangle if it is too big to fit</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L846-L855" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def iminterior(self, W, H):
    &#34;&#34;&#34;Transform bounding box to be interior to the image rectangle with shape (W,H).  
       Transform is applyed by computing smallest (dx,dy) translation that it is interior to the image rectangle, then clip to the image rectangle if it is too big to fit
    &#34;&#34;&#34;        
    assert self.intersection(BoundingBox(xmin=0, ymin=0, width=W, height=H)).area() &gt; 0, &#34;Bounding box must intersect image rectangle&#34;
    self.translate(dx=0 if self.xmin()&gt;0 else -self.xmin(),
                   dy=0 if self.ymin()&gt;0 else -self.ymin())
    self.translate(dx=0 if self.xmax()&lt;W else -(W-self.xmax()),
                   dy=0 if self.ymax()&lt;H else -(H-self.ymax()))
    return self.imclip(width=W, height=H)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.imscale"><code class="name flex">
<span>def <span class="ident">imscale</span></span>(<span>self, im)</span>
</code></dt>
<dd>
<div class="desc"><p>Given a vipy.image object im, scale the box to be within [0,1], relative to height and width of image</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L774-L782" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def imscale(self, im):
    &#34;&#34;&#34;Given a vipy.image object im, scale the box to be within [0,1], relative to height and width of image&#34;&#34;&#34;
    w = (1.0 / float(im.width()))
    h = (1.0 / float(im.height()))
    self._xmin = w * self._xmin
    self._ymin = h * self._ymin
    self._xmax = w * self._xmax
    self._ymax = h * self._ymax
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.int"><code class="name flex">
<span>def <span class="ident">int</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert corners to integer with rounding, in-place update</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L331-L342" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def int(self):
    &#34;&#34;&#34;Convert corners to integer with rounding, in-place update&#34;&#34;&#34;
    (w,h) = (int(np.round(self.width())), int(np.round(self.height())))
    self._xmin = int(np.round(self._xmin))
    self._ymin = int(np.round(self._ymin))
    self._xmax = int(np.round(self._xmax))
    self._ymax = int(np.round(self._ymax))
    if w != self.width():
        self.right(w - self.width())  # preserve aspect ratio due to rounding by +/- right side of box 
    if h != self.height():
        self.bottom(h-self.height())  # preserve aspect ratio due to rounding by +/- bottom of box
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.intersection"><code class="name flex">
<span>def <span class="ident">intersection</span></span>(<span>self, bb, strict=True)</span>
</code></dt>
<dd>
<div class="desc"><p>Intersection of two bounding boxes, throw an error on degeneracy of intersection result (if strict=True)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L599-L608" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def intersection(self, bb, strict=True):
    &#34;&#34;&#34;Intersection of two bounding boxes, throw an error on degeneracy of intersection result (if strict=True)&#34;&#34;&#34;
    assert isinstance(bb, BoundingBox), &#34;Invalid BoundingBox() input of type &#39;%s&#39;&#34; % str(type(bb))                        
    self._xmin = max(bb._xmin, self._xmin)
    self._ymin = max(bb._ymin, self._ymin)
    self._xmax = min(bb._xmax, self._xmax)
    self._ymax = min(bb._ymax, self._ymax)
    if strict and self.isdegenerate():
        raise ValueError(&#39;Degenerate intersection for bounding boxes &#34;%s&#34; and &#34;%s&#34;&#39; % (str(bb), str(self)))
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.intersection_over_union"><code class="name flex">
<span>def <span class="ident">intersection_over_union</span></span>(<span>self, bb)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for iou</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L549-L551" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def intersection_over_union(self, bb):
    &#34;&#34;&#34;Alias for iou&#34;&#34;&#34;
    return self.iou(bb)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.invalid"><code class="name flex">
<span>def <span class="ident">invalid</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Is the box a valid bounding box?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L382-L386" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def invalid(self):
    &#34;&#34;&#34;Is the box a valid bounding box?&#34;&#34;&#34;
    #is_undefined = np.isnan(self._xmin) or np.isnan(self._ymin) or np.isnan(self._xmax) or np.isnan(self._ymax)
    is_valid = ((self._xmax - self._xmin) &gt;= 0) and ((self._ymax - self._ymin) &gt;= 0)  # if nan, will return False
    return not is_valid</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.iou"><code class="name flex">
<span>def <span class="ident">iou</span></span>(<span>self, bb, area=None, otherarea=None)</span>
</code></dt>
<dd>
<div class="desc"><p>area of intersection / area of union</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L531-L547" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def iou(self, bb, area=None, otherarea=None):
    &#34;&#34;&#34;area of intersection / area of union&#34;&#34;&#34;
    assert bb is None or isinstance(bb, BoundingBox), &#34;Invalid BoundingBox() input of type &#39;%s&#39;&#34; % str(type(bb))        
    if bb is None:
        return 0
    w = min(self._xmax, bb._xmax) - max(self._xmin, bb._xmin)
    if w &lt;= 0:
        return 0  # invalid (no overlap), early exit
    h = min(self._ymax, bb._ymax) - max(self._ymin, bb._ymin)
    if h &lt;= 0:
        return 0  # invalid (no overlap), early exit

    area_intersection = w * h
    area_union = ((self.area() if area is None else area) +
                  (bb.area() if otherarea is None else otherarea) -
                  area_intersection)
    return (area_intersection / float(area_union)) if area_union &gt; 0 else 0</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.is_point_inside"><code class="name flex">
<span>def <span class="ident">is_point_inside</span></span>(<span>self, p)</span>
</code></dt>
<dd>
<div class="desc"><p>synonym for <code><a title="vipy.geometry.BoundingBox.ispointinside" href="#vipy.geometry.BoundingBox.ispointinside">BoundingBox.ispointinside()</a></code></p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L648-L650" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def is_point_inside(self, p):
    &#34;&#34;&#34;synonym for `vipy.geometry.BoundingBox.ispointinside`&#34;&#34;&#34;
    return self.ispointinside(p)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.isdegenerate"><code class="name flex">
<span>def <span class="ident">isdegenerate</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L394-L395" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isdegenerate(self):
    return self.invalid()</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.iseven"><code class="name flex">
<span>def <span class="ident">iseven</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Are all corners even number integers?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L799-L804" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def iseven(self):
    &#34;&#34;&#34;Are all corners even number integers?&#34;&#34;&#34;
    return (isinstance(self.xmin(), int) and self.xmin() % 2 == 0 and
            isinstance(self.ymin(), int) and self.ymin() % 2 == 0 and
            isinstance(self.xmax(), int) and self.xmax() % 2 == 0 and
            isinstance(self.ymax(), int) and self.ymax() % 2 == 0)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.isinside"><code class="name flex">
<span>def <span class="ident">isinside</span></span>(<span>self, bb)</span>
</code></dt>
<dd>
<div class="desc"><p>Is this boundingbox fully within the provided bounding box?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L638-L641" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isinside(self, bb):
    &#34;&#34;&#34;Is this boundingbox fully within the provided bounding box?&#34;&#34;&#34;
    assert isinstance(bb, BoundingBox)
    return self.hasintersection(bb) and self.cover(bb) == 1.0</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.isinteger"><code class="name flex">
<span>def <span class="ident">isinteger</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L325-L329" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isinteger(self):
    return (isinstance(self._xmin, int) and
            isinstance(self._ymin, int) and
            isinstance(self._xmax, int) and
            isinstance(self._ymax, int))</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.isinterior"><code class="name flex">
<span>def <span class="ident">isinterior</span></span>(<span>self, width, height, border=1.0)</span>
</code></dt>
<dd>
<div class="desc"><p>Is this boundingbox fully within the provided image rectangle?
</p>
<ul>
<li>If border in [0,1], then the image is dilated by a border percentage prior to computing interior, useful to check if self is near the image edge</li>
<li>If border=0.8, then the image rectangle is dilated by 80% (smaller) keeping the centroid constant.</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L837-L844" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isinterior(self, width, height, border=1.0):
    &#34;&#34;&#34;Is this boundingbox fully within the provided image rectangle?  
    
       * If border in [0,1], then the image is dilated by a border percentage prior to computing interior, useful to check if self is near the image edge
       * If border=0.8, then the image rectangle is dilated by 80% (smaller) keeping the centroid constant. 
    &#34;&#34;&#34;
    assert border &gt; 0 and border &lt;= 1, &#34;Border must be a dilation fraction of the image, such that the image centroid is constant and the sides are dilated by a scale [0,1]&#34;
    return self.isinside(imagebox((height, width)).dilate(border))</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.isnonnegative"><code class="name flex">
<span>def <span class="ident">isnonnegative</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L397-L401" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isnonnegative(self):
    return (self.xmin() &gt;= 0 and
            self.ymin() &gt;= 0 and
            self.xmax() &gt;= 0 and
            self.ymax() &gt;= 0)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.ispointinside"><code class="name flex">
<span>def <span class="ident">ispointinside</span></span>(<span>self, p)</span>
</code></dt>
<dd>
<div class="desc"><p>Is the 2D point p=(x,y) inside this boundingbox, or is the p=boundingbox() inside this bounding box?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L643-L646" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def ispointinside(self, p):
    &#34;&#34;&#34;Is the 2D point p=(x,y) inside this boundingbox, or is the p=boundingbox() inside this bounding box?&#34;&#34;&#34;
    assert len(p) == 2, &#34;Invalid 2D point=(x,y) input&#34;
    return (p[0] &gt;= self._xmin) and (p[1] &gt;= self._ymin) and (p[0] &lt;= self._xmax) and (p[1] &lt;= self._ymax)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.issquare"><code class="name flex">
<span>def <span class="ident">issquare</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L796-L797" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def issquare(self):
    return np.allclose(self.height(), self.width())</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.isvalid"><code class="name flex">
<span>def <span class="ident">isvalid</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L391-L392" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isvalid(self):
    return not self.invalid()</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.json"><code class="name flex">
<span>def <span class="ident">json</span></span>(<span>self, encode=True)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L210-L212" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def json(self, encode=True):
    d = {k.lstrip(&#39;_&#39;):getattr(self, k) for k in BoundingBox.__slots__}  # prettyjson (remove &#34;_&#34; prefix to attributes)        
    return json.dumps(d) if encode else d</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.left"><code class="name flex">
<span>def <span class="ident">left</span></span>(<span>self, dx)</span>
</code></dt>
<dd>
<div class="desc"><p>Make left of box wider (closer to left side of image) by an offset dx</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L702-L705" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def left(self, dx):
    &#34;&#34;&#34;Make left of box wider (closer to left side of image) by an offset dx&#34;&#34;&#34;
    self._xmin = self._xmin - dx
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.ll"><code class="name flex">
<span>def <span class="ident">ll</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Lower left coordinate (x,y), synonym for bl()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L262-L264" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def ll(self):
    &#34;&#34;&#34;Lower left coordinate (x,y), synonym for bl()&#34;&#34;&#34;
    return (self._xmin, self._ymax)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.lr"><code class="name flex">
<span>def <span class="ident">lr</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Lower right coordinate (x,y), synonym for br()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L278-L280" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def lr(self):
    &#34;&#34;&#34;Lower right coordinate (x,y), synonym for br()&#34;&#34;&#34;
    return (self._xmax, self._ymax)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.maxcover"><code class="name flex">
<span>def <span class="ident">maxcover</span></span>(<span>self, bb, area=None, otherarea=None)</span>
</code></dt>
<dd>
<div class="desc"><p>The maximum cover of self to bb and bb to self</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L581-L585" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def maxcover(self, bb, area=None, otherarea=None):
    &#34;&#34;&#34;The maximum cover of self to bb and bb to self&#34;&#34;&#34;
    aoi = self.area_of_intersection(bb, strict=False)
    (area, otherarea) = (self.area() if area is None else area, bb.area() if otherarea is None else otherarea)
    return float(max((aoi/area) if area&gt;0 else 0, (aoi/otherarea) if otherarea&gt;0 else 0))</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.maxdim"><code class="name flex">
<span>def <span class="ident">maxdim</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return max(width, height) typecast to float</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L897-L899" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def maxdim(self):
    &#34;&#34;&#34;Return max(width, height) typecast to float&#34;&#34;&#34;
    return float(np.max(self.shape())) </code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.maxsquare"><code class="name flex">
<span>def <span class="ident">maxsquare</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the bounding box to be square by setting width and height to the maximum dimension of the box, keeping centroid constant</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L784-L794" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def maxsquare(self):
    &#34;&#34;&#34;Set the bounding box to be square by setting width and height to the maximum dimension of the box, keeping centroid constant&#34;&#34;&#34;
    (height, width) = (self._ymax-self._ymin, self._xmax-self._xmin)                            
    if width != height:
        dim = float(max(width, height))
        c = self.centroid()
        self._xmin = c[0] - (dim / 2.0)
        self._ymin = c[1] - (dim / 2.0)
        self._xmax = c[0] + (dim / 2.0)
        self._ymax = c[1] + (dim / 2.0)
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.medianshape"><code class="name flex">
<span>def <span class="ident">medianshape</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Compute the median bounding box width and height between self and other.
Other may be a singleton bounding box or a list of bounding boxes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L919-L925" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def medianshape(self, other):
    &#34;&#34;&#34;Compute the median bounding box width and height between self and other.  Other may be a singleton bounding box or a list of bounding boxes&#34;&#34;&#34;
    assert all([isinstance(bb, BoundingBox) for bb in tolist(other)]), &#34;Invalid input - must be BoundingBox&#34;        
    (height, width) = np.median( [self.shape()] + [bb.shape() for bb in tolist(other)], axis=0)
    self.setwidth(width)
    self.setheight(height)
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.mindim"><code class="name flex">
<span>def <span class="ident">mindim</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return min(width, height) typecast to float</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L893-L895" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def mindim(self):
    &#34;&#34;&#34;Return min(width, height) typecast to float&#34;&#34;&#34;
    return float(np.min(self.shape()))</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.mindimension"><code class="name flex">
<span>def <span class="ident">mindimension</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return min(width, height) typecast to float</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L889-L891" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def mindimension(self):
    &#34;&#34;&#34;Return min(width, height) typecast to float&#34;&#34;&#34;
    return float(np.min(self.shape()))</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.minsquare"><code class="name flex">
<span>def <span class="ident">minsquare</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the bounding box to be square by setting width and height to the minimum dimension of the box, keeping centroid constant</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L815-L825" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def minsquare(self):
    &#34;&#34;&#34;Set the bounding box to be square by setting width and height to the minimum dimension of the box, keeping centroid constant&#34;&#34;&#34;
    (height, width) = (self._ymax-self._ymin, self._xmax-self._xmin)                            
    if width != height:
        dim = float(min(width, height))
        c = self.centroid()
        self._xmin = c[0] - (dim / 2.0)
        self._ymin = c[1] - (dim / 2.0)
        self._xmax = c[0] + (dim / 2.0)
        self._ymax = c[1] + (dim / 2.0)
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.offset"><code class="name flex">
<span>def <span class="ident">offset</span></span>(<span>self, dx=0, dy=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for translate</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L378-L380" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def offset(self, dx=0, dy=0):
    &#34;&#34;&#34;Alias for translate&#34;&#34;&#34;
    return self.translate(dx, dy)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.pdist"><code class="name flex">
<span>def <span class="ident">pdist</span></span>(<span>self, bb, sigma=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Normalized Gaussian distance in [0,1] between centroids of two bounding boxes, where 0 is far and 1 is same with sigma=maxdim() of this box</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L526-L529" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def pdist(self, bb, sigma=None):
    &#34;&#34;&#34;Normalized Gaussian distance in [0,1] between centroids of two bounding boxes, where 0 is far and 1 is same with sigma=maxdim() of this box&#34;&#34;&#34;
    assert isinstance(bb, BoundingBox), &#34;Invalid BoundingBox() input of type &#39;%s&#39;&#34; % str(type(bb))
    return np.exp(-self.sqdist(bb)/(float(2*self.maxdim()*self.maxdim()) if sigma is None else float(2.0*sigma*sigma)))</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.projective"><code class="name flex">
<span>def <span class="ident">projective</span></span>(<span>self, A)</span>
</code></dt>
<dd>
<div class="desc"><p>Apply an 3x3 projective transformation to the box centroid.
</p>
<div class="admonition note">
<p class="admonition-title">Note:&ensp;This transformation is performed on the centroid and not the box corners, so the box will still be rectilinear after the transform</p>
</div></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L940-L946" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def projective(self, A):
    &#34;&#34;&#34;Apply an 3x3 projective transformation to the box centroid.  
    
    .. note:: This transformation is performed on the centroid and not the box corners, so the box will still be rectilinear after the transform
    &#34;&#34;&#34;
    assert isnumpy(A) and A.shape == (3,3), &#34;A must be a 3x3 affine transformation matrix&#34;
    return self.centroid(dehomogenize(np.dot(A, homogenize(np.array(self.centroid())))))</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.rescale"><code class="name flex">
<span>def <span class="ident">rescale</span></span>(<span>self, s)</span>
</code></dt>
<dd>
<div class="desc"><p>Multiply the box corners by a scale factor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L712-L718" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rescale(self, s):
    &#34;&#34;&#34;Multiply the box corners by a scale factor&#34;&#34;&#34;
    self._xmin = s * self._xmin
    self._ymin = s * self._ymin
    self._xmax = s * self._xmax
    self._ymax = s * self._ymax
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.resize"><code class="name flex">
<span>def <span class="ident">resize</span></span>(<span>self, width, height)</span>
</code></dt>
<dd>
<div class="desc"><p>Change the aspect ratio width and height of the box</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L732-L736" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def resize(self, width, height):
    &#34;&#34;&#34;Change the aspect ratio width and height of the box&#34;&#34;&#34;
    self.setwidth(width)
    self.setheight(height)
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.right"><code class="name flex">
<span>def <span class="ident">right</span></span>(<span>self, dx)</span>
</code></dt>
<dd>
<div class="desc"><p>Make right of box wider (closer to right side of image) by an offset dx</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L707-L710" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def right(self, dx):
    &#34;&#34;&#34;Make right of box wider (closer to right side of image) by an offset dx&#34;&#34;&#34;
    self._xmax = self._xmax + dx
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.rot90ccw"><code class="name flex">
<span>def <span class="ident">rot90ccw</span></span>(<span>self, H, W)</span>
</code></dt>
<dd>
<div class="desc"><p>Rotate a bounding box such that if an image of size (H,W) is rotated 90 deg counter clockwise, the boxes align</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L744-L748" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rot90ccw(self, H, W):
    &#34;&#34;&#34;Rotate a bounding box such that if an image of size (H,W) is rotated 90 deg counter clockwise, the boxes align&#34;&#34;&#34;
    (x,y,w,h) = self.xywh()
    (urx, ury) = self.upperright()
    return self.xywh((ury, W - urx, h, w))</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.rot90cw"><code class="name flex">
<span>def <span class="ident">rot90cw</span></span>(<span>self, H, W)</span>
</code></dt>
<dd>
<div class="desc"><p>Rotate a bounding box such that if an image of size (H,W) is rotated 90 deg clockwise, the boxes align</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L738-L742" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rot90cw(self, H, W):
    &#34;&#34;&#34;Rotate a bounding box such that if an image of size (H,W) is rotated 90 deg clockwise, the boxes align&#34;&#34;&#34;
    (x,y,w,h) = self.xywh()
    (blx, bly) = self.bottomleft()
    return self.xywh((H - bly, blx, h, w))</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.scale_x"><code class="name flex">
<span>def <span class="ident">scale_x</span></span>(<span>self, s)</span>
</code></dt>
<dd>
<div class="desc"><p>Multiply the box corners in the x dimension by a scale factor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L720-L724" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def scale_x(self, s):
    &#34;&#34;&#34;Multiply the box corners in the x dimension by a scale factor&#34;&#34;&#34;
    self._xmin = s * self._xmin
    self._xmax = s * self._xmax
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.scale_y"><code class="name flex">
<span>def <span class="ident">scale_y</span></span>(<span>self, s)</span>
</code></dt>
<dd>
<div class="desc"><p>Multiply the box corners in the y dimension by a scale factor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L726-L730" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def scale_y(self, s):
    &#34;&#34;&#34;Multiply the box corners in the y dimension by a scale factor&#34;&#34;&#34;
    self._ymin = s * self._ymin
    self._ymax = s * self._ymax
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.set_origin"><code class="name flex">
<span>def <span class="ident">set_origin</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the origin of the coordinates of this bounding box to be relative to the upper left of the other bounding box</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L373-L376" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def set_origin(self, other):
    &#34;&#34;&#34;Set the origin of the coordinates of this bounding box to be relative to the upper left of the other bounding box&#34;&#34;&#34;
    assert isinstance(other, BoundingBox), &#34;Invalid BoundingBox() input of type &#39;%s&#39;&#34; % str(type(other))
    return self.translate(other.xmin(), other.ymin())                </code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.setheight"><code class="name flex">
<span>def <span class="ident">setheight</span></span>(<span>self, h)</span>
</code></dt>
<dd>
<div class="desc"><p>Set new height keeping centroid constant</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L415-L422" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def setheight(self, h):
    &#34;&#34;&#34;Set new height keeping centroid constant&#34;&#34;&#34;
    if h &lt;= 0:
        raise ValueError(&#39;invalid height&#39;)
    horig = self._ymax - self._ymin
    self._ymax += float((h - horig) / 2.0)
    self._ymin -= float((h - horig) / 2.0)
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.setwidth"><code class="name flex">
<span>def <span class="ident">setwidth</span></span>(<span>self, w)</span>
</code></dt>
<dd>
<div class="desc"><p>Set new width keeping centroid constant</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L406-L413" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def setwidth(self, w):
    &#34;&#34;&#34;Set new width keeping centroid constant&#34;&#34;&#34;
    if w &lt;= 0:
        raise ValueError(&#39;invalid width&#39;)
    worig = (self._xmax - self._xmin)
    self._xmax += float((w - worig) / 2.0)
    self._xmin -= float((w - worig) / 2.0)
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.shape"><code class="name flex">
<span>def <span class="ident">shape</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the (height, width) tuple for the box shape</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L885-L887" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def shape(self):
    &#34;&#34;&#34;Return the (height, width) tuple for the box shape&#34;&#34;&#34;
    return (self._ymax-self._ymin, self._xmax-self._xmin)                            </code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.shapedist"><code class="name flex">
<span>def <span class="ident">shapedist</span></span>(<span>self, other)</span>
</code></dt>
<dd>
<div class="desc"><p>L1 distance between (width,height) of two boxes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L927-L930" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def shapedist(self, other):
    &#34;&#34;&#34;L1 distance between (width,height) of two boxes&#34;&#34;&#34;
    assert isinstance(other, BoundingBox), &#34;Invalid input - must be BoundingBox()&#34;                
    return np.abs(self.width()-other.width())  + np.abs(self.height()-other.height())</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.shapeiou"><code class="name flex">
<span>def <span class="ident">shapeiou</span></span>(<span>self, bb, area=None, otherarea=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Shape IoU is the IoU with the upper left corners aligned. This measures the deformation of the two boxes by removing the effect of translation</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L587-L597" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def shapeiou(self, bb, area=None, otherarea=None):
    &#34;&#34;&#34;Shape IoU is the IoU with the upper left corners aligned. This measures the deformation of the two boxes by removing the effect of translation&#34;&#34;&#34;
    #return self.iou(bb.clone().translate(dx=self._xmin-bb._xmin, dy=self._ymin-bb._ymin))  # equivalent to
    assert isinstance(bb, BoundingBox), &#34;Invalid input - must be BoundingBox()&#34;
    w = min(self._xmax, bb._xmax + (self._xmin-bb._xmin)) - max(self._xmin, bb._xmin + (self._xmin-bb._xmin))
    h = min(self._ymax, bb._ymax + (self._ymin-bb._ymin)) - max(self._ymin, bb._ymin + (self._ymin-bb._ymin))
    area_intersection = w * h
    area_union = ((self.area() if area is None else area) +
                  (bb.area() if otherarea is None else otherarea)
                  - area_intersection)
    return (area_intersection / float(area_union)) if area_union&gt;0 else 0</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.significant_digits"><code class="name flex">
<span>def <span class="ident">significant_digits</span></span>(<span>self, n)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert corners to have at most n significant digits for efficient JSON storage</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L352-L359" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def significant_digits(self, n):
    &#34;&#34;&#34;Convert corners to have at most n significant digits for efficient JSON storage&#34;&#34;&#34;
    assert isinstance(n, int) and n&gt;=0
    self._xmin = round(self._xmin, n)
    self._ymin = round(self._ymin, n)
    self._xmax = round(self._xmax, n)
    self._ymax = round(self._ymax, n)
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.sqdist"><code class="name flex">
<span>def <span class="ident">sqdist</span></span>(<span>self, bb)</span>
</code></dt>
<dd>
<div class="desc"><p>Squared Euclidean distance between upper left corners of two bounding boxes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L516-L519" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def sqdist(self, bb):
    &#34;&#34;&#34;Squared Euclidean distance between upper left corners of two bounding boxes&#34;&#34;&#34;
    assert isinstance(bb, BoundingBox), &#34;Invalid BoundingBox() input of type &#39;%s&#39;&#34; % str(type(bb))                
    return np.power(self.dx(bb), 2.0) + np.power(self.dy(bb), 2.0)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.to_origin"><code class="name flex">
<span>def <span class="ident">to_origin</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Translate the bounding box so that (xmin, ymin) = (0,0)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L369-L371" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def to_origin(self):
    &#34;&#34;&#34;Translate the bounding box so that (xmin, ymin) = (0,0)&#34;&#34;&#34;
    return self.translate(-self.xmin(), -self.ymin())</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.to_ulbr"><code class="name flex">
<span>def <span class="ident">to_ulbr</span></span>(<span>self, ulbr=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for ulbr()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L504-L506" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def to_ulbr(self, ulbr=None):
    &#34;&#34;&#34;Alias for ulbr()&#34;&#34;&#34;
    return self.ulbr(ulbr)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.to_xywh"><code class="name flex">
<span>def <span class="ident">to_xywh</span></span>(<span>self, xywh=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return bounding box corners as (x,y,width,height) tuple</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L466-L477" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def to_xywh(self, xywh=None):
    &#34;&#34;&#34;Return bounding box corners as (x,y,width,height) tuple&#34;&#34;&#34;
    if xywh is None:
        (height, width) = (self._ymax-self._ymin, self._xmax-self._xmin)                    
        return tuple([self._xmin, self._ymin, width, height])
    else:
        assert len(xywh) == 4, &#34;Invalid (xmin,ymin,width,height) input&#34;
        self._xmin = float(xywh[0])
        self._ymin = float(xywh[1])
        self._xmax = float(self._xmin + xywh[2])
        self._ymax = float(self._ymin + xywh[3])
        return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.top"><code class="name flex">
<span>def <span class="ident">top</span></span>(<span>self, dy)</span>
</code></dt>
<dd>
<div class="desc"><p>Make top of box taller (closer to top of image) by an offset dy</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L692-L695" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def top(self, dy):
    &#34;&#34;&#34;Make top of box taller (closer to top of image) by an offset dy&#34;&#34;&#34;
    self._ymin = self._ymin - dy
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.translate"><code class="name flex">
<span>def <span class="ident">translate</span></span>(<span>self, dx=0, dy=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Translate the bounding box by dx in x and dy in y</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L361-L367" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def translate(self, dx=0, dy=0):
    &#34;&#34;&#34;Translate the bounding box by dx in x and dy in y&#34;&#34;&#34;
    self._xmin = self._xmin + dx
    self._ymin = self._ymin + dy
    self._xmax = self._xmax + dx
    self._ymax = self._ymax + dy
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.ul"><code class="name flex">
<span>def <span class="ident">ul</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Upper left coordinate (x,y)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L238-L240" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def ul(self):
    &#34;&#34;&#34;Upper left coordinate (x,y)&#34;&#34;&#34;
    return (self._xmin, self._ymin)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.ulbr"><code class="name flex">
<span>def <span class="ident">ulbr</span></span>(<span>self, ulbr=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return bounding box corners as upper left, bottom right (xmin, ymin, xmax, ymax)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L492-L502" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def ulbr(self, ulbr=None):
    &#34;&#34;&#34;Return bounding box corners as upper left, bottom right (xmin, ymin, xmax, ymax)&#34;&#34;&#34;
    if ulbr is None:
        return (self._xmin, self._ymin, self._xmax, self._ymax)            
    else:
        assert len(ulbr) == 4, &#34;Invalid (xmin,ymin,xmax,ymax) input&#34;
        self._xmin = float(ulbr[0])
        self._ymin = float(ulbr[1])
        self._xmax = float(ulbr[2])
        self._ymax = float(ulbr[3])
        return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.ulx"><code class="name flex">
<span>def <span class="ident">ulx</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Upper left coordinate (x)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L242-L244" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def ulx(self):
    &#34;&#34;&#34;Upper left coordinate (x)&#34;&#34;&#34;
    return self.ul()[0]</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.uly"><code class="name flex">
<span>def <span class="ident">uly</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Upper left coordinate (y)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L246-L248" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def uly(self):
    &#34;&#34;&#34;Upper left coordinate (y)&#34;&#34;&#34;
    return self.ul()[1]</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.union"><code class="name flex">
<span>def <span class="ident">union</span></span>(<span>self, bb)</span>
</code></dt>
<dd>
<div class="desc"><p>Union of one or more bounding boxes with this box</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L628-L636" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def union(self, bb):
    &#34;&#34;&#34;Union of one or more bounding boxes with this box&#34;&#34;&#34;        
    bblist = tolist(bb)        
    assert all([isinstance(bb, BoundingBox) for bb in bblist]), &#34;Invalid BoundingBox() input&#34;
    self._xmin = min([bb._xmin for bb in bblist] + [self._xmin])
    self._ymin = min([bb._ymin for bb in bblist] + [self._ymin])
    self._xmax = max([bb._xmax for bb in bblist] + [self._xmax])
    self._ymax = max([bb._ymax for bb in bblist] + [self._ymax])
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.upperleft"><code class="name flex">
<span>def <span class="ident">upperleft</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the (x,y) upper left corner coordinate of the box</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L309-L311" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def upperleft(self):
    &#34;&#34;&#34;Return the (x,y) upper left corner coordinate of the box&#34;&#34;&#34;
    return (self.xmin(), self.ymin())</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.upperright"><code class="name flex">
<span>def <span class="ident">upperright</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the (x,y) upper right corner coordinate of the box</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L317-L319" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def upperright(self):
    &#34;&#34;&#34;Return the (x,y) upper right corner coordinate of the box&#34;&#34;&#34;
    return (self.xmax(), self.ymin())</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.ur"><code class="name flex">
<span>def <span class="ident">ur</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Upper right coordinate (x,y)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L250-L252" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def ur(self):
    &#34;&#34;&#34;Upper right coordinate (x,y)&#34;&#34;&#34;
    return (self._xmax, self._ymin)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.urx"><code class="name flex">
<span>def <span class="ident">urx</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Upper right coordinate (x)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L254-L256" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def urx(self):
    &#34;&#34;&#34;Upper right coordinate (x)&#34;&#34;&#34;
    return self.ur()[0]</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.ury"><code class="name flex">
<span>def <span class="ident">ury</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Upper right coordinate (y)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L258-L260" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def ury(self):
    &#34;&#34;&#34;Upper right coordinate (y)&#34;&#34;&#34;
    return self.ur()[1]</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.valid"><code class="name flex">
<span>def <span class="ident">valid</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L388-L389" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def valid(self):
    return not self.invalid()</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.width"><code class="name flex">
<span>def <span class="ident">width</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L403-L404" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def width(self):
    return self._xmax - self._xmin</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.x_centroid"><code class="name flex">
<span>def <span class="ident">x_centroid</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L441-L442" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def x_centroid(self):
    return self.centroid()[0]</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.xcentroid"><code class="name flex">
<span>def <span class="ident">xcentroid</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for x_centroid()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L444-L446" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def xcentroid(self):
    &#34;&#34;&#34;Alias for x_centroid()&#34;&#34;&#34;
    return self.centroid()[0]</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.xmax"><code class="name flex">
<span>def <span class="ident">xmax</span></span>(<span>self, x=None)</span>
</code></dt>
<dd>
<div class="desc"><p>x coordinate of lower right corner of box, x-axis is image column</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L299-L302" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def xmax(self, x=None):
    &#34;&#34;&#34;x coordinate of lower right corner of box, x-axis is image column&#34;&#34;&#34;
    self._xmax = self._xmax if x is None else x
    return self._xmax if x is None else self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.xmin"><code class="name flex">
<span>def <span class="ident">xmin</span></span>(<span>self, x=None)</span>
</code></dt>
<dd>
<div class="desc"><p>x coordinate of upper left corner of box, x-axis is image column</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L233-L236" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def xmin(self, x=None):
    &#34;&#34;&#34;x coordinate of upper left corner of box, x-axis is image column&#34;&#34;&#34;
    self._xmin = self._xmin if x is None else x
    return self._xmin if x is None else self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.xywh"><code class="name flex">
<span>def <span class="ident">xywh</span></span>(<span>self, xywh_=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for to_xywh</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L479-L481" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def xywh(self, xywh_=None):
    &#34;&#34;&#34;Alias for to_xywh&#34;&#34;&#34;
    return self.to_xywh(xywh_)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.y_centroid"><code class="name flex">
<span>def <span class="ident">y_centroid</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L451-L452" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def y_centroid(self):
    return self.centroid()[1]</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.ycentroid"><code class="name flex">
<span>def <span class="ident">ycentroid</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for y_centroid()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L454-L456" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def ycentroid(self):
    &#34;&#34;&#34;Alias for y_centroid()&#34;&#34;&#34;
    return self.centroid()[1]</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.ymax"><code class="name flex">
<span>def <span class="ident">ymax</span></span>(<span>self, y=None)</span>
</code></dt>
<dd>
<div class="desc"><p>y coordinate of lower right corner of box, y-axis is image row</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L304-L307" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def ymax(self, y=None):
    &#34;&#34;&#34;y coordinate of lower right corner of box, y-axis is image row&#34;&#34;&#34;
    self._ymax = self._ymax if y is None else y
    return self._ymax if y is None else self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.BoundingBox.ymin"><code class="name flex">
<span>def <span class="ident">ymin</span></span>(<span>self, y=None)</span>
</code></dt>
<dd>
<div class="desc"><p>y coordinate of upper left corner of box, y-axis is image row, set if provided</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L294-L297" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def ymin(self, y=None):
    &#34;&#34;&#34;y coordinate of upper left corner of box, y-axis is image row, set if provided&#34;&#34;&#34;
    self._ymin = self._ymin if y is None else y
    return self._ymin if y is None else self</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="vipy.geometry.Ellipse"><code class="flex name class">
<span>class <span class="ident">Ellipse</span></span>
<span>(</span><span>semi_major, semi_minor, xcenter, ycenter, phi)</span>
</code></dt>
<dd>
<div class="desc"><p>Ellipse parameterization, for length of semimajor (half width of ellipse) and semiminor axis (half height), center point and angle phi in radians</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L966-L1037" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Ellipse():
    __slots__ = [&#39;_major&#39;, &#39;_minor&#39;, &#39;_xcenter&#39;, &#39;_ycenter&#39;, &#39;_phi&#39;]
    def __init__(self, semi_major, semi_minor, xcenter, ycenter, phi):
        &#34;&#34;&#34;Ellipse parameterization, for length of semimajor (half width of ellipse) and semiminor axis (half height), center point and angle phi in radians&#34;&#34;&#34;
        self._major = semi_major
        self._minor = semi_minor
        self._xcenter = xcenter
        self._ycenter = ycenter
        self._phi = phi

    def __repr__(self):
        return str(&#39;&lt;vipy.geometry.Ellipse: semimajor=%s, semiminor=%s, xcenter=%s, ycenter=%s, phi=%s (rad)&gt;&#39; % (self._major, self._minor, self._xcenter, self._ycenter, self._phi))

    def dict(self):
        return {&#39;semimajor&#39;:self._major, &#39;semiminor&#39;:self._minor, &#39;xcenter&#39;:self._xcenter, &#39;ycenter&#39;:self._ycenter, &#39;phi&#39;:self._phi}
    
    def area(self):
        &#34;&#34;&#34;Area of ellipse&#34;&#34;&#34;
        return math.pi * self._major * self._minor

    def center(self):
        &#34;&#34;&#34;Return centroid&#34;&#34;&#34;
        return (self._xcenter, self._ycenter)

    def centroid(self):
        &#34;&#34;&#34;Alias for center&#34;&#34;&#34;
        return self.center()

    
    def axes(self):
        &#34;&#34;&#34;Return the (major,minor) axis lengths&#34;&#34;&#34;
        return (self._major, self._minor)

    def angle(self):
        &#34;&#34;&#34;Return the angle phi (in degrees)&#34;&#34;&#34;
        return (self._phi * 180 / math.pi)

    def rescale(self, scale):
        &#34;&#34;&#34;Scale ellipse by scale factor&#34;&#34;&#34;
        assert isnumber(scale), &#34;Invalid input&#34;
        self._major *= scale
        self._minor *= scale
        self._xcenter *= scale
        self._ycenter *= scale
        return self

    def boundingbox(self):
        &#34;&#34;&#34; Estimate an equivalent bounding box based on scaling to a common area.
        Note, this does not factor in rotation.
        (c*l)*(c*w) = a_e  --&gt; c = sqrt(a_e / a_r) &#34;&#34;&#34;
        assert self._phi == 0, &#34;This function does not currently factor in rotation&#34;

        bbox = BoundingBox(width=2 * self._major, height=2 * self._minor, xcentroid=self._xcenter, ycentroid=self._ycenter)
        a_r = bbox.area()
        c = (self.area() / a_r) ** 0.5
        bbox2 = bbox.clone().dilate(c)
        return bbox2

    def inside(self, x, y=None):
        &#34;&#34;&#34;Return true if a point p=(x,y) is inside the ellipse&#34;&#34;&#34;
        p = (x,y) if y is not None else x
        assert len(p) == 2, &#34;Invalid input&#34;
        assert self._phi == 0, &#34;inside only currently supported for phi=0&#34;
        return ((np.square(p[0] - self._xcenter) / np.square(self._major)) + (np.square(p[1] - self._ycenter) / np.square(self._minor))) &lt;= 1

    def mask(self):
        &#34;&#34;&#34;Return a binary mask of size equal to the bounding box such that the pixels correspond to the interior of the ellipse&#34;&#34;&#34;
        (H,W) = (int(np.round(2 * self._minor)), int(np.round(2 * self._major)))
        img = np.zeros((H,W), dtype=bool)
        for (y,x) in product(range(0,H), range(0,W)):
            img[y,x] = self.inside(x,y)
        return img</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="vipy.geometry.Ellipse.angle"><code class="name flex">
<span>def <span class="ident">angle</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the angle phi (in degrees)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L999-L1001" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def angle(self):
    &#34;&#34;&#34;Return the angle phi (in degrees)&#34;&#34;&#34;
    return (self._phi * 180 / math.pi)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Ellipse.area"><code class="name flex">
<span>def <span class="ident">area</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Area of ellipse</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L982-L984" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def area(self):
    &#34;&#34;&#34;Area of ellipse&#34;&#34;&#34;
    return math.pi * self._major * self._minor</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Ellipse.axes"><code class="name flex">
<span>def <span class="ident">axes</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return the (major,minor) axis lengths</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L995-L997" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def axes(self):
    &#34;&#34;&#34;Return the (major,minor) axis lengths&#34;&#34;&#34;
    return (self._major, self._minor)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Ellipse.boundingbox"><code class="name flex">
<span>def <span class="ident">boundingbox</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Estimate an equivalent bounding box based on scaling to a common area.
Note, this does not factor in rotation.
(c<em>l)</em>(c*w) = a_e
&ndash;&gt; c = sqrt(a_e / a_r)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L1012-L1022" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def boundingbox(self):
    &#34;&#34;&#34; Estimate an equivalent bounding box based on scaling to a common area.
    Note, this does not factor in rotation.
    (c*l)*(c*w) = a_e  --&gt; c = sqrt(a_e / a_r) &#34;&#34;&#34;
    assert self._phi == 0, &#34;This function does not currently factor in rotation&#34;

    bbox = BoundingBox(width=2 * self._major, height=2 * self._minor, xcentroid=self._xcenter, ycentroid=self._ycenter)
    a_r = bbox.area()
    c = (self.area() / a_r) ** 0.5
    bbox2 = bbox.clone().dilate(c)
    return bbox2</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Ellipse.center"><code class="name flex">
<span>def <span class="ident">center</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return centroid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L986-L988" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def center(self):
    &#34;&#34;&#34;Return centroid&#34;&#34;&#34;
    return (self._xcenter, self._ycenter)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Ellipse.centroid"><code class="name flex">
<span>def <span class="ident">centroid</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for center</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L990-L992" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def centroid(self):
    &#34;&#34;&#34;Alias for center&#34;&#34;&#34;
    return self.center()</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Ellipse.dict"><code class="name flex">
<span>def <span class="ident">dict</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L979-L980" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dict(self):
    return {&#39;semimajor&#39;:self._major, &#39;semiminor&#39;:self._minor, &#39;xcenter&#39;:self._xcenter, &#39;ycenter&#39;:self._ycenter, &#39;phi&#39;:self._phi}</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Ellipse.inside"><code class="name flex">
<span>def <span class="ident">inside</span></span>(<span>self, x, y=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Return true if a point p=(x,y) is inside the ellipse</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L1024-L1029" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def inside(self, x, y=None):
    &#34;&#34;&#34;Return true if a point p=(x,y) is inside the ellipse&#34;&#34;&#34;
    p = (x,y) if y is not None else x
    assert len(p) == 2, &#34;Invalid input&#34;
    assert self._phi == 0, &#34;inside only currently supported for phi=0&#34;
    return ((np.square(p[0] - self._xcenter) / np.square(self._major)) + (np.square(p[1] - self._ycenter) / np.square(self._minor))) &lt;= 1</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Ellipse.mask"><code class="name flex">
<span>def <span class="ident">mask</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Return a binary mask of size equal to the bounding box such that the pixels correspond to the interior of the ellipse</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L1031-L1037" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def mask(self):
    &#34;&#34;&#34;Return a binary mask of size equal to the bounding box such that the pixels correspond to the interior of the ellipse&#34;&#34;&#34;
    (H,W) = (int(np.round(2 * self._minor)), int(np.round(2 * self._major)))
    img = np.zeros((H,W), dtype=bool)
    for (y,x) in product(range(0,H), range(0,W)):
        img[y,x] = self.inside(x,y)
    return img</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Ellipse.rescale"><code class="name flex">
<span>def <span class="ident">rescale</span></span>(<span>self, scale)</span>
</code></dt>
<dd>
<div class="desc"><p>Scale ellipse by scale factor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L1003-L1010" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rescale(self, scale):
    &#34;&#34;&#34;Scale ellipse by scale factor&#34;&#34;&#34;
    assert isnumber(scale), &#34;Invalid input&#34;
    self._major *= scale
    self._minor *= scale
    self._xcenter *= scale
    self._ycenter *= scale
    return self</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="vipy.geometry.Point2d"><code class="flex name class">
<span>class <span class="ident">Point2d</span></span>
<span>(</span><span>x, y, r=None)</span>
</code></dt>
<dd>
<div class="desc"><p>vipy.geometry.Point2d class</p>
<p>2D point parameterization</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L1048-L1305" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Point2d():
    &#34;&#34;&#34;vipy.geometry.Point2d class&#34;&#34;&#34;
    __slots__ = [&#39;_x&#39;, &#39;_y&#39;, &#39;_r&#39;]
    
    def __init__(self, x, y, r=None):
        &#34;&#34;&#34;2D point parameterization&#34;&#34;&#34;
        assert math.isfinite(x)
        assert math.isfinite(y)
        assert r&gt;=0                        
        self._x = x
        self._y = y
        self._r = r if r is not None else 0       

    def __repr__(self):
        return str(&#39;&lt;vipy.geometry.Point2d: x=%s, y=%s%s&gt;&#39; % (self._x, self._y, (&#39;, r=%s&#39; % self._r) if self._r !=0 else &#39;&#39;))

    @property
    def x(self):
        return self._x
    
    @property
    def y(self):
        return self._y

    @property
    def r(self):
        return self._r

    @property
    def radius(self):
        return self._r

    def diameter(self):
        return 2*self.r
    
    @property
    def coord(self):
        return (self._x, self._y)

    @classmethod
    def from_json(cls, s):
        d = json.loads(s) if not isinstance(s, dict) else s        
        return cls(d[&#39;x&#39;], d[&#39;y&#39;], d[&#39;r&#39;])

    @classmethod
    def origin(cls):
        return Point2d(0,0)

    def boundingbox(self):
        return BoundingBox(xcentroid=self.x, ycentroid=self.y, width=2*self.r, height=2*self.r)
    
    def __getitem__(self, k):
        return self.coord[k]
    
    def __iter__(self):
        for c in self.coord:
            yield c
                
    def __sub__(self, p):
        assert isinstance(p, Point2d), &#34;invalid input&#34;        
        return Point2d(self._x-p._x, self._y-p._y, self._r)

    def __add__(self, p):
        assert isinstance(p, Point2d), &#34;invalid input&#34;        
        return Point2d(self._x+p._x, self._y+p._y, self._r)

    def __neg__(self, p):
        assert isinstance(p, Point2d), &#34;invalid input&#34;        
        return Point2d(-self._x, -self._y, self._r)
    
    def __gt__(self, p):
        assert isinstance(p, Point2d), &#34;invalid input&#34;
        return self._x &gt; p._x and self._y &gt; p._y

    def __lt__(self, p):
        assert isinstance(p, Point2d), &#34;invalid input&#34;
        return self._x &lt; p._x and self._y &lt; p._y

    def __eq__(self, p):
        assert isinstance(p, Point2d), &#34;invalid input&#34;
        return self.clone().int().coord == p.clone().int().coord

    def __len__(self):
        return len(self.coord)

    def dict(self):
        return {&#39;x&#39;:self._x, &#39;y&#39;:self._y, &#39;r&#39;:self._r}

    def json(self):
        return json.dumps(self.dict())
    
    def is_positive(self):
        return self._x&gt;0 and self._y&gt;0
    
    def is_inside_boundingbox(self, bb):
        assert isinstance(bb, BoundingBox), &#34;invalid input&#34;
        return bb.is_point_inside(self.coord)

    def dist(self, p):
        assert isinstance(p, Point2d), &#34;invalid input&#34;
        return math.sqrt((self.x-p.x)**2 + (self.y-p.y)**2)
    
    def is_inside_radius(self, p):
        assert isinstance(p, Point2d), &#34;invalid input&#34;
        return self.dist(p) &lt;= self.r
    
    def is_inside_imagebox(self, width, height):
        return self.is_inside_boundingbox(BoundingBox(xmin=0, ymin=0, width=width, height=height))

    def significant_digits(self, n):
        &#34;&#34;&#34;Convert corners to have at most n significant digits for efficient JSON storage&#34;&#34;&#34;
        assert isinstance(n, int) and n&gt;=0
        self._x = round(self._x, n)
        self._y = round(self._y, n)
        self._r = round(self._r, n)                   
        return self
        
    def translate(self, dx=0, dy=0):
        &#34;&#34;&#34;Translate the coordinates by dx in x and dy in y&#34;&#34;&#34;
        self._x = self._x + dx
        self._y = self._y + dy
        return self

    def offset(self, dx=0, dy=0):
        &#34;&#34;&#34;Alias for translate&#34;&#34;&#34;
        return self.translate(dx, dy)

    
    def rescale(self, s):
        &#34;&#34;&#34;Multiply the coordinates by a scale factor&#34;&#34;&#34;
        self._x = s * self._x
        self._y = s * self._y
        self._r = s * self._r                   
        return self

    def scale_x(self, s=1):
        &#34;&#34;&#34;Multiply the x coordinate (and radius) by a scale factor&#34;&#34;&#34;
        self._x = s * self._x
        self._r = s * self._r
        return self
        
    def scale_y(self, s=1):
        &#34;&#34;&#34;Multiply the y coordinate by a scale factor&#34;&#34;&#34;
        self._y = s * self._y
        return self
        
    def scale_r(self, s=1):
        &#34;&#34;&#34;Multiply the r coordinate by a scale factor&#34;&#34;&#34;
        self._r = s * self._r        
        return self

    def isinteger(self):
        return (isinstance(self._x, int) and
                isinstance(self._y, int))
                
    def int(self):
        &#34;&#34;&#34;Convert coords to integer with rounding, in-place update&#34;&#34;&#34;
        self._x = int(np.round(self._x))
        self._y = int(np.round(self._y))
        return self

    def float(self):
        &#34;&#34;&#34;Convert coords to float&#34;&#34;&#34;
        self._x = float(self._x)
        self._y = float(self._y)
        return self

    def fliplr(self, img=None, width=None):
        &#34;&#34;&#34;Flip the x coordinate left/right consistent with fliplr of the provided img (or consistent with the image width)&#34;&#34;&#34;
        if img is not None:
            assert isnumpy(img), &#34;Invalid numpy image input&#34;
            width = img.shape[1]
        else:
            assert isnumber(width), &#34;Invalid width&#34;
        self._x = width - self._x
        return self

    def flipud(self, img=None, height=None):
        &#34;&#34;&#34;Flip the y coordinate up/down consistent with flipud of the provided img (or consistent with the image height)&#34;&#34;&#34;
        if img is not None:
            assert isnumpy(img), &#34;Invalid numpy image input&#34;
            height = img.shape[0]
        else:
            assert height is not None and isnumber(height), &#34;Invalid height&#34;
        self._y = height - self._y
        return self
  
    def dilate(self, scale=1):
        self._r = scale*self._r
        return self

    def clone(self):
        return Point2d(self._x, self._y, self._r)
        
    def rot90cw(self, H, W):
        &#34;&#34;&#34;Rotate a point such that if an image of size (H,W) is rotated 90 deg clockwise, the point rotates with the image&#34;&#34;&#34;        
        (x,y) = self.coord
        p = self.clone()
        p._x = H - y
        p._y = x
        return p

    def rot90ccw(self, H, W):
        &#34;&#34;&#34;Rotate a point such that if an image of size (H,W) is rotated 90 deg counter clockwise, the point rotates with the image&#34;&#34;&#34;
        (x, y) = self.coord
        p = self.clone()
        p._x = y
        p._y = W-x
        return p

    def hasoverlap(self, img=None, width=None, height=None):
        &#34;&#34;&#34;Does the point inside with the provided image rectangle?&#34;&#34;&#34;
        if img is not None:
            assert isnumpy(img), &#34;Invalid image input&#34;
            (width, height) = (img.shape[1], img.shape[0])
        return self.is_inside_imagebox(width, height)

    def imclip(self, img=None, width=None, height=None):
        &#34;&#34;&#34;clip does not apply to points&#34;&#34;&#34;
        return self

    def area_of_intersection(self, p):
        &#34;&#34;&#34;area of intersection&#34;&#34;&#34;
        return self.boundingbox().area_of_intersection(p.boundingbox())

    def area_of_union(self, p):
        return self.boundingbox().area_of_union(p.boundingbox())

    def iou(self, p):
        return self.boundingbox().iou(p.boundingbox())
    
    def cover(self, p):
        return self.boundingbox().cover(p.boundingbox())

    def has_intersection(self, p):
        return (self.r + p.r) &gt;= self.dist(p)

    def xmin(self):
        return self.x - self.r

    def xmax(self):
        return self.x + self.r

    def ymin(self):
        return self.y - self.r

    def ymax(self):
        return self.y + self.r

    def width(self):
        return self.diameter()

    def height(self):
        return self.diameter()

    def union(self, points):
        bb = self.boundingbox().union( (p.boundingbox() for p in points) )
        return Point2d(bb.xcentroid(), bb.ycentroid(), max(bb.height(), bb.width())/2)</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="vipy.object.Keypoint2d" href="object.html#vipy.object.Keypoint2d">Keypoint2d</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="vipy.geometry.Point2d.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>s)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="vipy.geometry.Point2d.origin"><code class="name flex">
<span>def <span class="ident">origin</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="vipy.geometry.Point2d.coord"><code class="name">var <span class="ident">coord</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L1083-L1085" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def coord(self):
    return (self._x, self._y)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Point2d.r"><code class="name">var <span class="ident">r</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L1072-L1074" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def r(self):
    return self._r</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Point2d.radius"><code class="name">var <span class="ident">radius</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L1076-L1078" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def radius(self):
    return self._r</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Point2d.x"><code class="name">var <span class="ident">x</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L1064-L1066" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def x(self):
    return self._x</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Point2d.y"><code class="name">var <span class="ident">y</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L1068-L1070" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def y(self):
    return self._y</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="vipy.geometry.Point2d.area_of_intersection"><code class="name flex">
<span>def <span class="ident">area_of_intersection</span></span>(<span>self, p)</span>
</code></dt>
<dd>
<div class="desc"><p>area of intersection</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L1269-L1271" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def area_of_intersection(self, p):
    &#34;&#34;&#34;area of intersection&#34;&#34;&#34;
    return self.boundingbox().area_of_intersection(p.boundingbox())</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Point2d.area_of_union"><code class="name flex">
<span>def <span class="ident">area_of_union</span></span>(<span>self, p)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L1273-L1274" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def area_of_union(self, p):
    return self.boundingbox().area_of_union(p.boundingbox())</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Point2d.boundingbox"><code class="name flex">
<span>def <span class="ident">boundingbox</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L1096-L1097" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def boundingbox(self):
    return BoundingBox(xcentroid=self.x, ycentroid=self.y, width=2*self.r, height=2*self.r)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Point2d.clone"><code class="name flex">
<span>def <span class="ident">clone</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L1239-L1240" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def clone(self):
    return Point2d(self._x, self._y, self._r)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Point2d.cover"><code class="name flex">
<span>def <span class="ident">cover</span></span>(<span>self, p)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L1279-L1280" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def cover(self, p):
    return self.boundingbox().cover(p.boundingbox())</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Point2d.diameter"><code class="name flex">
<span>def <span class="ident">diameter</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L1080-L1081" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def diameter(self):
    return 2*self.r</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Point2d.dict"><code class="name flex">
<span>def <span class="ident">dict</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L1133-L1134" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dict(self):
    return {&#39;x&#39;:self._x, &#39;y&#39;:self._y, &#39;r&#39;:self._r}</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Point2d.dilate"><code class="name flex">
<span>def <span class="ident">dilate</span></span>(<span>self, scale=1)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L1235-L1237" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dilate(self, scale=1):
    self._r = scale*self._r
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Point2d.dist"><code class="name flex">
<span>def <span class="ident">dist</span></span>(<span>self, p)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L1146-L1148" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def dist(self, p):
    assert isinstance(p, Point2d), &#34;invalid input&#34;
    return math.sqrt((self.x-p.x)**2 + (self.y-p.y)**2)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Point2d.fliplr"><code class="name flex">
<span>def <span class="ident">fliplr</span></span>(<span>self, img=None, width=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Flip the x coordinate left/right consistent with fliplr of the provided img (or consistent with the image width)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L1215-L1223" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def fliplr(self, img=None, width=None):
    &#34;&#34;&#34;Flip the x coordinate left/right consistent with fliplr of the provided img (or consistent with the image width)&#34;&#34;&#34;
    if img is not None:
        assert isnumpy(img), &#34;Invalid numpy image input&#34;
        width = img.shape[1]
    else:
        assert isnumber(width), &#34;Invalid width&#34;
    self._x = width - self._x
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Point2d.flipud"><code class="name flex">
<span>def <span class="ident">flipud</span></span>(<span>self, img=None, height=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Flip the y coordinate up/down consistent with flipud of the provided img (or consistent with the image height)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L1225-L1233" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def flipud(self, img=None, height=None):
    &#34;&#34;&#34;Flip the y coordinate up/down consistent with flipud of the provided img (or consistent with the image height)&#34;&#34;&#34;
    if img is not None:
        assert isnumpy(img), &#34;Invalid numpy image input&#34;
        height = img.shape[0]
    else:
        assert height is not None and isnumber(height), &#34;Invalid height&#34;
    self._y = height - self._y
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Point2d.float"><code class="name flex">
<span>def <span class="ident">float</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert coords to float</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L1209-L1213" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def float(self):
    &#34;&#34;&#34;Convert coords to float&#34;&#34;&#34;
    self._x = float(self._x)
    self._y = float(self._y)
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Point2d.has_intersection"><code class="name flex">
<span>def <span class="ident">has_intersection</span></span>(<span>self, p)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L1282-L1283" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def has_intersection(self, p):
    return (self.r + p.r) &gt;= self.dist(p)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Point2d.hasoverlap"><code class="name flex">
<span>def <span class="ident">hasoverlap</span></span>(<span>self, img=None, width=None, height=None)</span>
</code></dt>
<dd>
<div class="desc"><p>Does the point inside with the provided image rectangle?</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L1258-L1263" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def hasoverlap(self, img=None, width=None, height=None):
    &#34;&#34;&#34;Does the point inside with the provided image rectangle?&#34;&#34;&#34;
    if img is not None:
        assert isnumpy(img), &#34;Invalid image input&#34;
        (width, height) = (img.shape[1], img.shape[0])
    return self.is_inside_imagebox(width, height)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Point2d.height"><code class="name flex">
<span>def <span class="ident">height</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L1300-L1301" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def height(self):
    return self.diameter()</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Point2d.imclip"><code class="name flex">
<span>def <span class="ident">imclip</span></span>(<span>self, img=None, width=None, height=None)</span>
</code></dt>
<dd>
<div class="desc"><p>clip does not apply to points</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L1265-L1267" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def imclip(self, img=None, width=None, height=None):
    &#34;&#34;&#34;clip does not apply to points&#34;&#34;&#34;
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Point2d.int"><code class="name flex">
<span>def <span class="ident">int</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert coords to integer with rounding, in-place update</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L1203-L1207" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def int(self):
    &#34;&#34;&#34;Convert coords to integer with rounding, in-place update&#34;&#34;&#34;
    self._x = int(np.round(self._x))
    self._y = int(np.round(self._y))
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Point2d.iou"><code class="name flex">
<span>def <span class="ident">iou</span></span>(<span>self, p)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L1276-L1277" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def iou(self, p):
    return self.boundingbox().iou(p.boundingbox())</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Point2d.is_inside_boundingbox"><code class="name flex">
<span>def <span class="ident">is_inside_boundingbox</span></span>(<span>self, bb)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L1142-L1144" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def is_inside_boundingbox(self, bb):
    assert isinstance(bb, BoundingBox), &#34;invalid input&#34;
    return bb.is_point_inside(self.coord)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Point2d.is_inside_imagebox"><code class="name flex">
<span>def <span class="ident">is_inside_imagebox</span></span>(<span>self, width, height)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L1154-L1155" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def is_inside_imagebox(self, width, height):
    return self.is_inside_boundingbox(BoundingBox(xmin=0, ymin=0, width=width, height=height))</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Point2d.is_inside_radius"><code class="name flex">
<span>def <span class="ident">is_inside_radius</span></span>(<span>self, p)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L1150-L1152" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def is_inside_radius(self, p):
    assert isinstance(p, Point2d), &#34;invalid input&#34;
    return self.dist(p) &lt;= self.r</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Point2d.is_positive"><code class="name flex">
<span>def <span class="ident">is_positive</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L1139-L1140" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def is_positive(self):
    return self._x&gt;0 and self._y&gt;0</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Point2d.isinteger"><code class="name flex">
<span>def <span class="ident">isinteger</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L1199-L1201" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def isinteger(self):
    return (isinstance(self._x, int) and
            isinstance(self._y, int))</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Point2d.json"><code class="name flex">
<span>def <span class="ident">json</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L1136-L1137" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def json(self):
    return json.dumps(self.dict())</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Point2d.offset"><code class="name flex">
<span>def <span class="ident">offset</span></span>(<span>self, dx=0, dy=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Alias for translate</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L1171-L1173" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def offset(self, dx=0, dy=0):
    &#34;&#34;&#34;Alias for translate&#34;&#34;&#34;
    return self.translate(dx, dy)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Point2d.rescale"><code class="name flex">
<span>def <span class="ident">rescale</span></span>(<span>self, s)</span>
</code></dt>
<dd>
<div class="desc"><p>Multiply the coordinates by a scale factor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L1176-L1181" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rescale(self, s):
    &#34;&#34;&#34;Multiply the coordinates by a scale factor&#34;&#34;&#34;
    self._x = s * self._x
    self._y = s * self._y
    self._r = s * self._r                   
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Point2d.rot90ccw"><code class="name flex">
<span>def <span class="ident">rot90ccw</span></span>(<span>self, H, W)</span>
</code></dt>
<dd>
<div class="desc"><p>Rotate a point such that if an image of size (H,W) is rotated 90 deg counter clockwise, the point rotates with the image</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L1250-L1256" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rot90ccw(self, H, W):
    &#34;&#34;&#34;Rotate a point such that if an image of size (H,W) is rotated 90 deg counter clockwise, the point rotates with the image&#34;&#34;&#34;
    (x, y) = self.coord
    p = self.clone()
    p._x = y
    p._y = W-x
    return p</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Point2d.rot90cw"><code class="name flex">
<span>def <span class="ident">rot90cw</span></span>(<span>self, H, W)</span>
</code></dt>
<dd>
<div class="desc"><p>Rotate a point such that if an image of size (H,W) is rotated 90 deg clockwise, the point rotates with the image</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L1242-L1248" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def rot90cw(self, H, W):
    &#34;&#34;&#34;Rotate a point such that if an image of size (H,W) is rotated 90 deg clockwise, the point rotates with the image&#34;&#34;&#34;        
    (x,y) = self.coord
    p = self.clone()
    p._x = H - y
    p._y = x
    return p</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Point2d.scale_r"><code class="name flex">
<span>def <span class="ident">scale_r</span></span>(<span>self, s=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Multiply the r coordinate by a scale factor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L1194-L1197" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def scale_r(self, s=1):
    &#34;&#34;&#34;Multiply the r coordinate by a scale factor&#34;&#34;&#34;
    self._r = s * self._r        
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Point2d.scale_x"><code class="name flex">
<span>def <span class="ident">scale_x</span></span>(<span>self, s=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Multiply the x coordinate (and radius) by a scale factor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L1183-L1187" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def scale_x(self, s=1):
    &#34;&#34;&#34;Multiply the x coordinate (and radius) by a scale factor&#34;&#34;&#34;
    self._x = s * self._x
    self._r = s * self._r
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Point2d.scale_y"><code class="name flex">
<span>def <span class="ident">scale_y</span></span>(<span>self, s=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Multiply the y coordinate by a scale factor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L1189-L1192" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def scale_y(self, s=1):
    &#34;&#34;&#34;Multiply the y coordinate by a scale factor&#34;&#34;&#34;
    self._y = s * self._y
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Point2d.significant_digits"><code class="name flex">
<span>def <span class="ident">significant_digits</span></span>(<span>self, n)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert corners to have at most n significant digits for efficient JSON storage</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L1157-L1163" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def significant_digits(self, n):
    &#34;&#34;&#34;Convert corners to have at most n significant digits for efficient JSON storage&#34;&#34;&#34;
    assert isinstance(n, int) and n&gt;=0
    self._x = round(self._x, n)
    self._y = round(self._y, n)
    self._r = round(self._r, n)                   
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Point2d.translate"><code class="name flex">
<span>def <span class="ident">translate</span></span>(<span>self, dx=0, dy=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Translate the coordinates by dx in x and dy in y</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L1165-L1169" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def translate(self, dx=0, dy=0):
    &#34;&#34;&#34;Translate the coordinates by dx in x and dy in y&#34;&#34;&#34;
    self._x = self._x + dx
    self._y = self._y + dy
    return self</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Point2d.union"><code class="name flex">
<span>def <span class="ident">union</span></span>(<span>self, points)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L1303-L1305" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def union(self, points):
    bb = self.boundingbox().union( (p.boundingbox() for p in points) )
    return Point2d(bb.xcentroid(), bb.ycentroid(), max(bb.height(), bb.width())/2)</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Point2d.width"><code class="name flex">
<span>def <span class="ident">width</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L1297-L1298" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def width(self):
    return self.diameter()</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Point2d.xmax"><code class="name flex">
<span>def <span class="ident">xmax</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L1288-L1289" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def xmax(self):
    return self.x + self.r</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Point2d.xmin"><code class="name flex">
<span>def <span class="ident">xmin</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L1285-L1286" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def xmin(self):
    return self.x - self.r</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Point2d.ymax"><code class="name flex">
<span>def <span class="ident">ymax</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L1294-L1295" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def ymax(self):
    return self.y + self.r</code></pre>
</details>
</dd>
<dt id="vipy.geometry.Point2d.ymin"><code class="name flex">
<span>def <span class="ident">ymin</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/aeafa05f49d28db0926b8db763349138abc3f87a/vipy/geometry.py#L1291-L1292" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def ymin(self):
    return self.y - self.r</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="VIPY" href="https://github.com/visym/vipy/">
<img src="https://www.visym.com/labs/images/visym_logo_black_notext.png" alt="" width="60">
</a>
<h1 style="font-size:200%;"><b>VIPY:</b> Visual Dataset Transformation</h1>
</header>
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = './doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="vipy" href="index.html">vipy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="vipy.geometry.RandomBox" href="#vipy.geometry.RandomBox">RandomBox</a></code></li>
<li><code><a title="vipy.geometry.RandomPoint2d" href="#vipy.geometry.RandomPoint2d">RandomPoint2d</a></code></li>
<li><code><a title="vipy.geometry.affine_transform" href="#vipy.geometry.affine_transform">affine_transform</a></code></li>
<li><code><a title="vipy.geometry.apply_homography" href="#vipy.geometry.apply_homography">apply_homography</a></code></li>
<li><code><a title="vipy.geometry.covariance_to_ellipse" href="#vipy.geometry.covariance_to_ellipse">covariance_to_ellipse</a></code></li>
<li><code><a title="vipy.geometry.dehomogenize" href="#vipy.geometry.dehomogenize">dehomogenize</a></code></li>
<li><code><a title="vipy.geometry.homogenize" href="#vipy.geometry.homogenize">homogenize</a></code></li>
<li><code><a title="vipy.geometry.imagebox" href="#vipy.geometry.imagebox">imagebox</a></code></li>
<li><code><a title="vipy.geometry.imtransform" href="#vipy.geometry.imtransform">imtransform</a></code></li>
<li><code><a title="vipy.geometry.normalize" href="#vipy.geometry.normalize">normalize</a></code></li>
<li><code><a title="vipy.geometry.random_affine_transform" href="#vipy.geometry.random_affine_transform">random_affine_transform</a></code></li>
<li><code><a title="vipy.geometry.similarity_transform" href="#vipy.geometry.similarity_transform">similarity_transform</a></code></li>
<li><code><a title="vipy.geometry.similarity_transform_2x3" href="#vipy.geometry.similarity_transform_2x3">similarity_transform_2x3</a></code></li>
<li><code><a title="vipy.geometry.union" href="#vipy.geometry.union">union</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="vipy.geometry.BoundingBox" href="#vipy.geometry.BoundingBox">BoundingBox</a></code></h4>
<ul class="">
<li><code><a title="vipy.geometry.BoundingBox.affine" href="#vipy.geometry.BoundingBox.affine">affine</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.area" href="#vipy.geometry.BoundingBox.area">area</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.area_of_intersection" href="#vipy.geometry.BoundingBox.area_of_intersection">area_of_intersection</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.area_of_union" href="#vipy.geometry.BoundingBox.area_of_union">area_of_union</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.aspectratio" href="#vipy.geometry.BoundingBox.aspectratio">aspectratio</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.average" href="#vipy.geometry.BoundingBox.average">average</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.averageshape" href="#vipy.geometry.BoundingBox.averageshape">averageshape</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.bbclone" href="#vipy.geometry.BoundingBox.bbclone">bbclone</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.bl" href="#vipy.geometry.BoundingBox.bl">bl</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.blx" href="#vipy.geometry.BoundingBox.blx">blx</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.bly" href="#vipy.geometry.BoundingBox.bly">bly</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.bottom" href="#vipy.geometry.BoundingBox.bottom">bottom</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.bottomleft" href="#vipy.geometry.BoundingBox.bottomleft">bottomleft</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.bottomright" href="#vipy.geometry.BoundingBox.bottomright">bottomright</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.br" href="#vipy.geometry.BoundingBox.br">br</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.brx" href="#vipy.geometry.BoundingBox.brx">brx</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.bry" href="#vipy.geometry.BoundingBox.bry">bry</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.cast" href="#vipy.geometry.BoundingBox.cast">cast</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.centroid" href="#vipy.geometry.BoundingBox.centroid">centroid</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.centroid_x" href="#vipy.geometry.BoundingBox.centroid_x">centroid_x</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.centroid_y" href="#vipy.geometry.BoundingBox.centroid_y">centroid_y</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.clone" href="#vipy.geometry.BoundingBox.clone">clone</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.convexhull" href="#vipy.geometry.BoundingBox.convexhull">convexhull</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.cover" href="#vipy.geometry.BoundingBox.cover">cover</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.crop" href="#vipy.geometry.BoundingBox.crop">crop</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.cxywh" href="#vipy.geometry.BoundingBox.cxywh">cxywh</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.dict" href="#vipy.geometry.BoundingBox.dict">dict</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.dilate" href="#vipy.geometry.BoundingBox.dilate">dilate</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.dilate_height" href="#vipy.geometry.BoundingBox.dilate_height">dilate_height</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.dilate_width" href="#vipy.geometry.BoundingBox.dilate_width">dilate_width</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.dilatepx" href="#vipy.geometry.BoundingBox.dilatepx">dilatepx</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.dist" href="#vipy.geometry.BoundingBox.dist">dist</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.dx" href="#vipy.geometry.BoundingBox.dx">dx</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.dy" href="#vipy.geometry.BoundingBox.dy">dy</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.ellipse" href="#vipy.geometry.BoundingBox.ellipse">ellipse</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.even" href="#vipy.geometry.BoundingBox.even">even</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.fliplr" href="#vipy.geometry.BoundingBox.fliplr">fliplr</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.flipud" href="#vipy.geometry.BoundingBox.flipud">flipud</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.float" href="#vipy.geometry.BoundingBox.float">float</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.from_json" href="#vipy.geometry.BoundingBox.from_json">from_json</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.grid" href="#vipy.geometry.BoundingBox.grid">grid</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.hasintersection" href="#vipy.geometry.BoundingBox.hasintersection">hasintersection</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.hasoverlap" href="#vipy.geometry.BoundingBox.hasoverlap">hasoverlap</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.height" href="#vipy.geometry.BoundingBox.height">height</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.imclip" href="#vipy.geometry.BoundingBox.imclip">imclip</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.imclipshape" href="#vipy.geometry.BoundingBox.imclipshape">imclipshape</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.iminterior" href="#vipy.geometry.BoundingBox.iminterior">iminterior</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.imscale" href="#vipy.geometry.BoundingBox.imscale">imscale</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.int" href="#vipy.geometry.BoundingBox.int">int</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.intersection" href="#vipy.geometry.BoundingBox.intersection">intersection</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.intersection_over_union" href="#vipy.geometry.BoundingBox.intersection_over_union">intersection_over_union</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.invalid" href="#vipy.geometry.BoundingBox.invalid">invalid</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.iou" href="#vipy.geometry.BoundingBox.iou">iou</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.is_point_inside" href="#vipy.geometry.BoundingBox.is_point_inside">is_point_inside</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.isdegenerate" href="#vipy.geometry.BoundingBox.isdegenerate">isdegenerate</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.iseven" href="#vipy.geometry.BoundingBox.iseven">iseven</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.isinside" href="#vipy.geometry.BoundingBox.isinside">isinside</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.isinteger" href="#vipy.geometry.BoundingBox.isinteger">isinteger</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.isinterior" href="#vipy.geometry.BoundingBox.isinterior">isinterior</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.isnonnegative" href="#vipy.geometry.BoundingBox.isnonnegative">isnonnegative</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.ispointinside" href="#vipy.geometry.BoundingBox.ispointinside">ispointinside</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.issquare" href="#vipy.geometry.BoundingBox.issquare">issquare</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.isvalid" href="#vipy.geometry.BoundingBox.isvalid">isvalid</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.json" href="#vipy.geometry.BoundingBox.json">json</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.left" href="#vipy.geometry.BoundingBox.left">left</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.ll" href="#vipy.geometry.BoundingBox.ll">ll</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.lr" href="#vipy.geometry.BoundingBox.lr">lr</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.maxcover" href="#vipy.geometry.BoundingBox.maxcover">maxcover</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.maxdim" href="#vipy.geometry.BoundingBox.maxdim">maxdim</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.maxsquare" href="#vipy.geometry.BoundingBox.maxsquare">maxsquare</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.medianshape" href="#vipy.geometry.BoundingBox.medianshape">medianshape</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.mindim" href="#vipy.geometry.BoundingBox.mindim">mindim</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.mindimension" href="#vipy.geometry.BoundingBox.mindimension">mindimension</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.minsquare" href="#vipy.geometry.BoundingBox.minsquare">minsquare</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.offset" href="#vipy.geometry.BoundingBox.offset">offset</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.pdist" href="#vipy.geometry.BoundingBox.pdist">pdist</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.projective" href="#vipy.geometry.BoundingBox.projective">projective</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.rescale" href="#vipy.geometry.BoundingBox.rescale">rescale</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.resize" href="#vipy.geometry.BoundingBox.resize">resize</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.right" href="#vipy.geometry.BoundingBox.right">right</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.rot90ccw" href="#vipy.geometry.BoundingBox.rot90ccw">rot90ccw</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.rot90cw" href="#vipy.geometry.BoundingBox.rot90cw">rot90cw</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.scale_x" href="#vipy.geometry.BoundingBox.scale_x">scale_x</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.scale_y" href="#vipy.geometry.BoundingBox.scale_y">scale_y</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.set_origin" href="#vipy.geometry.BoundingBox.set_origin">set_origin</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.setheight" href="#vipy.geometry.BoundingBox.setheight">setheight</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.setwidth" href="#vipy.geometry.BoundingBox.setwidth">setwidth</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.shape" href="#vipy.geometry.BoundingBox.shape">shape</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.shapedist" href="#vipy.geometry.BoundingBox.shapedist">shapedist</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.shapeiou" href="#vipy.geometry.BoundingBox.shapeiou">shapeiou</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.significant_digits" href="#vipy.geometry.BoundingBox.significant_digits">significant_digits</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.sqdist" href="#vipy.geometry.BoundingBox.sqdist">sqdist</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.to_origin" href="#vipy.geometry.BoundingBox.to_origin">to_origin</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.to_ulbr" href="#vipy.geometry.BoundingBox.to_ulbr">to_ulbr</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.to_xywh" href="#vipy.geometry.BoundingBox.to_xywh">to_xywh</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.top" href="#vipy.geometry.BoundingBox.top">top</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.translate" href="#vipy.geometry.BoundingBox.translate">translate</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.ul" href="#vipy.geometry.BoundingBox.ul">ul</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.ulbr" href="#vipy.geometry.BoundingBox.ulbr">ulbr</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.ulx" href="#vipy.geometry.BoundingBox.ulx">ulx</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.uly" href="#vipy.geometry.BoundingBox.uly">uly</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.union" href="#vipy.geometry.BoundingBox.union">union</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.upperleft" href="#vipy.geometry.BoundingBox.upperleft">upperleft</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.upperright" href="#vipy.geometry.BoundingBox.upperright">upperright</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.ur" href="#vipy.geometry.BoundingBox.ur">ur</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.urx" href="#vipy.geometry.BoundingBox.urx">urx</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.ury" href="#vipy.geometry.BoundingBox.ury">ury</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.valid" href="#vipy.geometry.BoundingBox.valid">valid</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.width" href="#vipy.geometry.BoundingBox.width">width</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.x_centroid" href="#vipy.geometry.BoundingBox.x_centroid">x_centroid</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.xcentroid" href="#vipy.geometry.BoundingBox.xcentroid">xcentroid</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.xmax" href="#vipy.geometry.BoundingBox.xmax">xmax</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.xmin" href="#vipy.geometry.BoundingBox.xmin">xmin</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.xywh" href="#vipy.geometry.BoundingBox.xywh">xywh</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.y_centroid" href="#vipy.geometry.BoundingBox.y_centroid">y_centroid</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.ycentroid" href="#vipy.geometry.BoundingBox.ycentroid">ycentroid</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.ymax" href="#vipy.geometry.BoundingBox.ymax">ymax</a></code></li>
<li><code><a title="vipy.geometry.BoundingBox.ymin" href="#vipy.geometry.BoundingBox.ymin">ymin</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vipy.geometry.Ellipse" href="#vipy.geometry.Ellipse">Ellipse</a></code></h4>
<ul class="two-column">
<li><code><a title="vipy.geometry.Ellipse.angle" href="#vipy.geometry.Ellipse.angle">angle</a></code></li>
<li><code><a title="vipy.geometry.Ellipse.area" href="#vipy.geometry.Ellipse.area">area</a></code></li>
<li><code><a title="vipy.geometry.Ellipse.axes" href="#vipy.geometry.Ellipse.axes">axes</a></code></li>
<li><code><a title="vipy.geometry.Ellipse.boundingbox" href="#vipy.geometry.Ellipse.boundingbox">boundingbox</a></code></li>
<li><code><a title="vipy.geometry.Ellipse.center" href="#vipy.geometry.Ellipse.center">center</a></code></li>
<li><code><a title="vipy.geometry.Ellipse.centroid" href="#vipy.geometry.Ellipse.centroid">centroid</a></code></li>
<li><code><a title="vipy.geometry.Ellipse.dict" href="#vipy.geometry.Ellipse.dict">dict</a></code></li>
<li><code><a title="vipy.geometry.Ellipse.inside" href="#vipy.geometry.Ellipse.inside">inside</a></code></li>
<li><code><a title="vipy.geometry.Ellipse.mask" href="#vipy.geometry.Ellipse.mask">mask</a></code></li>
<li><code><a title="vipy.geometry.Ellipse.rescale" href="#vipy.geometry.Ellipse.rescale">rescale</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vipy.geometry.Point2d" href="#vipy.geometry.Point2d">Point2d</a></code></h4>
<ul class="">
<li><code><a title="vipy.geometry.Point2d.area_of_intersection" href="#vipy.geometry.Point2d.area_of_intersection">area_of_intersection</a></code></li>
<li><code><a title="vipy.geometry.Point2d.area_of_union" href="#vipy.geometry.Point2d.area_of_union">area_of_union</a></code></li>
<li><code><a title="vipy.geometry.Point2d.boundingbox" href="#vipy.geometry.Point2d.boundingbox">boundingbox</a></code></li>
<li><code><a title="vipy.geometry.Point2d.clone" href="#vipy.geometry.Point2d.clone">clone</a></code></li>
<li><code><a title="vipy.geometry.Point2d.coord" href="#vipy.geometry.Point2d.coord">coord</a></code></li>
<li><code><a title="vipy.geometry.Point2d.cover" href="#vipy.geometry.Point2d.cover">cover</a></code></li>
<li><code><a title="vipy.geometry.Point2d.diameter" href="#vipy.geometry.Point2d.diameter">diameter</a></code></li>
<li><code><a title="vipy.geometry.Point2d.dict" href="#vipy.geometry.Point2d.dict">dict</a></code></li>
<li><code><a title="vipy.geometry.Point2d.dilate" href="#vipy.geometry.Point2d.dilate">dilate</a></code></li>
<li><code><a title="vipy.geometry.Point2d.dist" href="#vipy.geometry.Point2d.dist">dist</a></code></li>
<li><code><a title="vipy.geometry.Point2d.fliplr" href="#vipy.geometry.Point2d.fliplr">fliplr</a></code></li>
<li><code><a title="vipy.geometry.Point2d.flipud" href="#vipy.geometry.Point2d.flipud">flipud</a></code></li>
<li><code><a title="vipy.geometry.Point2d.float" href="#vipy.geometry.Point2d.float">float</a></code></li>
<li><code><a title="vipy.geometry.Point2d.from_json" href="#vipy.geometry.Point2d.from_json">from_json</a></code></li>
<li><code><a title="vipy.geometry.Point2d.has_intersection" href="#vipy.geometry.Point2d.has_intersection">has_intersection</a></code></li>
<li><code><a title="vipy.geometry.Point2d.hasoverlap" href="#vipy.geometry.Point2d.hasoverlap">hasoverlap</a></code></li>
<li><code><a title="vipy.geometry.Point2d.height" href="#vipy.geometry.Point2d.height">height</a></code></li>
<li><code><a title="vipy.geometry.Point2d.imclip" href="#vipy.geometry.Point2d.imclip">imclip</a></code></li>
<li><code><a title="vipy.geometry.Point2d.int" href="#vipy.geometry.Point2d.int">int</a></code></li>
<li><code><a title="vipy.geometry.Point2d.iou" href="#vipy.geometry.Point2d.iou">iou</a></code></li>
<li><code><a title="vipy.geometry.Point2d.is_inside_boundingbox" href="#vipy.geometry.Point2d.is_inside_boundingbox">is_inside_boundingbox</a></code></li>
<li><code><a title="vipy.geometry.Point2d.is_inside_imagebox" href="#vipy.geometry.Point2d.is_inside_imagebox">is_inside_imagebox</a></code></li>
<li><code><a title="vipy.geometry.Point2d.is_inside_radius" href="#vipy.geometry.Point2d.is_inside_radius">is_inside_radius</a></code></li>
<li><code><a title="vipy.geometry.Point2d.is_positive" href="#vipy.geometry.Point2d.is_positive">is_positive</a></code></li>
<li><code><a title="vipy.geometry.Point2d.isinteger" href="#vipy.geometry.Point2d.isinteger">isinteger</a></code></li>
<li><code><a title="vipy.geometry.Point2d.json" href="#vipy.geometry.Point2d.json">json</a></code></li>
<li><code><a title="vipy.geometry.Point2d.offset" href="#vipy.geometry.Point2d.offset">offset</a></code></li>
<li><code><a title="vipy.geometry.Point2d.origin" href="#vipy.geometry.Point2d.origin">origin</a></code></li>
<li><code><a title="vipy.geometry.Point2d.r" href="#vipy.geometry.Point2d.r">r</a></code></li>
<li><code><a title="vipy.geometry.Point2d.radius" href="#vipy.geometry.Point2d.radius">radius</a></code></li>
<li><code><a title="vipy.geometry.Point2d.rescale" href="#vipy.geometry.Point2d.rescale">rescale</a></code></li>
<li><code><a title="vipy.geometry.Point2d.rot90ccw" href="#vipy.geometry.Point2d.rot90ccw">rot90ccw</a></code></li>
<li><code><a title="vipy.geometry.Point2d.rot90cw" href="#vipy.geometry.Point2d.rot90cw">rot90cw</a></code></li>
<li><code><a title="vipy.geometry.Point2d.scale_r" href="#vipy.geometry.Point2d.scale_r">scale_r</a></code></li>
<li><code><a title="vipy.geometry.Point2d.scale_x" href="#vipy.geometry.Point2d.scale_x">scale_x</a></code></li>
<li><code><a title="vipy.geometry.Point2d.scale_y" href="#vipy.geometry.Point2d.scale_y">scale_y</a></code></li>
<li><code><a title="vipy.geometry.Point2d.significant_digits" href="#vipy.geometry.Point2d.significant_digits">significant_digits</a></code></li>
<li><code><a title="vipy.geometry.Point2d.translate" href="#vipy.geometry.Point2d.translate">translate</a></code></li>
<li><code><a title="vipy.geometry.Point2d.union" href="#vipy.geometry.Point2d.union">union</a></code></li>
<li><code><a title="vipy.geometry.Point2d.width" href="#vipy.geometry.Point2d.width">width</a></code></li>
<li><code><a title="vipy.geometry.Point2d.x" href="#vipy.geometry.Point2d.x">x</a></code></li>
<li><code><a title="vipy.geometry.Point2d.xmax" href="#vipy.geometry.Point2d.xmax">xmax</a></code></li>
<li><code><a title="vipy.geometry.Point2d.xmin" href="#vipy.geometry.Point2d.xmin">xmin</a></code></li>
<li><code><a title="vipy.geometry.Point2d.y" href="#vipy.geometry.Point2d.y">y</a></code></li>
<li><code><a title="vipy.geometry.Point2d.ymax" href="#vipy.geometry.Point2d.ymax">ymax</a></code></li>
<li><code><a title="vipy.geometry.Point2d.ymin" href="#vipy.geometry.Point2d.ymin">ymin</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
