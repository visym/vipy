<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.11.6" />
<meta name="google-site-verification" content="aB8LkQegj94_TJPdrcJm2ldIRWyXY82Jp24Gtkdgyn0" />
<title>vipy.pyramid API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}#lunr-search{width:100%;font-size:1em;padding:6px 9px 5px 9px;border:1px solid silver}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>vipy.pyramid</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/pyramid.py#L1-L332" class="git-link">Browse git</a>
</summary>
<pre><code class="python">import vipy
import numpy as np
import copy
import math

vipy.util.try_import(&#39;torch&#39;)
import torch



class GaussianPyramid():
    &#34;&#34;&#34;vipy.pyramid.GaussianPyramid() class&#34;&#34;&#34;
    def __init__(self, im=None, tensor=None):
        assert im is not None or tensor is not None
        assert im is None or isinstance(im, vipy.image.Image)
        assert tensor is None or (torch.is_tensor(tensor) and tensor.ndim == 4)
        
        g = ((1.0/np.sqrt(2*np.pi))*np.exp(-0.5*(np.array([-2,-1,0,1,2])**2))).astype(np.float32)
        G = torch.from_numpy(np.outer(g,g)).repeat( (3,1,1,1) )
        
        self._G = G
        self._band = []
        self._pad = torch.nn.ReflectionPad2d(2)
        
        x = im.float().torch(order=&#39;NCHW&#39;) if im is not None else tensor
        for k in range(int(np.log2(min(x.shape[2], x.shape[3]))-2)):
            y = torch.nn.functional.conv2d(self._pad(x), self._G, groups=3)  # anti-aliasing
            self._band.append(y)  # lowpass
            x = y[:,:,::2,::2]  # downsample
        self._band.append(x)  # lowpass

    def __len__(self):
        return len(self._band)

    def __iter__(self):
        for k in range(len(self)):
            yield self[k]
    
    def __getitem__(self, k):
        assert k&gt;=0 and k&lt;len(self)
        return vipy.image.Image.fromtorch(self._band[k])

    def band(self, k):
        return self[k]

    def show(self, mindim=256):
        return vipy.visualize.montage([im.maxsquare() for im in self], mindim, mindim).show()

    
class LaplacianPyramid():
    &#34;&#34;&#34;vipy.pyramid.LaplacianPyramid() class&#34;&#34;&#34;    
    def __init__(self, im, pad=&#39;zero&#39;):
        
        g = (1.0/np.sqrt(2*np.pi))*np.exp(-0.5*(np.array([-2,-1,0,1,2])**2))
        G = torch.from_numpy(np.outer(g,g).astype(np.float32))

        self._G = G.repeat( (3,1,1,1) )
        self._Ce = torch.sum(G[::2,::2])  # filter coefficient sum, even elements only
        self._Co = torch.sum(G[1::2,1::2]) # filter coefficient sum, odd elements only
        self._band = []
        self._im = im
        
        if pad == &#39;zero&#39;:
            self._pad = torch.nn.ZeroPad2d(2)  # introduces lowpass corner boundary artifact on reconstruction
            self._gain = 1.6  # rescale to approximately correct boundary artifact
        elif pad == &#39;reflect&#39;:
            self._pad = torch.nn.ReflectionPad2d(2)  # introduces lowpass gain boundary artifact on reconstruction
            self._gain = 1.4  # rescale to approximately correct boundary artifact
        else:
            raise ValueError(&#39;unknown padding &#34;%s&#34; - must be [&#34;zero&#34;, &#34;reflect&#34;]&#39; % pad)

        if isinstance(im, vipy.image.Image):
            x = im.float().torch(order=&#39;NCHW&#39;)
            for k in range(int(np.log2(im.mindim())-1)):
                y = torch.nn.functional.conv2d(self._pad(x), self._G, groups=3)  # anti-aliasing
                self._band.append(x-y)  # bandpass
                x = y[:,:,::2,::2]  # even downsample
            self._band.append(x)  # lowpass
        elif isinstance(im, list):
            assert all([torch.is_tensor(b) for b in im])
            self._band = im
            self._im = self[0].clone().zeros()  # no source image available
        else:
            raise ValueError(&#39;invalid input&#39;)

    def __repr__(self):
        return &#39;&lt;vipy.pyramid.LaplacianPyramid: scales=%d, channels=%d, height=%d, width=%d&gt;&#39; % (self.scales(), self.channels(), self.height(), self.width())
    
    def __len__(self):
        return len(self._band)

    def __iter__(self):
        for k in range(len(self)):
            yield self[k]
            
    def __getitem__(self, k):
        assert k&gt;=0 and k&lt;len(self)
        return vipy.image.Image.fromtorch(self._band[k])

    def band(self, k):
        return self[k]

    def reconstruct(self):
        x = self._band[-1]
        for b in reversed(self._band[0:-1]):
            xz = torch.zeros(1, b.shape[1], b.shape[2], b.shape[3])
            xz[:,:,::2,::2] = x  # odd zero interpolate (even signal)
            xu = torch.nn.functional.conv2d(self._pad(xz), (1.0/self._Ce)*self._G, groups=3)  # upsample, rescale using sum of non-zeroed kernel elements for even locations
            xu[:,:,1::2,1::2] *= (self._Ce/self._Co)  # upsample, rescale using sum of non-zeroed kernel elements for odd locations
            x = xu + b  # reconstruction
        im = vipy.image.Image.fromtorch((x * self._gain).clamp(0, 255))  # final rescale due to padding boundary artifact (can also use im.mat2gray)
        return im.array(im.numpy().astype(np.uint8)).colorspace(&#39;rgb&#39;)

    def show(self, mindim=256):
        return vipy.visualize.montage([im.maxsquare().resize(mindim, mindim, interp=&#39;nearest&#39;) for im in self], mindim, mindim).show()

    def height(self):
        return self._im.height()
    def width(self):
        return self._im.width()
    def channels(self):
        return self._im.channels()
    def scales(self):
        return len(self)
    
    def tensor(self, interp=&#39;nearest&#39;):
        return torch.stack([im.resize(self.height(), self.width(), interp=interp).torch(order=&#39;CHW&#39;) for im in self])  # scales() x channels() x height() x width()

    @staticmethod
    def fromtensor(bands):
        &#34;&#34;&#34;Convert a S*CxHxW torch tensor back to LaplacianPyramid&#34;&#34;&#34;
        assert torch.is_tensor(bands) and bands.ndim == 4
        (S,C,H,W) = bands.shape
        return LaplacianPyramid([vipy.image.Image.fromtorch(b).resize(H//(2**i), W//(2**i), interp=&#39;nearest&#39;).torch(order=&#39;NCHW&#39;) for (i,b) in enumerate(bands)])

    
class Foveation(LaplacianPyramid):
    def __init__(self, im, mode=&#39;log-circle&#39;, s=None):        
        super().__init__(im)

        (H,W) = (im.height(), im.width())
        allowable_modes = [&#39;gaussian&#39;, &#39;linear-circle&#39;, &#39;linear-square&#39;, &#39;log-circle&#39;]
        if mode == &#39;gaussian&#39;:
            s = s*(W/2) if s is not None else W/2            
            G = vipy.math.gaussian2d([W,H], [s,s], 2*H, 2*W)
            M = np.repeat(G[:,:,np.newaxis], 3, axis=2)
            thresholds = np.arange(0, float(np.max(G)), np.max(G)/len(self))
            masks = [vipy.image.Image(array=255*np.array(M&gt;=t).astype(np.uint8)).blur(16).mat2gray(min=0) for t in thresholds]
        elif mode == &#39;linear-circle&#39;:
            s = s*2.0 if s is not None else 2.0
            masks = [vipy.calibration.imcircle(W, H, s*(d/2), 2*W, 2*H, 3).rgb().blur(16).mat2gray(min=0) for d in np.arange(max(H,W), 0, -max(H,W)/len(self))]
        elif mode == &#39;log-circle&#39;:
            s = s*0.125 if s is not None else 0.125                        
            masks = [vipy.calibration.imcircle(W, H, (s*(d/2))**2, 2*W, 2*H, 3).rgb().blur(16).mat2gray(min=0) for d in np.arange(max(H,W), 0, -max(H,W)/len(self))]
        elif mode == &#39;linear-square&#39;:
            s = s*2.0 if s is not None else 2.0                        
            masks = [vipy.image.Image(array=vipy.calibration.square(W,H,s*(d/2),2*W,2*H,3).astype(np.float32), colorspace=&#39;float&#39;) for d in np.arange(max(H,W), 0, -max(H,W)/len(self))]
        else:
            raise ValueError(&#39;invalid mode &#34;%s&#34; - must be in %s&#39; % (mode, str(allowable_modes)))
        self._immasks = masks
        self._masks = [m.torch(order=&#39;NCHW&#39;) for m in masks]

    def __call__(self, tx=0, ty=0, sx=1.0, sy=1.0):
        (C, H,W) = (self.channels(), self.height(), self.width())        
        theta = torch.FloatTensor([[sx,0,tx],[0,sy,ty]]).repeat( (1, 1, 1) )
        G = torch.nn.functional.affine_grid(theta, (1, C, H, W), align_corners=False)
        blend = [GaussianPyramid(tensor=torch.nn.functional.grid_sample(m, G, align_corners=False)) for m in self._masks]        

        pyr = copy.deepcopy(self)
        pyr._band[:-1] = [torch.mul(w[k].torch(order=&#39;NCHW&#39;), b) for (k, (w,b)) in enumerate(zip(reversed(blend), pyr._band[:-1]))]
        return pyr.reconstruct()
        
    def foveate(self, tx=0, ty=0):
        &#34;&#34;&#34;Foveate the input image at location (tx, ty) in scaled image coordinates where (0,0) is the center and (1,1) is the upper left&#34;&#34;&#34;        
        return self.__call__(tx=tx, ty=ty, sx=1.0, sy=1.0)

    def visualize(self):
        &#34;&#34;&#34;Show the fovea density&#34;&#34;&#34;
        imgmask = self._immasks[0].clone().mat2gray().numpy()
        for (im,c) in zip(self._immasks, range(0, 255, len(self))):
            img = im.clone().mat2gray(min=0).numpy()
            imgmask += c*img
        return vipy.image.Image(array=imgmask)

    
class SteerablePyramid():
    def __init__(self, im):
        vipy.util.try_import(&#39;pyrtools&#39;)
        import pyrtools
        
        assert isinstance(im, vipy.image.Image)
        assert im.mindim() &gt;= 32        
        self._channels = [pyrtools.pyramids.SteerablePyramidFreq(imc.load().array().astype(float), height=&#39;auto&#39;, order=3) for imc in im.channel()]                
        
    @property
    def num_scales(self):
        return self._channels[0].num_scales

    @property
    def num_orientations(self):
        return self._channels[0].num_orientations

    @property
    def num_channels(self):
        return len(self._channels)           
        
    def bandpass(self, channel):
        return [self._channels[channel].pyr_coeffs[(s,o)] for s in range(self.num_scales) for o in range(self.num_orientations)]
    
    def lowpass(self, channel):
        return self._channels[channel].pyr_coeffs[&#39;residual_lowpass&#39;]

    def highpass(self, channel):
        return self._channels[channel].pyr_coeffs[&#39;residual_highpass&#39;]        
    
    def synthesis(self):        
        return vipy.image.Image(array=np.stack([pyr.recon_pyr() for pyr in self._channels], axis=2).astype(np.float32)).mat2gray()

    def multichannel(self):
        &#34;&#34;&#34;a multichannel image is an image of the same shape as the input, but with channels from pyramid decomposition.  Coefficients are resized using bilinear interpolation.&#34;&#34;&#34;
        (H,W) = self.highpass(0).shape
        resizer = lambda x: np.array(torch.nn.functional.interpolate(torch.tensor(x).view(1,1,x.shape[0],x.shape[1]), size=(H,W), mode=&#39;bilinear&#39;)).squeeze()            
        return vipy.image.Image(array=np.stack([resizer(x) for c in range(self.num_channels) for x in self.bandpass(c)+[self.lowpass(c),self.highpass(c)]], axis=2).astype(np.float32))

    def montage(self):
        &#34;&#34;&#34;scales by row, orientations by col, channels merged back into color image, last image is lowpass&#34;&#34;&#34;
        imlist = [vipy.image.Image(array=np.stack([self._channels[c].pyr_coeffs[(s,o)] for c in range(self.num_channels)], axis=2).astype(np.float32)) for s in range(self.num_scales) for o in range(self.num_orientations)]
        imlist += [vipy.image.Image(array=np.stack([self.lowpass(c) for c in range(self.num_channels)], axis=2).astype(np.float32))]
        imlist += [vipy.image.Image(array=np.stack([self.highpass(c) for c in range(self.num_channels)], axis=2).astype(np.float32))]        
        return vipy.visualize.montage([im.mat2gray().rgb() for im in imlist], gridrows=self.num_scales+1, gridcols=self.num_orientations)

    

class BatchSteerablePyramid():
    def __init__(self, height, width, channels, device=&#39;cpu&#39;, orientations=4):
        vipy.util.try_import(&#39;plenoptic&#39;)
        import plenoptic as po

        assert height &gt;= 32 and width &gt;= 32        
        self._pyr = po.simulate.SteerablePyramidFreq(height=&#39;auto&#39;, image_shape=[height, width], twidth=1, order=orientations-1, downsample=False, is_complex=True).to(device)
        self._pyr.eval()
        self._imheight = height
        self._imwidth = width
        self._imchannels = channels
        self._device = device
        self._pyr_info = None
        self._tensor = None
        
    def device(self, d=None):
        if d is not None:
            self._device = d  # check device in self._pyr._buffers[&#39;lo0mask&#39;], or just store here
            self._pyr = self._pyr.cpu() if d == &#39;cpu&#39; else self._pyr.to(d)
            return self
        return self._device
                
    @property
    def num_scales(self):
        return self._pyr.num_scales

    @property
    def num_orientations(self):
        return self._pyr.num_orientations

    @property
    def num_channels(self):
        return (self._pyr.num_orientations*self._pyr.num_scales + 2)*self._imchannels

    def to(self, dev):
        return self.device(dev)    

    def forward(self, x):
        assert (torch.is_tensor(x) and x.ndim == 4) or isinstance(x, vipy.image.Image) or (isinstance(x, (list, tuple)) and all([isinstance(im, vipy.image.Image) for im in x]))

        x = torch.stack([im.torch(&#39;CHW&#39;) for im in vipy.util.tolist(x)]) if not torch.is_tensor(x) else x
        assert x.shape[2] == self._imheight and x.shape[3] == self._imwidth, &#34;wrong input shape&#34;
        assert x.shape[1] == self._imchannels, &#34;wrong input channels&#34;

        with torch.no_grad():        
            (self._tensor, self._pyr_info) =  self._pyr.convert_pyr_to_tensor(self._pyr.forward(x.to(self.device())))
        return self

    def forwarded(self):
        return self._tensor is not None
    
    def tensor(self):
        &#34;&#34;&#34;a pyramid tensor is an NxCxHxW tensor (same shape as the input), but with channels from complex (even, odd) pyramid coefficients
        The first channel will be the residual highpass and the last will be the residual lowpass. Each band is then a separate channel in (scale, orientation) order

        input is NxCxHxW tensor
        &#34;&#34;&#34;
        assert self.forwarded() 
        return self._tensor

    def band(self, scale, orientation):
        assert scale &lt;= self.num_scales and orientation &lt;= self.num_orientations
        return self.tensor()[:, 1+scale*self.num_orientations + orientation,:,:]

    def magnitude(self):
        &#34;&#34;&#34;return magnitude component of complex steerable pyramid&#34;&#34;&#34;
        return self.tensor().abs()

    def phase(self):
        &#34;&#34;&#34;return phase component of complex steerable pyramid&#34;&#34;&#34;
        return self.tensor().angle()        
    
    def montage(self, x):
        &#34;&#34;&#34;return a montage visualization of the pyramid, scales by row, orientations by col, channels merged back into color image, last row is highpass and lowpass&#34;&#34;&#34;
        assert self.forwarded()
        assert torch.is_tensor(x) and x.ndim == 4 and x.shape == self._tensor.shape
        
        (C,N) = (x.shape[1], x.shape[1]//self._imchannels)
        return vipy.visualize.montage([vipy.image.Image.fromtorch(x[0,j::N,:,:]).mat2gray().rgb() for j in list(range(1,N-1))+[0,N-1]],
                                       gridrows=self.num_scales+1, gridcols=self.num_orientations)                

        
    def synthesis(self, x):
        &#34;&#34;&#34;Generate a synthesis of the multichannel tensor x&#34;&#34;&#34;
        assert self.forwarded()
        assert torch.is_tensor(x) and x.ndim == 4 and x.shape == self._tensor.shape

        img = self._pyr.recon_pyr(self._pyr.convert_tensor_to_pyr(x, pyr_keys=self._pyr_info[2], num_channels=self._pyr_info[0], split_complex=self._pyr_info[1]))
        return [vipy.image.Image.fromtorch(t) for t in img]  # one image per batch element

    
    def phase_congruency(self, eps=1E-6):
        (M,P) = (self.magnitude()[:,1:-1,:,:], self.phase()[:,1:-1,:,:])
        return torch.sum( M * torch.cos(P - ((M*P).sum(dim=1, keepdims=True) / (eps + M.sum(dim=1, keepdims=True)))), dim=1, keepdims=True) / (eps + torch.sum(M, dim=1, keepdims=True))

    def zero_crossing(self, eps=1E-6):
        (M,P) = (self.magnitude()[:,1:-1,:,:], self.phase()[:,1:-1,:,:])
        return torch.sum( M*torch.nn.functional.relu(torch.cos(P)), dim=1, keepdims=True)
    </code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="vipy.pyramid.BatchSteerablePyramid"><code class="flex name class">
<span>class <span class="ident">BatchSteerablePyramid</span></span>
<span>(</span><span>height, width, channels, device='cpu', orientations=4)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/pyramid.py#L234-L331" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class BatchSteerablePyramid():
    def __init__(self, height, width, channels, device=&#39;cpu&#39;, orientations=4):
        vipy.util.try_import(&#39;plenoptic&#39;)
        import plenoptic as po

        assert height &gt;= 32 and width &gt;= 32        
        self._pyr = po.simulate.SteerablePyramidFreq(height=&#39;auto&#39;, image_shape=[height, width], twidth=1, order=orientations-1, downsample=False, is_complex=True).to(device)
        self._pyr.eval()
        self._imheight = height
        self._imwidth = width
        self._imchannels = channels
        self._device = device
        self._pyr_info = None
        self._tensor = None
        
    def device(self, d=None):
        if d is not None:
            self._device = d  # check device in self._pyr._buffers[&#39;lo0mask&#39;], or just store here
            self._pyr = self._pyr.cpu() if d == &#39;cpu&#39; else self._pyr.to(d)
            return self
        return self._device
                
    @property
    def num_scales(self):
        return self._pyr.num_scales

    @property
    def num_orientations(self):
        return self._pyr.num_orientations

    @property
    def num_channels(self):
        return (self._pyr.num_orientations*self._pyr.num_scales + 2)*self._imchannels

    def to(self, dev):
        return self.device(dev)    

    def forward(self, x):
        assert (torch.is_tensor(x) and x.ndim == 4) or isinstance(x, vipy.image.Image) or (isinstance(x, (list, tuple)) and all([isinstance(im, vipy.image.Image) for im in x]))

        x = torch.stack([im.torch(&#39;CHW&#39;) for im in vipy.util.tolist(x)]) if not torch.is_tensor(x) else x
        assert x.shape[2] == self._imheight and x.shape[3] == self._imwidth, &#34;wrong input shape&#34;
        assert x.shape[1] == self._imchannels, &#34;wrong input channels&#34;

        with torch.no_grad():        
            (self._tensor, self._pyr_info) =  self._pyr.convert_pyr_to_tensor(self._pyr.forward(x.to(self.device())))
        return self

    def forwarded(self):
        return self._tensor is not None
    
    def tensor(self):
        &#34;&#34;&#34;a pyramid tensor is an NxCxHxW tensor (same shape as the input), but with channels from complex (even, odd) pyramid coefficients
        The first channel will be the residual highpass and the last will be the residual lowpass. Each band is then a separate channel in (scale, orientation) order

        input is NxCxHxW tensor
        &#34;&#34;&#34;
        assert self.forwarded() 
        return self._tensor

    def band(self, scale, orientation):
        assert scale &lt;= self.num_scales and orientation &lt;= self.num_orientations
        return self.tensor()[:, 1+scale*self.num_orientations + orientation,:,:]

    def magnitude(self):
        &#34;&#34;&#34;return magnitude component of complex steerable pyramid&#34;&#34;&#34;
        return self.tensor().abs()

    def phase(self):
        &#34;&#34;&#34;return phase component of complex steerable pyramid&#34;&#34;&#34;
        return self.tensor().angle()        
    
    def montage(self, x):
        &#34;&#34;&#34;return a montage visualization of the pyramid, scales by row, orientations by col, channels merged back into color image, last row is highpass and lowpass&#34;&#34;&#34;
        assert self.forwarded()
        assert torch.is_tensor(x) and x.ndim == 4 and x.shape == self._tensor.shape
        
        (C,N) = (x.shape[1], x.shape[1]//self._imchannels)
        return vipy.visualize.montage([vipy.image.Image.fromtorch(x[0,j::N,:,:]).mat2gray().rgb() for j in list(range(1,N-1))+[0,N-1]],
                                       gridrows=self.num_scales+1, gridcols=self.num_orientations)                

        
    def synthesis(self, x):
        &#34;&#34;&#34;Generate a synthesis of the multichannel tensor x&#34;&#34;&#34;
        assert self.forwarded()
        assert torch.is_tensor(x) and x.ndim == 4 and x.shape == self._tensor.shape

        img = self._pyr.recon_pyr(self._pyr.convert_tensor_to_pyr(x, pyr_keys=self._pyr_info[2], num_channels=self._pyr_info[0], split_complex=self._pyr_info[1]))
        return [vipy.image.Image.fromtorch(t) for t in img]  # one image per batch element

    
    def phase_congruency(self, eps=1E-6):
        (M,P) = (self.magnitude()[:,1:-1,:,:], self.phase()[:,1:-1,:,:])
        return torch.sum( M * torch.cos(P - ((M*P).sum(dim=1, keepdims=True) / (eps + M.sum(dim=1, keepdims=True)))), dim=1, keepdims=True) / (eps + torch.sum(M, dim=1, keepdims=True))

    def zero_crossing(self, eps=1E-6):
        (M,P) = (self.magnitude()[:,1:-1,:,:], self.phase()[:,1:-1,:,:])
        return torch.sum( M*torch.nn.functional.relu(torch.cos(P)), dim=1, keepdims=True)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="vipy.pyramid.BatchSteerablePyramid.num_channels"><code class="name">var <span class="ident">num_channels</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/pyramid.py#L264-L266" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def num_channels(self):
    return (self._pyr.num_orientations*self._pyr.num_scales + 2)*self._imchannels</code></pre>
</details>
</dd>
<dt id="vipy.pyramid.BatchSteerablePyramid.num_orientations"><code class="name">var <span class="ident">num_orientations</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/pyramid.py#L260-L262" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def num_orientations(self):
    return self._pyr.num_orientations</code></pre>
</details>
</dd>
<dt id="vipy.pyramid.BatchSteerablePyramid.num_scales"><code class="name">var <span class="ident">num_scales</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/pyramid.py#L256-L258" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def num_scales(self):
    return self._pyr.num_scales</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="vipy.pyramid.BatchSteerablePyramid.band"><code class="name flex">
<span>def <span class="ident">band</span></span>(<span>self, scale, orientation)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/pyramid.py#L294-L296" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def band(self, scale, orientation):
    assert scale &lt;= self.num_scales and orientation &lt;= self.num_orientations
    return self.tensor()[:, 1+scale*self.num_orientations + orientation,:,:]</code></pre>
</details>
</dd>
<dt id="vipy.pyramid.BatchSteerablePyramid.device"><code class="name flex">
<span>def <span class="ident">device</span></span>(<span>self, d=None)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/pyramid.py#L249-L254" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def device(self, d=None):
    if d is not None:
        self._device = d  # check device in self._pyr._buffers[&#39;lo0mask&#39;], or just store here
        self._pyr = self._pyr.cpu() if d == &#39;cpu&#39; else self._pyr.to(d)
        return self
    return self._device</code></pre>
</details>
</dd>
<dt id="vipy.pyramid.BatchSteerablePyramid.forward"><code class="name flex">
<span>def <span class="ident">forward</span></span>(<span>self, x)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/pyramid.py#L271-L280" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def forward(self, x):
    assert (torch.is_tensor(x) and x.ndim == 4) or isinstance(x, vipy.image.Image) or (isinstance(x, (list, tuple)) and all([isinstance(im, vipy.image.Image) for im in x]))

    x = torch.stack([im.torch(&#39;CHW&#39;) for im in vipy.util.tolist(x)]) if not torch.is_tensor(x) else x
    assert x.shape[2] == self._imheight and x.shape[3] == self._imwidth, &#34;wrong input shape&#34;
    assert x.shape[1] == self._imchannels, &#34;wrong input channels&#34;

    with torch.no_grad():        
        (self._tensor, self._pyr_info) =  self._pyr.convert_pyr_to_tensor(self._pyr.forward(x.to(self.device())))
    return self</code></pre>
</details>
</dd>
<dt id="vipy.pyramid.BatchSteerablePyramid.forwarded"><code class="name flex">
<span>def <span class="ident">forwarded</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/pyramid.py#L282-L283" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def forwarded(self):
    return self._tensor is not None</code></pre>
</details>
</dd>
<dt id="vipy.pyramid.BatchSteerablePyramid.magnitude"><code class="name flex">
<span>def <span class="ident">magnitude</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>return magnitude component of complex steerable pyramid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/pyramid.py#L298-L300" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def magnitude(self):
    &#34;&#34;&#34;return magnitude component of complex steerable pyramid&#34;&#34;&#34;
    return self.tensor().abs()</code></pre>
</details>
</dd>
<dt id="vipy.pyramid.BatchSteerablePyramid.montage"><code class="name flex">
<span>def <span class="ident">montage</span></span>(<span>self, x)</span>
</code></dt>
<dd>
<div class="desc"><p>return a montage visualization of the pyramid, scales by row, orientations by col, channels merged back into color image, last row is highpass and lowpass</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/pyramid.py#L306-L313" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def montage(self, x):
    &#34;&#34;&#34;return a montage visualization of the pyramid, scales by row, orientations by col, channels merged back into color image, last row is highpass and lowpass&#34;&#34;&#34;
    assert self.forwarded()
    assert torch.is_tensor(x) and x.ndim == 4 and x.shape == self._tensor.shape
    
    (C,N) = (x.shape[1], x.shape[1]//self._imchannels)
    return vipy.visualize.montage([vipy.image.Image.fromtorch(x[0,j::N,:,:]).mat2gray().rgb() for j in list(range(1,N-1))+[0,N-1]],
                                   gridrows=self.num_scales+1, gridcols=self.num_orientations)                </code></pre>
</details>
</dd>
<dt id="vipy.pyramid.BatchSteerablePyramid.phase"><code class="name flex">
<span>def <span class="ident">phase</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>return phase component of complex steerable pyramid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/pyramid.py#L302-L304" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def phase(self):
    &#34;&#34;&#34;return phase component of complex steerable pyramid&#34;&#34;&#34;
    return self.tensor().angle()        </code></pre>
</details>
</dd>
<dt id="vipy.pyramid.BatchSteerablePyramid.phase_congruency"><code class="name flex">
<span>def <span class="ident">phase_congruency</span></span>(<span>self, eps=1e-06)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/pyramid.py#L325-L327" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def phase_congruency(self, eps=1E-6):
    (M,P) = (self.magnitude()[:,1:-1,:,:], self.phase()[:,1:-1,:,:])
    return torch.sum( M * torch.cos(P - ((M*P).sum(dim=1, keepdims=True) / (eps + M.sum(dim=1, keepdims=True)))), dim=1, keepdims=True) / (eps + torch.sum(M, dim=1, keepdims=True))</code></pre>
</details>
</dd>
<dt id="vipy.pyramid.BatchSteerablePyramid.synthesis"><code class="name flex">
<span>def <span class="ident">synthesis</span></span>(<span>self, x)</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a synthesis of the multichannel tensor x</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/pyramid.py#L316-L322" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def synthesis(self, x):
    &#34;&#34;&#34;Generate a synthesis of the multichannel tensor x&#34;&#34;&#34;
    assert self.forwarded()
    assert torch.is_tensor(x) and x.ndim == 4 and x.shape == self._tensor.shape

    img = self._pyr.recon_pyr(self._pyr.convert_tensor_to_pyr(x, pyr_keys=self._pyr_info[2], num_channels=self._pyr_info[0], split_complex=self._pyr_info[1]))
    return [vipy.image.Image.fromtorch(t) for t in img]  # one image per batch element</code></pre>
</details>
</dd>
<dt id="vipy.pyramid.BatchSteerablePyramid.tensor"><code class="name flex">
<span>def <span class="ident">tensor</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>a pyramid tensor is an NxCxHxW tensor (same shape as the input), but with channels from complex (even, odd) pyramid coefficients
The first channel will be the residual highpass and the last will be the residual lowpass. Each band is then a separate channel in (scale, orientation) order</p>
<p>input is NxCxHxW tensor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/pyramid.py#L285-L292" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def tensor(self):
    &#34;&#34;&#34;a pyramid tensor is an NxCxHxW tensor (same shape as the input), but with channels from complex (even, odd) pyramid coefficients
    The first channel will be the residual highpass and the last will be the residual lowpass. Each band is then a separate channel in (scale, orientation) order

    input is NxCxHxW tensor
    &#34;&#34;&#34;
    assert self.forwarded() 
    return self._tensor</code></pre>
</details>
</dd>
<dt id="vipy.pyramid.BatchSteerablePyramid.to"><code class="name flex">
<span>def <span class="ident">to</span></span>(<span>self, dev)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/pyramid.py#L268-L269" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def to(self, dev):
    return self.device(dev)    </code></pre>
</details>
</dd>
<dt id="vipy.pyramid.BatchSteerablePyramid.zero_crossing"><code class="name flex">
<span>def <span class="ident">zero_crossing</span></span>(<span>self, eps=1e-06)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/pyramid.py#L329-L331" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def zero_crossing(self, eps=1E-6):
    (M,P) = (self.magnitude()[:,1:-1,:,:], self.phase()[:,1:-1,:,:])
    return torch.sum( M*torch.nn.functional.relu(torch.cos(P)), dim=1, keepdims=True)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="vipy.pyramid.Foveation"><code class="flex name class">
<span>class <span class="ident">Foveation</span></span>
<span>(</span><span>im, mode='log-circle', s=None)</span>
</code></dt>
<dd>
<div class="desc"><p>vipy.pyramid.LaplacianPyramid() class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/pyramid.py#L137-L183" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Foveation(LaplacianPyramid):
    def __init__(self, im, mode=&#39;log-circle&#39;, s=None):        
        super().__init__(im)

        (H,W) = (im.height(), im.width())
        allowable_modes = [&#39;gaussian&#39;, &#39;linear-circle&#39;, &#39;linear-square&#39;, &#39;log-circle&#39;]
        if mode == &#39;gaussian&#39;:
            s = s*(W/2) if s is not None else W/2            
            G = vipy.math.gaussian2d([W,H], [s,s], 2*H, 2*W)
            M = np.repeat(G[:,:,np.newaxis], 3, axis=2)
            thresholds = np.arange(0, float(np.max(G)), np.max(G)/len(self))
            masks = [vipy.image.Image(array=255*np.array(M&gt;=t).astype(np.uint8)).blur(16).mat2gray(min=0) for t in thresholds]
        elif mode == &#39;linear-circle&#39;:
            s = s*2.0 if s is not None else 2.0
            masks = [vipy.calibration.imcircle(W, H, s*(d/2), 2*W, 2*H, 3).rgb().blur(16).mat2gray(min=0) for d in np.arange(max(H,W), 0, -max(H,W)/len(self))]
        elif mode == &#39;log-circle&#39;:
            s = s*0.125 if s is not None else 0.125                        
            masks = [vipy.calibration.imcircle(W, H, (s*(d/2))**2, 2*W, 2*H, 3).rgb().blur(16).mat2gray(min=0) for d in np.arange(max(H,W), 0, -max(H,W)/len(self))]
        elif mode == &#39;linear-square&#39;:
            s = s*2.0 if s is not None else 2.0                        
            masks = [vipy.image.Image(array=vipy.calibration.square(W,H,s*(d/2),2*W,2*H,3).astype(np.float32), colorspace=&#39;float&#39;) for d in np.arange(max(H,W), 0, -max(H,W)/len(self))]
        else:
            raise ValueError(&#39;invalid mode &#34;%s&#34; - must be in %s&#39; % (mode, str(allowable_modes)))
        self._immasks = masks
        self._masks = [m.torch(order=&#39;NCHW&#39;) for m in masks]

    def __call__(self, tx=0, ty=0, sx=1.0, sy=1.0):
        (C, H,W) = (self.channels(), self.height(), self.width())        
        theta = torch.FloatTensor([[sx,0,tx],[0,sy,ty]]).repeat( (1, 1, 1) )
        G = torch.nn.functional.affine_grid(theta, (1, C, H, W), align_corners=False)
        blend = [GaussianPyramid(tensor=torch.nn.functional.grid_sample(m, G, align_corners=False)) for m in self._masks]        

        pyr = copy.deepcopy(self)
        pyr._band[:-1] = [torch.mul(w[k].torch(order=&#39;NCHW&#39;), b) for (k, (w,b)) in enumerate(zip(reversed(blend), pyr._band[:-1]))]
        return pyr.reconstruct()
        
    def foveate(self, tx=0, ty=0):
        &#34;&#34;&#34;Foveate the input image at location (tx, ty) in scaled image coordinates where (0,0) is the center and (1,1) is the upper left&#34;&#34;&#34;        
        return self.__call__(tx=tx, ty=ty, sx=1.0, sy=1.0)

    def visualize(self):
        &#34;&#34;&#34;Show the fovea density&#34;&#34;&#34;
        imgmask = self._immasks[0].clone().mat2gray().numpy()
        for (im,c) in zip(self._immasks, range(0, 255, len(self))):
            img = im.clone().mat2gray(min=0).numpy()
            imgmask += c*img
        return vipy.image.Image(array=imgmask)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="vipy.pyramid.LaplacianPyramid" href="#vipy.pyramid.LaplacianPyramid">LaplacianPyramid</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="vipy.pyramid.Foveation.foveate"><code class="name flex">
<span>def <span class="ident">foveate</span></span>(<span>self, tx=0, ty=0)</span>
</code></dt>
<dd>
<div class="desc"><p>Foveate the input image at location (tx, ty) in scaled image coordinates where (0,0) is the center and (1,1) is the upper left</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/pyramid.py#L173-L175" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def foveate(self, tx=0, ty=0):
    &#34;&#34;&#34;Foveate the input image at location (tx, ty) in scaled image coordinates where (0,0) is the center and (1,1) is the upper left&#34;&#34;&#34;        
    return self.__call__(tx=tx, ty=ty, sx=1.0, sy=1.0)</code></pre>
</details>
</dd>
<dt id="vipy.pyramid.Foveation.visualize"><code class="name flex">
<span>def <span class="ident">visualize</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Show the fovea density</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/pyramid.py#L177-L183" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def visualize(self):
    &#34;&#34;&#34;Show the fovea density&#34;&#34;&#34;
    imgmask = self._immasks[0].clone().mat2gray().numpy()
    for (im,c) in zip(self._immasks, range(0, 255, len(self))):
        img = im.clone().mat2gray(min=0).numpy()
        imgmask += c*img
    return vipy.image.Image(array=imgmask)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="vipy.pyramid.LaplacianPyramid" href="#vipy.pyramid.LaplacianPyramid">LaplacianPyramid</a></b></code>:
<ul class="hlist">
<li><code><a title="vipy.pyramid.LaplacianPyramid.fromtensor" href="#vipy.pyramid.LaplacianPyramid.fromtensor">fromtensor</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="vipy.pyramid.GaussianPyramid"><code class="flex name class">
<span>class <span class="ident">GaussianPyramid</span></span>
<span>(</span><span>im=None, tensor=None)</span>
</code></dt>
<dd>
<div class="desc"><p>vipy.pyramid.GaussianPyramid() class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/pyramid.py#L11-L47" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class GaussianPyramid():
    &#34;&#34;&#34;vipy.pyramid.GaussianPyramid() class&#34;&#34;&#34;
    def __init__(self, im=None, tensor=None):
        assert im is not None or tensor is not None
        assert im is None or isinstance(im, vipy.image.Image)
        assert tensor is None or (torch.is_tensor(tensor) and tensor.ndim == 4)
        
        g = ((1.0/np.sqrt(2*np.pi))*np.exp(-0.5*(np.array([-2,-1,0,1,2])**2))).astype(np.float32)
        G = torch.from_numpy(np.outer(g,g)).repeat( (3,1,1,1) )
        
        self._G = G
        self._band = []
        self._pad = torch.nn.ReflectionPad2d(2)
        
        x = im.float().torch(order=&#39;NCHW&#39;) if im is not None else tensor
        for k in range(int(np.log2(min(x.shape[2], x.shape[3]))-2)):
            y = torch.nn.functional.conv2d(self._pad(x), self._G, groups=3)  # anti-aliasing
            self._band.append(y)  # lowpass
            x = y[:,:,::2,::2]  # downsample
        self._band.append(x)  # lowpass

    def __len__(self):
        return len(self._band)

    def __iter__(self):
        for k in range(len(self)):
            yield self[k]
    
    def __getitem__(self, k):
        assert k&gt;=0 and k&lt;len(self)
        return vipy.image.Image.fromtorch(self._band[k])

    def band(self, k):
        return self[k]

    def show(self, mindim=256):
        return vipy.visualize.montage([im.maxsquare() for im in self], mindim, mindim).show()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="vipy.pyramid.GaussianPyramid.band"><code class="name flex">
<span>def <span class="ident">band</span></span>(<span>self, k)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/pyramid.py#L43-L44" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def band(self, k):
    return self[k]</code></pre>
</details>
</dd>
<dt id="vipy.pyramid.GaussianPyramid.show"><code class="name flex">
<span>def <span class="ident">show</span></span>(<span>self, mindim=256)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/pyramid.py#L46-L47" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def show(self, mindim=256):
    return vipy.visualize.montage([im.maxsquare() for im in self], mindim, mindim).show()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="vipy.pyramid.LaplacianPyramid"><code class="flex name class">
<span>class <span class="ident">LaplacianPyramid</span></span>
<span>(</span><span>im, pad='zero')</span>
</code></dt>
<dd>
<div class="desc"><p>vipy.pyramid.LaplacianPyramid() class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/pyramid.py#L50-L134" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class LaplacianPyramid():
    &#34;&#34;&#34;vipy.pyramid.LaplacianPyramid() class&#34;&#34;&#34;    
    def __init__(self, im, pad=&#39;zero&#39;):
        
        g = (1.0/np.sqrt(2*np.pi))*np.exp(-0.5*(np.array([-2,-1,0,1,2])**2))
        G = torch.from_numpy(np.outer(g,g).astype(np.float32))

        self._G = G.repeat( (3,1,1,1) )
        self._Ce = torch.sum(G[::2,::2])  # filter coefficient sum, even elements only
        self._Co = torch.sum(G[1::2,1::2]) # filter coefficient sum, odd elements only
        self._band = []
        self._im = im
        
        if pad == &#39;zero&#39;:
            self._pad = torch.nn.ZeroPad2d(2)  # introduces lowpass corner boundary artifact on reconstruction
            self._gain = 1.6  # rescale to approximately correct boundary artifact
        elif pad == &#39;reflect&#39;:
            self._pad = torch.nn.ReflectionPad2d(2)  # introduces lowpass gain boundary artifact on reconstruction
            self._gain = 1.4  # rescale to approximately correct boundary artifact
        else:
            raise ValueError(&#39;unknown padding &#34;%s&#34; - must be [&#34;zero&#34;, &#34;reflect&#34;]&#39; % pad)

        if isinstance(im, vipy.image.Image):
            x = im.float().torch(order=&#39;NCHW&#39;)
            for k in range(int(np.log2(im.mindim())-1)):
                y = torch.nn.functional.conv2d(self._pad(x), self._G, groups=3)  # anti-aliasing
                self._band.append(x-y)  # bandpass
                x = y[:,:,::2,::2]  # even downsample
            self._band.append(x)  # lowpass
        elif isinstance(im, list):
            assert all([torch.is_tensor(b) for b in im])
            self._band = im
            self._im = self[0].clone().zeros()  # no source image available
        else:
            raise ValueError(&#39;invalid input&#39;)

    def __repr__(self):
        return &#39;&lt;vipy.pyramid.LaplacianPyramid: scales=%d, channels=%d, height=%d, width=%d&gt;&#39; % (self.scales(), self.channels(), self.height(), self.width())
    
    def __len__(self):
        return len(self._band)

    def __iter__(self):
        for k in range(len(self)):
            yield self[k]
            
    def __getitem__(self, k):
        assert k&gt;=0 and k&lt;len(self)
        return vipy.image.Image.fromtorch(self._band[k])

    def band(self, k):
        return self[k]

    def reconstruct(self):
        x = self._band[-1]
        for b in reversed(self._band[0:-1]):
            xz = torch.zeros(1, b.shape[1], b.shape[2], b.shape[3])
            xz[:,:,::2,::2] = x  # odd zero interpolate (even signal)
            xu = torch.nn.functional.conv2d(self._pad(xz), (1.0/self._Ce)*self._G, groups=3)  # upsample, rescale using sum of non-zeroed kernel elements for even locations
            xu[:,:,1::2,1::2] *= (self._Ce/self._Co)  # upsample, rescale using sum of non-zeroed kernel elements for odd locations
            x = xu + b  # reconstruction
        im = vipy.image.Image.fromtorch((x * self._gain).clamp(0, 255))  # final rescale due to padding boundary artifact (can also use im.mat2gray)
        return im.array(im.numpy().astype(np.uint8)).colorspace(&#39;rgb&#39;)

    def show(self, mindim=256):
        return vipy.visualize.montage([im.maxsquare().resize(mindim, mindim, interp=&#39;nearest&#39;) for im in self], mindim, mindim).show()

    def height(self):
        return self._im.height()
    def width(self):
        return self._im.width()
    def channels(self):
        return self._im.channels()
    def scales(self):
        return len(self)
    
    def tensor(self, interp=&#39;nearest&#39;):
        return torch.stack([im.resize(self.height(), self.width(), interp=interp).torch(order=&#39;CHW&#39;) for im in self])  # scales() x channels() x height() x width()

    @staticmethod
    def fromtensor(bands):
        &#34;&#34;&#34;Convert a S*CxHxW torch tensor back to LaplacianPyramid&#34;&#34;&#34;
        assert torch.is_tensor(bands) and bands.ndim == 4
        (S,C,H,W) = bands.shape
        return LaplacianPyramid([vipy.image.Image.fromtorch(b).resize(H//(2**i), W//(2**i), interp=&#39;nearest&#39;).torch(order=&#39;NCHW&#39;) for (i,b) in enumerate(bands)])</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="vipy.pyramid.Foveation" href="#vipy.pyramid.Foveation">Foveation</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="vipy.pyramid.LaplacianPyramid.fromtensor"><code class="name flex">
<span>def <span class="ident">fromtensor</span></span>(<span>bands)</span>
</code></dt>
<dd>
<div class="desc"><p>Convert a S*CxHxW torch tensor back to LaplacianPyramid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/pyramid.py#L129-L134" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def fromtensor(bands):
    &#34;&#34;&#34;Convert a S*CxHxW torch tensor back to LaplacianPyramid&#34;&#34;&#34;
    assert torch.is_tensor(bands) and bands.ndim == 4
    (S,C,H,W) = bands.shape
    return LaplacianPyramid([vipy.image.Image.fromtorch(b).resize(H//(2**i), W//(2**i), interp=&#39;nearest&#39;).torch(order=&#39;NCHW&#39;) for (i,b) in enumerate(bands)])</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="vipy.pyramid.LaplacianPyramid.band"><code class="name flex">
<span>def <span class="ident">band</span></span>(<span>self, k)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/pyramid.py#L100-L101" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def band(self, k):
    return self[k]</code></pre>
</details>
</dd>
<dt id="vipy.pyramid.LaplacianPyramid.channels"><code class="name flex">
<span>def <span class="ident">channels</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/pyramid.py#L121-L122" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def channels(self):
    return self._im.channels()</code></pre>
</details>
</dd>
<dt id="vipy.pyramid.LaplacianPyramid.height"><code class="name flex">
<span>def <span class="ident">height</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/pyramid.py#L117-L118" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def height(self):
    return self._im.height()</code></pre>
</details>
</dd>
<dt id="vipy.pyramid.LaplacianPyramid.reconstruct"><code class="name flex">
<span>def <span class="ident">reconstruct</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/pyramid.py#L103-L112" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def reconstruct(self):
    x = self._band[-1]
    for b in reversed(self._band[0:-1]):
        xz = torch.zeros(1, b.shape[1], b.shape[2], b.shape[3])
        xz[:,:,::2,::2] = x  # odd zero interpolate (even signal)
        xu = torch.nn.functional.conv2d(self._pad(xz), (1.0/self._Ce)*self._G, groups=3)  # upsample, rescale using sum of non-zeroed kernel elements for even locations
        xu[:,:,1::2,1::2] *= (self._Ce/self._Co)  # upsample, rescale using sum of non-zeroed kernel elements for odd locations
        x = xu + b  # reconstruction
    im = vipy.image.Image.fromtorch((x * self._gain).clamp(0, 255))  # final rescale due to padding boundary artifact (can also use im.mat2gray)
    return im.array(im.numpy().astype(np.uint8)).colorspace(&#39;rgb&#39;)</code></pre>
</details>
</dd>
<dt id="vipy.pyramid.LaplacianPyramid.scales"><code class="name flex">
<span>def <span class="ident">scales</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/pyramid.py#L123-L124" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def scales(self):
    return len(self)</code></pre>
</details>
</dd>
<dt id="vipy.pyramid.LaplacianPyramid.show"><code class="name flex">
<span>def <span class="ident">show</span></span>(<span>self, mindim=256)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/pyramid.py#L114-L115" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def show(self, mindim=256):
    return vipy.visualize.montage([im.maxsquare().resize(mindim, mindim, interp=&#39;nearest&#39;) for im in self], mindim, mindim).show()</code></pre>
</details>
</dd>
<dt id="vipy.pyramid.LaplacianPyramid.tensor"><code class="name flex">
<span>def <span class="ident">tensor</span></span>(<span>self, interp='nearest')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/pyramid.py#L126-L127" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def tensor(self, interp=&#39;nearest&#39;):
    return torch.stack([im.resize(self.height(), self.width(), interp=interp).torch(order=&#39;CHW&#39;) for im in self])  # scales() x channels() x height() x width()</code></pre>
</details>
</dd>
<dt id="vipy.pyramid.LaplacianPyramid.width"><code class="name flex">
<span>def <span class="ident">width</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/pyramid.py#L119-L120" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def width(self):
    return self._im.width()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="vipy.pyramid.SteerablePyramid"><code class="flex name class">
<span>class <span class="ident">SteerablePyramid</span></span>
<span>(</span><span>im)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/pyramid.py#L186-L230" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SteerablePyramid():
    def __init__(self, im):
        vipy.util.try_import(&#39;pyrtools&#39;)
        import pyrtools
        
        assert isinstance(im, vipy.image.Image)
        assert im.mindim() &gt;= 32        
        self._channels = [pyrtools.pyramids.SteerablePyramidFreq(imc.load().array().astype(float), height=&#39;auto&#39;, order=3) for imc in im.channel()]                
        
    @property
    def num_scales(self):
        return self._channels[0].num_scales

    @property
    def num_orientations(self):
        return self._channels[0].num_orientations

    @property
    def num_channels(self):
        return len(self._channels)           
        
    def bandpass(self, channel):
        return [self._channels[channel].pyr_coeffs[(s,o)] for s in range(self.num_scales) for o in range(self.num_orientations)]
    
    def lowpass(self, channel):
        return self._channels[channel].pyr_coeffs[&#39;residual_lowpass&#39;]

    def highpass(self, channel):
        return self._channels[channel].pyr_coeffs[&#39;residual_highpass&#39;]        
    
    def synthesis(self):        
        return vipy.image.Image(array=np.stack([pyr.recon_pyr() for pyr in self._channels], axis=2).astype(np.float32)).mat2gray()

    def multichannel(self):
        &#34;&#34;&#34;a multichannel image is an image of the same shape as the input, but with channels from pyramid decomposition.  Coefficients are resized using bilinear interpolation.&#34;&#34;&#34;
        (H,W) = self.highpass(0).shape
        resizer = lambda x: np.array(torch.nn.functional.interpolate(torch.tensor(x).view(1,1,x.shape[0],x.shape[1]), size=(H,W), mode=&#39;bilinear&#39;)).squeeze()            
        return vipy.image.Image(array=np.stack([resizer(x) for c in range(self.num_channels) for x in self.bandpass(c)+[self.lowpass(c),self.highpass(c)]], axis=2).astype(np.float32))

    def montage(self):
        &#34;&#34;&#34;scales by row, orientations by col, channels merged back into color image, last image is lowpass&#34;&#34;&#34;
        imlist = [vipy.image.Image(array=np.stack([self._channels[c].pyr_coeffs[(s,o)] for c in range(self.num_channels)], axis=2).astype(np.float32)) for s in range(self.num_scales) for o in range(self.num_orientations)]
        imlist += [vipy.image.Image(array=np.stack([self.lowpass(c) for c in range(self.num_channels)], axis=2).astype(np.float32))]
        imlist += [vipy.image.Image(array=np.stack([self.highpass(c) for c in range(self.num_channels)], axis=2).astype(np.float32))]        
        return vipy.visualize.montage([im.mat2gray().rgb() for im in imlist], gridrows=self.num_scales+1, gridcols=self.num_orientations)</code></pre>
</details>
<h3>Instance variables</h3>
<dl>
<dt id="vipy.pyramid.SteerablePyramid.num_channels"><code class="name">var <span class="ident">num_channels</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/pyramid.py#L203-L205" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def num_channels(self):
    return len(self._channels)           </code></pre>
</details>
</dd>
<dt id="vipy.pyramid.SteerablePyramid.num_orientations"><code class="name">var <span class="ident">num_orientations</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/pyramid.py#L199-L201" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def num_orientations(self):
    return self._channels[0].num_orientations</code></pre>
</details>
</dd>
<dt id="vipy.pyramid.SteerablePyramid.num_scales"><code class="name">var <span class="ident">num_scales</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/pyramid.py#L195-L197" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@property
def num_scales(self):
    return self._channels[0].num_scales</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="vipy.pyramid.SteerablePyramid.bandpass"><code class="name flex">
<span>def <span class="ident">bandpass</span></span>(<span>self, channel)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/pyramid.py#L207-L208" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def bandpass(self, channel):
    return [self._channels[channel].pyr_coeffs[(s,o)] for s in range(self.num_scales) for o in range(self.num_orientations)]</code></pre>
</details>
</dd>
<dt id="vipy.pyramid.SteerablePyramid.highpass"><code class="name flex">
<span>def <span class="ident">highpass</span></span>(<span>self, channel)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/pyramid.py#L213-L214" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def highpass(self, channel):
    return self._channels[channel].pyr_coeffs[&#39;residual_highpass&#39;]        </code></pre>
</details>
</dd>
<dt id="vipy.pyramid.SteerablePyramid.lowpass"><code class="name flex">
<span>def <span class="ident">lowpass</span></span>(<span>self, channel)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/pyramid.py#L210-L211" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def lowpass(self, channel):
    return self._channels[channel].pyr_coeffs[&#39;residual_lowpass&#39;]</code></pre>
</details>
</dd>
<dt id="vipy.pyramid.SteerablePyramid.montage"><code class="name flex">
<span>def <span class="ident">montage</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>scales by row, orientations by col, channels merged back into color image, last image is lowpass</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/pyramid.py#L225-L230" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def montage(self):
    &#34;&#34;&#34;scales by row, orientations by col, channels merged back into color image, last image is lowpass&#34;&#34;&#34;
    imlist = [vipy.image.Image(array=np.stack([self._channels[c].pyr_coeffs[(s,o)] for c in range(self.num_channels)], axis=2).astype(np.float32)) for s in range(self.num_scales) for o in range(self.num_orientations)]
    imlist += [vipy.image.Image(array=np.stack([self.lowpass(c) for c in range(self.num_channels)], axis=2).astype(np.float32))]
    imlist += [vipy.image.Image(array=np.stack([self.highpass(c) for c in range(self.num_channels)], axis=2).astype(np.float32))]        
    return vipy.visualize.montage([im.mat2gray().rgb() for im in imlist], gridrows=self.num_scales+1, gridcols=self.num_orientations)</code></pre>
</details>
</dd>
<dt id="vipy.pyramid.SteerablePyramid.multichannel"><code class="name flex">
<span>def <span class="ident">multichannel</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>a multichannel image is an image of the same shape as the input, but with channels from pyramid decomposition.
Coefficients are resized using bilinear interpolation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/pyramid.py#L219-L223" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def multichannel(self):
    &#34;&#34;&#34;a multichannel image is an image of the same shape as the input, but with channels from pyramid decomposition.  Coefficients are resized using bilinear interpolation.&#34;&#34;&#34;
    (H,W) = self.highpass(0).shape
    resizer = lambda x: np.array(torch.nn.functional.interpolate(torch.tensor(x).view(1,1,x.shape[0],x.shape[1]), size=(H,W), mode=&#39;bilinear&#39;)).squeeze()            
    return vipy.image.Image(array=np.stack([resizer(x) for c in range(self.num_channels) for x in self.bandpass(c)+[self.lowpass(c),self.highpass(c)]], axis=2).astype(np.float32))</code></pre>
</details>
</dd>
<dt id="vipy.pyramid.SteerablePyramid.synthesis"><code class="name flex">
<span>def <span class="ident">synthesis</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/visym/vipy/blob/a3e4013930bb458420e1fcc86216fa191c42b880/vipy/pyramid.py#L216-L217" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def synthesis(self):        
    return vipy.image.Image(array=np.stack([pyr.recon_pyr() for pyr in self._channels], axis=2).astype(np.float32)).mat2gray()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="VIPY" href="https://github.com/visym/vipy/">
<img src="https://www.visym.com/labs/images/visym_logo_black_notext.png" alt="" width="60">
</a>
<h1 style="font-size:200%;"><b>VIPY:</b> Visual Dataset Transformation</h1>
</header>
<form>
<input id="lunr-search" name="q" placeholder="🔎 Search ..." aria-label="Search"
disabled minlength="2">
</form>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.css" integrity="sha512-j1u8eUJ4f23xPPxwOrLUPQaCD2dwzNqqmDDcWS4deWsMv2ohLqmXXuP3hU7g8TyzbMSakP/mMqoNBYWj8AEIFg==" crossorigin>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tingle/0.15.3/tingle.min.js" integrity="sha512-plGUER9JkeEWPPqQBE4sdLqBoQug5Ap+BCGMc7bJ8BXkm+VVj6QzkpBz5Yv2yPkkq+cqg9IpkBaGCas6uDbW8g==" crossorigin></script>
<style>
.modal-dialog iframe {
width: 100vw;
height: calc(100vh - 80px);
}
@media screen and (min-width: 700px) {
.modal-dialog iframe {
width: 70vw;
height: 80vh;
}
}
.modal-dialog .tingle-modal-box {width: auto;}
.modal-dialog .tingle-modal-box__content {padding: 0;}
</style>
<script>
const input = document.getElementById('lunr-search');
input.disabled = false;
input.form.addEventListener('submit', (ev) => {
ev.preventDefault();
const url = new URL(window.location);
url.searchParams.set('q', input.value);
history.replaceState({}, null, url.toString());
search(input.value);
});
const query = new URL(window.location).searchParams.get('q');
if (query)
search(query);
function search(query) {
const url = './doc-search.html#' + encodeURIComponent(query);
new tingle.modal({
cssClass: ['modal-dialog'],
onClose: () => {
const url = new URL(window.location);
url.searchParams.delete('q');
history.replaceState({}, null, url.toString());
setTimeout(() => input.focus(), 100);
}
}).setContent('<iframe src="' + url + '"></iframe>').open();
}
</script>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="vipy" href="index.html">vipy</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="vipy.pyramid.BatchSteerablePyramid" href="#vipy.pyramid.BatchSteerablePyramid">BatchSteerablePyramid</a></code></h4>
<ul class="two-column">
<li><code><a title="vipy.pyramid.BatchSteerablePyramid.band" href="#vipy.pyramid.BatchSteerablePyramid.band">band</a></code></li>
<li><code><a title="vipy.pyramid.BatchSteerablePyramid.device" href="#vipy.pyramid.BatchSteerablePyramid.device">device</a></code></li>
<li><code><a title="vipy.pyramid.BatchSteerablePyramid.forward" href="#vipy.pyramid.BatchSteerablePyramid.forward">forward</a></code></li>
<li><code><a title="vipy.pyramid.BatchSteerablePyramid.forwarded" href="#vipy.pyramid.BatchSteerablePyramid.forwarded">forwarded</a></code></li>
<li><code><a title="vipy.pyramid.BatchSteerablePyramid.magnitude" href="#vipy.pyramid.BatchSteerablePyramid.magnitude">magnitude</a></code></li>
<li><code><a title="vipy.pyramid.BatchSteerablePyramid.montage" href="#vipy.pyramid.BatchSteerablePyramid.montage">montage</a></code></li>
<li><code><a title="vipy.pyramid.BatchSteerablePyramid.num_channels" href="#vipy.pyramid.BatchSteerablePyramid.num_channels">num_channels</a></code></li>
<li><code><a title="vipy.pyramid.BatchSteerablePyramid.num_orientations" href="#vipy.pyramid.BatchSteerablePyramid.num_orientations">num_orientations</a></code></li>
<li><code><a title="vipy.pyramid.BatchSteerablePyramid.num_scales" href="#vipy.pyramid.BatchSteerablePyramid.num_scales">num_scales</a></code></li>
<li><code><a title="vipy.pyramid.BatchSteerablePyramid.phase" href="#vipy.pyramid.BatchSteerablePyramid.phase">phase</a></code></li>
<li><code><a title="vipy.pyramid.BatchSteerablePyramid.phase_congruency" href="#vipy.pyramid.BatchSteerablePyramid.phase_congruency">phase_congruency</a></code></li>
<li><code><a title="vipy.pyramid.BatchSteerablePyramid.synthesis" href="#vipy.pyramid.BatchSteerablePyramid.synthesis">synthesis</a></code></li>
<li><code><a title="vipy.pyramid.BatchSteerablePyramid.tensor" href="#vipy.pyramid.BatchSteerablePyramid.tensor">tensor</a></code></li>
<li><code><a title="vipy.pyramid.BatchSteerablePyramid.to" href="#vipy.pyramid.BatchSteerablePyramid.to">to</a></code></li>
<li><code><a title="vipy.pyramid.BatchSteerablePyramid.zero_crossing" href="#vipy.pyramid.BatchSteerablePyramid.zero_crossing">zero_crossing</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vipy.pyramid.Foveation" href="#vipy.pyramid.Foveation">Foveation</a></code></h4>
<ul class="">
<li><code><a title="vipy.pyramid.Foveation.foveate" href="#vipy.pyramid.Foveation.foveate">foveate</a></code></li>
<li><code><a title="vipy.pyramid.Foveation.visualize" href="#vipy.pyramid.Foveation.visualize">visualize</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vipy.pyramid.GaussianPyramid" href="#vipy.pyramid.GaussianPyramid">GaussianPyramid</a></code></h4>
<ul class="">
<li><code><a title="vipy.pyramid.GaussianPyramid.band" href="#vipy.pyramid.GaussianPyramid.band">band</a></code></li>
<li><code><a title="vipy.pyramid.GaussianPyramid.show" href="#vipy.pyramid.GaussianPyramid.show">show</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vipy.pyramid.LaplacianPyramid" href="#vipy.pyramid.LaplacianPyramid">LaplacianPyramid</a></code></h4>
<ul class="two-column">
<li><code><a title="vipy.pyramid.LaplacianPyramid.band" href="#vipy.pyramid.LaplacianPyramid.band">band</a></code></li>
<li><code><a title="vipy.pyramid.LaplacianPyramid.channels" href="#vipy.pyramid.LaplacianPyramid.channels">channels</a></code></li>
<li><code><a title="vipy.pyramid.LaplacianPyramid.fromtensor" href="#vipy.pyramid.LaplacianPyramid.fromtensor">fromtensor</a></code></li>
<li><code><a title="vipy.pyramid.LaplacianPyramid.height" href="#vipy.pyramid.LaplacianPyramid.height">height</a></code></li>
<li><code><a title="vipy.pyramid.LaplacianPyramid.reconstruct" href="#vipy.pyramid.LaplacianPyramid.reconstruct">reconstruct</a></code></li>
<li><code><a title="vipy.pyramid.LaplacianPyramid.scales" href="#vipy.pyramid.LaplacianPyramid.scales">scales</a></code></li>
<li><code><a title="vipy.pyramid.LaplacianPyramid.show" href="#vipy.pyramid.LaplacianPyramid.show">show</a></code></li>
<li><code><a title="vipy.pyramid.LaplacianPyramid.tensor" href="#vipy.pyramid.LaplacianPyramid.tensor">tensor</a></code></li>
<li><code><a title="vipy.pyramid.LaplacianPyramid.width" href="#vipy.pyramid.LaplacianPyramid.width">width</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="vipy.pyramid.SteerablePyramid" href="#vipy.pyramid.SteerablePyramid">SteerablePyramid</a></code></h4>
<ul class="two-column">
<li><code><a title="vipy.pyramid.SteerablePyramid.bandpass" href="#vipy.pyramid.SteerablePyramid.bandpass">bandpass</a></code></li>
<li><code><a title="vipy.pyramid.SteerablePyramid.highpass" href="#vipy.pyramid.SteerablePyramid.highpass">highpass</a></code></li>
<li><code><a title="vipy.pyramid.SteerablePyramid.lowpass" href="#vipy.pyramid.SteerablePyramid.lowpass">lowpass</a></code></li>
<li><code><a title="vipy.pyramid.SteerablePyramid.montage" href="#vipy.pyramid.SteerablePyramid.montage">montage</a></code></li>
<li><code><a title="vipy.pyramid.SteerablePyramid.multichannel" href="#vipy.pyramid.SteerablePyramid.multichannel">multichannel</a></code></li>
<li><code><a title="vipy.pyramid.SteerablePyramid.num_channels" href="#vipy.pyramid.SteerablePyramid.num_channels">num_channels</a></code></li>
<li><code><a title="vipy.pyramid.SteerablePyramid.num_orientations" href="#vipy.pyramid.SteerablePyramid.num_orientations">num_orientations</a></code></li>
<li><code><a title="vipy.pyramid.SteerablePyramid.num_scales" href="#vipy.pyramid.SteerablePyramid.num_scales">num_scales</a></code></li>
<li><code><a title="vipy.pyramid.SteerablePyramid.synthesis" href="#vipy.pyramid.SteerablePyramid.synthesis">synthesis</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
